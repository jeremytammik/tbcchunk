[
  {
    "original_filename": "1132_instance_void_cut",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<head>\n<link href=\"bc.css\" rel=\"stylesheet\" type=\"text/css\"/>\n</head>"
  },
  {
    "original_filename": "1132_instance_void_cut",
    "header_text": "Transaction Group and Regeneration for InstanceVoidCutUtils",
    "local_header_href": "#transaction-group-and-regeneration-for-instancevoidcututils",
    "chunk_text": "<h3>Transaction Group and Regeneration for InstanceVoidCutUtils</h3><p>We looked at a nice example of using\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2011/06/boolean-operations-and-instancevoidcututils.html\">\nBoolean operations and InstanceVoidCutUtils</a> back\n\nin the year 2011, cutting out part of a beam using a void cutter family.</p><p>I tried to make use of this again in a\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2014/02/different-revit-api-aspects-and-features.html\">\nrecent Revit API training</a> and was\n\nsomewhat shocked to discover that it did not work as expected.</p><p>I checked all the prerequisites were fulfilled.</p><a name=\"2\"></a>"
  },
  {
    "original_filename": "1132_instance_void_cut",
    "header_text": "Void Cutter Family",
    "local_header_href": "#void-cutter-family",
    "chunk_text": "<h4>Void Cutter Family</h4><p>First of all, the void cutter family must have its 'Cut with Voids When Loaded' parameter checked:</p><center>\n<img alt=\"Cut with void property\" src=\"img/instance_void_cut_cut_with_voids.png\" width=\"356\"/>\n</center><p>If this is not the case, the void is not an 'Unattached' void, and it will throw an exception saying \"The element is not a family instance with an unattached void that can cut. Parameter name: cuttingInstance\".</p><p>The cutting symbol has three angle parameters associated with it, which can be used to rotate it around various axes.</p><a name=\"3\"></a>"
  },
  {
    "original_filename": "1132_instance_void_cut",
    "header_text": "CutBeamWithVoid Method",
    "local_header_href": "#cutbeamwithvoid-method",
    "chunk_text": "<h4>CutBeamWithVoid Method</h4><p>The sample code implements a method CutBeamWithVoid taking two arguments: the beam family instance and the void cutter family symbol. It places three cutter instances along the top of the beam, modifies their angle parameters and applies the cut.</p><p>Initially, the three cutting instances are placed along the top face of the beam.</p><p>Their angle parameter values are changed from the default zero to 45 degrees, causing two of them to partially cut the beam.</p><p>The call to the InstanceVoidCutUtils.AddInstanceVoidCut method still threw a message saying \"The element is not a family instance with an unattached void that can cut. Parameter name: cuttingInstance\".</p><p>When the call to InstanceVoidCutUtils.AddInstanceVoidCut was commented out, you could see that the cutter family instances were correctly positioned:</p><center>\n<img alt=\"Cutting instances placed with no cut applied\" src=\"img/instance_void_cut_no_cut.png\"/>\n</center><p>Selecting the elements manually and combining them using the join and cut tools in the UI Modify tab successfully completed the operation:</p><center>\n<img alt=\"Cutting instances placed with cut applied\" src=\"img/instance_void_cut_applied.png\"/>\n</center><p>The manual operation should be completely analogous to InstanceVoidCutUtils.</p><p>What was wrong?</p><a name=\"4\"></a>"
  },
  {
    "original_filename": "1132_instance_void_cut",
    "header_text": "Need for Regeneration",
    "local_header_href": "#need-for-regeneration",
    "chunk_text": "<h4>Need for Regeneration</h4><p>After struggling for a while with that, I gave up and asked my colleagues.</p><p>Scott Conover answered: could the solution be as simple as Regenerating after the creation of the instance?  Your sample code does not do that.</p><p>Normally, before any part of a newly created element is read or used, Revit requires a regeneration to take place.</p><p>Note that for that reason, if you have a significant number to place and join in a loop, you may want to structure the code that it places them all, then regenerates, and then creates all of cuts/joins.</p><p>Jim Jia added: Scott is right – I verified doc.Regenerate can solve the issue.</p><p>Besides, I also noticed if the cutter family was already loaded and some cutter instances were ever created, the call to doc.Regenerate is not required.</p><p>Shockingly enough (for me personally), that really is the simple solution to this problem.</p><p>We have talked about this numerous times in the past, and yet I missed it myself this time around, again:</p><ul>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2010/04/manual-regeneration-mode-danger.html\">\nManual regeneration option danger</a></li>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2010/04/regeneration-option-best-practices.html\">Regeneration option best practices</a></li>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2010/06/to-regenerate-or-not-to-regenerate.html\">\nTo regenerate or not to regenerate...</a></li>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2010/11/refresh-referencing-sheet-parameter-display.html\">Refresh referencing sheet parameter display</a></li>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2010/11/setting-text-width-requires-regen.html\">\nSetting text width requires regen</a></li>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2012/12/extra-transaction-or-regeneration-required.html\">Extra transaction or regeneration required</a></li>\n<!-- <li><a href=\"http://thebuildingcoder.typepad.com/blog/2013/03/curve-evaluation-and-song-of-the-gulls.html\">Curve Evaluation and Song of the Gulls</a></li> -->\n<li><a href=\"http://adndevblog.typepad.com/aec/2013/01/it-is-easy-to-miss-this-regenerating-the-model.html\">Regenerate between plane and dimension creation</a></li>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2013/11/erasing-extensible-storage-with-linked-files.html#3\">\nRegenerate to avoid accessing stale data</a></li>\n</ul><p>The topic of regeneration is also related to the\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2012/10/the-temporary-transaction-trick-for-gross-slab-data.html\">\ntemporary transaction trick</a>,\n\nthe associated suggestion to\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2012/11/temporary-transaction-trick-touchup.html\">\nencapsulate multiple transactions in a transaction group</a>,\n\ncommit the individual transactions and then roll bock the entire group instead.</p><p>In Revit 2010, in this particular case, the regeneration was apparently not required.</p><p>Whenever you run into an issue like this, you must always consider the\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/about-the-author.html#5.33\">\nneed to regenerate</a>.</p><a name=\"5\"></a>"
  },
  {
    "original_filename": "1132_instance_void_cut",
    "header_text": "InstanceVoidCutTest Add-in",
    "local_header_href": "#instancevoidcuttest-add-in",
    "chunk_text": "<h4>InstanceVoidCutTest Add-in</h4><p>I implemented a Revit add-in defining an external command to demonstrate this in the\n\n<a href=\"https://github.com/jeremytammik/InstanceVoidCutTest\">InstanceVoidCutTest GitHub repository</a>.</p><p>The initial code without the cut working is captured in\n\n<a href=\"https://github.com/jeremytammik/InstanceVoidCutTest/releases/tag/2014.0.0.0\">release 2014.0.0.0</a>.</p><p>In\n\n<a href=\"https://github.com/jeremytammik/InstanceVoidCutTest/releases/tag/2014.0.0.2\">release 2014.0.0.2</a>,\n\nI separated the operations placing the cutting instances and applying the cut into two separate transactions.\nBoth operations were performed in a single loop iterating over the three instances, so I separated them into two loops, each contained in its own transaction.</p><p>At that point, all works well.</p><a name=\"6\"></a>"
  },
  {
    "original_filename": "1132_instance_void_cut",
    "header_text": "Transactions, Transaction Groups and Simple Regeneration",
    "local_header_href": "#transactions-transaction-groups-and-simple-regeneration",
    "chunk_text": "<h4>Transactions, Transaction Groups and Simple Regeneration</h4><p>Three separate transactions are used to load the cutting family, create the cutting instances and apply the actual cuts:</p><center>\n<img alt=\"Three separate transactions\" src=\"img/instance_void_cut_three_transactions.png\"/>\n</center><p>If you prefer not to display the individual transaction generated by one single command in the undo stack visible in the user interface, you can collect them all together into a transaction group.</p><p>I therefor added a transaction group and assimilated the transactions into that by calling its Assimilate method.</p><p>Note that the call to Assimilate includes the commit, so trying to call Commit afterwards in addition to Assimilate will throw an exception saying \"The Transaction group has not been started (its status is not 'Started')\".</p><p>Here is the undo stack displaying the single transaction group:</p><center>\n<img alt=\"Transaction group\" src=\"img/instance_void_cut_transaction_group.png\"/>\n</center><p>This version is captured in the GitHub repository as\n\n<a href=\"https://github.com/jeremytammik/InstanceVoidCutTest/releases/tag/2014.0.0.3\">release 2014.0.0.3</a>.</p><p>Looking more closely at my colleagues' recommendations above, I see that they are actually just pointing out the need to regenerate, which is a less expensive operation than committing a transaction and starting a new one.</p><p>I therefore updated the implementation in\n\n<a href=\"https://github.com/jeremytammik/InstanceVoidCutTest/releases/tag/2014.0.0.4\">release 2014.0.0.4</a> to\n\nuse one single transaction to both create instances and apply the cut, and added a call to regenerate in between.</p><a name=\"7\"></a>"
  },
  {
    "original_filename": "1132_instance_void_cut",
    "header_text": "InstanceVoidCutTest External Command Implementation",
    "local_header_href": "#instancevoidcuttest-external-command-implementation",
    "chunk_text": "<h4>InstanceVoidCutTest External Command Implementation</h4><p>Here is the final implementation:</p><pre class=\"code\">\n<span class=\"blue\">#region</span> Namespaces\n<span class=\"blue\">using</span> System;\n<span class=\"blue\">using</span> System.Collections.Generic;\n<span class=\"blue\">using</span> System.Diagnostics;\n<span class=\"blue\">using</span> System.Linq;\n<span class=\"blue\">using</span> Autodesk.Revit.ApplicationServices;\n<span class=\"blue\">using</span> Autodesk.Revit.Attributes;\n<span class=\"blue\">using</span> Autodesk.Revit.DB;\n<span class=\"blue\">using</span> Autodesk.Revit.UI;\n<span class=\"blue\">using</span> Autodesk.Revit.UI.Selection;\n<span class=\"blue\">using</span> Autodesk.Revit.DB.Structure;\n<span class=\"blue\">using</span> System.IO;\n<span class=\"blue\">#endregion</span>\n \n<span class=\"blue\">namespace</span> InstanceVoidCutTest\n{\n  [<span class=\"teal\">Transaction</span>( <span class=\"teal\">TransactionMode</span>.Manual )]\n  <span class=\"blue\">public</span> <span class=\"blue\">class</span> <span class=\"teal\">Command</span> : <span class=\"teal\">IExternalCommand</span>\n  {\n    <span class=\"blue\">const</span> <span class=\"blue\">string</span> FamilyName = <span class=\"maroon\">\"Cutter\"</span>;\n \n    <span class=\"blue\">const</span> <span class=\"blue\">string</span> FamilyPath\n      = <span class=\"maroon\">\"C:/a/vs/InstanceVoidCutTest/Cutter.rfa\"</span>;\n \n    <span class=\"blue\">public</span> <span class=\"blue\">static</span> <span class=\"blue\">void</span> ErrorMsg( <span class=\"blue\">string</span> msg )\n    {\n      <span class=\"teal\">Debug</span>.WriteLine( msg );\n \n      <span class=\"teal\">TaskDialog</span>.Show( <span class=\"maroon\">\"InstanceVoidCutUtils Test\"</span>,\n        msg );\n    }\n \n    <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n    <span class=\"gray\">///</span><span class=\"green\"> Return a string for a real number</span>\n    <span class=\"gray\">///</span><span class=\"green\"> formatted to two decimal places.</span>\n    <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n    <span class=\"blue\">public</span> <span class=\"blue\">static</span> <span class=\"blue\">string</span> RealString( <span class=\"blue\">double</span> a )\n    {\n      <span class=\"blue\">return</span> a.ToString( <span class=\"maroon\">\"0.##\"</span> );\n    }\n \n    <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n    <span class=\"gray\">///</span><span class=\"green\"> Return a string for an XYZ point</span>\n    <span class=\"gray\">///</span><span class=\"green\"> or vector with its coordinates</span>\n    <span class=\"gray\">///</span><span class=\"green\"> formatted to two decimal places.</span>\n    <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n    <span class=\"blue\">public</span> <span class=\"blue\">static</span> <span class=\"blue\">string</span> PointString( <span class=\"teal\">XYZ</span> p )\n    {\n      <span class=\"blue\">return</span> <span class=\"blue\">string</span>.Format( <span class=\"maroon\">\"({0},{1},{2})\"</span>,\n        RealString( p.X ),\n        RealString( p.Y ),\n        RealString( p.Z ) );\n    }\n \n    <span class=\"blue\">public</span> <span class=\"blue\">class</span> <span class=\"teal\">BeamSelectionFilter</span> : <span class=\"teal\">ISelectionFilter</span>\n    {\n      <span class=\"blue\">public</span> <span class=\"blue\">bool</span> AllowElement( <span class=\"teal\">Element</span> e )\n      {\n        <span class=\"blue\">return</span> e <span class=\"blue\">is</span> <span class=\"teal\">FamilyInstance</span>\n          &amp;&amp; <span class=\"blue\">null</span> != e.Category\n          &amp;&amp; e.Category.Id.IntegerValue.Equals( (<span class=\"blue\">int</span>)\n            <span class=\"teal\">BuiltInCategory</span>.OST_StructuralFraming );\n      }\n \n      <span class=\"blue\">public</span> <span class=\"blue\">bool</span> AllowReference( <span class=\"teal\">Reference</span> r, <span class=\"teal\">XYZ</span> p )\n      {\n        <span class=\"blue\">return</span> <span class=\"blue\">true</span>;\n      }\n    }\n \n    <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n    <span class=\"gray\">///</span><span class=\"green\"> Retrieve cutting symbol, </span>\n    <span class=\"gray\">///</span><span class=\"green\"> loading family if needed.</span>\n    <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n    <span class=\"blue\">static</span> <span class=\"teal\">FamilySymbol</span> RetrieveOrLoadCuttingSymbol(\n      <span class=\"teal\">Document</span> doc )\n    {\n      <span class=\"teal\">FilteredElementCollector</span> a\n          = <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( doc )\n            .OfClass( <span class=\"blue\">typeof</span>( <span class=\"teal\">Family</span> ) );\n \n      <span class=\"teal\">Family</span> family = a.FirstOrDefault&lt;<span class=\"teal\">Element</span>&gt;(\n        e =&gt; e.Name.Equals( FamilyName ) )\n          <span class=\"blue\">as</span> <span class=\"teal\">Family</span>;\n \n      <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == family )\n      {\n        <span class=\"green\">// It is not present, so check for </span>\n        <span class=\"green\">// the file to load it from:</span>\n \n        <span class=\"blue\">if</span>( !<span class=\"teal\">File</span>.Exists( FamilyPath ) )\n        {\n          ErrorMsg( <span class=\"blue\">string</span>.Format(\n            <span class=\"maroon\">\"Please ensure that the void cutter \"</span>\n            + <span class=\"maroon\">\"family file '{0}' is present.\"</span>,\n            FamilyPath ) );\n \n          <span class=\"blue\">return</span> <span class=\"blue\">null</span>;\n        }\n \n        <span class=\"green\">// Load family from file:</span>\n \n        <span class=\"blue\">using</span>( <span class=\"teal\">Transaction</span> tx = <span class=\"blue\">new</span> <span class=\"teal\">Transaction</span>(\n          doc ) )\n        {\n          tx.Start( <span class=\"maroon\">\"Load Family\"</span> );\n          doc.LoadFamily( FamilyPath, <span class=\"blue\">out</span> family );\n          tx.Commit();\n        }\n      }\n \n      <span class=\"teal\">FamilySymbol</span> cuttingSymbol = <span class=\"blue\">null</span>;\n \n      <span class=\"blue\">foreach</span>( <span class=\"teal\">FamilySymbol</span> s <span class=\"blue\">in</span> family.Symbols )\n      {\n        cuttingSymbol = s;\n        <span class=\"blue\">break</span>;\n      }\n \n      <span class=\"blue\">return</span> cuttingSymbol;\n    }\n \n    <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n    <span class=\"gray\">///</span><span class=\"green\"> Cut a beam with three instances of a void</span>\n    <span class=\"gray\">///</span><span class=\"green\"> cutting family. Its family parameter \"Cut </span>\n    <span class=\"gray\">///</span><span class=\"green\"> with Voids When Loaded\" must be set to true.</span>\n    <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n    <span class=\"blue\">static</span> <span class=\"blue\">void</span> CutBeamWithVoid(\n      <span class=\"teal\">FamilyInstance</span> beam,\n      <span class=\"teal\">FamilySymbol</span> cuttingSymbol )\n    {\n      <span class=\"teal\">Document</span> doc = beam.Document;\n \n      <span class=\"teal\">Level</span> level = doc.GetElement( beam.LevelId )\n        <span class=\"blue\">as</span> <span class=\"teal\">Level</span>;\n \n      <span class=\"teal\">LocationCurve</span> lc = beam.Location\n        <span class=\"blue\">as</span> <span class=\"teal\">LocationCurve</span>;\n \n      <span class=\"teal\">Curve</span> beamCurve = lc.Curve;\n \n      <span class=\"teal\">Debug</span>.Print( <span class=\"maroon\">\"Beam location from {0} to {1}.\"</span>,\n        PointString( beamCurve.GetEndPoint( 0 ) ),\n        PointString( beamCurve.GetEndPoint( 1 ) ) );\n \n      <span class=\"teal\">XYZ</span> p;\n      <span class=\"blue\">int</span> n = 3;\n      <span class=\"blue\">string</span> parameter_name;\n      <span class=\"teal\">ElementId</span>[] ids = <span class=\"blue\">new</span> <span class=\"teal\">ElementId</span>[n];\n \n      <span class=\"blue\">using</span>( <span class=\"teal\">Transaction</span> tx = <span class=\"blue\">new</span> <span class=\"teal\">Transaction</span>( doc ) )\n      {\n        tx.Start( <span class=\"maroon\">\"Create Cutting Instances and Apply Cut\"</span> );\n \n        <span class=\"blue\">for</span>( <span class=\"blue\">int</span> i = 1; i &lt;= n; ++i )\n        {\n          <span class=\"green\">// Position on beam for this cutting instance</span>\n \n          p = beamCurve.Evaluate( i * 0.25, <span class=\"blue\">true</span> );\n \n          <span class=\"teal\">Debug</span>.Print(\n            <span class=\"maroon\">\"Family instance insertion at {0}.\"</span>,\n            PointString( p ) );\n \n          <span class=\"teal\">FamilyInstance</span> cuttingInstance = doc.Create\n            .NewFamilyInstance( p, cuttingSymbol,\n              level, <span class=\"teal\">StructuralType</span>.NonStructural );\n \n          parameter_name = <span class=\"maroon\">\"A\"</span> + i.ToString();\n \n          cuttingInstance\n            .get_Parameter( parameter_name )\n            .Set( 0.5 * <span class=\"teal\">Math</span>.PI );\n \n          ids[i - 1] = cuttingInstance.Id;\n        }\n \n        <b style=\"font-size:large; font-weight:bold;\">doc.Regenerate();</b>\n \n        <span class=\"blue\">for</span>( <span class=\"blue\">int</span> i = 0; i &lt; n; ++i )\n        {\n          <span class=\"teal\">InstanceVoidCutUtils</span>.AddInstanceVoidCut(\n            doc, beam, doc.GetElement( ids[i] ) );\n        }\n        tx.Commit();\n      }\n    }\n \n    <span class=\"blue\">public</span> <span class=\"teal\">Result</span> Execute(\n      <span class=\"teal\">ExternalCommandData</span> commandData,\n      <span class=\"blue\">ref</span> <span class=\"blue\">string</span> message,\n      <span class=\"teal\">ElementSet</span> elements )\n    {\n      <span class=\"teal\">UIApplication</span> uiapp = commandData.Application;\n      <span class=\"teal\">UIDocument</span> uidoc = uiapp.ActiveUIDocument;\n      <span class=\"teal\">Document</span> doc = uidoc.Document;\n \n      <span class=\"blue\">using</span>( <span class=\"teal\">TransactionGroup</span> g\n        = <span class=\"blue\">new</span> <span class=\"teal\">TransactionGroup</span>( doc ) )\n      {\n        g.Start( <span class=\"maroon\">\"Cut Beam with Voids\"</span> );\n \n        <span class=\"green\">// Retrieve or load cutting symbol</span>\n \n        <span class=\"teal\">FamilySymbol</span> cuttingSymbol\n          = RetrieveOrLoadCuttingSymbol( doc );\n \n        <span class=\"green\">// Select beam to cut</span>\n \n        <span class=\"teal\">Selection</span> sel = uidoc.Selection;\n \n        <span class=\"teal\">FamilyInstance</span> beam = <span class=\"blue\">null</span>;\n \n        <span class=\"blue\">try</span>\n        {\n          <span class=\"teal\">Reference</span> r = sel.PickObject(\n            <span class=\"teal\">ObjectType</span>.Element,\n            <span class=\"blue\">new</span> <span class=\"teal\">BeamSelectionFilter</span>(),\n            <span class=\"maroon\">\"Pick beam to cut\"</span> );\n \n          beam = doc.GetElement( r.ElementId )\n            <span class=\"blue\">as</span> <span class=\"teal\">FamilyInstance</span>;\n        }\n        <span class=\"blue\">catch</span>( Autodesk.Revit.Exceptions\n          .<span class=\"teal\">OperationCanceledException</span> )\n        {\n          <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Cancelled;\n        }\n \n        <span class=\"green\">// Place cutting instances and apply cuts</span>\n \n        CutBeamWithVoid( beam, cuttingSymbol );\n \n        g.Assimilate();\n      }\n      <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Succeeded;\n    }\n  }\n}\n</pre><p>In future (Jeremy), please do remember the</p><p style=\"text-align:center; font-size:xx-large; font-weight:bold; color:darkorange;\">need to regenerate</p><br/><a name=\"8\"></a><p><strong>Addendum:</strong> Arnošt Löbel points out that the title of this post may be a bit misleading.</p><p>There is no regeneration for 'Transaction Groups'.\nRegenerations of a model are possible only within a Transaction.</p><p>Jeremy replies that the original title was 'Transaction Groups and Regeneration Need for InstanceVoidCutUtils', but that is too long and causes a horrible line break, so I just removed all the words that could possibly be left out.</p><p>Sorry for that  :-)</p>"
  }
]