[
  {
    "original_filename": "1417_distinguish_rooms",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n<link rel=\"stylesheet\" type=\"text/css\" href=\"bc.css\">\n<script src=\"run_prettify.js\" type=\"text/javascript\"></script>\n<!---\n<script src=\"https://google-code-prettify.googlecode.com/svn/loader/run_prettify.js\" type=\"text/javascript\"></script>\n-->\n</head>\n\n<!---\n\n- Diane Christoforo RE: How to distinguish between \"Redundant\" and \"NotEnclosed\" Rooms?\n\nHow to Distinguish Redundant Rooms #revitAPI #3dwebcoder @AutodeskRevit #adsk #aec #bim\n\nA couple of interesting Revit API issues were resolved during my recent absence. Let's start with this question raised by Miroslav Schonauer and resolved by Diane Christoforo: Using the terminology as shown in Schedules, I need to report all 'Not Placed', 'Redundant' and 'Not Enclosed' rooms...\n\n-->"
  },
  {
    "original_filename": "1417_distinguish_rooms",
    "header_text": "How to Distinguish Redundant Rooms",
    "local_header_href": "#how-to-distinguish-redundant-rooms",
    "chunk_text": "### How to Distinguish Redundant Rooms\n\nA couple of interesting Revit API issues were resolved during my recent absence.\n\nLet's start with this question raised by Miroslav Schonauer and resolved by Diane Christoforo:\n\n**Question:** Using the terminology as shown in Schedules, I need to report all 'Not Placed', 'Redundant' and 'Not Enclosed' rooms.\n\nI cannot rely on any particular schedule being present in the model.\n\nSo far, my research shows that:\n\n- All of these 3 'failure' cases have `.Area` as 0.\n- 'Not Placed' additionally has `.Location` as null.\n\nThe only remaining issue is how to distinguish between 'Redundant' and 'Not Enclosed' rooms.\n\nDo you have any ideas how can I do this comprehensively and deterministically from the room properties and params?\n\nBTW, I'm aware that an alternative approach would be via the Failure API. I can see, e.g., the enumeration value  `BuiltInFailures.RoomFailures.RoomNotEnclosed`.\n\nAfter just reading about it and looking into some samples, I worry about this approach and think that it is possible to 'override' the failures, which may prevent me from determining whether the rooms really are Not Enclosed or Redundant.\n\nHere is sample code illustrating the approach I have been able to develop so far:\n\n<pre class=\"code\">\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> Distinguish 'Not Placed', 'Redundant' and 'Not Enclosed' rooms.</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n&nbsp; <span class=\"blue\">void</span> DistinguishRooms(\n&nbsp; &nbsp; <span class=\"teal\">Document</span> doc,\n&nbsp; &nbsp; <span class=\"blue\">ref</span> <span class=\"teal\">StringBuilder</span> sb,\n&nbsp; &nbsp; <span class=\"blue\">ref</span> <span class=\"blue\">int</span> numErr,\n&nbsp; &nbsp; <span class=\"blue\">ref</span> <span class=\"blue\">int</span> numWarn )\n&nbsp; {\n&nbsp; &nbsp; sb = <span class=\"blue\">new</span> <span class=\"teal\">StringBuilder</span>();\n&nbsp;\n&nbsp; &nbsp; <span class=\"teal\">FilteredElementCollector</span> rooms\n&nbsp; &nbsp; &nbsp; = <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( doc );\n&nbsp;\n&nbsp; &nbsp; rooms.WherePasses( <span class=\"blue\">new</span> <span class=\"teal\">RoomFilter</span>() );\n&nbsp;\n&nbsp; &nbsp; <span class=\"blue\">foreach</span>( <span class=\"teal\">Room</span> r <span class=\"blue\">in</span> rooms )\n&nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; sb.AppendFormat( <span class=\"maroon\">&quot;\\r\\n&nbsp; Room {0}:'{1}': &quot;</span>,\n&nbsp; &nbsp; &nbsp; &nbsp; r.Id.ToString(), r.Name );\n&nbsp;\n&nbsp; &nbsp; &nbsp; <span class=\"blue\">if</span>( r.Area &gt; 0 ) <span class=\"green\">// OK if having Area</span>\n&nbsp; &nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; &nbsp; sb.AppendFormat( <span class=\"maroon\">&quot;OK (A={0}[ft3])&quot;</span>, r.Area );\n&nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; <span class=\"blue\">else</span> <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == r.Location ) <span class=\"green\">// Unplaced if no Location</span>\n&nbsp; &nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; &nbsp; sb.AppendFormat( <span class=\"maroon\">&quot;UnPlaced (Location is null)&quot;</span> );\n&nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; <span class=\"blue\">else</span>\n&nbsp; &nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; &nbsp; sb.AppendFormat( <span class=\"maroon\">&quot;NotEnclosed or Redundant &quot;</span>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; + <span class=\"maroon\">&quot;- how to distinguish?&quot;</span> );\n&nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n&nbsp; }\n</pre>\n\nAny ideas if this is possible?\n\n**Answer:** Rooms that are redundant still have normal boundaries.\n\nSo you can call `Room.GetBoundarySegments` to test.\n\nThe list will be empty for a non-enclosed or unplaced room.\n\n**Response:** Thank you, Diane!\n\nHere is the final solution implementing your suggestion:\n\n<pre class=\"code\">\n&nbsp; <span class=\"blue\">public</span> <span class=\"blue\">enum</span> <span class=\"teal\">RoomState</span>\n&nbsp; {\n&nbsp; &nbsp; Unknown,\n&nbsp; &nbsp; Placed,\n&nbsp; &nbsp; NotPlaced,\n&nbsp; &nbsp; NotEnclosed,\n&nbsp; &nbsp; Redundant\n&nbsp; }\n&nbsp;\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> Distinguish 'Not Placed',&nbsp; 'Redundant' </span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> and 'Not Enclosed' rooms.</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n&nbsp; <span class=\"teal\">RoomState</span> DistinguishRoom( <span class=\"teal\">Room</span> room )\n&nbsp; {\n&nbsp; &nbsp; <span class=\"teal\">RoomState</span> res = <span class=\"teal\">RoomState</span>.Unknown;\n&nbsp;\n&nbsp; &nbsp; <span class=\"blue\">if</span>( room.Area &gt; 0 )\n&nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; <span class=\"green\">// Placed if having Area</span>\n&nbsp;\n&nbsp; &nbsp; &nbsp; res = <span class=\"teal\">RoomState</span>.Placed;\n&nbsp; &nbsp; }\n&nbsp; &nbsp; <span class=\"blue\">else</span> <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == room.Location )\n&nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; <span class=\"green\">// No Area and No Location =&gt; Unplaced</span>\n&nbsp;\n&nbsp; &nbsp; &nbsp; res = <span class=\"teal\">RoomState</span>.NotPlaced;\n&nbsp; &nbsp; }\n&nbsp; &nbsp; <span class=\"blue\">else</span>\n&nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; <span class=\"green\">// must be Redundant or NotEnclosed</span>\n&nbsp;\n&nbsp; &nbsp; &nbsp; <span class=\"teal\">SpatialElementBoundaryOptions</span> opt\n&nbsp; &nbsp; &nbsp; &nbsp; = <span class=\"blue\">new</span> <span class=\"teal\">SpatialElementBoundaryOptions</span>();\n&nbsp;\n&nbsp; &nbsp; &nbsp; <span class=\"teal\">IList</span>&lt;<span class=\"teal\">IList</span>&lt;<span class=\"teal\">BoundarySegment</span>&gt;&gt; segs\n&nbsp; &nbsp; &nbsp; &nbsp; = room.GetBoundarySegments( opt );\n&nbsp;\n&nbsp; &nbsp; &nbsp; res = ( <span class=\"blue\">null</span> == segs || segs.Count == 0 )\n&nbsp; &nbsp; &nbsp; &nbsp; ? <span class=\"teal\">RoomState</span>.NotEnclosed\n&nbsp; &nbsp; &nbsp; &nbsp; : <span class=\"teal\">RoomState</span>.Redundant;\n&nbsp; &nbsp; }\n&nbsp; &nbsp; <span class=\"blue\">return</span> res;\n&nbsp; }\n</pre>\n\nJeremy adds: I added Miro's test methods as `DistinguishRoomsDraft` and `DistinguishRoom`\nto [The Building Coder samples](https://github.com/jeremytammik/the_building_coder_samples)\n[release 2016.0.126.8](https://github.com/jeremytammik/the_building_coder_samples/releases/tag/2016.0.126.8) in\nthe module [CmdListAllRooms.cs](https://github.com/jeremytammik/the_building_coder_samples/blob/master/BuildingCoder/BuildingCoder/CmdListAllRooms.cs#L30-L110).\n\nMany thanks to Miro and Diane for the interesting question, research and answer.\n\nI actually cleaned up both the draft and final methods before publishing them, with the two following strong recommendations\non [performance](#2) and [exception handling](#3):"
  },
  {
    "original_filename": "1417_distinguish_rooms",
    "header_text": "<a name=\"2\"></a>Performance",
    "local_header_href": "#a-name2aperformance",
    "chunk_text": "#### <a name=\"2\"></a>Performance\n\nLooking at your code, I notice an important inefficiency:\n\n<pre>\n  foreach( Element elRoom in fecRooms.ToElements() )\n  {\n    Room r = elRoom as Room;\n</pre>\n\nYou can save yourself the duplication of the entire list of rooms by eliminating the call to `ToElements`, and the cast is not needed either:\n\n<pre>\n  foreach( Room r in fecRooms )\n</pre>\n\nI hope this helps... systematically!\n\nI hope you can eliminate a thousand calls to `ToElements` all over all your projects.\n\nI discussed this and other similar issues many times here in the past, e.g.\nfor [FindElement and filtered element collector optimisation](http://thebuildingcoder.typepad.com/blog/2012/09/findelement-and-collector-optimisation.html)\nand\n[ToElementIds performance](http://thebuildingcoder.typepad.com/blog/2012/12/toelementids-performance.html)."
  },
  {
    "original_filename": "1417_distinguish_rooms",
    "header_text": "<a name=\"3\"></a>Exception Handling",
    "local_header_href": "#a-name3aexception-handling",
    "chunk_text": "#### <a name=\"3\"></a>Exception Handling\n\nI eliminated a catch-all exception handler from Miro's solution.\n\nAre you aware of the strong recommendation against never, ever, catching all exceptions?\n\nUsing a `catch` with no specific exceptions listed is very strongly discouraged, cf. e.g. these articles\non [C# catching all exceptions](http://stackoverflow.com/questions/315948/c-catching-all-exceptions)\nand [why <code>catch(Exception)</code> and empty <code>catch</code> is bad](http://blogs.msdn.com/b/dotnet/archive/2009/02/19/why-catch-exception-empty-catch-is-bad.aspx).\n\nHere is another more extensive discussion\non [exception handling in C# with the \"Do Not Catch Exceptions That You Cannot Handle\" rule in mind](http://www.codeproject.com/Articles/7557/Exception-Handling-in-C-with-the-quot-Do-Not-Catch)."
  }
]