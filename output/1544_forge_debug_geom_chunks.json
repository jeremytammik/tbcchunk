[
  {
    "original_filename": "1544_forge_debug_geom",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n<link rel=\"stylesheet\" type=\"text/css\" href=\"bc.css\">\n<!-- <script src=\"run_prettify.js\" type=\"text/javascript\"></script> --> \n<script src=\"https://google-code-prettify.googlecode.com/svn/loader/run_prettify.js\" type=\"text/javascript\"></script>\n</head>\n\n<!---\n\n- debugging node.js with vs 2015 on mac\n  http://through-the-interface.typepad.com/through_the_interface/2017/02/enabling-visual-studio-codes-integrated-web-debugging.html\n  [Visual Studio Code](https://code.visualstudio.com)\n\n\nAdding Custom Geometry to the Forge Viewer #RevitAPI @AutodeskRevit #aec #bim #dynamobim @AutodeskForge http://bit.ly/addforgegeom\n\nI am in Gothenburg supporting the Forge accelerator.\nMy project here is ForgeFader, implementing the same end user functionality as the RvtFader Revit C# .NET API add-in that I implemented last week.\nI have not quite finished it yet, but the existing functionality looks as if it already ought to be very useful indeed to anyone working with geometry in the Forge viewer\n&ndash; Working in Visual Studio Code\n&ndash; ForgeFader\n&ndash; Implementation\n&ndash; Adding custom geometry to the Forge Viewer\n&ndash; Next steps...\n\n-->"
  },
  {
    "original_filename": "1544_forge_debug_geom",
    "header_text": "Adding Custom Geometry to the Forge Viewer",
    "local_header_href": "#adding-custom-geometry-to-the-forge-viewer",
    "chunk_text": "### Adding Custom Geometry to the Forge Viewer\n\nI am in Gothenburg supporting the\n[Forge accelerator](http://thebuildingcoder.typepad.com/blog/2017/03/events-uv-coordinates-and-rooms-on-level.html#2).\n\nMy project here is [ForgeFader](https://github.com/jeremytammik/forgefader),\nimplementing the same end user functionality as\nthe [RvtFader](https://github.com/jeremytammik/RvtFader) Revit\nC# .NET API add-in that I implemented last week.\n\nI have not quite finished it yet, but the existing functionality looks as if it already ought to be very useful indeed to anyone working with geometry in the Forge viewer.\n\n- [Working in Visual Studio Code](#2)\n- [ForgeFader](#3)\n- [Implementation](#4)\n- [Adding custom geometry to the Forge Viewer](#5)\n- [Next steps](#6)\n- [Detailed notes and pointers](#7)"
  },
  {
    "original_filename": "1544_forge_debug_geom",
    "header_text": "<a name=\"2\"></a>Working in Visual Studio Code",
    "local_header_href": "#a-name2aworking-in-visual-studio-code",
    "chunk_text": "#### <a name=\"2\"></a>Working in Visual Studio Code\n\nInspired by Kean Walmsley's note\non [enabling Visual Studio Codeâ€™s integrated web debugging](http://through-the-interface.typepad.com/through_the_interface/2017/02/enabling-visual-studio-codes-integrated-web-debugging.html),\nI am using [Visual Studio Code](https://code.visualstudio.com) to develop ForgeFader and very happy with it indeed.\n\n<center>\n<img src=\"img/forgefader_in_vs_code.png\" alt=\"ForgeFaver in Visual Studio Code\" width=\"500\"/>\n</center>\n\nI have not actually enabled\nthe [integration with Chrome debugging](https://marketplace.visualstudio.com/items?itemName=msjsdiag.debugger-for-chrome) that\nis the main point of Kean's article, but just using this as an editor is a good start."
  },
  {
    "original_filename": "1544_forge_debug_geom",
    "header_text": "<a name=\"3\"></a>ForgeFader",
    "local_header_href": "#a-name3aforgefader",
    "chunk_text": "#### <a name=\"3\"></a>ForgeFader\n\nForgeFader implements a Forge viewer extension to calculate and display signal attenuation caused by distance and obstacles in a building model with a floor plan containing walls.\n\nIt implements a functionality similar to [RvtFader](https://github.com/jeremytammik/RvtFader):\n\nGiven a source point, calculate the attenuation in a widening circle around it and display that as a heat map.\n\nTwo signal attenuation values in decibels are defined in the application settings:\n\n- Attenuation per metre in air\n- Attenuation by a wall\n\nThis app is based on Philippe Leefsma's [Forge React boilerplate sample](https://github.com/Autodesk-Forge/forge-react-boiler.nodejs).\n\nPlease refer to that for more details on the underlying architecture and components used."
  },
  {
    "original_filename": "1544_forge_debug_geom",
    "header_text": "<a name=\"4\"></a>Implementation",
    "local_header_href": "#a-name4aimplementation",
    "chunk_text": "#### <a name=\"4\"></a>Implementation\n\nThe ForgeFader implementation lives\nin [Viewing.Extension.Fader.js](https://github.com/jeremytammik/forgefader/blob/master/src/client/viewer.components/Viewing.Extension.Fader/Viewing.Extension.Fader.js).\n\nOn loading, in `onGeometryLoaded`, it determines the Revit BIM wall fragments for subsequent ray tracing.\n\nOn picking a point on a floor in the model, in `onSelection`, it launches the `attenuationCalculator` function to do the work.\n\nThat fiddles around a bit to determine the picked floor top faces and add a new mesh to the model on which to draw the attenuation map.\n\nOnce the mesh has been added, it in turn calls `rayTraceToFindWalls` to create a bitmap representing the signal attenuation to be displayed by a custom shader."
  },
  {
    "original_filename": "1544_forge_debug_geom",
    "header_text": "<a name=\"5\"></a>Adding Custom Geometry to the Forge Viewer",
    "local_header_href": "#a-name5aadding-custom-geometry-to-the-forge-viewer",
    "chunk_text": "#### <a name=\"5\"></a>Adding Custom Geometry to the Forge Viewer\n\nWhen debugging any kind of geometrical programming task, it is of utmost importance to be able to comfortably visualise the situation.\n\nIn this app, I add three different kinds of geometry dynamically to the model displayed by the Forge viewer:\n\n- Points and lines representing the top face of the floor and the picked source point.\n- A mesh representing the top face of the floor to be equipped with a custom shader and offset slightly above and away from the floor element surface.\n- Points and lines representing the raytracing rays.\n\nThree example screen snapshots illustrate what I mean.\n\nDisplay points and lines for debugging using `drawVertex` and `drawLine`:\n\n<center>\n<img src=\"img/forgefader_line_vertex_debug_marker_300.png\" alt=\"Line and vertex debug markers\" width=\"300\"/>\n</center>\n\nCreate a mesh to represent the floor top face and offset it up slightly above the floor surface:\n\n<center>\n<img src=\"img/forgefader_floor_top_face_mesh_250.png\" alt=\"Floor top face mesh\" width=\"250\"/>\n</center>\n\nA debug helper displaying lines in the model representing the ray tracing rays:\n\n<center>\n<img src=\"img/forgefader_ray_trace_rays_250.png\" alt=\"Ray tracing rays\" width=\"250\"/>\n</center>"
  },
  {
    "original_filename": "1544_forge_debug_geom",
    "header_text": "<a name=\"6\"></a>Next Steps",
    "local_header_href": "#a-name6anext-steps",
    "chunk_text": "#### <a name=\"6\"></a>Next Steps\n\n- Perform the raytracing to determine the number of walls between the picked signal source point and a grid of target points\n- Generate a bitmap based on that information, or simply a mapping of `(u.v)` values to the desired colour value.\n- Implement a custom fragment shader to display the (u,v) to colour mapping on the floor top face mesh."
  },
  {
    "original_filename": "1544_forge_debug_geom",
    "header_text": "<a name=\"7\"></a>Detailed Notes and Pointers",
    "local_header_href": "#a-name7adetailed-notes-and-pointers",
    "chunk_text": "#### <a name=\"7\"></a>Detailed Notes and Pointers\n\nI made the following notes during the research and implementation steps.\n\n- Colour gradient examples:\n    - A series of three consecutive approaches to solve the task, starting with the most obvious, for the learning curve.\n      However, the last in the series, using shaders, although last in the learning curve, once understood, is actually probably the most effective and simplest approach.\n    - [Projecting Dynamic Textures onto Flat Surfaces with Three.js](https://forge.autodesk.com/cloud_and_mobile/2016/07/projecting-dynamic-textures-onto-flat-surfaces-with-threejs.html).\n    - [Using Shaders to Generate Dynamic Textures in the Viewer API](https://forge.autodesk.com/cloud_and_mobile/2016/07/using-shaders-to-generate-dynamic-textures.html).\n    - [mourner/simpleheat](https://github.com/mourner/simpleheat), A super-tiny JavaScript library for drawing heatmaps with Canvas\n- Setting up the new project based on boilerplate code:\n    - Fork [forge-react-boiler.nodejs](https://github.com/Autodesk-Forge/forge-react-boiler.nodejs).\n    - Clone, npm install, npm start.\n    - Translate my Revit model to obtain a `urn`: [models.autodesk.io](https://models.autodesk.io).\n    - Load model into boilerplate: [localhost:3000/viewer?urn=...](http://localhost:3000/viewer?urn=...)\n    - My urn for the little house floor is `dXJuOm...ydnQ`\n    - [localhost:3000/viewer?urn=dXJuOm...ydnQ](http://localhost:3000/viewer?urn=dXJuOmFkc2sub2JqZWN0czpvcy5vYmplY3Q6bW9kZWwyMDE3LTAzLTI3LTEwLTM4LTMzLWQ0MWQ4Y2Q5OGYwMGIyMDRlOTgwMDk5OGVjZjg0MjdlL2xpdHRsZV9ob3VzZV9mbG9vci5ydnQ)\n- Looked at `forge-rcdb.nodejs` sample `Viewing.Extension.Configurator.Predix.js` `onSelection`; it relies on `EventTool` and `EventsEmitter`.\n- [How to get the model object tree of 2d drawing](http://stackoverflow.com/questions/41558468/how-to-get-the-model-object-tree-of-2d-drawing).\n- `Viewer.Toolkit/Viewer.Toolkit.js` `getLeafNodes`.\n- For ray tracing, look at `library-javascript-viewer-extensions` `Viewing.Extension.Transform/Viewing.Tool.Rotate.js` `onPointerDown` and `pointerToRaycaster`.\n- [Create a custom mesh](http://stackoverflow.com/questions/9252764/how-to-create-a-custom-mesh-on-three-js) with a finer resolution than the original face.\n- [Assign colours to the mesh](http://stackoverflow.com/questions/32063065/assigning-non-interpolated-colors-on-a-mesh-in-three-js).\n- Call `scene.add` and pass a mesh.\n- The viewer does not have any concept of the face of an element. \n  It is all just individual triangular fragments.\n- Philippe implemented a snapper tool to collect as many triangles as possible to guess what the face might be in\n  his  [GeometrySelector](http://viewer.autodesk.io/node/gallery/embed?id=560c6c57611ca14810e1b2bf&extIds=Autodesk.ADN.Viewing.Extension.GeometrySelector) in\n  the [library-javascript-viewer-extensions](https://github.com/Autodesk-Forge/library-javascript-viewer-extensions).\n- Check out the function `drawFace` in [Snapper.js](https://github.com/Autodesk-Forge/library-javascript-viewer-extensions/blob/master/src/Autodesk.ADN.Viewing.Extension.GeometrySelector/Autodesk.ADN.Viewing.Tool.Snapper.js).\n- Shader produces all the points, calculates and sets result.\n- [Stemkoski Three.js Examples](https://stemkoski.github.io/Three.js/),\n[Shader &ndash; Attributes](https://stemkoski.github.io/Three.js/Shader-Attributes.html)\n([source](view-source:https://stemkoski.github.io/Three.js/Shader-Attributes.html)).\n- [Intro to Pixel Shaders in Three.js](https://www.airtightinteractive.com/2013/02/intro-to-pixel-shaders-in-three-js).\n\nI want to attach a fragment shader to the picked floor face.\nMy shader should draw an image or texture directly, i.e., the desired 'heat map'.\nHere are [som more complex pixel shader samples](https://threejs.org/examples/webgl_shader2.html).\nI need to implement a fragment shader script and equip it with an id.\n  \n- WebGL shaders are written in GLSL, the [OpenGL Shading Language](https://en.wikipedia.org/wiki/OpenGL_Shading_Language).\n- [Pixel Shaders](http://pixelshaders.com) by Toby Schachman and the [sample tutorial chapter](http://pixelshaders.com/sample).\n- Philippe's first article on [Forge viewer custom shaders](http://adndevblog.typepad.com/cloud_and_mobile/2017/01/forge-viewer-custom-shaders-part-1.html)."
  }
]