[
  {
    "original_filename": "0293_spot_elevation_at_beam_top",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<head>\n<link href=\"bc.css\" rel=\"stylesheet\" type=\"text/css\"/>\n</head>"
  },
  {
    "original_filename": "0293_spot_elevation_at_beam_top",
    "header_text": "Spot Elevation Creation on Top of Beam",
    "local_header_href": "#spot-elevation-creation-on-top-of-beam",
    "chunk_text": "<h3>Spot Elevation Creation on Top of Beam</h3><p>Here is another interesting solution to discuss in between the series on the Revit API geometry library from Scott Conover's Autodesk University presentation on\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/01/analyse-building-geometry.html\">\nanalysing building geometry</a>.\n\nThis issue was also raised by Scott and deals with adding a spot elevation to a beam.\nIt contains useful information both about spot elevation creation and using FindReferencesByDirection to find the top of a beam more easily than with get_Geometry.\n\n<p><strong>Question:</strong> I am trying to add a spot dimension to the location curve of a beam.\nHowever, when I ask the beam location curve for a reference, it returns null.\nI found the same when I tried to obtain a reference for the location curve of a wall.\n\n<p><strong>Answer:</strong> The assumption that a location curve can return a reference is completely incorrect.\nThe location curve of a beam or wall does not represent a referenceable object.\n\n<p>A spot elevation should be created referencing a <strong>physical</strong> piece of geometry, for instance the <strong>top surface</strong> of the beam.\nYou can still rely on the location curve to compute the nearest point of the spot elevation.\n\n<p>Below is the source code for a Revit 2010 VSTA macro that places three spot elevations on the top of a beam, at the midpoint and both ends.\nIt defines three methods:\n\n<ul>\n<li>FindView – Return a view in the document with the given name.\n<li>FindTopMostReference – Return a reference to the topmost face of the given element.\n<li>NewSpotElevation – the macro entry point, creating new spot elevations on the top surface of a beam.\n</li></li></li></ul>\n<p>The implementation of FindView is pretty standard:\n\n<pre class=\"code\">\n<span class=\"blue\">private</span> <span class=\"teal\">View</span> FindView( <span class=\"teal\">Document</span> doc, <span class=\"teal\">String</span> name )\n{\n  <span class=\"teal\">TypeFilter</span> filter = Create.Filter.NewTypeFilter(\n    <span class=\"blue\">typeof</span>( <span class=\"teal\">View</span> ), <span class=\"blue\">true</span> );\n \n  <span class=\"teal\">ElementIterator</span> iter = doc.get_Elements( filter );\n  <span class=\"teal\">View</span> ret = <span class=\"blue\">null</span>;\n \n  iter.Reset();\n  <span class=\"blue\">while</span>( iter.MoveNext() )\n  {\n    <span class=\"teal\">Element</span> e = iter.Current <span class=\"blue\">as</span> <span class=\"teal\">Element</span>;\n \n    <span class=\"blue\">if</span>( e.Name == name )\n    {\n      ret = e <span class=\"blue\">as</span> <span class=\"teal\">View</span>;\n      <span class=\"blue\">break</span>;\n    }\n  }\n  <span class=\"blue\">return</span> ret;\n}\n</pre>\n<p>FindTopMostReference is much more interesting.\nWe define a viewDirection vector pointing straight down, and a point centerOfTopOfBox that is located exactly above the element whose top surface we are targeting.\nUsing FindReferencesByDirection and filtering the resulting intersections to get the closest reference that belongs to the given element guarantees that the top surface is identified.\n\n<p>The entire operation is encapsulated in a transaction.\nThis is used for the creation of a temporary view which can then be discarded afterwards.\nWe thus avoid having to search for an existing 3D view.  \nRemember that a 3D view is needed to use FindReferencesByDirection.\nThe view is created within the transaction so we have a default 3D view to work with, and the transaction is then aborted so as not to keep the view around afterwards.\n\n<pre class=\"code\">\n<span class=\"blue\">private</span> <span class=\"teal\">Reference</span> FindTopMostReference( <span class=\"teal\">Element</span> e )\n{\n  <span class=\"teal\">Document</span> doc = e.Document;\n \n  doc.BeginTransaction();\n \n  <span class=\"teal\">XYZ</span> viewDirection = Create.NewXYZ( 0, 0, -1 );\n \n  <span class=\"teal\">View3D</span> view3D = doc.Create.NewView3D(\n    viewDirection );\n \n  <span class=\"teal\">BoundingBoxXYZ</span> elemBoundingBox\n    = e.get_BoundingBox( view3D );\n \n  <span class=\"teal\">XYZ</span> max = elemBoundingBox.Max;\n \n  <span class=\"teal\">XYZ</span> minAtMaxElevation = elemBoundingBox.Min;\n \n  minAtMaxElevation.Z = max.Z;\n \n  <span class=\"teal\">XYZ</span> centerOfTopOfBox = minAtMaxElevation\n    .Add( max ).Divide( 2 );\n \n  centerOfTopOfBox.Z = centerOfTopOfBox.Z + 10;\n \n  <span class=\"teal\">ReferenceArray</span> references\n    = doc.FindReferencesByDirection(\n      centerOfTopOfBox, viewDirection, view3D );\n \n  <span class=\"blue\">double</span> closest = <span class=\"teal\">Double</span>.PositiveInfinity;\n \n  <span class=\"teal\">Reference</span> ret = <span class=\"blue\">null</span>;\n \n  <span class=\"blue\">foreach</span>( <span class=\"teal\">Reference</span> r <span class=\"blue\">in</span> references )\n  {\n    <span class=\"blue\">if</span>( r.Element.Id.Value == e.Id.Value\n      &amp;&amp; r.ProximityParameter &lt; closest )\n    {\n      ret = r;\n      closest = r.ProximityParameter;\n    }\n  }\n  doc.AbortTransaction();\n \n  <span class=\"blue\">return</span> ret;\n}\n</pre>\n<p>Note how the reference is the face on the top of the element, whereas the target point is evaluated from the location curve parameter.\nThis works even if the location alignment of the beam is along the bottom of the beam; the elevations are still at the top.\n\n<p>This method probably deserves being copied into your personal toolbox right away for reference and future reuse.\nIt looks both generally useful and instructive to me.\n\n<p>Finally, here is the implementation of the NewSpotElevation macro mainline, which performs the following steps:\n\n<ul>\n<li>Find the view named \"West\".\n<li>Find the beam family instance with a specific hardcoded element id.\n<li>Use FindTopMostReference to obtain a reference to its top surface.\n<li>Retrieve its location curve.\n<li>Open a transaction to apply changes to the model.\n<li>Step along the location curve to create spot elevations along the top surface at the beginning, midpoint and end of the beam.\n<li>Close the transaction to apply the changes to the model.\n</li></li></li></li></li></li></li></ul>\n<p>Note that this is an application-level macro.\nApplication-level macros are required to manage all their own transactions, whereas document-level macros automatically open a transaction on the active document, just like external commands.\n\n<pre class=\"code\">\n<span class=\"blue\">public</span> <span class=\"blue\">void</span> NewSpotElevation()\n{\n  <span class=\"teal\">Document</span> doc = ActiveDocument;\n \n  <span class=\"teal\">View</span> westView = FindView( doc, <span class=\"maroon\">\"West\"</span> );\n \n  <span class=\"green\">// define the hard coded element id of beam:</span>\n \n  <span class=\"teal\">ElementId</span> instanceId = Create.NewElementId();\n \n  instanceId.Value = 230298;\n \n  <span class=\"teal\">FamilyInstance</span> familyInstance = doc.get_Element(\n    <span class=\"blue\">ref</span> instanceId ) <span class=\"blue\">as</span> <span class=\"teal\">FamilyInstance</span>;\n \n  <span class=\"teal\">Reference</span> topReference = FindTopMostReference(\n    familyInstance );\n \n  <span class=\"teal\">LocationCurve</span> lCurve = familyInstance.Location\n    <span class=\"blue\">as</span> <span class=\"teal\">LocationCurve</span>;\n \n  doc.BeginTransaction();\n \n  <span class=\"blue\">for</span>( <span class=\"blue\">int</span> beamIndex = 0; beamIndex &lt; 3; ++beamIndex )\n  {\n    <span class=\"teal\">XYZ</span> lCurvePnt = lCurve.Curve.Evaluate(\n      0.5 * beamIndex, <span class=\"blue\">true</span> );\n \n    <span class=\"teal\">XYZ</span> bendPnt = lCurvePnt.Add(\n      Create.NewXYZ( 0, 1, 4 ) );\n \n    <span class=\"teal\">XYZ</span> endPnt = lCurvePnt.Add(\n      Create.NewXYZ( 0, 2, 4 ) );\n \n    <span class=\"green\">// NewSpotElevation arguments:</span>\n    <span class=\"green\">//</span>\n    <span class=\"green\">// View view, Reference reference, </span>\n    <span class=\"green\">// XYZ origin, XYZ bend, XYZ end, XYZ refPt, </span>\n    <span class=\"green\">// bool hasLeader</span>\n \n    <span class=\"teal\">SpotDimension</span> sd = doc.Create.NewSpotElevation(\n      westView, topReference, lCurvePnt, bendPnt,\n      endPnt, lCurvePnt, <span class=\"blue\">true</span> );\n  }\n  doc.EndTransaction();\n}\n</pre>\n<p>Scott provided a \n\n<a href=\"zip/ForSpotElevation.rvt\">\nsample model ForSpotElevation.rvt</a>\n\ncontaining a beam that runs N-S so that the West view shows the three different spot elevations, displaying them even more clearly by putting it at an angle.\n\n<p>Here is the west view of the target beam before running the macro:</p>\n<center>\n<img alt=\"Original beam\" src=\"img/spot_elevation_beam.png\"/>\n</center>\n<p>Here are the resulting spot elevations created by the macro on the beam's top surface:</p>\n<center>\n<img alt=\"Spot elevations on beam\" src=\"img/spot_elevations_on_beam.png\"/>\n</center>\n<p>I converted Scott's VSTA macro source code to create a new Building Coder sample external command named CmdNewSpotElevation.\nHere is\n\n<a href=\"zip/bc11060.zip\">\nversion 1.1.0.60</a>\n\nof the complete Building Coder source code and Visual Studio solution including the new command.</p>\n<p>Many thanks to Scott for providing this useful and instructive solution!\n</p></p></p></p></p></p></p></p></p></p></p></p></p></p>"
  }
]