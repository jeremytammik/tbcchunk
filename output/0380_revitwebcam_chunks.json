[
  {
    "original_filename": "0380_revitwebcam",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<head>\n<link href=\"bc.css\" rel=\"stylesheet\" type=\"text/css\"/>\n</head>"
  },
  {
    "original_filename": "0380_revitwebcam",
    "header_text": "Display Webcam Image on Building Element Face",
    "local_header_href": "#display-webcam-image-on-building-element-face",
    "chunk_text": "<h3>Display Webcam Image on Building Element Face</h3><p>We are now ready to implement RevitWebcam, making use of the \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/06/grabbing-an-internet-webcam-image.html\">\nwebcam image grabber</a>\n\nthat I presented yesterday.\n\n<p>As I explained, the idea is to make use of the new Revit API\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/04/idling-event.html\">\nIdling event</a> \n\nwhich allows \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/04/asynchronous-api-calls-and-idling.html\">\nsemi-asynchronous access</a> to the Revit API.\n\n<p>In order to display the webcam image updating itself in real-time on a Revit building element face, I implement the following steps:\n\n<ul>\n<li><a href=\"#1\">Select a face on a BIM element</a>.\n<li><a href=\"#2\">Set up a spatial field primitive for it</a>.\n<li><a href=\"#3\">Set the analysis display style</a>.\n<li><a href=\"#4\">Subscribe to the Idling event</a>.\n<li><a href=\"#5\">Handle the Idling event</a>.\n</li></li></li></li></li></ul>\n<p>The first item is standard selection handling, and a suitable Revit SDK sample demonstrating that is the aptly named Selections sample.\nThe second and third items have more to do with the analysis visualisation framework than the Idling event handling, and I based the code I wrote to implement them on the Revit SDK AVF samples DistanceToSurfaces and SpatialFieldGradient.\n\n<a name=\"1\"></a>\n<h4>Select a Face on a BIM Element</h4>\n<p>In order to select the face, we make use of the new picking facilities and set up a filter to allow the user to only select faces, and only on building elements. \nThe method that I use to check whether an element is in fact a building element and not part of the annotation or something else is to check whether it has a valid category and its category contributes material to the building model.\nThe call to select the element face and store it in a global variable _faceReference looks like this:\n\n<pre class=\"code\">\n  <span class=\"teal\">Reference</span> r = uidoc.Selection.PickObject( \n    <span class=\"teal\">ObjectType</span>.Face, \n    <span class=\"blue\">new</span> <span class=\"teal\">BimElementFilter</span>(), \n    _prompt );\n\n  _faceReference = r;\n</pre>\n<p>It makes use of the following selection filter:\n\n<pre class=\"code\">\n<span class=\"blue\">class</span> <span class=\"teal\">BimElementFilter</span> : <span class=\"teal\">ISelectionFilter</span>\n{\n  <span class=\"blue\">public</span> <span class=\"blue\">bool</span> AllowElement( <span class=\"teal\">Element</span> e )\n  {\n    <span class=\"blue\">return</span> <span class=\"blue\">null</span> != e.Category\n      &amp;&amp; e.Category.HasMaterialQuantities;\n  }\n \n  <span class=\"blue\">public</span> <span class=\"blue\">bool</span> AllowReference( <span class=\"teal\">Reference</span> r, <span class=\"teal\">XYZ</span> p )\n  {\n    <span class=\"blue\">return</span> <span class=\"blue\">true</span>;\n  }\n}\n</pre>\n<a name=\"2\"></a>\n<h4>Set a Spatial Field Primitive for a Face on a BIM Element</h4>\n<p>To display analysis results on the selected face requires us to set up a spatial field primitive for it.\nSpatial field primitives are handled by the SpatialFieldManager class, which uses integer indices to keep track of them.\nIn order to update the correct primitive later on, we store it in a global variable _sfp_index.\nHere is the code to access the manager and set up the primitive:\n\n<pre class=\"code\">\n  <span class=\"teal\">SpatialFieldManager</span> sfm\n    = <span class=\"teal\">SpatialFieldManager</span>.GetSpatialFieldManager( \n      view );\n \n  <span class=\"blue\">if</span>( <span class=\"blue\">null</span> != sfm &amp;&amp; 0 &lt; _sfp_index )\n  {\n    sfm.RemoveSpatialFieldPrimitive( \n      _sfp_index );\n \n    _sfp_index = -1;\n  }\n</pre>\n<a name=\"3\"></a>\n<h4>Set the Analysis Display Style</h4>\n<p>I set up an analysis display style in order to turn off the gridlines and define a black and white colour range suitable for the greyscale image I retrieve from the webcam.\nThe code to do so is based on the SpatialFieldGradient SDK sample and looks like this:\n\n<pre class=\"code\">\n<span class=\"blue\">void</span> SetAnalysisDisplayStyle( <span class=\"teal\">Document</span> doc )\n{\n  <span class=\"teal\">AnalysisDisplayStyle</span> analysisDisplayStyle;\n \n  <span class=\"blue\">const</span> <span class=\"blue\">string</span> styleName \n    = <span class=\"maroon\">\"Revit Webcam Display Style\"</span>;\n \n  <span class=\"green\">// extract existing display styles with specific name</span>\n \n  <span class=\"teal\">FilteredElementCollector</span> a \n    = <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( doc );\n \n  <span class=\"teal\">IList</span>&lt;<span class=\"teal\">Element</span>&gt; elements = a\n    .OfClass( <span class=\"blue\">typeof</span>( <span class=\"teal\">AnalysisDisplayStyle</span> ) )\n    .Where( x =&gt; x.Name.Equals( styleName ) )\n    .Cast&lt;<span class=\"teal\">Element</span>&gt;()\n    .ToList();\n \n  <span class=\"blue\">if</span>( 0 &lt; elements.Count )\n  {\n    <span class=\"green\">// use the existing display style</span>\n \n    analysisDisplayStyle = elements[0] \n      <span class=\"blue\">as</span> <span class=\"teal\">AnalysisDisplayStyle</span>;\n  }\n  <span class=\"blue\">else</span>\n  {\n    <span class=\"green\">// create new display style:</span>\n \n    <span class=\"green\">// coloured surface settings:</span>\n \n    <span class=\"teal\">AnalysisDisplayColoredSurfaceSettings</span> \n      coloredSurfaceSettings \n        = <span class=\"blue\">new</span> <span class=\"teal\">AnalysisDisplayColoredSurfaceSettings</span>();\n \n    coloredSurfaceSettings.ShowGridLines = <span class=\"blue\">false</span>;\n \n    <span class=\"green\">// color settings:</span>\n \n    <span class=\"teal\">AnalysisDisplayColorSettings</span> colorSettings \n      = <span class=\"blue\">new</span> <span class=\"teal\">AnalysisDisplayColorSettings</span>();\n \n    colorSettings.MaxColor = <span class=\"blue\">new</span> <span class=\"teal\">Color</span>( 255, 255, 255 );\n    colorSettings.MinColor = <span class=\"blue\">new</span> <span class=\"teal\">Color</span>( 0, 0, 0 );\n \n    <span class=\"green\">// legend settings:</span>\n \n    <span class=\"teal\">AnalysisDisplayLegendSettings</span> legendSettings \n      = <span class=\"blue\">new</span> <span class=\"teal\">AnalysisDisplayLegendSettings</span>();\n \n    legendSettings.NumberOfSteps = 10;\n    legendSettings.Rounding = 0.05;\n    legendSettings.ShowDataDescription = <span class=\"blue\">false</span>;\n    legendSettings.ShowLegend = <span class=\"blue\">true</span>;\n \n    <span class=\"green\">// extract legend text:</span>\n \n    a = <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( doc );\n \n    elements = a\n      .OfClass( <span class=\"blue\">typeof</span>( <span class=\"teal\">TextNoteType</span> ) )\n      .Where( x =&gt; x.Name == <span class=\"maroon\">\"LegendText\"</span> )\n      .Cast&lt;<span class=\"teal\">Element</span>&gt;()\n      .ToList();\n \n    <span class=\"blue\">if</span>( 0 &lt; elements.Count )\n    {\n      <span class=\"green\">// if LegendText exists, use it for this display style</span>\n \n      <span class=\"teal\">TextNoteType</span> textType = elements[0] <span class=\"blue\">as</span> <span class=\"teal\">TextNoteType</span>;\n \n      legendSettings.SetTextTypeId( textType.Id, doc );\n    }\n \n    <span class=\"green\">// create the analysis display style:</span>\n \n    analysisDisplayStyle = <span class=\"teal\">AnalysisDisplayStyle</span>\n      .CreateAnalysisDisplayStyle(\n        doc, styleName, coloredSurfaceSettings, \n        colorSettings, legendSettings );\n  }\n \n  <span class=\"green\">// assign the display style to the active view</span>\n \n  doc.ActiveView.AnalysisDisplayStyleId \n    = analysisDisplayStyle.Id;\n}\n</pre>\n<a name=\"4\"></a>\n<h4>Subscribe to the Idling Event</h4>\n<p>Now we get to the real meat of this discussion, subscribing to the Idling event and implementing the handler to process it.\n\n<p>The actual subscription process is a one-liner:\n\n<pre class=\"code\">\n  uiapp.Idling\n    += <span class=\"blue\">new</span> <span class=\"teal\">EventHandler</span>&lt;<span class=\"teal\">IdlingEventArgs</span>&gt;(\n      OnIdling );\n</pre>\n<a name=\"5\"></a>\n<h4>Handle the Idling Event</h4>\n<p>The event handler may be called very frequently, as demonstrated by The Building Coder \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/04/idling-event.html\">\nCmdIdling</a> command.\n\nSince the webcam image will be updated less frequently, it makes sense to check for updates less frequently than the handler is called, i.e. skip the majority of the calls. \nI do so by defining a minimum elapsed time interval, and simply returning immediately from the handler if it has not yet passed since the last update.\n\n<p>If the minimum time interval is up, I grab the current image from URL.\nThere is still no guarantee that it has changed, so before starting a transaction and making any changes to the Revit model, I compare the current image with the last one displayed.\nThe comparison is rather simplistic, based on a SHA256Managed hash value calculated from the image pixel data like this:\n\n<pre class=\"code\">\n<span class=\"blue\">public</span> <span class=\"blue\">byte</span> [] HashValue\n{\n  <span class=\"blue\">get</span>\n  {\n    <span class=\"green\">// convert image to a byte array</span>\n \n    <span class=\"teal\">ImageConverter</span> ic = <span class=\"blue\">new</span> <span class=\"teal\">ImageConverter</span>();\n \n    <span class=\"blue\">byte</span>[] bytes = ( <span class=\"blue\">byte</span>[] ) ic.ConvertTo( \n      _bitmap, <span class=\"blue\">typeof</span>( <span class=\"blue\">byte</span>[] ) );\n \n    <span class=\"green\">// compute a hash for image</span>\n \n    <span class=\"teal\">SHA256Managed</span> shaM = <span class=\"blue\">new</span> <span class=\"teal\">SHA256Managed</span>();\n    <span class=\"blue\">return</span> shaM.ComputeHash( bytes );\n  }\n}\n</pre>\n<p>If an update is deemed necessary, a transaction is started, the spatial field primitive is set up for the face, and the field points and values to display the image data are calculated and applied.\n\n<p>Here is the code to calculate the points and values for a given face and greyscale bitmap data:\n\n<pre class=\"code\">\n<span class=\"blue\">static</span> <span class=\"blue\">void</span> GetFieldPointsAndValues( \n  <span class=\"blue\">ref</span> <span class=\"teal\">IList</span>&lt;<span class=\"teal\">UV</span>&gt; pts,\n  <span class=\"blue\">ref</span> <span class=\"teal\">IList</span>&lt;<span class=\"teal\">ValueAtPoint</span>&gt; valuesAtPoints,\n  <span class=\"blue\">ref</span> <span class=\"teal\">GreyscaleBitmapData</span> data,\n  <span class=\"teal\">Face</span> face )\n{\n  <span class=\"teal\">BoundingBoxUV</span> bb = face.GetBoundingBox();\n \n  <span class=\"blue\">double</span> umin = bb.Min.U;\n  <span class=\"blue\">double</span> umax = bb.Max.U;\n  <span class=\"blue\">double</span> ustep = ( umax - umin ) / data.Width;\n  <span class=\"blue\">double</span> u = umin;\n \n  <span class=\"blue\">double</span> v = bb.Min.V;\n  <span class=\"blue\">double</span> vmax = bb.Max.V;\n  <span class=\"blue\">double</span> vstep = ( vmax - v ) / data.Height;\n \n  <span class=\"teal\">List</span>&lt;<span class=\"blue\">double</span>&gt; values = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"blue\">double</span>&gt;( 1 );\n \n  <span class=\"blue\">for</span>( <span class=\"blue\">int</span> y = 0; y &lt; data.Height; ++y, v += vstep )\n  {\n    <span class=\"teal\">Debug</span>.Assert( v &lt; vmax, \n      <span class=\"maroon\">\"expected v to remain within bounds\"</span> );\n \n    u = umin;\n \n    <span class=\"blue\">for</span>( <span class=\"blue\">int</span> x = 0; x &lt; data.Width; ++x, u += ustep )\n    {\n      <span class=\"teal\">Debug</span>.Assert( u &lt; umax, \n        <span class=\"maroon\">\"expected u to remain within bounds\"</span> );\n \n      <span class=\"blue\">double</span> brightness = data.GetBrightnessAt( \n        x, y );\n \n      <span class=\"teal\">UV</span> uv = <span class=\"blue\">new</span> <span class=\"teal\">UV</span>( u, v );\n      pts.Add( uv );\n \n      values.Clear();\n      values.Add( brightness );\n      valuesAtPoints.Add( <span class=\"blue\">new</span> <span class=\"teal\">ValueAtPoint</span>( \n        values ) );\n    }\n  }\n}\n</pre>\n<p>To summarise, the event handler thus needs to perform the following steps:\n\n<ul>\n<li>Check minimum elapsed time interval.\n<li>Grab current image from URL.\n<li>Check whether an update is required.\n<li>Start transaction for write access.\n<li>Set up spatial field primitive.\n<li>Calculate field points and values from the image data.\n<li>Update the spatial field primitive.\n</li></li></li></li></li></li></li></ul>\n<p>Here is the actual code implementing these steps:\n\n<pre class=\"code\">\n<span class=\"blue\">static</span> <span class=\"blue\">void</span> OnIdling( \n  <span class=\"blue\">object</span> sender, \n  <span class=\"teal\">IdlingEventArgs</span> e )\n{\n  <span class=\"blue\">if</span>( <span class=\"teal\">DateTime</span>.Now.Subtract( _lastUpdate ) \n    &gt; _interval )\n  {\n    Log( <span class=\"maroon\">\"OnIdling\"</span> );\n \n    <span class=\"teal\">GreyscaleBitmapData</span> data \n      = <span class=\"blue\">new</span> <span class=\"teal\">GreyscaleBitmapData</span>( \n        _width, _height, _url );\n \n    <span class=\"blue\">byte</span>[] hash = data.HashValue;\n \n    <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == _lastHash\n      || 0 != CompareBytes( hash, _lastHash ) )\n    {\n      _lastHash = hash;\n \n      <span class=\"green\">// access active document from sender:</span>\n \n      <span class=\"teal\">Application</span> app = sender <span class=\"blue\">as</span> <span class=\"teal\">Application</span>;\n \n      <span class=\"teal\">Debug</span>.Assert( <span class=\"blue\">null</span> != app,\n        <span class=\"maroon\">\"expected a valid Revit application instance\"</span> );\n \n      <span class=\"teal\">UIApplication</span> uiapp = <span class=\"blue\">new</span> <span class=\"teal\">UIApplication</span>( app );\n      <span class=\"teal\">UIDocument</span> uidoc = uiapp.ActiveUIDocument;\n      <span class=\"teal\">Document</span> doc = uidoc.Document;\n \n      Log( <span class=\"maroon\">\"OnIdling image changed, active document \"</span>\n        + doc.Title );\n \n      <span class=\"teal\">Transaction</span> transaction \n        = <span class=\"blue\">new</span> <span class=\"teal\">Transaction</span>( doc, <span class=\"maroon\">\"Revit Webcam Update\"</span> );\n \n      transaction.Start();\n \n      <span class=\"teal\">View</span> view = doc.ActiveView; <span class=\"green\">// maybe has to be 3D</span>\n \n      <span class=\"teal\">SpatialFieldManager</span> sfm \n        = <span class=\"teal\">SpatialFieldManager</span>.GetSpatialFieldManager( \n          view );\n \n      <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == sfm ) \n      {\n        sfm = <span class=\"teal\">SpatialFieldManager</span>\n          .CreateSpatialFieldManager( view, 1 );\n      }\n \n      <span class=\"blue\">if</span>( 0 &gt; _sfp_index )\n      {\n        _sfp_index = sfm.AddSpatialFieldPrimitive(\n          _faceReference );\n      }\n \n      <span class=\"blue\">int</span> nPoints = data.Width * data.Height;\n \n      <span class=\"teal\">IList</span>&lt;<span class=\"teal\">UV</span>&gt; pts = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">UV</span>&gt;( nPoints );\n \n      <span class=\"teal\">IList</span>&lt;<span class=\"teal\">ValueAtPoint</span>&gt; valuesAtPoints \n        = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">ValueAtPoint</span>&gt;( nPoints );\n \n      <span class=\"teal\">Face</span> face = _faceReference.GeometryObject \n        <span class=\"blue\">as</span> <span class=\"teal\">Face</span>;\n \n      GetFieldPointsAndValues( <span class=\"blue\">ref</span> pts, \n        <span class=\"blue\">ref</span> valuesAtPoints, <span class=\"blue\">ref</span> data, face );\n \n      <span class=\"teal\">FieldDomainPointsByUV</span> fieldPoints \n        = <span class=\"blue\">new</span> <span class=\"teal\">FieldDomainPointsByUV</span>( pts );\n \n      <span class=\"teal\">FieldValues</span> fieldValues \n        = <span class=\"blue\">new</span> <span class=\"teal\">FieldValues</span>( valuesAtPoints );\n \n      sfm.UpdateSpatialFieldPrimitive( \n        _sfp_index, fieldPoints, fieldValues );\n \n      transaction.Commit();\n      doc.Regenerate();\n \n      _lastUpdate = <span class=\"teal\">DateTime</span>.Now;\n    }\n  }\n}\n</pre>\n<p>Notice that we open our own transaction here and regenerate the document manually.\n\n<p>The mainline of the external command Execute method putting this all together looks like this:\n\n<pre class=\"code\">\n<span class=\"teal\">UIApplication</span> uiapp = commandData.Application;\n<span class=\"teal\">UIDocument</span> uidoc = uiapp.ActiveUIDocument;\n<span class=\"teal\">Document</span> doc = uidoc.Document;\n<span class=\"teal\">View</span> view = doc.ActiveView; <span class=\"green\">// maybe has to be 3D</span>\n \n<span class=\"teal\">Reference</span> r = uidoc.Selection.PickObject( \n  <span class=\"teal\">ObjectType</span>.Face, \n  <span class=\"blue\">new</span> <span class=\"teal\">BimElementFilter</span>(), \n  _prompt );\n \n<span class=\"teal\">Debug</span>.Assert( <span class=\"blue\">null</span> != r, \n  <span class=\"maroon\">\"expected non-null reference from PickObject\"</span> );\n \n<span class=\"teal\">Debug</span>.Assert( <span class=\"blue\">null</span> != r.Element, \n  <span class=\"maroon\">\"expected non-null element from PickObject\"</span> );\n \n<span class=\"teal\">Debug</span>.Assert( <span class=\"blue\">null</span> != r.GeometryObject, \n  <span class=\"maroon\">\"expected non-null geometry object from PickObject\"</span> );\n \n<span class=\"teal\">SpatialFieldManager</span> sfm\n  = <span class=\"teal\">SpatialFieldManager</span>.GetSpatialFieldManager( \n    view );\n \n<span class=\"blue\">if</span>( <span class=\"blue\">null</span> != sfm &amp;&amp; 0 &lt; _sfp_index )\n{\n  sfm.RemoveSpatialFieldPrimitive( \n    _sfp_index );\n \n  _sfp_index = -1;\n}\n_faceReference = r;\n \nSetAnalysisDisplayStyle( doc );\n \nuiapp.Idling\n  += <span class=\"blue\">new</span> <span class=\"teal\">EventHandler</span>&lt;<span class=\"teal\">IdlingEventArgs</span>&gt;(\n    OnIdling );\n \n<span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Succeeded;\n</pre>\n<p>The mainline is enclosed in an exception handler, but I have not noticed any exceptions being thrown by it so far.\n\n<p>The command uses manual transaction mode and the manual regeneration option, since the required transaction and regeneration handling is indeed implemented by the OnIdling method.\n\n<p>We can use of the view of Piccadilly Circus from the webcam we used for our \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/06/grabbing-an-internet-webcam-image.html\">\nimage grabbing samples</a>:</p>\n<center>\n<img alt=\"Webcam image of Picadilly Circus\" src=\"img/webcam_piccadilly.jpg\"/>\n</center>\n<p>I test ran the add-in in the sample project SpatialFieldGradient.rvt provided with the AVF SDK sample mentioned above, which contains various types of wall elements.\nHere is a daytime view of the Revit screen:</p>\n<center>\n<img alt=\"RevitWebcam image of Picadilly Circus at daytime\" src=\"img/webcam_on_wall.jpg\"/>\n</center>\n<p>Here is a similar view at night:</p>\n<center>\n<img alt=\"RevitWebcam image of Picadilly Circus at night\" src=\"img/webcam_on_wall_at_night.jpg\"/>\n</center>\n<p>Here is \n\n<a href=\"zip/RevitWebcam.zip\">\nRevitWebcam.zip</a>\n\ncontaining the complete source code and Visual Studio solution for this Revit external command add-in.\n\n<p>I still have one more Idling sample up my sleeve which I hope to be able to document in the coming days as well. \nMeanwhile, I hope that you find this as interesting as I do, even if this specific sample may not have that many immediate uses in most people's day-to-day work, and that the underlying principles and solution steps are useful anyway.\n</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p>"
  },
  {
    "original_filename": "0380_revitwebcam",
    "header_text": "Select a Face on a BIM Element",
    "local_header_href": "#select-a-face-on-a-bim-element",
    "chunk_text": "<h4>Select a Face on a BIM Element</h4><p>In order to select the face, we make use of the new picking facilities and set up a filter to allow the user to only select faces, and only on building elements. \nThe method that I use to check whether an element is in fact a building element and not part of the annotation or something else is to check whether it has a valid category and its category contributes material to the building model.\nThe call to select the element face and store it in a global variable _faceReference looks like this:\n\n<pre class=\"code\">\n  <span class=\"teal\">Reference</span> r = uidoc.Selection.PickObject( \n    <span class=\"teal\">ObjectType</span>.Face, \n    <span class=\"blue\">new</span> <span class=\"teal\">BimElementFilter</span>(), \n    _prompt );\n\n  _faceReference = r;\n</pre>\n<p>It makes use of the following selection filter:\n\n<pre class=\"code\">\n<span class=\"blue\">class</span> <span class=\"teal\">BimElementFilter</span> : <span class=\"teal\">ISelectionFilter</span>\n{\n  <span class=\"blue\">public</span> <span class=\"blue\">bool</span> AllowElement( <span class=\"teal\">Element</span> e )\n  {\n    <span class=\"blue\">return</span> <span class=\"blue\">null</span> != e.Category\n      &amp;&amp; e.Category.HasMaterialQuantities;\n  }\n \n  <span class=\"blue\">public</span> <span class=\"blue\">bool</span> AllowReference( <span class=\"teal\">Reference</span> r, <span class=\"teal\">XYZ</span> p )\n  {\n    <span class=\"blue\">return</span> <span class=\"blue\">true</span>;\n  }\n}\n</pre>\n<a name=\"2\"></a>\n<h4>Set a Spatial Field Primitive for a Face on a BIM Element</h4>\n<p>To display analysis results on the selected face requires us to set up a spatial field primitive for it.\nSpatial field primitives are handled by the SpatialFieldManager class, which uses integer indices to keep track of them.\nIn order to update the correct primitive later on, we store it in a global variable _sfp_index.\nHere is the code to access the manager and set up the primitive:\n\n<pre class=\"code\">\n  <span class=\"teal\">SpatialFieldManager</span> sfm\n    = <span class=\"teal\">SpatialFieldManager</span>.GetSpatialFieldManager( \n      view );\n \n  <span class=\"blue\">if</span>( <span class=\"blue\">null</span> != sfm &amp;&amp; 0 &lt; _sfp_index )\n  {\n    sfm.RemoveSpatialFieldPrimitive( \n      _sfp_index );\n \n    _sfp_index = -1;\n  }\n</pre>\n<a name=\"3\"></a>\n<h4>Set the Analysis Display Style</h4>\n<p>I set up an analysis display style in order to turn off the gridlines and define a black and white colour range suitable for the greyscale image I retrieve from the webcam.\nThe code to do so is based on the SpatialFieldGradient SDK sample and looks like this:\n\n<pre class=\"code\">\n<span class=\"blue\">void</span> SetAnalysisDisplayStyle( <span class=\"teal\">Document</span> doc )\n{\n  <span class=\"teal\">AnalysisDisplayStyle</span> analysisDisplayStyle;\n \n  <span class=\"blue\">const</span> <span class=\"blue\">string</span> styleName \n    = <span class=\"maroon\">\"Revit Webcam Display Style\"</span>;\n \n  <span class=\"green\">// extract existing display styles with specific name</span>\n \n  <span class=\"teal\">FilteredElementCollector</span> a \n    = <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( doc );\n \n  <span class=\"teal\">IList</span>&lt;<span class=\"teal\">Element</span>&gt; elements = a\n    .OfClass( <span class=\"blue\">typeof</span>( <span class=\"teal\">AnalysisDisplayStyle</span> ) )\n    .Where( x =&gt; x.Name.Equals( styleName ) )\n    .Cast&lt;<span class=\"teal\">Element</span>&gt;()\n    .ToList();\n \n  <span class=\"blue\">if</span>( 0 &lt; elements.Count )\n  {\n    <span class=\"green\">// use the existing display style</span>\n \n    analysisDisplayStyle = elements[0] \n      <span class=\"blue\">as</span> <span class=\"teal\">AnalysisDisplayStyle</span>;\n  }\n  <span class=\"blue\">else</span>\n  {\n    <span class=\"green\">// create new display style:</span>\n \n    <span class=\"green\">// coloured surface settings:</span>\n \n    <span class=\"teal\">AnalysisDisplayColoredSurfaceSettings</span> \n      coloredSurfaceSettings \n        = <span class=\"blue\">new</span> <span class=\"teal\">AnalysisDisplayColoredSurfaceSettings</span>();\n \n    coloredSurfaceSettings.ShowGridLines = <span class=\"blue\">false</span>;\n \n    <span class=\"green\">// color settings:</span>\n \n    <span class=\"teal\">AnalysisDisplayColorSettings</span> colorSettings \n      = <span class=\"blue\">new</span> <span class=\"teal\">AnalysisDisplayColorSettings</span>();\n \n    colorSettings.MaxColor = <span class=\"blue\">new</span> <span class=\"teal\">Color</span>( 255, 255, 255 );\n    colorSettings.MinColor = <span class=\"blue\">new</span> <span class=\"teal\">Color</span>( 0, 0, 0 );\n \n    <span class=\"green\">// legend settings:</span>\n \n    <span class=\"teal\">AnalysisDisplayLegendSettings</span> legendSettings \n      = <span class=\"blue\">new</span> <span class=\"teal\">AnalysisDisplayLegendSettings</span>();\n \n    legendSettings.NumberOfSteps = 10;\n    legendSettings.Rounding = 0.05;\n    legendSettings.ShowDataDescription = <span class=\"blue\">false</span>;\n    legendSettings.ShowLegend = <span class=\"blue\">true</span>;\n \n    <span class=\"green\">// extract legend text:</span>\n \n    a = <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( doc );\n \n    elements = a\n      .OfClass( <span class=\"blue\">typeof</span>( <span class=\"teal\">TextNoteType</span> ) )\n      .Where( x =&gt; x.Name == <span class=\"maroon\">\"LegendText\"</span> )\n      .Cast&lt;<span class=\"teal\">Element</span>&gt;()\n      .ToList();\n \n    <span class=\"blue\">if</span>( 0 &lt; elements.Count )\n    {\n      <span class=\"green\">// if LegendText exists, use it for this display style</span>\n \n      <span class=\"teal\">TextNoteType</span> textType = elements[0] <span class=\"blue\">as</span> <span class=\"teal\">TextNoteType</span>;\n \n      legendSettings.SetTextTypeId( textType.Id, doc );\n    }\n \n    <span class=\"green\">// create the analysis display style:</span>\n \n    analysisDisplayStyle = <span class=\"teal\">AnalysisDisplayStyle</span>\n      .CreateAnalysisDisplayStyle(\n        doc, styleName, coloredSurfaceSettings, \n        colorSettings, legendSettings );\n  }\n \n  <span class=\"green\">// assign the display style to the active view</span>\n \n  doc.ActiveView.AnalysisDisplayStyleId \n    = analysisDisplayStyle.Id;\n}\n</pre>\n<a name=\"4\"></a>\n<h4>Subscribe to the Idling Event</h4>\n<p>Now we get to the real meat of this discussion, subscribing to the Idling event and implementing the handler to process it.\n\n<p>The actual subscription process is a one-liner:\n\n<pre class=\"code\">\n  uiapp.Idling\n    += <span class=\"blue\">new</span> <span class=\"teal\">EventHandler</span>&lt;<span class=\"teal\">IdlingEventArgs</span>&gt;(\n      OnIdling );\n</pre>\n<a name=\"5\"></a>\n<h4>Handle the Idling Event</h4>\n<p>The event handler may be called very frequently, as demonstrated by The Building Coder \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/04/idling-event.html\">\nCmdIdling</a> command.\n\nSince the webcam image will be updated less frequently, it makes sense to check for updates less frequently than the handler is called, i.e. skip the majority of the calls. \nI do so by defining a minimum elapsed time interval, and simply returning immediately from the handler if it has not yet passed since the last update.\n\n<p>If the minimum time interval is up, I grab the current image from URL.\nThere is still no guarantee that it has changed, so before starting a transaction and making any changes to the Revit model, I compare the current image with the last one displayed.\nThe comparison is rather simplistic, based on a SHA256Managed hash value calculated from the image pixel data like this:\n\n<pre class=\"code\">\n<span class=\"blue\">public</span> <span class=\"blue\">byte</span> [] HashValue\n{\n  <span class=\"blue\">get</span>\n  {\n    <span class=\"green\">// convert image to a byte array</span>\n \n    <span class=\"teal\">ImageConverter</span> ic = <span class=\"blue\">new</span> <span class=\"teal\">ImageConverter</span>();\n \n    <span class=\"blue\">byte</span>[] bytes = ( <span class=\"blue\">byte</span>[] ) ic.ConvertTo( \n      _bitmap, <span class=\"blue\">typeof</span>( <span class=\"blue\">byte</span>[] ) );\n \n    <span class=\"green\">// compute a hash for image</span>\n \n    <span class=\"teal\">SHA256Managed</span> shaM = <span class=\"blue\">new</span> <span class=\"teal\">SHA256Managed</span>();\n    <span class=\"blue\">return</span> shaM.ComputeHash( bytes );\n  }\n}\n</pre>\n<p>If an update is deemed necessary, a transaction is started, the spatial field primitive is set up for the face, and the field points and values to display the image data are calculated and applied.\n\n<p>Here is the code to calculate the points and values for a given face and greyscale bitmap data:\n\n<pre class=\"code\">\n<span class=\"blue\">static</span> <span class=\"blue\">void</span> GetFieldPointsAndValues( \n  <span class=\"blue\">ref</span> <span class=\"teal\">IList</span>&lt;<span class=\"teal\">UV</span>&gt; pts,\n  <span class=\"blue\">ref</span> <span class=\"teal\">IList</span>&lt;<span class=\"teal\">ValueAtPoint</span>&gt; valuesAtPoints,\n  <span class=\"blue\">ref</span> <span class=\"teal\">GreyscaleBitmapData</span> data,\n  <span class=\"teal\">Face</span> face )\n{\n  <span class=\"teal\">BoundingBoxUV</span> bb = face.GetBoundingBox();\n \n  <span class=\"blue\">double</span> umin = bb.Min.U;\n  <span class=\"blue\">double</span> umax = bb.Max.U;\n  <span class=\"blue\">double</span> ustep = ( umax - umin ) / data.Width;\n  <span class=\"blue\">double</span> u = umin;\n \n  <span class=\"blue\">double</span> v = bb.Min.V;\n  <span class=\"blue\">double</span> vmax = bb.Max.V;\n  <span class=\"blue\">double</span> vstep = ( vmax - v ) / data.Height;\n \n  <span class=\"teal\">List</span>&lt;<span class=\"blue\">double</span>&gt; values = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"blue\">double</span>&gt;( 1 );\n \n  <span class=\"blue\">for</span>( <span class=\"blue\">int</span> y = 0; y &lt; data.Height; ++y, v += vstep )\n  {\n    <span class=\"teal\">Debug</span>.Assert( v &lt; vmax, \n      <span class=\"maroon\">\"expected v to remain within bounds\"</span> );\n \n    u = umin;\n \n    <span class=\"blue\">for</span>( <span class=\"blue\">int</span> x = 0; x &lt; data.Width; ++x, u += ustep )\n    {\n      <span class=\"teal\">Debug</span>.Assert( u &lt; umax, \n        <span class=\"maroon\">\"expected u to remain within bounds\"</span> );\n \n      <span class=\"blue\">double</span> brightness = data.GetBrightnessAt( \n        x, y );\n \n      <span class=\"teal\">UV</span> uv = <span class=\"blue\">new</span> <span class=\"teal\">UV</span>( u, v );\n      pts.Add( uv );\n \n      values.Clear();\n      values.Add( brightness );\n      valuesAtPoints.Add( <span class=\"blue\">new</span> <span class=\"teal\">ValueAtPoint</span>( \n        values ) );\n    }\n  }\n}\n</pre>\n<p>To summarise, the event handler thus needs to perform the following steps:\n\n<ul>\n<li>Check minimum elapsed time interval.\n<li>Grab current image from URL.\n<li>Check whether an update is required.\n<li>Start transaction for write access.\n<li>Set up spatial field primitive.\n<li>Calculate field points and values from the image data.\n<li>Update the spatial field primitive.\n</li></li></li></li></li></li></li></ul>\n<p>Here is the actual code implementing these steps:\n\n<pre class=\"code\">\n<span class=\"blue\">static</span> <span class=\"blue\">void</span> OnIdling( \n  <span class=\"blue\">object</span> sender, \n  <span class=\"teal\">IdlingEventArgs</span> e )\n{\n  <span class=\"blue\">if</span>( <span class=\"teal\">DateTime</span>.Now.Subtract( _lastUpdate ) \n    &gt; _interval )\n  {\n    Log( <span class=\"maroon\">\"OnIdling\"</span> );\n \n    <span class=\"teal\">GreyscaleBitmapData</span> data \n      = <span class=\"blue\">new</span> <span class=\"teal\">GreyscaleBitmapData</span>( \n        _width, _height, _url );\n \n    <span class=\"blue\">byte</span>[] hash = data.HashValue;\n \n    <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == _lastHash\n      || 0 != CompareBytes( hash, _lastHash ) )\n    {\n      _lastHash = hash;\n \n      <span class=\"green\">// access active document from sender:</span>\n \n      <span class=\"teal\">Application</span> app = sender <span class=\"blue\">as</span> <span class=\"teal\">Application</span>;\n \n      <span class=\"teal\">Debug</span>.Assert( <span class=\"blue\">null</span> != app,\n        <span class=\"maroon\">\"expected a valid Revit application instance\"</span> );\n \n      <span class=\"teal\">UIApplication</span> uiapp = <span class=\"blue\">new</span> <span class=\"teal\">UIApplication</span>( app );\n      <span class=\"teal\">UIDocument</span> uidoc = uiapp.ActiveUIDocument;\n      <span class=\"teal\">Document</span> doc = uidoc.Document;\n \n      Log( <span class=\"maroon\">\"OnIdling image changed, active document \"</span>\n        + doc.Title );\n \n      <span class=\"teal\">Transaction</span> transaction \n        = <span class=\"blue\">new</span> <span class=\"teal\">Transaction</span>( doc, <span class=\"maroon\">\"Revit Webcam Update\"</span> );\n \n      transaction.Start();\n \n      <span class=\"teal\">View</span> view = doc.ActiveView; <span class=\"green\">// maybe has to be 3D</span>\n \n      <span class=\"teal\">SpatialFieldManager</span> sfm \n        = <span class=\"teal\">SpatialFieldManager</span>.GetSpatialFieldManager( \n          view );\n \n      <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == sfm ) \n      {\n        sfm = <span class=\"teal\">SpatialFieldManager</span>\n          .CreateSpatialFieldManager( view, 1 );\n      }\n \n      <span class=\"blue\">if</span>( 0 &gt; _sfp_index )\n      {\n        _sfp_index = sfm.AddSpatialFieldPrimitive(\n          _faceReference );\n      }\n \n      <span class=\"blue\">int</span> nPoints = data.Width * data.Height;\n \n      <span class=\"teal\">IList</span>&lt;<span class=\"teal\">UV</span>&gt; pts = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">UV</span>&gt;( nPoints );\n \n      <span class=\"teal\">IList</span>&lt;<span class=\"teal\">ValueAtPoint</span>&gt; valuesAtPoints \n        = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">ValueAtPoint</span>&gt;( nPoints );\n \n      <span class=\"teal\">Face</span> face = _faceReference.GeometryObject \n        <span class=\"blue\">as</span> <span class=\"teal\">Face</span>;\n \n      GetFieldPointsAndValues( <span class=\"blue\">ref</span> pts, \n        <span class=\"blue\">ref</span> valuesAtPoints, <span class=\"blue\">ref</span> data, face );\n \n      <span class=\"teal\">FieldDomainPointsByUV</span> fieldPoints \n        = <span class=\"blue\">new</span> <span class=\"teal\">FieldDomainPointsByUV</span>( pts );\n \n      <span class=\"teal\">FieldValues</span> fieldValues \n        = <span class=\"blue\">new</span> <span class=\"teal\">FieldValues</span>( valuesAtPoints );\n \n      sfm.UpdateSpatialFieldPrimitive( \n        _sfp_index, fieldPoints, fieldValues );\n \n      transaction.Commit();\n      doc.Regenerate();\n \n      _lastUpdate = <span class=\"teal\">DateTime</span>.Now;\n    }\n  }\n}\n</pre>\n<p>Notice that we open our own transaction here and regenerate the document manually.\n\n<p>The mainline of the external command Execute method putting this all together looks like this:\n\n<pre class=\"code\">\n<span class=\"teal\">UIApplication</span> uiapp = commandData.Application;\n<span class=\"teal\">UIDocument</span> uidoc = uiapp.ActiveUIDocument;\n<span class=\"teal\">Document</span> doc = uidoc.Document;\n<span class=\"teal\">View</span> view = doc.ActiveView; <span class=\"green\">// maybe has to be 3D</span>\n \n<span class=\"teal\">Reference</span> r = uidoc.Selection.PickObject( \n  <span class=\"teal\">ObjectType</span>.Face, \n  <span class=\"blue\">new</span> <span class=\"teal\">BimElementFilter</span>(), \n  _prompt );\n \n<span class=\"teal\">Debug</span>.Assert( <span class=\"blue\">null</span> != r, \n  <span class=\"maroon\">\"expected non-null reference from PickObject\"</span> );\n \n<span class=\"teal\">Debug</span>.Assert( <span class=\"blue\">null</span> != r.Element, \n  <span class=\"maroon\">\"expected non-null element from PickObject\"</span> );\n \n<span class=\"teal\">Debug</span>.Assert( <span class=\"blue\">null</span> != r.GeometryObject, \n  <span class=\"maroon\">\"expected non-null geometry object from PickObject\"</span> );\n \n<span class=\"teal\">SpatialFieldManager</span> sfm\n  = <span class=\"teal\">SpatialFieldManager</span>.GetSpatialFieldManager( \n    view );\n \n<span class=\"blue\">if</span>( <span class=\"blue\">null</span> != sfm &amp;&amp; 0 &lt; _sfp_index )\n{\n  sfm.RemoveSpatialFieldPrimitive( \n    _sfp_index );\n \n  _sfp_index = -1;\n}\n_faceReference = r;\n \nSetAnalysisDisplayStyle( doc );\n \nuiapp.Idling\n  += <span class=\"blue\">new</span> <span class=\"teal\">EventHandler</span>&lt;<span class=\"teal\">IdlingEventArgs</span>&gt;(\n    OnIdling );\n \n<span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Succeeded;\n</pre>\n<p>The mainline is enclosed in an exception handler, but I have not noticed any exceptions being thrown by it so far.\n\n<p>The command uses manual transaction mode and the manual regeneration option, since the required transaction and regeneration handling is indeed implemented by the OnIdling method.\n\n<p>We can use of the view of Piccadilly Circus from the webcam we used for our \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/06/grabbing-an-internet-webcam-image.html\">\nimage grabbing samples</a>:</p>\n<center>\n<img alt=\"Webcam image of Picadilly Circus\" src=\"img/webcam_piccadilly.jpg\"/>\n</center>\n<p>I test ran the add-in in the sample project SpatialFieldGradient.rvt provided with the AVF SDK sample mentioned above, which contains various types of wall elements.\nHere is a daytime view of the Revit screen:</p>\n<center>\n<img alt=\"RevitWebcam image of Picadilly Circus at daytime\" src=\"img/webcam_on_wall.jpg\"/>\n</center>\n<p>Here is a similar view at night:</p>\n<center>\n<img alt=\"RevitWebcam image of Picadilly Circus at night\" src=\"img/webcam_on_wall_at_night.jpg\"/>\n</center>\n<p>Here is \n\n<a href=\"zip/RevitWebcam.zip\">\nRevitWebcam.zip</a>\n\ncontaining the complete source code and Visual Studio solution for this Revit external command add-in.\n\n<p>I still have one more Idling sample up my sleeve which I hope to be able to document in the coming days as well. \nMeanwhile, I hope that you find this as interesting as I do, even if this specific sample may not have that many immediate uses in most people's day-to-day work, and that the underlying principles and solution steps are useful anyway.\n</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p>"
  },
  {
    "original_filename": "0380_revitwebcam",
    "header_text": "Set a Spatial Field Primitive for a Face on a BIM Element",
    "local_header_href": "#set-a-spatial-field-primitive-for-a-face-on-a-bim-element",
    "chunk_text": "<h4>Set a Spatial Field Primitive for a Face on a BIM Element</h4><p>To display analysis results on the selected face requires us to set up a spatial field primitive for it.\nSpatial field primitives are handled by the SpatialFieldManager class, which uses integer indices to keep track of them.\nIn order to update the correct primitive later on, we store it in a global variable _sfp_index.\nHere is the code to access the manager and set up the primitive:\n\n<pre class=\"code\">\n  <span class=\"teal\">SpatialFieldManager</span> sfm\n    = <span class=\"teal\">SpatialFieldManager</span>.GetSpatialFieldManager( \n      view );\n \n  <span class=\"blue\">if</span>( <span class=\"blue\">null</span> != sfm &amp;&amp; 0 &lt; _sfp_index )\n  {\n    sfm.RemoveSpatialFieldPrimitive( \n      _sfp_index );\n \n    _sfp_index = -1;\n  }\n</pre>\n<a name=\"3\"></a>\n<h4>Set the Analysis Display Style</h4>\n<p>I set up an analysis display style in order to turn off the gridlines and define a black and white colour range suitable for the greyscale image I retrieve from the webcam.\nThe code to do so is based on the SpatialFieldGradient SDK sample and looks like this:\n\n<pre class=\"code\">\n<span class=\"blue\">void</span> SetAnalysisDisplayStyle( <span class=\"teal\">Document</span> doc )\n{\n  <span class=\"teal\">AnalysisDisplayStyle</span> analysisDisplayStyle;\n \n  <span class=\"blue\">const</span> <span class=\"blue\">string</span> styleName \n    = <span class=\"maroon\">\"Revit Webcam Display Style\"</span>;\n \n  <span class=\"green\">// extract existing display styles with specific name</span>\n \n  <span class=\"teal\">FilteredElementCollector</span> a \n    = <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( doc );\n \n  <span class=\"teal\">IList</span>&lt;<span class=\"teal\">Element</span>&gt; elements = a\n    .OfClass( <span class=\"blue\">typeof</span>( <span class=\"teal\">AnalysisDisplayStyle</span> ) )\n    .Where( x =&gt; x.Name.Equals( styleName ) )\n    .Cast&lt;<span class=\"teal\">Element</span>&gt;()\n    .ToList();\n \n  <span class=\"blue\">if</span>( 0 &lt; elements.Count )\n  {\n    <span class=\"green\">// use the existing display style</span>\n \n    analysisDisplayStyle = elements[0] \n      <span class=\"blue\">as</span> <span class=\"teal\">AnalysisDisplayStyle</span>;\n  }\n  <span class=\"blue\">else</span>\n  {\n    <span class=\"green\">// create new display style:</span>\n \n    <span class=\"green\">// coloured surface settings:</span>\n \n    <span class=\"teal\">AnalysisDisplayColoredSurfaceSettings</span> \n      coloredSurfaceSettings \n        = <span class=\"blue\">new</span> <span class=\"teal\">AnalysisDisplayColoredSurfaceSettings</span>();\n \n    coloredSurfaceSettings.ShowGridLines = <span class=\"blue\">false</span>;\n \n    <span class=\"green\">// color settings:</span>\n \n    <span class=\"teal\">AnalysisDisplayColorSettings</span> colorSettings \n      = <span class=\"blue\">new</span> <span class=\"teal\">AnalysisDisplayColorSettings</span>();\n \n    colorSettings.MaxColor = <span class=\"blue\">new</span> <span class=\"teal\">Color</span>( 255, 255, 255 );\n    colorSettings.MinColor = <span class=\"blue\">new</span> <span class=\"teal\">Color</span>( 0, 0, 0 );\n \n    <span class=\"green\">// legend settings:</span>\n \n    <span class=\"teal\">AnalysisDisplayLegendSettings</span> legendSettings \n      = <span class=\"blue\">new</span> <span class=\"teal\">AnalysisDisplayLegendSettings</span>();\n \n    legendSettings.NumberOfSteps = 10;\n    legendSettings.Rounding = 0.05;\n    legendSettings.ShowDataDescription = <span class=\"blue\">false</span>;\n    legendSettings.ShowLegend = <span class=\"blue\">true</span>;\n \n    <span class=\"green\">// extract legend text:</span>\n \n    a = <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( doc );\n \n    elements = a\n      .OfClass( <span class=\"blue\">typeof</span>( <span class=\"teal\">TextNoteType</span> ) )\n      .Where( x =&gt; x.Name == <span class=\"maroon\">\"LegendText\"</span> )\n      .Cast&lt;<span class=\"teal\">Element</span>&gt;()\n      .ToList();\n \n    <span class=\"blue\">if</span>( 0 &lt; elements.Count )\n    {\n      <span class=\"green\">// if LegendText exists, use it for this display style</span>\n \n      <span class=\"teal\">TextNoteType</span> textType = elements[0] <span class=\"blue\">as</span> <span class=\"teal\">TextNoteType</span>;\n \n      legendSettings.SetTextTypeId( textType.Id, doc );\n    }\n \n    <span class=\"green\">// create the analysis display style:</span>\n \n    analysisDisplayStyle = <span class=\"teal\">AnalysisDisplayStyle</span>\n      .CreateAnalysisDisplayStyle(\n        doc, styleName, coloredSurfaceSettings, \n        colorSettings, legendSettings );\n  }\n \n  <span class=\"green\">// assign the display style to the active view</span>\n \n  doc.ActiveView.AnalysisDisplayStyleId \n    = analysisDisplayStyle.Id;\n}\n</pre>\n<a name=\"4\"></a>\n<h4>Subscribe to the Idling Event</h4>\n<p>Now we get to the real meat of this discussion, subscribing to the Idling event and implementing the handler to process it.\n\n<p>The actual subscription process is a one-liner:\n\n<pre class=\"code\">\n  uiapp.Idling\n    += <span class=\"blue\">new</span> <span class=\"teal\">EventHandler</span>&lt;<span class=\"teal\">IdlingEventArgs</span>&gt;(\n      OnIdling );\n</pre>\n<a name=\"5\"></a>\n<h4>Handle the Idling Event</h4>\n<p>The event handler may be called very frequently, as demonstrated by The Building Coder \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/04/idling-event.html\">\nCmdIdling</a> command.\n\nSince the webcam image will be updated less frequently, it makes sense to check for updates less frequently than the handler is called, i.e. skip the majority of the calls. \nI do so by defining a minimum elapsed time interval, and simply returning immediately from the handler if it has not yet passed since the last update.\n\n<p>If the minimum time interval is up, I grab the current image from URL.\nThere is still no guarantee that it has changed, so before starting a transaction and making any changes to the Revit model, I compare the current image with the last one displayed.\nThe comparison is rather simplistic, based on a SHA256Managed hash value calculated from the image pixel data like this:\n\n<pre class=\"code\">\n<span class=\"blue\">public</span> <span class=\"blue\">byte</span> [] HashValue\n{\n  <span class=\"blue\">get</span>\n  {\n    <span class=\"green\">// convert image to a byte array</span>\n \n    <span class=\"teal\">ImageConverter</span> ic = <span class=\"blue\">new</span> <span class=\"teal\">ImageConverter</span>();\n \n    <span class=\"blue\">byte</span>[] bytes = ( <span class=\"blue\">byte</span>[] ) ic.ConvertTo( \n      _bitmap, <span class=\"blue\">typeof</span>( <span class=\"blue\">byte</span>[] ) );\n \n    <span class=\"green\">// compute a hash for image</span>\n \n    <span class=\"teal\">SHA256Managed</span> shaM = <span class=\"blue\">new</span> <span class=\"teal\">SHA256Managed</span>();\n    <span class=\"blue\">return</span> shaM.ComputeHash( bytes );\n  }\n}\n</pre>\n<p>If an update is deemed necessary, a transaction is started, the spatial field primitive is set up for the face, and the field points and values to display the image data are calculated and applied.\n\n<p>Here is the code to calculate the points and values for a given face and greyscale bitmap data:\n\n<pre class=\"code\">\n<span class=\"blue\">static</span> <span class=\"blue\">void</span> GetFieldPointsAndValues( \n  <span class=\"blue\">ref</span> <span class=\"teal\">IList</span>&lt;<span class=\"teal\">UV</span>&gt; pts,\n  <span class=\"blue\">ref</span> <span class=\"teal\">IList</span>&lt;<span class=\"teal\">ValueAtPoint</span>&gt; valuesAtPoints,\n  <span class=\"blue\">ref</span> <span class=\"teal\">GreyscaleBitmapData</span> data,\n  <span class=\"teal\">Face</span> face )\n{\n  <span class=\"teal\">BoundingBoxUV</span> bb = face.GetBoundingBox();\n \n  <span class=\"blue\">double</span> umin = bb.Min.U;\n  <span class=\"blue\">double</span> umax = bb.Max.U;\n  <span class=\"blue\">double</span> ustep = ( umax - umin ) / data.Width;\n  <span class=\"blue\">double</span> u = umin;\n \n  <span class=\"blue\">double</span> v = bb.Min.V;\n  <span class=\"blue\">double</span> vmax = bb.Max.V;\n  <span class=\"blue\">double</span> vstep = ( vmax - v ) / data.Height;\n \n  <span class=\"teal\">List</span>&lt;<span class=\"blue\">double</span>&gt; values = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"blue\">double</span>&gt;( 1 );\n \n  <span class=\"blue\">for</span>( <span class=\"blue\">int</span> y = 0; y &lt; data.Height; ++y, v += vstep )\n  {\n    <span class=\"teal\">Debug</span>.Assert( v &lt; vmax, \n      <span class=\"maroon\">\"expected v to remain within bounds\"</span> );\n \n    u = umin;\n \n    <span class=\"blue\">for</span>( <span class=\"blue\">int</span> x = 0; x &lt; data.Width; ++x, u += ustep )\n    {\n      <span class=\"teal\">Debug</span>.Assert( u &lt; umax, \n        <span class=\"maroon\">\"expected u to remain within bounds\"</span> );\n \n      <span class=\"blue\">double</span> brightness = data.GetBrightnessAt( \n        x, y );\n \n      <span class=\"teal\">UV</span> uv = <span class=\"blue\">new</span> <span class=\"teal\">UV</span>( u, v );\n      pts.Add( uv );\n \n      values.Clear();\n      values.Add( brightness );\n      valuesAtPoints.Add( <span class=\"blue\">new</span> <span class=\"teal\">ValueAtPoint</span>( \n        values ) );\n    }\n  }\n}\n</pre>\n<p>To summarise, the event handler thus needs to perform the following steps:\n\n<ul>\n<li>Check minimum elapsed time interval.\n<li>Grab current image from URL.\n<li>Check whether an update is required.\n<li>Start transaction for write access.\n<li>Set up spatial field primitive.\n<li>Calculate field points and values from the image data.\n<li>Update the spatial field primitive.\n</li></li></li></li></li></li></li></ul>\n<p>Here is the actual code implementing these steps:\n\n<pre class=\"code\">\n<span class=\"blue\">static</span> <span class=\"blue\">void</span> OnIdling( \n  <span class=\"blue\">object</span> sender, \n  <span class=\"teal\">IdlingEventArgs</span> e )\n{\n  <span class=\"blue\">if</span>( <span class=\"teal\">DateTime</span>.Now.Subtract( _lastUpdate ) \n    &gt; _interval )\n  {\n    Log( <span class=\"maroon\">\"OnIdling\"</span> );\n \n    <span class=\"teal\">GreyscaleBitmapData</span> data \n      = <span class=\"blue\">new</span> <span class=\"teal\">GreyscaleBitmapData</span>( \n        _width, _height, _url );\n \n    <span class=\"blue\">byte</span>[] hash = data.HashValue;\n \n    <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == _lastHash\n      || 0 != CompareBytes( hash, _lastHash ) )\n    {\n      _lastHash = hash;\n \n      <span class=\"green\">// access active document from sender:</span>\n \n      <span class=\"teal\">Application</span> app = sender <span class=\"blue\">as</span> <span class=\"teal\">Application</span>;\n \n      <span class=\"teal\">Debug</span>.Assert( <span class=\"blue\">null</span> != app,\n        <span class=\"maroon\">\"expected a valid Revit application instance\"</span> );\n \n      <span class=\"teal\">UIApplication</span> uiapp = <span class=\"blue\">new</span> <span class=\"teal\">UIApplication</span>( app );\n      <span class=\"teal\">UIDocument</span> uidoc = uiapp.ActiveUIDocument;\n      <span class=\"teal\">Document</span> doc = uidoc.Document;\n \n      Log( <span class=\"maroon\">\"OnIdling image changed, active document \"</span>\n        + doc.Title );\n \n      <span class=\"teal\">Transaction</span> transaction \n        = <span class=\"blue\">new</span> <span class=\"teal\">Transaction</span>( doc, <span class=\"maroon\">\"Revit Webcam Update\"</span> );\n \n      transaction.Start();\n \n      <span class=\"teal\">View</span> view = doc.ActiveView; <span class=\"green\">// maybe has to be 3D</span>\n \n      <span class=\"teal\">SpatialFieldManager</span> sfm \n        = <span class=\"teal\">SpatialFieldManager</span>.GetSpatialFieldManager( \n          view );\n \n      <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == sfm ) \n      {\n        sfm = <span class=\"teal\">SpatialFieldManager</span>\n          .CreateSpatialFieldManager( view, 1 );\n      }\n \n      <span class=\"blue\">if</span>( 0 &gt; _sfp_index )\n      {\n        _sfp_index = sfm.AddSpatialFieldPrimitive(\n          _faceReference );\n      }\n \n      <span class=\"blue\">int</span> nPoints = data.Width * data.Height;\n \n      <span class=\"teal\">IList</span>&lt;<span class=\"teal\">UV</span>&gt; pts = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">UV</span>&gt;( nPoints );\n \n      <span class=\"teal\">IList</span>&lt;<span class=\"teal\">ValueAtPoint</span>&gt; valuesAtPoints \n        = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">ValueAtPoint</span>&gt;( nPoints );\n \n      <span class=\"teal\">Face</span> face = _faceReference.GeometryObject \n        <span class=\"blue\">as</span> <span class=\"teal\">Face</span>;\n \n      GetFieldPointsAndValues( <span class=\"blue\">ref</span> pts, \n        <span class=\"blue\">ref</span> valuesAtPoints, <span class=\"blue\">ref</span> data, face );\n \n      <span class=\"teal\">FieldDomainPointsByUV</span> fieldPoints \n        = <span class=\"blue\">new</span> <span class=\"teal\">FieldDomainPointsByUV</span>( pts );\n \n      <span class=\"teal\">FieldValues</span> fieldValues \n        = <span class=\"blue\">new</span> <span class=\"teal\">FieldValues</span>( valuesAtPoints );\n \n      sfm.UpdateSpatialFieldPrimitive( \n        _sfp_index, fieldPoints, fieldValues );\n \n      transaction.Commit();\n      doc.Regenerate();\n \n      _lastUpdate = <span class=\"teal\">DateTime</span>.Now;\n    }\n  }\n}\n</pre>\n<p>Notice that we open our own transaction here and regenerate the document manually.\n\n<p>The mainline of the external command Execute method putting this all together looks like this:\n\n<pre class=\"code\">\n<span class=\"teal\">UIApplication</span> uiapp = commandData.Application;\n<span class=\"teal\">UIDocument</span> uidoc = uiapp.ActiveUIDocument;\n<span class=\"teal\">Document</span> doc = uidoc.Document;\n<span class=\"teal\">View</span> view = doc.ActiveView; <span class=\"green\">// maybe has to be 3D</span>\n \n<span class=\"teal\">Reference</span> r = uidoc.Selection.PickObject( \n  <span class=\"teal\">ObjectType</span>.Face, \n  <span class=\"blue\">new</span> <span class=\"teal\">BimElementFilter</span>(), \n  _prompt );\n \n<span class=\"teal\">Debug</span>.Assert( <span class=\"blue\">null</span> != r, \n  <span class=\"maroon\">\"expected non-null reference from PickObject\"</span> );\n \n<span class=\"teal\">Debug</span>.Assert( <span class=\"blue\">null</span> != r.Element, \n  <span class=\"maroon\">\"expected non-null element from PickObject\"</span> );\n \n<span class=\"teal\">Debug</span>.Assert( <span class=\"blue\">null</span> != r.GeometryObject, \n  <span class=\"maroon\">\"expected non-null geometry object from PickObject\"</span> );\n \n<span class=\"teal\">SpatialFieldManager</span> sfm\n  = <span class=\"teal\">SpatialFieldManager</span>.GetSpatialFieldManager( \n    view );\n \n<span class=\"blue\">if</span>( <span class=\"blue\">null</span> != sfm &amp;&amp; 0 &lt; _sfp_index )\n{\n  sfm.RemoveSpatialFieldPrimitive( \n    _sfp_index );\n \n  _sfp_index = -1;\n}\n_faceReference = r;\n \nSetAnalysisDisplayStyle( doc );\n \nuiapp.Idling\n  += <span class=\"blue\">new</span> <span class=\"teal\">EventHandler</span>&lt;<span class=\"teal\">IdlingEventArgs</span>&gt;(\n    OnIdling );\n \n<span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Succeeded;\n</pre>\n<p>The mainline is enclosed in an exception handler, but I have not noticed any exceptions being thrown by it so far.\n\n<p>The command uses manual transaction mode and the manual regeneration option, since the required transaction and regeneration handling is indeed implemented by the OnIdling method.\n\n<p>We can use of the view of Piccadilly Circus from the webcam we used for our \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/06/grabbing-an-internet-webcam-image.html\">\nimage grabbing samples</a>:</p>\n<center>\n<img alt=\"Webcam image of Picadilly Circus\" src=\"img/webcam_piccadilly.jpg\"/>\n</center>\n<p>I test ran the add-in in the sample project SpatialFieldGradient.rvt provided with the AVF SDK sample mentioned above, which contains various types of wall elements.\nHere is a daytime view of the Revit screen:</p>\n<center>\n<img alt=\"RevitWebcam image of Picadilly Circus at daytime\" src=\"img/webcam_on_wall.jpg\"/>\n</center>\n<p>Here is a similar view at night:</p>\n<center>\n<img alt=\"RevitWebcam image of Picadilly Circus at night\" src=\"img/webcam_on_wall_at_night.jpg\"/>\n</center>\n<p>Here is \n\n<a href=\"zip/RevitWebcam.zip\">\nRevitWebcam.zip</a>\n\ncontaining the complete source code and Visual Studio solution for this Revit external command add-in.\n\n<p>I still have one more Idling sample up my sleeve which I hope to be able to document in the coming days as well. \nMeanwhile, I hope that you find this as interesting as I do, even if this specific sample may not have that many immediate uses in most people's day-to-day work, and that the underlying principles and solution steps are useful anyway.\n</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p>"
  },
  {
    "original_filename": "0380_revitwebcam",
    "header_text": "Set the Analysis Display Style",
    "local_header_href": "#set-the-analysis-display-style",
    "chunk_text": "<h4>Set the Analysis Display Style</h4><p>I set up an analysis display style in order to turn off the gridlines and define a black and white colour range suitable for the greyscale image I retrieve from the webcam.\nThe code to do so is based on the SpatialFieldGradient SDK sample and looks like this:\n\n<pre class=\"code\">\n<span class=\"blue\">void</span> SetAnalysisDisplayStyle( <span class=\"teal\">Document</span> doc )\n{\n  <span class=\"teal\">AnalysisDisplayStyle</span> analysisDisplayStyle;\n \n  <span class=\"blue\">const</span> <span class=\"blue\">string</span> styleName \n    = <span class=\"maroon\">\"Revit Webcam Display Style\"</span>;\n \n  <span class=\"green\">// extract existing display styles with specific name</span>\n \n  <span class=\"teal\">FilteredElementCollector</span> a \n    = <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( doc );\n \n  <span class=\"teal\">IList</span>&lt;<span class=\"teal\">Element</span>&gt; elements = a\n    .OfClass( <span class=\"blue\">typeof</span>( <span class=\"teal\">AnalysisDisplayStyle</span> ) )\n    .Where( x =&gt; x.Name.Equals( styleName ) )\n    .Cast&lt;<span class=\"teal\">Element</span>&gt;()\n    .ToList();\n \n  <span class=\"blue\">if</span>( 0 &lt; elements.Count )\n  {\n    <span class=\"green\">// use the existing display style</span>\n \n    analysisDisplayStyle = elements[0] \n      <span class=\"blue\">as</span> <span class=\"teal\">AnalysisDisplayStyle</span>;\n  }\n  <span class=\"blue\">else</span>\n  {\n    <span class=\"green\">// create new display style:</span>\n \n    <span class=\"green\">// coloured surface settings:</span>\n \n    <span class=\"teal\">AnalysisDisplayColoredSurfaceSettings</span> \n      coloredSurfaceSettings \n        = <span class=\"blue\">new</span> <span class=\"teal\">AnalysisDisplayColoredSurfaceSettings</span>();\n \n    coloredSurfaceSettings.ShowGridLines = <span class=\"blue\">false</span>;\n \n    <span class=\"green\">// color settings:</span>\n \n    <span class=\"teal\">AnalysisDisplayColorSettings</span> colorSettings \n      = <span class=\"blue\">new</span> <span class=\"teal\">AnalysisDisplayColorSettings</span>();\n \n    colorSettings.MaxColor = <span class=\"blue\">new</span> <span class=\"teal\">Color</span>( 255, 255, 255 );\n    colorSettings.MinColor = <span class=\"blue\">new</span> <span class=\"teal\">Color</span>( 0, 0, 0 );\n \n    <span class=\"green\">// legend settings:</span>\n \n    <span class=\"teal\">AnalysisDisplayLegendSettings</span> legendSettings \n      = <span class=\"blue\">new</span> <span class=\"teal\">AnalysisDisplayLegendSettings</span>();\n \n    legendSettings.NumberOfSteps = 10;\n    legendSettings.Rounding = 0.05;\n    legendSettings.ShowDataDescription = <span class=\"blue\">false</span>;\n    legendSettings.ShowLegend = <span class=\"blue\">true</span>;\n \n    <span class=\"green\">// extract legend text:</span>\n \n    a = <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( doc );\n \n    elements = a\n      .OfClass( <span class=\"blue\">typeof</span>( <span class=\"teal\">TextNoteType</span> ) )\n      .Where( x =&gt; x.Name == <span class=\"maroon\">\"LegendText\"</span> )\n      .Cast&lt;<span class=\"teal\">Element</span>&gt;()\n      .ToList();\n \n    <span class=\"blue\">if</span>( 0 &lt; elements.Count )\n    {\n      <span class=\"green\">// if LegendText exists, use it for this display style</span>\n \n      <span class=\"teal\">TextNoteType</span> textType = elements[0] <span class=\"blue\">as</span> <span class=\"teal\">TextNoteType</span>;\n \n      legendSettings.SetTextTypeId( textType.Id, doc );\n    }\n \n    <span class=\"green\">// create the analysis display style:</span>\n \n    analysisDisplayStyle = <span class=\"teal\">AnalysisDisplayStyle</span>\n      .CreateAnalysisDisplayStyle(\n        doc, styleName, coloredSurfaceSettings, \n        colorSettings, legendSettings );\n  }\n \n  <span class=\"green\">// assign the display style to the active view</span>\n \n  doc.ActiveView.AnalysisDisplayStyleId \n    = analysisDisplayStyle.Id;\n}\n</pre>\n<a name=\"4\"></a>\n<h4>Subscribe to the Idling Event</h4>\n<p>Now we get to the real meat of this discussion, subscribing to the Idling event and implementing the handler to process it.\n\n<p>The actual subscription process is a one-liner:\n\n<pre class=\"code\">\n  uiapp.Idling\n    += <span class=\"blue\">new</span> <span class=\"teal\">EventHandler</span>&lt;<span class=\"teal\">IdlingEventArgs</span>&gt;(\n      OnIdling );\n</pre>\n<a name=\"5\"></a>\n<h4>Handle the Idling Event</h4>\n<p>The event handler may be called very frequently, as demonstrated by The Building Coder \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/04/idling-event.html\">\nCmdIdling</a> command.\n\nSince the webcam image will be updated less frequently, it makes sense to check for updates less frequently than the handler is called, i.e. skip the majority of the calls. \nI do so by defining a minimum elapsed time interval, and simply returning immediately from the handler if it has not yet passed since the last update.\n\n<p>If the minimum time interval is up, I grab the current image from URL.\nThere is still no guarantee that it has changed, so before starting a transaction and making any changes to the Revit model, I compare the current image with the last one displayed.\nThe comparison is rather simplistic, based on a SHA256Managed hash value calculated from the image pixel data like this:\n\n<pre class=\"code\">\n<span class=\"blue\">public</span> <span class=\"blue\">byte</span> [] HashValue\n{\n  <span class=\"blue\">get</span>\n  {\n    <span class=\"green\">// convert image to a byte array</span>\n \n    <span class=\"teal\">ImageConverter</span> ic = <span class=\"blue\">new</span> <span class=\"teal\">ImageConverter</span>();\n \n    <span class=\"blue\">byte</span>[] bytes = ( <span class=\"blue\">byte</span>[] ) ic.ConvertTo( \n      _bitmap, <span class=\"blue\">typeof</span>( <span class=\"blue\">byte</span>[] ) );\n \n    <span class=\"green\">// compute a hash for image</span>\n \n    <span class=\"teal\">SHA256Managed</span> shaM = <span class=\"blue\">new</span> <span class=\"teal\">SHA256Managed</span>();\n    <span class=\"blue\">return</span> shaM.ComputeHash( bytes );\n  }\n}\n</pre>\n<p>If an update is deemed necessary, a transaction is started, the spatial field primitive is set up for the face, and the field points and values to display the image data are calculated and applied.\n\n<p>Here is the code to calculate the points and values for a given face and greyscale bitmap data:\n\n<pre class=\"code\">\n<span class=\"blue\">static</span> <span class=\"blue\">void</span> GetFieldPointsAndValues( \n  <span class=\"blue\">ref</span> <span class=\"teal\">IList</span>&lt;<span class=\"teal\">UV</span>&gt; pts,\n  <span class=\"blue\">ref</span> <span class=\"teal\">IList</span>&lt;<span class=\"teal\">ValueAtPoint</span>&gt; valuesAtPoints,\n  <span class=\"blue\">ref</span> <span class=\"teal\">GreyscaleBitmapData</span> data,\n  <span class=\"teal\">Face</span> face )\n{\n  <span class=\"teal\">BoundingBoxUV</span> bb = face.GetBoundingBox();\n \n  <span class=\"blue\">double</span> umin = bb.Min.U;\n  <span class=\"blue\">double</span> umax = bb.Max.U;\n  <span class=\"blue\">double</span> ustep = ( umax - umin ) / data.Width;\n  <span class=\"blue\">double</span> u = umin;\n \n  <span class=\"blue\">double</span> v = bb.Min.V;\n  <span class=\"blue\">double</span> vmax = bb.Max.V;\n  <span class=\"blue\">double</span> vstep = ( vmax - v ) / data.Height;\n \n  <span class=\"teal\">List</span>&lt;<span class=\"blue\">double</span>&gt; values = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"blue\">double</span>&gt;( 1 );\n \n  <span class=\"blue\">for</span>( <span class=\"blue\">int</span> y = 0; y &lt; data.Height; ++y, v += vstep )\n  {\n    <span class=\"teal\">Debug</span>.Assert( v &lt; vmax, \n      <span class=\"maroon\">\"expected v to remain within bounds\"</span> );\n \n    u = umin;\n \n    <span class=\"blue\">for</span>( <span class=\"blue\">int</span> x = 0; x &lt; data.Width; ++x, u += ustep )\n    {\n      <span class=\"teal\">Debug</span>.Assert( u &lt; umax, \n        <span class=\"maroon\">\"expected u to remain within bounds\"</span> );\n \n      <span class=\"blue\">double</span> brightness = data.GetBrightnessAt( \n        x, y );\n \n      <span class=\"teal\">UV</span> uv = <span class=\"blue\">new</span> <span class=\"teal\">UV</span>( u, v );\n      pts.Add( uv );\n \n      values.Clear();\n      values.Add( brightness );\n      valuesAtPoints.Add( <span class=\"blue\">new</span> <span class=\"teal\">ValueAtPoint</span>( \n        values ) );\n    }\n  }\n}\n</pre>\n<p>To summarise, the event handler thus needs to perform the following steps:\n\n<ul>\n<li>Check minimum elapsed time interval.\n<li>Grab current image from URL.\n<li>Check whether an update is required.\n<li>Start transaction for write access.\n<li>Set up spatial field primitive.\n<li>Calculate field points and values from the image data.\n<li>Update the spatial field primitive.\n</li></li></li></li></li></li></li></ul>\n<p>Here is the actual code implementing these steps:\n\n<pre class=\"code\">\n<span class=\"blue\">static</span> <span class=\"blue\">void</span> OnIdling( \n  <span class=\"blue\">object</span> sender, \n  <span class=\"teal\">IdlingEventArgs</span> e )\n{\n  <span class=\"blue\">if</span>( <span class=\"teal\">DateTime</span>.Now.Subtract( _lastUpdate ) \n    &gt; _interval )\n  {\n    Log( <span class=\"maroon\">\"OnIdling\"</span> );\n \n    <span class=\"teal\">GreyscaleBitmapData</span> data \n      = <span class=\"blue\">new</span> <span class=\"teal\">GreyscaleBitmapData</span>( \n        _width, _height, _url );\n \n    <span class=\"blue\">byte</span>[] hash = data.HashValue;\n \n    <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == _lastHash\n      || 0 != CompareBytes( hash, _lastHash ) )\n    {\n      _lastHash = hash;\n \n      <span class=\"green\">// access active document from sender:</span>\n \n      <span class=\"teal\">Application</span> app = sender <span class=\"blue\">as</span> <span class=\"teal\">Application</span>;\n \n      <span class=\"teal\">Debug</span>.Assert( <span class=\"blue\">null</span> != app,\n        <span class=\"maroon\">\"expected a valid Revit application instance\"</span> );\n \n      <span class=\"teal\">UIApplication</span> uiapp = <span class=\"blue\">new</span> <span class=\"teal\">UIApplication</span>( app );\n      <span class=\"teal\">UIDocument</span> uidoc = uiapp.ActiveUIDocument;\n      <span class=\"teal\">Document</span> doc = uidoc.Document;\n \n      Log( <span class=\"maroon\">\"OnIdling image changed, active document \"</span>\n        + doc.Title );\n \n      <span class=\"teal\">Transaction</span> transaction \n        = <span class=\"blue\">new</span> <span class=\"teal\">Transaction</span>( doc, <span class=\"maroon\">\"Revit Webcam Update\"</span> );\n \n      transaction.Start();\n \n      <span class=\"teal\">View</span> view = doc.ActiveView; <span class=\"green\">// maybe has to be 3D</span>\n \n      <span class=\"teal\">SpatialFieldManager</span> sfm \n        = <span class=\"teal\">SpatialFieldManager</span>.GetSpatialFieldManager( \n          view );\n \n      <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == sfm ) \n      {\n        sfm = <span class=\"teal\">SpatialFieldManager</span>\n          .CreateSpatialFieldManager( view, 1 );\n      }\n \n      <span class=\"blue\">if</span>( 0 &gt; _sfp_index )\n      {\n        _sfp_index = sfm.AddSpatialFieldPrimitive(\n          _faceReference );\n      }\n \n      <span class=\"blue\">int</span> nPoints = data.Width * data.Height;\n \n      <span class=\"teal\">IList</span>&lt;<span class=\"teal\">UV</span>&gt; pts = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">UV</span>&gt;( nPoints );\n \n      <span class=\"teal\">IList</span>&lt;<span class=\"teal\">ValueAtPoint</span>&gt; valuesAtPoints \n        = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">ValueAtPoint</span>&gt;( nPoints );\n \n      <span class=\"teal\">Face</span> face = _faceReference.GeometryObject \n        <span class=\"blue\">as</span> <span class=\"teal\">Face</span>;\n \n      GetFieldPointsAndValues( <span class=\"blue\">ref</span> pts, \n        <span class=\"blue\">ref</span> valuesAtPoints, <span class=\"blue\">ref</span> data, face );\n \n      <span class=\"teal\">FieldDomainPointsByUV</span> fieldPoints \n        = <span class=\"blue\">new</span> <span class=\"teal\">FieldDomainPointsByUV</span>( pts );\n \n      <span class=\"teal\">FieldValues</span> fieldValues \n        = <span class=\"blue\">new</span> <span class=\"teal\">FieldValues</span>( valuesAtPoints );\n \n      sfm.UpdateSpatialFieldPrimitive( \n        _sfp_index, fieldPoints, fieldValues );\n \n      transaction.Commit();\n      doc.Regenerate();\n \n      _lastUpdate = <span class=\"teal\">DateTime</span>.Now;\n    }\n  }\n}\n</pre>\n<p>Notice that we open our own transaction here and regenerate the document manually.\n\n<p>The mainline of the external command Execute method putting this all together looks like this:\n\n<pre class=\"code\">\n<span class=\"teal\">UIApplication</span> uiapp = commandData.Application;\n<span class=\"teal\">UIDocument</span> uidoc = uiapp.ActiveUIDocument;\n<span class=\"teal\">Document</span> doc = uidoc.Document;\n<span class=\"teal\">View</span> view = doc.ActiveView; <span class=\"green\">// maybe has to be 3D</span>\n \n<span class=\"teal\">Reference</span> r = uidoc.Selection.PickObject( \n  <span class=\"teal\">ObjectType</span>.Face, \n  <span class=\"blue\">new</span> <span class=\"teal\">BimElementFilter</span>(), \n  _prompt );\n \n<span class=\"teal\">Debug</span>.Assert( <span class=\"blue\">null</span> != r, \n  <span class=\"maroon\">\"expected non-null reference from PickObject\"</span> );\n \n<span class=\"teal\">Debug</span>.Assert( <span class=\"blue\">null</span> != r.Element, \n  <span class=\"maroon\">\"expected non-null element from PickObject\"</span> );\n \n<span class=\"teal\">Debug</span>.Assert( <span class=\"blue\">null</span> != r.GeometryObject, \n  <span class=\"maroon\">\"expected non-null geometry object from PickObject\"</span> );\n \n<span class=\"teal\">SpatialFieldManager</span> sfm\n  = <span class=\"teal\">SpatialFieldManager</span>.GetSpatialFieldManager( \n    view );\n \n<span class=\"blue\">if</span>( <span class=\"blue\">null</span> != sfm &amp;&amp; 0 &lt; _sfp_index )\n{\n  sfm.RemoveSpatialFieldPrimitive( \n    _sfp_index );\n \n  _sfp_index = -1;\n}\n_faceReference = r;\n \nSetAnalysisDisplayStyle( doc );\n \nuiapp.Idling\n  += <span class=\"blue\">new</span> <span class=\"teal\">EventHandler</span>&lt;<span class=\"teal\">IdlingEventArgs</span>&gt;(\n    OnIdling );\n \n<span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Succeeded;\n</pre>\n<p>The mainline is enclosed in an exception handler, but I have not noticed any exceptions being thrown by it so far.\n\n<p>The command uses manual transaction mode and the manual regeneration option, since the required transaction and regeneration handling is indeed implemented by the OnIdling method.\n\n<p>We can use of the view of Piccadilly Circus from the webcam we used for our \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/06/grabbing-an-internet-webcam-image.html\">\nimage grabbing samples</a>:</p>\n<center>\n<img alt=\"Webcam image of Picadilly Circus\" src=\"img/webcam_piccadilly.jpg\"/>\n</center>\n<p>I test ran the add-in in the sample project SpatialFieldGradient.rvt provided with the AVF SDK sample mentioned above, which contains various types of wall elements.\nHere is a daytime view of the Revit screen:</p>\n<center>\n<img alt=\"RevitWebcam image of Picadilly Circus at daytime\" src=\"img/webcam_on_wall.jpg\"/>\n</center>\n<p>Here is a similar view at night:</p>\n<center>\n<img alt=\"RevitWebcam image of Picadilly Circus at night\" src=\"img/webcam_on_wall_at_night.jpg\"/>\n</center>\n<p>Here is \n\n<a href=\"zip/RevitWebcam.zip\">\nRevitWebcam.zip</a>\n\ncontaining the complete source code and Visual Studio solution for this Revit external command add-in.\n\n<p>I still have one more Idling sample up my sleeve which I hope to be able to document in the coming days as well. \nMeanwhile, I hope that you find this as interesting as I do, even if this specific sample may not have that many immediate uses in most people's day-to-day work, and that the underlying principles and solution steps are useful anyway.\n</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p>"
  },
  {
    "original_filename": "0380_revitwebcam",
    "header_text": "Subscribe to the Idling Event",
    "local_header_href": "#subscribe-to-the-idling-event",
    "chunk_text": "<h4>Subscribe to the Idling Event</h4><p>Now we get to the real meat of this discussion, subscribing to the Idling event and implementing the handler to process it.\n\n<p>The actual subscription process is a one-liner:\n\n<pre class=\"code\">\n  uiapp.Idling\n    += <span class=\"blue\">new</span> <span class=\"teal\">EventHandler</span>&lt;<span class=\"teal\">IdlingEventArgs</span>&gt;(\n      OnIdling );\n</pre>\n<a name=\"5\"></a>\n<h4>Handle the Idling Event</h4>\n<p>The event handler may be called very frequently, as demonstrated by The Building Coder \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/04/idling-event.html\">\nCmdIdling</a> command.\n\nSince the webcam image will be updated less frequently, it makes sense to check for updates less frequently than the handler is called, i.e. skip the majority of the calls. \nI do so by defining a minimum elapsed time interval, and simply returning immediately from the handler if it has not yet passed since the last update.\n\n<p>If the minimum time interval is up, I grab the current image from URL.\nThere is still no guarantee that it has changed, so before starting a transaction and making any changes to the Revit model, I compare the current image with the last one displayed.\nThe comparison is rather simplistic, based on a SHA256Managed hash value calculated from the image pixel data like this:\n\n<pre class=\"code\">\n<span class=\"blue\">public</span> <span class=\"blue\">byte</span> [] HashValue\n{\n  <span class=\"blue\">get</span>\n  {\n    <span class=\"green\">// convert image to a byte array</span>\n \n    <span class=\"teal\">ImageConverter</span> ic = <span class=\"blue\">new</span> <span class=\"teal\">ImageConverter</span>();\n \n    <span class=\"blue\">byte</span>[] bytes = ( <span class=\"blue\">byte</span>[] ) ic.ConvertTo( \n      _bitmap, <span class=\"blue\">typeof</span>( <span class=\"blue\">byte</span>[] ) );\n \n    <span class=\"green\">// compute a hash for image</span>\n \n    <span class=\"teal\">SHA256Managed</span> shaM = <span class=\"blue\">new</span> <span class=\"teal\">SHA256Managed</span>();\n    <span class=\"blue\">return</span> shaM.ComputeHash( bytes );\n  }\n}\n</pre>\n<p>If an update is deemed necessary, a transaction is started, the spatial field primitive is set up for the face, and the field points and values to display the image data are calculated and applied.\n\n<p>Here is the code to calculate the points and values for a given face and greyscale bitmap data:\n\n<pre class=\"code\">\n<span class=\"blue\">static</span> <span class=\"blue\">void</span> GetFieldPointsAndValues( \n  <span class=\"blue\">ref</span> <span class=\"teal\">IList</span>&lt;<span class=\"teal\">UV</span>&gt; pts,\n  <span class=\"blue\">ref</span> <span class=\"teal\">IList</span>&lt;<span class=\"teal\">ValueAtPoint</span>&gt; valuesAtPoints,\n  <span class=\"blue\">ref</span> <span class=\"teal\">GreyscaleBitmapData</span> data,\n  <span class=\"teal\">Face</span> face )\n{\n  <span class=\"teal\">BoundingBoxUV</span> bb = face.GetBoundingBox();\n \n  <span class=\"blue\">double</span> umin = bb.Min.U;\n  <span class=\"blue\">double</span> umax = bb.Max.U;\n  <span class=\"blue\">double</span> ustep = ( umax - umin ) / data.Width;\n  <span class=\"blue\">double</span> u = umin;\n \n  <span class=\"blue\">double</span> v = bb.Min.V;\n  <span class=\"blue\">double</span> vmax = bb.Max.V;\n  <span class=\"blue\">double</span> vstep = ( vmax - v ) / data.Height;\n \n  <span class=\"teal\">List</span>&lt;<span class=\"blue\">double</span>&gt; values = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"blue\">double</span>&gt;( 1 );\n \n  <span class=\"blue\">for</span>( <span class=\"blue\">int</span> y = 0; y &lt; data.Height; ++y, v += vstep )\n  {\n    <span class=\"teal\">Debug</span>.Assert( v &lt; vmax, \n      <span class=\"maroon\">\"expected v to remain within bounds\"</span> );\n \n    u = umin;\n \n    <span class=\"blue\">for</span>( <span class=\"blue\">int</span> x = 0; x &lt; data.Width; ++x, u += ustep )\n    {\n      <span class=\"teal\">Debug</span>.Assert( u &lt; umax, \n        <span class=\"maroon\">\"expected u to remain within bounds\"</span> );\n \n      <span class=\"blue\">double</span> brightness = data.GetBrightnessAt( \n        x, y );\n \n      <span class=\"teal\">UV</span> uv = <span class=\"blue\">new</span> <span class=\"teal\">UV</span>( u, v );\n      pts.Add( uv );\n \n      values.Clear();\n      values.Add( brightness );\n      valuesAtPoints.Add( <span class=\"blue\">new</span> <span class=\"teal\">ValueAtPoint</span>( \n        values ) );\n    }\n  }\n}\n</pre>\n<p>To summarise, the event handler thus needs to perform the following steps:\n\n<ul>\n<li>Check minimum elapsed time interval.\n<li>Grab current image from URL.\n<li>Check whether an update is required.\n<li>Start transaction for write access.\n<li>Set up spatial field primitive.\n<li>Calculate field points and values from the image data.\n<li>Update the spatial field primitive.\n</li></li></li></li></li></li></li></ul>\n<p>Here is the actual code implementing these steps:\n\n<pre class=\"code\">\n<span class=\"blue\">static</span> <span class=\"blue\">void</span> OnIdling( \n  <span class=\"blue\">object</span> sender, \n  <span class=\"teal\">IdlingEventArgs</span> e )\n{\n  <span class=\"blue\">if</span>( <span class=\"teal\">DateTime</span>.Now.Subtract( _lastUpdate ) \n    &gt; _interval )\n  {\n    Log( <span class=\"maroon\">\"OnIdling\"</span> );\n \n    <span class=\"teal\">GreyscaleBitmapData</span> data \n      = <span class=\"blue\">new</span> <span class=\"teal\">GreyscaleBitmapData</span>( \n        _width, _height, _url );\n \n    <span class=\"blue\">byte</span>[] hash = data.HashValue;\n \n    <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == _lastHash\n      || 0 != CompareBytes( hash, _lastHash ) )\n    {\n      _lastHash = hash;\n \n      <span class=\"green\">// access active document from sender:</span>\n \n      <span class=\"teal\">Application</span> app = sender <span class=\"blue\">as</span> <span class=\"teal\">Application</span>;\n \n      <span class=\"teal\">Debug</span>.Assert( <span class=\"blue\">null</span> != app,\n        <span class=\"maroon\">\"expected a valid Revit application instance\"</span> );\n \n      <span class=\"teal\">UIApplication</span> uiapp = <span class=\"blue\">new</span> <span class=\"teal\">UIApplication</span>( app );\n      <span class=\"teal\">UIDocument</span> uidoc = uiapp.ActiveUIDocument;\n      <span class=\"teal\">Document</span> doc = uidoc.Document;\n \n      Log( <span class=\"maroon\">\"OnIdling image changed, active document \"</span>\n        + doc.Title );\n \n      <span class=\"teal\">Transaction</span> transaction \n        = <span class=\"blue\">new</span> <span class=\"teal\">Transaction</span>( doc, <span class=\"maroon\">\"Revit Webcam Update\"</span> );\n \n      transaction.Start();\n \n      <span class=\"teal\">View</span> view = doc.ActiveView; <span class=\"green\">// maybe has to be 3D</span>\n \n      <span class=\"teal\">SpatialFieldManager</span> sfm \n        = <span class=\"teal\">SpatialFieldManager</span>.GetSpatialFieldManager( \n          view );\n \n      <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == sfm ) \n      {\n        sfm = <span class=\"teal\">SpatialFieldManager</span>\n          .CreateSpatialFieldManager( view, 1 );\n      }\n \n      <span class=\"blue\">if</span>( 0 &gt; _sfp_index )\n      {\n        _sfp_index = sfm.AddSpatialFieldPrimitive(\n          _faceReference );\n      }\n \n      <span class=\"blue\">int</span> nPoints = data.Width * data.Height;\n \n      <span class=\"teal\">IList</span>&lt;<span class=\"teal\">UV</span>&gt; pts = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">UV</span>&gt;( nPoints );\n \n      <span class=\"teal\">IList</span>&lt;<span class=\"teal\">ValueAtPoint</span>&gt; valuesAtPoints \n        = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">ValueAtPoint</span>&gt;( nPoints );\n \n      <span class=\"teal\">Face</span> face = _faceReference.GeometryObject \n        <span class=\"blue\">as</span> <span class=\"teal\">Face</span>;\n \n      GetFieldPointsAndValues( <span class=\"blue\">ref</span> pts, \n        <span class=\"blue\">ref</span> valuesAtPoints, <span class=\"blue\">ref</span> data, face );\n \n      <span class=\"teal\">FieldDomainPointsByUV</span> fieldPoints \n        = <span class=\"blue\">new</span> <span class=\"teal\">FieldDomainPointsByUV</span>( pts );\n \n      <span class=\"teal\">FieldValues</span> fieldValues \n        = <span class=\"blue\">new</span> <span class=\"teal\">FieldValues</span>( valuesAtPoints );\n \n      sfm.UpdateSpatialFieldPrimitive( \n        _sfp_index, fieldPoints, fieldValues );\n \n      transaction.Commit();\n      doc.Regenerate();\n \n      _lastUpdate = <span class=\"teal\">DateTime</span>.Now;\n    }\n  }\n}\n</pre>\n<p>Notice that we open our own transaction here and regenerate the document manually.\n\n<p>The mainline of the external command Execute method putting this all together looks like this:\n\n<pre class=\"code\">\n<span class=\"teal\">UIApplication</span> uiapp = commandData.Application;\n<span class=\"teal\">UIDocument</span> uidoc = uiapp.ActiveUIDocument;\n<span class=\"teal\">Document</span> doc = uidoc.Document;\n<span class=\"teal\">View</span> view = doc.ActiveView; <span class=\"green\">// maybe has to be 3D</span>\n \n<span class=\"teal\">Reference</span> r = uidoc.Selection.PickObject( \n  <span class=\"teal\">ObjectType</span>.Face, \n  <span class=\"blue\">new</span> <span class=\"teal\">BimElementFilter</span>(), \n  _prompt );\n \n<span class=\"teal\">Debug</span>.Assert( <span class=\"blue\">null</span> != r, \n  <span class=\"maroon\">\"expected non-null reference from PickObject\"</span> );\n \n<span class=\"teal\">Debug</span>.Assert( <span class=\"blue\">null</span> != r.Element, \n  <span class=\"maroon\">\"expected non-null element from PickObject\"</span> );\n \n<span class=\"teal\">Debug</span>.Assert( <span class=\"blue\">null</span> != r.GeometryObject, \n  <span class=\"maroon\">\"expected non-null geometry object from PickObject\"</span> );\n \n<span class=\"teal\">SpatialFieldManager</span> sfm\n  = <span class=\"teal\">SpatialFieldManager</span>.GetSpatialFieldManager( \n    view );\n \n<span class=\"blue\">if</span>( <span class=\"blue\">null</span> != sfm &amp;&amp; 0 &lt; _sfp_index )\n{\n  sfm.RemoveSpatialFieldPrimitive( \n    _sfp_index );\n \n  _sfp_index = -1;\n}\n_faceReference = r;\n \nSetAnalysisDisplayStyle( doc );\n \nuiapp.Idling\n  += <span class=\"blue\">new</span> <span class=\"teal\">EventHandler</span>&lt;<span class=\"teal\">IdlingEventArgs</span>&gt;(\n    OnIdling );\n \n<span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Succeeded;\n</pre>\n<p>The mainline is enclosed in an exception handler, but I have not noticed any exceptions being thrown by it so far.\n\n<p>The command uses manual transaction mode and the manual regeneration option, since the required transaction and regeneration handling is indeed implemented by the OnIdling method.\n\n<p>We can use of the view of Piccadilly Circus from the webcam we used for our \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/06/grabbing-an-internet-webcam-image.html\">\nimage grabbing samples</a>:</p>\n<center>\n<img alt=\"Webcam image of Picadilly Circus\" src=\"img/webcam_piccadilly.jpg\"/>\n</center>\n<p>I test ran the add-in in the sample project SpatialFieldGradient.rvt provided with the AVF SDK sample mentioned above, which contains various types of wall elements.\nHere is a daytime view of the Revit screen:</p>\n<center>\n<img alt=\"RevitWebcam image of Picadilly Circus at daytime\" src=\"img/webcam_on_wall.jpg\"/>\n</center>\n<p>Here is a similar view at night:</p>\n<center>\n<img alt=\"RevitWebcam image of Picadilly Circus at night\" src=\"img/webcam_on_wall_at_night.jpg\"/>\n</center>\n<p>Here is \n\n<a href=\"zip/RevitWebcam.zip\">\nRevitWebcam.zip</a>\n\ncontaining the complete source code and Visual Studio solution for this Revit external command add-in.\n\n<p>I still have one more Idling sample up my sleeve which I hope to be able to document in the coming days as well. \nMeanwhile, I hope that you find this as interesting as I do, even if this specific sample may not have that many immediate uses in most people's day-to-day work, and that the underlying principles and solution steps are useful anyway.\n</p></p></p></p></p></p></p></p></p></p></p></p></p></p>"
  },
  {
    "original_filename": "0380_revitwebcam",
    "header_text": "Handle the Idling Event",
    "local_header_href": "#handle-the-idling-event",
    "chunk_text": "<h4>Handle the Idling Event</h4><p>The event handler may be called very frequently, as demonstrated by The Building Coder \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/04/idling-event.html\">\nCmdIdling</a> command.\n\nSince the webcam image will be updated less frequently, it makes sense to check for updates less frequently than the handler is called, i.e. skip the majority of the calls. \nI do so by defining a minimum elapsed time interval, and simply returning immediately from the handler if it has not yet passed since the last update.\n\n<p>If the minimum time interval is up, I grab the current image from URL.\nThere is still no guarantee that it has changed, so before starting a transaction and making any changes to the Revit model, I compare the current image with the last one displayed.\nThe comparison is rather simplistic, based on a SHA256Managed hash value calculated from the image pixel data like this:\n\n<pre class=\"code\">\n<span class=\"blue\">public</span> <span class=\"blue\">byte</span> [] HashValue\n{\n  <span class=\"blue\">get</span>\n  {\n    <span class=\"green\">// convert image to a byte array</span>\n \n    <span class=\"teal\">ImageConverter</span> ic = <span class=\"blue\">new</span> <span class=\"teal\">ImageConverter</span>();\n \n    <span class=\"blue\">byte</span>[] bytes = ( <span class=\"blue\">byte</span>[] ) ic.ConvertTo( \n      _bitmap, <span class=\"blue\">typeof</span>( <span class=\"blue\">byte</span>[] ) );\n \n    <span class=\"green\">// compute a hash for image</span>\n \n    <span class=\"teal\">SHA256Managed</span> shaM = <span class=\"blue\">new</span> <span class=\"teal\">SHA256Managed</span>();\n    <span class=\"blue\">return</span> shaM.ComputeHash( bytes );\n  }\n}\n</pre>\n<p>If an update is deemed necessary, a transaction is started, the spatial field primitive is set up for the face, and the field points and values to display the image data are calculated and applied.\n\n<p>Here is the code to calculate the points and values for a given face and greyscale bitmap data:\n\n<pre class=\"code\">\n<span class=\"blue\">static</span> <span class=\"blue\">void</span> GetFieldPointsAndValues( \n  <span class=\"blue\">ref</span> <span class=\"teal\">IList</span>&lt;<span class=\"teal\">UV</span>&gt; pts,\n  <span class=\"blue\">ref</span> <span class=\"teal\">IList</span>&lt;<span class=\"teal\">ValueAtPoint</span>&gt; valuesAtPoints,\n  <span class=\"blue\">ref</span> <span class=\"teal\">GreyscaleBitmapData</span> data,\n  <span class=\"teal\">Face</span> face )\n{\n  <span class=\"teal\">BoundingBoxUV</span> bb = face.GetBoundingBox();\n \n  <span class=\"blue\">double</span> umin = bb.Min.U;\n  <span class=\"blue\">double</span> umax = bb.Max.U;\n  <span class=\"blue\">double</span> ustep = ( umax - umin ) / data.Width;\n  <span class=\"blue\">double</span> u = umin;\n \n  <span class=\"blue\">double</span> v = bb.Min.V;\n  <span class=\"blue\">double</span> vmax = bb.Max.V;\n  <span class=\"blue\">double</span> vstep = ( vmax - v ) / data.Height;\n \n  <span class=\"teal\">List</span>&lt;<span class=\"blue\">double</span>&gt; values = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"blue\">double</span>&gt;( 1 );\n \n  <span class=\"blue\">for</span>( <span class=\"blue\">int</span> y = 0; y &lt; data.Height; ++y, v += vstep )\n  {\n    <span class=\"teal\">Debug</span>.Assert( v &lt; vmax, \n      <span class=\"maroon\">\"expected v to remain within bounds\"</span> );\n \n    u = umin;\n \n    <span class=\"blue\">for</span>( <span class=\"blue\">int</span> x = 0; x &lt; data.Width; ++x, u += ustep )\n    {\n      <span class=\"teal\">Debug</span>.Assert( u &lt; umax, \n        <span class=\"maroon\">\"expected u to remain within bounds\"</span> );\n \n      <span class=\"blue\">double</span> brightness = data.GetBrightnessAt( \n        x, y );\n \n      <span class=\"teal\">UV</span> uv = <span class=\"blue\">new</span> <span class=\"teal\">UV</span>( u, v );\n      pts.Add( uv );\n \n      values.Clear();\n      values.Add( brightness );\n      valuesAtPoints.Add( <span class=\"blue\">new</span> <span class=\"teal\">ValueAtPoint</span>( \n        values ) );\n    }\n  }\n}\n</pre>\n<p>To summarise, the event handler thus needs to perform the following steps:\n\n<ul>\n<li>Check minimum elapsed time interval.\n<li>Grab current image from URL.\n<li>Check whether an update is required.\n<li>Start transaction for write access.\n<li>Set up spatial field primitive.\n<li>Calculate field points and values from the image data.\n<li>Update the spatial field primitive.\n</li></li></li></li></li></li></li></ul>\n<p>Here is the actual code implementing these steps:\n\n<pre class=\"code\">\n<span class=\"blue\">static</span> <span class=\"blue\">void</span> OnIdling( \n  <span class=\"blue\">object</span> sender, \n  <span class=\"teal\">IdlingEventArgs</span> e )\n{\n  <span class=\"blue\">if</span>( <span class=\"teal\">DateTime</span>.Now.Subtract( _lastUpdate ) \n    &gt; _interval )\n  {\n    Log( <span class=\"maroon\">\"OnIdling\"</span> );\n \n    <span class=\"teal\">GreyscaleBitmapData</span> data \n      = <span class=\"blue\">new</span> <span class=\"teal\">GreyscaleBitmapData</span>( \n        _width, _height, _url );\n \n    <span class=\"blue\">byte</span>[] hash = data.HashValue;\n \n    <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == _lastHash\n      || 0 != CompareBytes( hash, _lastHash ) )\n    {\n      _lastHash = hash;\n \n      <span class=\"green\">// access active document from sender:</span>\n \n      <span class=\"teal\">Application</span> app = sender <span class=\"blue\">as</span> <span class=\"teal\">Application</span>;\n \n      <span class=\"teal\">Debug</span>.Assert( <span class=\"blue\">null</span> != app,\n        <span class=\"maroon\">\"expected a valid Revit application instance\"</span> );\n \n      <span class=\"teal\">UIApplication</span> uiapp = <span class=\"blue\">new</span> <span class=\"teal\">UIApplication</span>( app );\n      <span class=\"teal\">UIDocument</span> uidoc = uiapp.ActiveUIDocument;\n      <span class=\"teal\">Document</span> doc = uidoc.Document;\n \n      Log( <span class=\"maroon\">\"OnIdling image changed, active document \"</span>\n        + doc.Title );\n \n      <span class=\"teal\">Transaction</span> transaction \n        = <span class=\"blue\">new</span> <span class=\"teal\">Transaction</span>( doc, <span class=\"maroon\">\"Revit Webcam Update\"</span> );\n \n      transaction.Start();\n \n      <span class=\"teal\">View</span> view = doc.ActiveView; <span class=\"green\">// maybe has to be 3D</span>\n \n      <span class=\"teal\">SpatialFieldManager</span> sfm \n        = <span class=\"teal\">SpatialFieldManager</span>.GetSpatialFieldManager( \n          view );\n \n      <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == sfm ) \n      {\n        sfm = <span class=\"teal\">SpatialFieldManager</span>\n          .CreateSpatialFieldManager( view, 1 );\n      }\n \n      <span class=\"blue\">if</span>( 0 &gt; _sfp_index )\n      {\n        _sfp_index = sfm.AddSpatialFieldPrimitive(\n          _faceReference );\n      }\n \n      <span class=\"blue\">int</span> nPoints = data.Width * data.Height;\n \n      <span class=\"teal\">IList</span>&lt;<span class=\"teal\">UV</span>&gt; pts = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">UV</span>&gt;( nPoints );\n \n      <span class=\"teal\">IList</span>&lt;<span class=\"teal\">ValueAtPoint</span>&gt; valuesAtPoints \n        = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">ValueAtPoint</span>&gt;( nPoints );\n \n      <span class=\"teal\">Face</span> face = _faceReference.GeometryObject \n        <span class=\"blue\">as</span> <span class=\"teal\">Face</span>;\n \n      GetFieldPointsAndValues( <span class=\"blue\">ref</span> pts, \n        <span class=\"blue\">ref</span> valuesAtPoints, <span class=\"blue\">ref</span> data, face );\n \n      <span class=\"teal\">FieldDomainPointsByUV</span> fieldPoints \n        = <span class=\"blue\">new</span> <span class=\"teal\">FieldDomainPointsByUV</span>( pts );\n \n      <span class=\"teal\">FieldValues</span> fieldValues \n        = <span class=\"blue\">new</span> <span class=\"teal\">FieldValues</span>( valuesAtPoints );\n \n      sfm.UpdateSpatialFieldPrimitive( \n        _sfp_index, fieldPoints, fieldValues );\n \n      transaction.Commit();\n      doc.Regenerate();\n \n      _lastUpdate = <span class=\"teal\">DateTime</span>.Now;\n    }\n  }\n}\n</pre>\n<p>Notice that we open our own transaction here and regenerate the document manually.\n\n<p>The mainline of the external command Execute method putting this all together looks like this:\n\n<pre class=\"code\">\n<span class=\"teal\">UIApplication</span> uiapp = commandData.Application;\n<span class=\"teal\">UIDocument</span> uidoc = uiapp.ActiveUIDocument;\n<span class=\"teal\">Document</span> doc = uidoc.Document;\n<span class=\"teal\">View</span> view = doc.ActiveView; <span class=\"green\">// maybe has to be 3D</span>\n \n<span class=\"teal\">Reference</span> r = uidoc.Selection.PickObject( \n  <span class=\"teal\">ObjectType</span>.Face, \n  <span class=\"blue\">new</span> <span class=\"teal\">BimElementFilter</span>(), \n  _prompt );\n \n<span class=\"teal\">Debug</span>.Assert( <span class=\"blue\">null</span> != r, \n  <span class=\"maroon\">\"expected non-null reference from PickObject\"</span> );\n \n<span class=\"teal\">Debug</span>.Assert( <span class=\"blue\">null</span> != r.Element, \n  <span class=\"maroon\">\"expected non-null element from PickObject\"</span> );\n \n<span class=\"teal\">Debug</span>.Assert( <span class=\"blue\">null</span> != r.GeometryObject, \n  <span class=\"maroon\">\"expected non-null geometry object from PickObject\"</span> );\n \n<span class=\"teal\">SpatialFieldManager</span> sfm\n  = <span class=\"teal\">SpatialFieldManager</span>.GetSpatialFieldManager( \n    view );\n \n<span class=\"blue\">if</span>( <span class=\"blue\">null</span> != sfm &amp;&amp; 0 &lt; _sfp_index )\n{\n  sfm.RemoveSpatialFieldPrimitive( \n    _sfp_index );\n \n  _sfp_index = -1;\n}\n_faceReference = r;\n \nSetAnalysisDisplayStyle( doc );\n \nuiapp.Idling\n  += <span class=\"blue\">new</span> <span class=\"teal\">EventHandler</span>&lt;<span class=\"teal\">IdlingEventArgs</span>&gt;(\n    OnIdling );\n \n<span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Succeeded;\n</pre>\n<p>The mainline is enclosed in an exception handler, but I have not noticed any exceptions being thrown by it so far.\n\n<p>The command uses manual transaction mode and the manual regeneration option, since the required transaction and regeneration handling is indeed implemented by the OnIdling method.\n\n<p>We can use of the view of Piccadilly Circus from the webcam we used for our \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/06/grabbing-an-internet-webcam-image.html\">\nimage grabbing samples</a>:</p>\n<center>\n<img alt=\"Webcam image of Picadilly Circus\" src=\"img/webcam_piccadilly.jpg\"/>\n</center>\n<p>I test ran the add-in in the sample project SpatialFieldGradient.rvt provided with the AVF SDK sample mentioned above, which contains various types of wall elements.\nHere is a daytime view of the Revit screen:</p>\n<center>\n<img alt=\"RevitWebcam image of Picadilly Circus at daytime\" src=\"img/webcam_on_wall.jpg\"/>\n</center>\n<p>Here is a similar view at night:</p>\n<center>\n<img alt=\"RevitWebcam image of Picadilly Circus at night\" src=\"img/webcam_on_wall_at_night.jpg\"/>\n</center>\n<p>Here is \n\n<a href=\"zip/RevitWebcam.zip\">\nRevitWebcam.zip</a>\n\ncontaining the complete source code and Visual Studio solution for this Revit external command add-in.\n\n<p>I still have one more Idling sample up my sleeve which I hope to be able to document in the coming days as well. \nMeanwhile, I hope that you find this as interesting as I do, even if this specific sample may not have that many immediate uses in most people's day-to-day work, and that the underlying principles and solution steps are useful anyway.\n</p></p></p></p></p></p></p></p></p></p></p></p>"
  }
]