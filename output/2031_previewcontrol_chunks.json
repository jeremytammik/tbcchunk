[
  {
    "original_filename": "2031_previewcontrol",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n<link rel=\"stylesheet\" type=\"text/css\" href=\"bc.css\">\n<!-- https://highlightjs.org/#usage\n<link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css\">\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js\"></script>\n<script>hljs.highlightAll();</script>\n-->\n\n<!-- https://prismjs.com -->\n<link href=\"https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism.min.css\" rel=\"stylesheet\" />\n<script src=\"https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js\"></script>\n<script src=\"https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js\"></script>\n<style> code[class*=language-], pre[class*=language-] { font-size : 90%; } </style>\n</head>\n\n<!---\n\n- PreviewControl border\n  https://forums.autodesk.com/t5/revit-api-forum/previewcontrol-border/td-p/12570113\n  /Users/jta/a/doc/revit/tbc/git/a/img/preview_border_hide.png\n\n- spy on the preview control\n  PreviewControl border\n  https://forums.autodesk.com/t5/revit-api-forum/previewcontrol-border/m-p/12612782#M77175\n\n- change level of piping elements\n  https://forums.autodesk.com/t5/revit-api-forum/transferring-elements-from-one-level-to-another-while/m-p/12664814#M77745\n\ntwitter:\n\nPicking up two illuminating conversations from the #RevitAPI discussion forum, we look at spying to suppress the PreviewControl border and changing the level of piping elements in @AutodeskRevit #BIM @DynamoBIM https://autode.sk/previewcontrolborder\n\n&ndash; ...\n\nPicking up two illuminating conversations from the Revit API discussion forum, we look at spying to suppress the <code>PreviewControl</code> border and changing the level of piping elements...\n\nlinkedin:\n\nPicking up two illuminating conversations from the #RevitAPI discussion forum, we look at spying to suppress the PreviewControl border and changing the level of piping elements\n\nhttps://autode.sk/previewcontrolborder\n\n#BIM #DynamoBIM #AutodeskAPS #Revit #API #IFC #SDK #Autodesk #AEC #adsk\n\nthe [Revit API discussion forum](http://forums.autodesk.com/t5/revit-api-forum/bd-p/160) thread\n\n<center>\n<img src=\"img/\" alt=\"\" title=\"\" width=\"600\"/>\n<p style=\"font-size: 80%; font-style:italic\"></p>\n</center>\n\n-->"
  },
  {
    "original_filename": "2031_previewcontrol",
    "header_text": "Change Pipe Level and PreviewControl Border",
    "local_header_href": "#change-pipe-level-and-previewcontrol-border",
    "chunk_text": "### Change Pipe Level and PreviewControl Border\n\nPicking up two illuminating conversations from\nthe [Revit API discussion forum](http://forums.autodesk.com/t5/revit-api-forum/bd-p/160):\n\n- [Spying to suppress the `PreviewControl` border](#2)\n- [Changing the level of piping elements](#3)"
  },
  {
    "original_filename": "2031_previewcontrol",
    "header_text": "Spying to Suppress the PreviewControl Border",
    "local_header_href": "#2",
    "chunk_text": "####<a name=\"2\"></a> Spying to Suppress the PreviewControl Border\n\nRoman [@Nice3point](https://t.me/nice3point) Karpovich, aka Роман Карпович,\nraised and solved the question of how to suppress the unwanted\n[PreviewControl border](https://forums.autodesk.com/t5/revit-api-forum/previewcontrol-border/td-p/12570113):\n\n**Question:**\nIs it possible to disable the PreviewControl border ? This border comes from the Win32 window. Setting User32.WindowStyles by Hwnd handle does not give any results. Except WS_CHILD and similar, no other styles are applied. Is this border added by Revit development team or is it a HwndHost issue ?\n\n<center>\n<img src=\"img/preview_border_hide_1.png\" alt=\"PreviewControl border\" title=\"PreviewControl border\" width=\"300\"/> <!-- Pixel Height: 592 Pixel Width: 523 -->\n</center>\n\n**Answer:**\nThe only way I could do it when I used it, was to set the Grid margin to -4, but this only works if the grid is set entirely to the window.\n\n**Response:**\nThat is not a solution; the negative margin just covers other content.\n\n**Answer:**\nI don't like the negative margin either, but it was the only way to hide the border. And for it to work, the container (Grid) must cover the entire window.\n\n**Answer B:**\nYou can use Spy++ to determine the window structure and use WinAPI to remove the borders and some WPF magic to trigger the repaint.\nIt took me hours of experimenting, but it is doable.\nIf I recall correctly, there are multiple levels of controls and you have to figure out which ones carry the borders.\n\nI am off for a while and have no access to the code, but don’t feel discouraged if it doesn’t work the first time.\nIt was really painful to solve this and I wish Autodesk would just remove the borders in an upcoming release.\nIt is hard to make software look good if the underlying API takes you back to the nineties ;-).\n\nI can post some code for you to fill the gaps.\nThe important snippet (to be called after `previewControl.Loaded` AND `previewControl.IsVisibleChanged`) is the following:\n\n<pre><code class=\"language-csharp\">\n// get preview window host\nvar previewWndHost = previewControl.Content;\nif (previewWndHost is null)\n  return;\n\n// get preview view handle\nvar previewHwnd = (IntPtr)previewWndHost.GetType().GetProperty(\"Handle\").GetValue(previewWndHost, null);\nif (previewHwnd == IntPtr.Zero)\n  return;\n\n// remove WS_EX_CLIENTEDGE on all child windows\nforeach (var hwnd in HwndHelpers.GetAllChildHandles(previewHwnd).Append(previewHwnd))\n{\n  var style = User32.GetWindowLong(hwnd, Constants.GWL_EXSTYLE).ToInt32() & ~(int)Constants.WS_EX_CLIENTEDGE;\n  User32.SetWindowLong(hwnd, Constants.GWL_EXSTYLE, style);\n}\n\n// trigger redraw by adding or removing a slight padding at the bottom\n// the original padding is stored in the tag, so try to avoid using the\n// tag property for anything else if you want this to work.\nvar p = previewControl.Padding;\nif (previewControl.Tag is null)\n  previewControl.Tag = p;\nif (previewControl.Tag is System.Windows.Thickness t)\n{\n  p.Bottom = p.Bottom == t.Bottom ? p.Bottom + 1 : t.Bottom;\n  previewControl.Padding = p;\n}\n</code></pre>\n\nThe `IsVisibleChanged` handler is required for use in tab controls, since Revit seems to re-create the view in case of visibility changes.\nI misused the tag to save the previous state and avoid shrinking/growing of the control due to the padding-changes at \"reentry\".\nIf you find a better solution to trigger the redraw, please let me know.\nThis part is pretty hacky, but I had to move on at some point and got stuck with whatever did the job.\n\nI also use some WinAPI functions which can be easily imported (google, pinvoke).\nThe HwndHelpers function is just syntactic sugar around EnumChildWindows.\n\n<pre><code class=\"language-csharp\">\npublic static IList&lt;IntPtr&gt; GetAllChildHandles(IntPtr hwnd)\n{\n  var childHandles = new List&lt;IntPtr&gt;();\n  var gcChildHandles = GCHandle.Alloc(childHandles);\n\n  try\n  {\n    bool EnumWindow(IntPtr hWnd, IntPtr lParam)\n    {\n      (GCHandle.FromIntPtr(lParam).Target as List&lt;IntPtr&gt;)?.Add(hWnd);\n      return true;\n    }\n\n    var childProc = new User32.EnumWindowsProc(EnumWindow);\n    User32.EnumChildWindows(hwnd, childProc, GCHandle.ToIntPtr(gcChildHandles));\n  }\n  finally\n  {\n    gcChildHandles.Free();\n  }\n  return childHandles;\n}\n</code></pre>\n\n**Response:**\nAmazing.\nI completely forgot about the Child when writing similar code.\nNow all borders are gone.\nIn addition, I have solved the redrawing problem, for which you used Padding (it was not working correctly).\n\nBefore:\n\n<center>\n<img src=\"img/preview_border_hide_2.png\" alt=\"PreviewControl border\" title=\"PreviewControl border\" width=\"200\"/> <!-- Pixel Height: 790 Pixel Width: 466 -->\n</center>\n\nAfter:\n\n<center>\n<img src=\"img/preview_border_hide_3.png\" alt=\"PreviewControl border suppressed\" title=\"PreviewControl border suppressed\" width=\"200\"/> <!-- Pixel Height: 852 Pixel Width: 525 -->\n</center>\n\nSolution:\n\n<pre><code class=\"language-csharp\">\npublic void Initialize()\n{\n  var previewControl = new PreviewControl(_context, view.Id);\n  previewControl.Loaded += RemovePreviewControlStyles;\n}\n\nprivate void RemovePreviewControlStyles(object sender, EventArgs args)\n{\n  var control = (PreviewControl)sender;\n  var previewHost = (FrameworkElement)control.Content;\n  var previewType = previewHost.GetType();\n  var hostField = previewType.GetField(\"m_hwndHost\", BindingFlags.NonPublic | BindingFlags.DeclaredOnly | BindingFlags.Instance)!;\n  var handle = (IntPtr)hostField.GetValue(previewHost);\n\n  var childHandles = UnsafeNativeMethods.GetChildHandles(handle);\n\n  UnsafeNativeMethods.RemoveWindowStyles(handle);\n  UnsafeNativeMethods.RemoveWindowCaption(handle);\n  foreach (var childHandle in childHandles)\n  {\n    UnsafeNativeMethods.RemoveWindowStyles(childHandle);\n  }\n}\n</code></pre>\n\nUnsafeNativeMethods:\n\n<pre><code class=\"language-csharp\">\n/// &lt;summary&gt;\n/// Tries to remove styles from selected window handle.\n/// &lt;/summary&gt;\n/// &lt;param name=\"handle\"&gt;Window handle.&lt;/param&gt;\n/// &lt;returns&gt;&lt;see langword=\"true\"/&gt; if invocation of native Windows function succeeds.&lt;/returns&gt;\npublic static bool RemoveWindowStyles(IntPtr handle)\n{\n  if (handle == IntPtr.Zero)\n  {\n    return false;\n  }\n\n  if (!User32.IsWindow(handle))\n  {\n    return false;\n  }\n\n  var cornerResult = ApplyWindowCornerPreference(handle, WindowCornerPreference.DoNotRound);\n  if (!cornerResult) return false;\n\n  var windowStyleLong = User32.GetWindowLong(handle, User32.GWL.GWL_EXSTYLE);\n  windowStyleLong &= ~(int)User32.WS_EX.CLIENTEDGE;\n\n  var styleResult = SetWindowLong(handle, User32.GWL.GWL_EXSTYLE, windowStyleLong);\n  return styleResult.ToInt64() &gt; 0x0;\n}\n\n/// &lt;summary&gt;\n///   Get the child windows that belong to the specified parent window by passing the handle to each child window.\n/// &lt;/summary&gt;\n/// &lt;param name=\"hwnd\"&gt;Window handle.&lt;/param&gt;\npublic static IList&lt;IntPtr&gt; GetChildHandles(IntPtr hwnd)\n{\n  var handles = new List&lt;IntPtr&gt;();\n  var gcHandles = GCHandle.Alloc(handles);\n\n  try\n  {\n    var callbackPointer = new User32.EnumWindowsProc(EnumWindowCallback);\n    User32.EnumChildWindows(hwnd, callbackPointer, GCHandle.ToIntPtr(gcHandles));\n  }\n  finally\n  {\n    gcHandles.Free();\n  }\n  return handles;\n}\n\nprivate static bool EnumWindowCallback(IntPtr hwnd, IntPtr lParam)\n{\n  var target = GCHandle.FromIntPtr(lParam).Target as List&lt;IntPtr&gt;;\n  if (target is null) return false;\n\n  target.Add(hwnd);\n  return true;\n}\n</code></pre>\n\nUser32:\n\n<pre><code class=\"language-csharp\">\n/// &lt;summary&gt;\n/// An application-defined callback function used with the EnumChildWindows function.\n/// It receives the child window handles. The WNDENUMPROC type defines a pointer to\n/// this callback function. EnumChildProc is a placeholder for the application-defined\n/// function name.\n/// &lt;/summary&gt;\npublic delegate bool EnumWindowsProc(IntPtr hWnd, IntPtr lParam);\n\n/// &lt;summary&gt;\n/// Enumerates the child windows that belong to the specified parent window by\n/// passing the handle to each child window, in turn, to an application-defined\n/// callback function. EnumChildWindows continues until the last child window\n/// is enumerated or the callback function returns FALSE.\n/// &lt;/summary&gt;\n/// &lt;param name=\"hwnd\"&gt;The window that you want to get information about.&lt;/param&gt;\n/// &lt;param name=\"func\"&gt;A pointer to an application-defined callback function&lt;/param&gt;\n/// &lt;param name=\"lParam\"&gt;An application-defined value to be passed to the callback function.&lt;/param&gt;\n/// &lt;returns&gt;&lt;/returns&gt;\n[DllImport(Libraries.User32)]\npublic static extern bool EnumChildWindows(IntPtr hwnd, EnumWindowsProc func, IntPtr lParam);\n</code></pre>\n\nI've also disabled edge rounding for Windows 11.\nThe methods used can be found in the WPF UI repository:\n\n- [User32](https://github.com/lepoco/wpfui/blob/development/src/Wpf.Ui/Interop/User32.cs)\n- [UnsafeNativeMethods](https://github.com/lepoco/wpfui/blob/development/src/Wpf.Ui/Interop/UnsafeNativeMethods.cs)\n\nSo, problem solved; I think it will be useful to share this on the blog.\nHowever, I would like to ask the Revit development team to turn this off by default,\nas it is easier for users to configure the control themselves than to mess with Win API and native code.\n\nThe lines to get me rid of the padding-trick are\n\n- UnsafeNativeMethods.RemoveWindowCaption(handle);\n\nwhere handle is `hwndHost`,\ncf. [UnsafeNativeMethods.cs line 468](https://github.com/lepoco/wpfui/blob/development/src/Wpf.Ui/Interop/UnsafeNativeMethods.cs#L468).\n\nMany thanks to Roman for researching and sharing this helpful solution!"
  },
  {
    "original_filename": "2031_previewcontrol",
    "header_text": "Changing Level of Piping Elements",
    "local_header_href": "#3",
    "chunk_text": "####<a name=\"3\"></a> Changing Level of Piping Elements\n\n[Evan Geer](https://evangeer.com/)) shared\na nice example for changing the level for selected piping elements in his answer\nto [transferring elements from one level to another while maintaining their position in space](https://forums.autodesk.com/t5/revit-api-forum/transferring-elements-from-one-level-to-another-while/m-p/12664814)\n\n**Question:**\nHow to move selected elements to another level while maintaining their position in space?\n\n**Answer:**\nCan you achieve what you want manually in the end user interface?\nIf so, that is a good start.\nIf not, it would be good to check that first, determine the optimal workflow and best practices, cf.\nthe [standard approach to address a Revit API programming task](https://thebuildingcoder.typepad.com/blog/2017/01/virtues-of-reproduction-research-mep-settings-ontology.html#3).\n\nPossibly, some elements cannot simply be moved to an different level, but need to be recreated from scratch based on the new level.\n\nThere is an older post showing how to do something similar here:\n\nhttps://forums.autodesk.com/t5/revit-api-forum/change-the-level-of-an-element/td-p/3707640\n\nHere is an example command that will change the level of the selected elements.\nNote that you will need to determine which parameter you want to change for different types of elements, and as noted above, you may not be able to change the level of some elements.\nThis example changes the level for selected piping elements:\n\n<pre><code class=\"language-csharp\">\npublic Result Execute(ExternalCommandData commandData, ref string message, ElementSet elements)\n{\n  var doc = commandData.Application.ActiveUIDocument.Document;\n  var selectedIds = commandData.Application.ActiveUIDocument.Selection.GetElementIds();\n\n  var selectedElements = selectedIds.Select(x =&gt; doc.GetElement(x)).ToList();\n\n  var newLevelName = \"L2\";\n  var newLevel = new FilteredElementCollector(doc)\n    .OfClass(typeof(Level))\n    .FirstOrDefault(x =&gt; x.Name == newLevelName) as Level;\n\n  var levelHostedElements = selectedElements\n    .Where(x =&gt; x.LevelId != null && x.LevelId != ElementId.InvalidElementId)\n    .ToList();\n\n  using (var t = new Transaction(doc, \"update level\"))\n  {\n    t.Start();\n    foreach (var element in levelHostedElements)\n    {\n      // NOTE: you will need to select the correct parameter for the element type you are targeting\n      var levelParameter = element.get_Parameter(BuiltInParameter.RBS_START_LEVEL_PARAM);\n      if (levelParameter?.HasValue == true /*&& offsetParameter?.HasValue == true*/)\n      {\n        var oldLevel = doc.GetElement(levelParameter.AsElementId()) as Level;\n\n        levelParameter.Set(newLevel.Id);\n      }\n    }\n    t.Commit();\n  }\n  return Result.Succeeded;\n}\n</code></pre>\n\nIn order to select a level interactively, transfer all elements from it to the target level, and list elements that were not transferred in a dialog box,\nyou just need some handling for parameters and element type match-up.\nThis seems like a perfect match for an abstract factory pattern or something similar.\nYou might also save some time using the RevitLookup tools to identify which parameters match to which types.\n\nIt's not ideal, but I do not think that there is a universal solution to changing the level of an element.\nAs far as I understand, the reason for this is that different elements are hosted by and associated with levels in different ways.\nSo, Revit's engine under the hood is doing different things to make that work, and the options we have exposed to us in the API therefore differ by type.\n\nRegarding handling moving everything on a given level, that can be accomplished with some changes to my example.\nWhere I have hard-code the level name in `newLevelName`, set to \"L2\"; you could easily replace that with a UI allowing users to select the destination level. Similarly, you could add a UI to allow the user to select a source level, and supply that id to this block of code:\n\n<pre><code class=\"language-csharp\">\n  var levelHostedElements = selectedElements\n    .Where(x =&gt; x.LevelId == sourceLevel.Id)\n    .ToList();\n</code></pre>\n\nMany thanks to Evan for the nice sample code and thorough explanation!"
  }
]