[
  {
    "original_filename": "0552_app_versus_cmd_event",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<head>\n<link href=\"bc.css\" rel=\"stylesheet\" type=\"text/css\"/>\n</head>"
  },
  {
    "original_filename": "0552_app_versus_cmd_event",
    "header_text": "Application Versus Command Event",
    "local_header_href": "#application-versus-command-event",
    "chunk_text": "<h3>Application Versus Command Event</h3><p>Here is an interesting observation by Ning Zhou on the difference between registering a handler for the DialogBoxShowing event in an external application versus an external command.\n\n<p>Here is the initial query:\n\n<p><strong>Question:</strong> We have an add-in which loads multiple families and suppresses the warning message which is displayed in case family instances already exist for some of them by registering a DialogBoxShowing event handler.\n\n<p>The problem with this is that the installation of this event handler also affects the normal Revit load family behaviour from the user interface. \nThe warning message is suppressed for load family using insert, but load family using reload still displays it. \n\n<p>If I uninstall our add-in, both load family methods display the warning message again. \n\n<p>Can you provide any solution or workaround for this? \n\n<p>Here are the relevant code snippets to explain what we are doing:\n\n<pre class=\"code\">\n<span class=\"blue\">public</span> CmdResult OnStartup(\n  <span class=\"teal\">UIControlledApplication</span> application )\n{\n  application.DialogBoxShowing\n    += <span class=\"blue\">new</span> <span class=\"teal\">EventHandler</span>&lt;<span class=\"teal\">DialogBoxShowingEventArgs</span>&gt;(\n      myDialogBoxShowing );\n  <span class=\"green\">// ... </span>\n}\n \n<span class=\"blue\">void</span> myDialogBoxShowing(\n  <span class=\"blue\">object</span> sender,\n  <span class=\"teal\">DialogBoxShowingEventArgs</span> e )\n{\n  <span class=\"teal\">TaskDialogShowingEventArgs</span> e1\n    = e <span class=\"blue\">as</span> <span class=\"teal\">TaskDialogShowingEventArgs</span>;\n \n  <span class=\"blue\">if</span>( e1 != <span class=\"blue\">null</span>\n    &amp;&amp; e1.DialogId.Equals(\n      <span class=\"maroon\">\"TaskDialog_Family_Already_Exists\"</span> ) )\n  {\n    e1.OverrideResult( ( <span class=\"blue\">int</span> ) \n      <span class=\"teal\">TaskDialogResult</span>.CommandLink1 ); <span class=\"green\">// 1001</span>\n  }\n}\n</pre>\n<p><strong>Solution:</strong> I fixed it myself by placing the DialogBoxShowing event at command level instead of application level. \n\n<!--\n<p>I assume that the loading of a modified family by \"insert\" is based on application level,\nand loading the modified family by \"reload\" is based on command level? \n-->\n<p><strong>Response:</strong> Yes, exactly, if you register the DialogBoxShowing event handler at the beginning of an external command and then unregister it again at the end of the command, the warning message will be suppressed only for the duration of your command.\n\n<p>After your command ends, the dialogue suppressing mechanism is deactivated again.\nWithout the double negation: the messages are displayed as normal again.\nThis explains why the warning dialogue box is showing again when you manually insert a family file. \n\n<p>If you register the DialogBoxShowing event handler in the external application OnStartup method, the dialogue suppressing mechanism is always active. \nThen it can dismiss the warning dialogue both when your own external command is programmatically loading families and also when you manually insert a family file from disk through the user interface. \n</p></p></p></p></p></p></p></p></p></p></p>"
  }
]