[
  {
    "original_filename": "0055_3d_polygon_area",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<style>\n.blue { color: blue; }\n.teal { color: teal; }\n.maroon { color: maroon; }\n.green { color: green; }\n</style>"
  },
  {
    "original_filename": "0055_3d_polygon_area",
    "header_text": "3D Polygon Areas",
    "local_header_href": "#3d-polygon-areas",
    "chunk_text": "<h3>3D Polygon Areas</h3><p>We continue the discussion initiated in the recent post on\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2008/12/2d-polygon-areas-and-outer-loop.html\">\ntwo-dimensional polygon area calculation</a>.\n\nWe can use these areas to determine which of the edge loops is the outer loop versus inner loops defining holes.\nThe polygon with the largest area is the outer loop, all others are inner holes.\nThis is a continuation of the analysis for determining the profile boundary loop polygons for\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2008/10/slab-boundary.html\">\nfloor slabs</a>\n\nand\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2008/11/wall-elevation-profile.html\">\nwalls</a>.\n\nIn this instalment, we expand our analysis to include three-dimensional polygons, i.e. planar polygons oriented arbitrarily in 3D space.</p><p>To determine the area of a two-dimensional polygon in the previous post, we used a simple formula which basically works by calculating the area of the triangles spanned by an arbitrary point in the plane and any two consecutive polygon vertices, and summing up all of those triangle areas.\nThe polygons returned for the floor and wall boundary loops are three dimensional.\nWe have two choices for calculating the area of a three-dimensional planar polygon in space.\nOne approach is to transform the polygon appropriately onto the XY plane and make use of the formula we already have.\nAnother approach makes use of the same algorithm adapted for use on the three-dimensional vertices directly.\nIt calculates each polygon's plane data in space, i.e. its distance from the origin and normal vector.\nThe polygon area is by-product of these calculations, because it is equal to half of the length of the non-normalized normal vector.\nI would like to demonstrate both approaches, so we can compare them and ensure that both return the same results.\nWe will begin with the implementation of the three-dimensional algorithm, including optimised implementations for the special cases of triangles and four-sided polygons:</p><pre class=\"code\">\n<span class=\"blue\">bool</span> GetPolygonPlane(\n  <span class=\"teal\">List</span>&lt;<span class=\"teal\">XYZ</span>&gt; polygon,\n  <span class=\"blue\">out</span> <span class=\"teal\">XYZ</span> normal,\n  <span class=\"blue\">out</span> <span class=\"blue\">double</span> dist,\n  <span class=\"blue\">out</span> <span class=\"blue\">double</span> area )\n{\n  normal = <span class=\"teal\">XYZ</span>.Zero;\n  dist = area = 0.0;\n  <span class=\"blue\">int</span> n = ( <span class=\"blue\">null</span> == polygon ) ? 0 : polygon.Count;\n  <span class=\"blue\">bool</span> rc = ( 2 &lt; n );\n  <span class=\"blue\">if</span>( 3 == n )\n  {\n    <span class=\"teal\">XYZ</span> a = polygon[0];\n    <span class=\"teal\">XYZ</span> b = polygon[1];\n    <span class=\"teal\">XYZ</span> c = polygon[2];\n    <span class=\"teal\">XYZ</span> v = b - a;\n    normal = v.Cross( c - a );\n    dist = normal.Dot( a );\n  }\n  <span class=\"blue\">else</span> <span class=\"blue\">if</span>( 4 == n )\n  {\n    <span class=\"teal\">XYZ</span> a = polygon[0];\n    <span class=\"teal\">XYZ</span> b = polygon[1];\n    <span class=\"teal\">XYZ</span> c = polygon[2];\n    <span class=\"teal\">XYZ</span> d = polygon[3];\n \n    normal.X = ( c.Y - a.Y ) * ( d.Z - b.Z )\n      + ( c.Z - a.Z ) * ( b.Y - d.Y );\n    normal.Y = ( c.Z - a.Z ) * ( d.X - b.X )\n      + ( c.X - a.X ) * ( b.Z - d.Z );\n    normal.Z = ( c.X - a.X ) * ( d.Y - b.Y )\n      + ( c.Y - a.Y ) * ( b.X - d.X );\n \n    dist = 0.25 *\n      ( normal.X * ( a.X + b.X + c.X + d.X )\n      + normal.Y * ( a.Y + b.Y + c.Y + d.Y )\n      + normal.Z * ( a.Z + b.Z + c.Z + d.Z ) );\n  }\n  <span class=\"blue\">else</span> <span class=\"blue\">if</span>( 4 &lt; n )\n  {\n    <span class=\"teal\">XYZ</span> a;\n    <span class=\"teal\">XYZ</span> b = polygon[n - 2];\n    <span class=\"teal\">XYZ</span> c = polygon[n - 1];\n    <span class=\"teal\">XYZ</span> s = <span class=\"teal\">XYZ</span>.Zero;\n \n    <span class=\"blue\">for</span>( <span class=\"blue\">int</span> i = 0; i &lt; n; ++i ) {\n      a = b;\n      b = c;\n      c = polygon[i];\n \n      normal.X += b.Y * ( c.Z - a.Z );\n      normal.Y += b.Z * ( c.X - a.X );\n      normal.Z += b.X * ( c.Y - a.Y );\n \n      s += c;\n    }\n    dist = s.Dot( normal ) / n;\n  }\n  <span class=\"blue\">if</span>( rc )\n  {\n    <span class=\"blue\">double</span> length = normal.Length;\n    rc = !<span class=\"teal\">Util</span>.IsZero( length );\n    <span class=\"teal\">Debug</span>.Assert( rc );\n \n    <span class=\"blue\">if</span>( rc )\n    {\n      normal /= length;\n      dist /= length;\n      area = 0.5 * length;\n    }\n  }\n  <span class=\"blue\">return</span> rc;\n}\n</pre><p>We define a variable n for the number of polygon vertices.\nWe have implemented specific code for triangles, i.e. the case n = 3, and 4-sided polygons.\nThe polygon area is half of the length of the non-normalized normal vector of the plane.</p><p>Here is the main section of the external command making use of this function.\nIt lists the areas of the various loops of the selected walls, or all walls in the model, if none were explicitly selected, and highlights the largest area.\nJust like in the floor area calculation, the code assumes that only one wall is picked.\nIf more than one is processed, then the determination of the outer loop will only work for the wall with the largest surface area, since all loops of all walls are included in one single list.\nWe repackaged the functionality for determining the wall profile polygons into a separate utility method GetWallProfilePolygons() in the CmdWallProfile class, so that we can reuse that functionality from the new command as well:</p><pre class=\"code\">\n<span class=\"teal\">List</span>&lt;<span class=\"teal\">List</span>&lt;<span class=\"teal\">XYZ</span>&gt;&gt; polygons\n  = <span class=\"teal\">CmdWallProfile</span>.GetWallProfilePolygons(\n    app, walls );\n \n<span class=\"blue\">int</span> i = 0, n = polygons.Count;\n<span class=\"blue\">double</span>[] areas = <span class=\"blue\">new</span> <span class=\"blue\">double</span>[n];\n<span class=\"blue\">double</span> d, a, maxArea = 0.0;\n<span class=\"teal\">XYZ</span> normal;\n<span class=\"blue\">foreach</span>( <span class=\"teal\">List</span>&lt;<span class=\"teal\">XYZ</span>&gt; polygon <span class=\"blue\">in</span> polygons )\n{\n  GetPolygonPlane( polygon,\n    <span class=\"blue\">out</span> normal, <span class=\"blue\">out</span> d, <span class=\"blue\">out</span> a );\n  <span class=\"blue\">if</span>( <span class=\"teal\">Math</span>.Abs( maxArea ) &lt; <span class=\"teal\">Math</span>.Abs( a ) )\n  {\n    maxArea = a;\n  }\n  areas[i++] = a;\n}\n \n<span class=\"teal\">Debug</span>.WriteLine( <span class=\"blue\">string</span>.Format(\n  <span class=\"maroon\">\"{0} boundary loop{1} found.\"</span>,\n  n, <span class=\"teal\">Util</span>.PluralSuffix( n ) ) );\n \n<span class=\"blue\">for</span>( i = 0; i &lt; n; ++i )\n{\n  <span class=\"teal\">Debug</span>.WriteLine( <span class=\"blue\">string</span>.Format(\n    <span class=\"maroon\">\"  Loop {0} area is {1} square feet{2}\"</span>,\n    i,\n    <span class=\"teal\">Util</span>.RealString( areas[i] ),\n    ( areas[i].Equals( maxArea )\n      ? <span class=\"maroon\">\", outer loop of largest wall\"</span>\n      : <span class=\"maroon\">\"\"</span> ) ) );\n}\n</pre><p>Here is a small example model with two walls selected and highlighted in red. Their boundary loops are represented by model lines in green, offset outward from the outer wall face by one foot:</p><img alt=\"Wall boundary loops\" src=\"img/wall_boundary_loops.png\"/><p>This is the list of the boundary loop areas of the two selected walls.\nThe first wall has an outer loop and two inner ones for the two windows.\nThe second wall has only one single simple rectangular outer loop:</p><pre>\n4 boundary loops found.\n  Loop 0 area is 288.98 square feet, outer loop of largest wall\n  Loop 1 area is 2.67 square feet\n  Loop 2 area is 2.67 square feet\n  Loop 3 area is 172.22 square feet\n</pre><p>There are still some aspects of this topic left that we would like to address in future posts.\nAs mentioned above, we would like to transform the 3D polygons into the 2D XY plane\nso we can use the two-dimensional GetSignedPolygonArea() on those as well, instead of performing the area calculation in 3D.\nThen we can compare the 2D and 3D results to ensure that they are equal.\nIt would also be interesting to compare the relative speed of transforming the 3D situation to 2D and using 2D area calculation versus direct 3D area calculation.</p><p>Here is an updated\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/files/bc10015.zip\">\nversion 1.0.0.15</a>\n\nof the complete Visual Studio solution,\nincluding the two new commands CmdSlabBoundaryArea and CmdWallProfileArea as well as all other commands discussed so far.</p>"
  }
]