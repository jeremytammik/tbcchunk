[
  {
    "original_filename": "0823_filter_touching_beam",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<head>\n<link href=\"bc.css\" rel=\"stylesheet\" type=\"text/css\"/>\n</head>"
  },
  {
    "original_filename": "0823_filter_touching_beam",
    "header_text": "Filter for Touching Beams Using Solid Intersection",
    "local_header_href": "#filter-for-touching-beams-using-solid-intersection",
    "chunk_text": "<h3>Filter for Touching Beams Using Solid Intersection</h3><p>I discussed how I created my first \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2012/09/sphere-creation-for-avf-and-filtering.html\">\nsphere in the Revit API</a> and\n\ndisplayed it using the analysis visualisation framework \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/avf\">\nAVF</a>.\n\nNow let's make more serious use of it.\n\n<p>As I mentioned, the transient solids created by the geometry creation utility class can be used to set up geometrical proximity filters.\n\n<p>This exploration was prompted by the following query:\n\n<p><strong>Question:</strong> I would like to programmatically retrieve all touching beams, regardless of whether they are officially connected or not.\n\n<p>The user should pick one single beam, and all other beams touching it should be selected, recursively.\n\n<p>How can I achieve this, please?\n\n<p><strong>Answer:</strong> First let's look at the case you are not interested in :-)\n\n<p>If the beams are properly connected, you can use the LocationCurve ElementsAtJoin property to determine the connected beams at each end of the first, manually selected one, and iterate through the connection elements as demonstrated by the TraverseSystem SDK sample for duct systems using the MEP connector manager.\n\n<p>If the beams are not properly connected, but just touching, as you say, you can use the ElementIntersectsSolidFilter instead. \nSuch as filter detects elements within a given geometrical space defined by solid, which may come from the BIM model or be transient, i.e. generated in memory on the fly.\n\n<p>To recursively iterate through the beam system requires creating a new solid and a new filter for each beam you find, since each solid has its own location in space.\nIf you are interested in beams touching anywhere, you could create an extruded shape matching the beam shape and detect all other beams that intersect it or come close to it anywhere at all along the length of the beam.\nIf you are only interested in beams touching at the end points, you could set up a simple sphere at each end of the beam.\n\n<p>This process could be repeated recursively for all touching beams encountered.\nOf course you would have to skip beams that you have already found, or you would run into an infinite loop.\n\n<p>Here is the algorithm I am thinking of:\n\n<ul>\n<li>Maintain three lists of beams:\n<ul>\n<li>The beams already visited.\n<li>The current ones being analysed.\n<li>The neighbours of the current ones.\n</li></li></li></ul>\n<li>Select a starting beam, making it the current one.\n<li>While the set of current beams is non-empty, repeat the following:\n<ul>\n<li>Add the current to the list of visited beams.\n<li>Clear the list of neighbours.\n<li>For each of the current beams, add all beams touching it to the list of neighbours.\n<li>Make the neighbours found in the previous step the new set of current beams.\n</li></li></li></li></ul>\n</li></li></li></ul>\n<p>Finding all touching neighbours for a given beam is implement in the method AddConnectedElements, which sets up a sphere at each end of the beam, creates a proximity detector based on it using an ElementIntersectsSolidFilter, and adds all beams retrieved by that, excluding the beams already visited and neighbours already found.\n\n<p>I already presented the sphere creation method\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2012/09/sphere-creation-for-avf-and-filtering.html#3\">\nCreateSphereAt</a>.\n\n<p>Here is the AddConnectedElements method and its helper method AddElementsIntersectingSphereAt to detect touching elements:\n\n<pre class=\"code\">\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n  <span class=\"gray\">///</span><span class=\"green\"> Determine all neighbouring elements connected</span>\n  <span class=\"gray\">///</span><span class=\"green\"> to the current element 'e', skipping all </span>\n  <span class=\"gray\">///</span><span class=\"green\"> previously visited ones.</span>\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n  <span class=\"blue\">void</span> AddElementsIntersectingSphereAt(\n    <span class=\"teal\">List</span>&lt;<span class=\"teal\">ElementId</span>&gt; neighbours,\n    <span class=\"teal\">XYZ</span> p,\n    <span class=\"teal\">List</span>&lt;<span class=\"teal\">ElementId</span>&gt; visited,\n    <span class=\"teal\">Document</span> doc )\n  {\n    <span class=\"teal\">Solid</span> sphere = CreateSphereAt(\n      doc.Application.Create, p, _sphere_radius );\n \n    <span class=\"teal\">ElementIntersectsSolidFilter</span> intersectSphere\n      = <span class=\"blue\">new</span> <span class=\"teal\">ElementIntersectsSolidFilter</span>( sphere );\n \n    <span class=\"teal\">FilteredElementCollector</span> collector\n      = <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( doc )\n        .WhereElementIsCurveDriven() <span class=\"green\">// we work with the location curve</span>\n        .OfCategory( _bic )\n        .Excluding( visited.Union&lt;<span class=\"teal\">ElementId</span>&gt;( \n          neighbours ).ToList&lt;<span class=\"teal\">ElementId</span>&gt;() )\n        .WherePasses( intersectSphere );\n \n    neighbours.AddRange( collector.ToElementIds() );\n  }\n \n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n  <span class=\"gray\">///</span><span class=\"green\"> Determine all neighbouring elements close to </span>\n  <span class=\"gray\">///</span><span class=\"green\"> the two ends of the current element 'e', </span>\n  <span class=\"gray\">///</span><span class=\"green\"> skipping all previously visited ones.</span>\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n  <span class=\"blue\">void</span> AddConnectedElements(\n    <span class=\"teal\">List</span>&lt;<span class=\"teal\">ElementId</span>&gt; neighbours,\n    <span class=\"teal\">Element</span> e,\n    <span class=\"teal\">List</span>&lt;<span class=\"teal\">ElementId</span>&gt; visited )\n  {\n    <span class=\"teal\">Location</span> loc = e.Location;\n \n    <span class=\"teal\">Debug</span>.Print( <span class=\"blue\">string</span>.Format(\n      <span class=\"maroon\">\"current element {0} has location {1}\"</span>,\n      ElementDescription( e ),\n      <span class=\"blue\">null</span> == loc ? <span class=\"maroon\">\"&lt;null&gt;\"</span> : loc.GetType().Name ) );\n \n    <span class=\"teal\">LocationCurve</span> lc = loc <span class=\"blue\">as</span> <span class=\"teal\">LocationCurve</span>;\n \n    <span class=\"blue\">if</span>( <span class=\"blue\">null</span> != lc )\n    {\n      <span class=\"teal\">Document</span> doc = e.Document;\n \n      <span class=\"teal\">Curve</span> c = lc.Curve;\n \n      <span class=\"teal\">XYZ</span> p = c.get_EndPoint( 0 );\n      <span class=\"teal\">XYZ</span> q = c.get_EndPoint( 1 );\n \n      AddElementsIntersectingSphereAt(\n        neighbours, p, visited, doc );\n \n      AddElementsIntersectingSphereAt(\n        neighbours, q, visited, doc );\n    }\n  }\n</pre>\n<p>The lists of neighbours and visited elements are implemented as collections of ElementId instead of Element instances, since I do not trust the .NET comparison methods to work properly on Elements. \nAlso, this aligns nicely with the Exclude method on the filtered element collector, which takes a collection of element ids as an argument.\n\n<p>I initially tried calling Exclude twice with separate calls for the lists of already visited elements and neighbours, both of which should be eliminated. \nIn the first call, though, the list of neighbours is always empty. Providing an empty list to the Exclude method throws an exception. \nI could have called the Exclude method conditionally, checking first that the list of neighbours is non-empty. \nHowever, I found it more succinct to combine the two lists into a single one for the call.\n\n<p>With the AddConnectedElements method in place, the algorithm described above translates to the following C# implementation of the external command Execute mainline method:\n\n<pre class=\"code\">\n<span class=\"blue\">public</span> <span class=\"teal\">Result</span> Execute(\n  <span class=\"teal\">ExternalCommandData</span> commandData,\n  <span class=\"blue\">ref</span> <span class=\"blue\">string</span> message,\n  <span class=\"teal\">ElementSet</span> elements )\n{\n  <span class=\"teal\">UIApplication</span> uiapp = commandData.Application;\n  <span class=\"teal\">UIDocument</span> uidoc = uiapp.ActiveUIDocument;\n  <span class=\"teal\">Application</span> app = uiapp.Application;\n  <span class=\"teal\">CreationApp</span> creapp = app.Create;\n  <span class=\"teal\">Document</span> doc = uidoc.Document;\n  <span class=\"teal\">Selection</span> sel = uidoc.Selection;\n  <span class=\"teal\">Reference</span> r = <span class=\"blue\">null</span>;\n \n  <span class=\"blue\">try</span>\n  {\n    r = sel.PickObject(\n      <span class=\"teal\">ObjectType</span>.Element,\n      <span class=\"maroon\">\"Please select a beam\"</span> );\n  }\n  <span class=\"blue\">catch</span>( <span class=\"teal\">RvtOperationCanceledException</span> )\n  {\n    <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Cancelled;\n  }\n \n  <span class=\"green\">// Starting element</span>\n \n  <span class=\"teal\">Element</span> start = doc.GetElement( r );\n \n  <span class=\"green\">// The current elements whose neighbours </span>\n  <span class=\"green\">// we are seeking</span>\n \n  <span class=\"teal\">List</span>&lt;<span class=\"teal\">ElementId</span>&gt; current = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">ElementId</span>&gt;();\n \n  current.Add( start.Id );\n \n  <span class=\"green\">// List of elements already visited</span>\n \n  <span class=\"teal\">List</span>&lt;<span class=\"teal\">ElementId</span>&gt; visited = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">ElementId</span>&gt;();\n \n  <span class=\"green\">// Continue as long as new connected </span>\n  <span class=\"green\">// elements are found</span>\n \n  <span class=\"teal\">List</span>&lt;<span class=\"teal\">ElementId</span>&gt; neighbours = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">ElementId</span>&gt;();\n \n  <span class=\"blue\">while</span>( 0 &lt; current.Count )\n  {\n    <span class=\"green\">// Remember where we have been, add this to </span>\n    <span class=\"green\">// the result so far, and do not revisit these</span>\n \n    visited.AddRange( current );\n \n    <span class=\"green\">// We found no new neighbours yet</span>\n \n    neighbours.Clear();\n \n    <span class=\"green\">// Search current elements for new connected </span>\n    <span class=\"green\">// elements not already visited</span>\n \n    <span class=\"blue\">foreach</span>( <span class=\"teal\">ElementId</span> id <span class=\"blue\">in</span> current )\n    {\n      <span class=\"teal\">Element</span> e = doc.GetElement( id );\n \n      AddConnectedElements(\n        neighbours, e, visited );\n    }\n \n    <span class=\"green\">// Done with the current elements, and the</span>\n    <span class=\"green\">// newly found become the next current ones</span>\n \n    current.Clear();\n    current.AddRange( neighbours );\n  }\n \n  <span class=\"blue\">foreach</span>( <span class=\"teal\">ElementId</span> id <span class=\"blue\">in</span> visited )\n  {\n    uidoc.Selection.Elements.Add(\n      doc.GetElement( id ) );\n  }\n  <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Succeeded;\n}\n</pre>\n<p>Pretty neat, huh?\n\n<p>And pretty readable, I think?\n\n<p>Here is a sample model with several sets of touching but not officially connected beams: two sets of two beams each on the right-hand side of the room in the middle, and a bunch of more beams all touching along the left, top and bottom. Some of them are longer than others and stretch across several columns:</p>\n<center>\n<img alt=\"System of non-connected but touching beams\" src=\"img/touching_beams_3.png\"/>\n</center>\n<p>After running the command and picking any single one of the beams on the left, the connected elements are all selected and therefore highlighted in blue, whereas the unconnected ones on the right remain unhighlighted:</p>\n<center>\n<img alt=\"Touching beams detected and selected\" src=\"img/touching_beams_4.png\"/>\n</center>\n<p>Note that this approach is useful for any curve based element, so it could also be adapted to find all touching walls, ducts, pipes, and many other object types.\n\n<p>Here is \n\n<a href=\"zip/SelectTouchingBeams.zip\">SelectTouchingBeams.zip</a> containing\n\nthe source code, Visual Studio solution and add-in manifest of the 'Select Touching Beams' command.\nIt also includes the \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2012/09/sphere-creation-for-avf-and-filtering.html#4\">\nDisplay Sphere</a> command that I discussed in the previous post.\n</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p>"
  }
]