[
  {
    "original_filename": "1140_fill_pattern_benchmark",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<head>\n<link href=\"bc.css\" rel=\"stylesheet\" type=\"text/css\"/>\n<meta content=\"text/html; charset=utf-8\" http-equiv=\"Content-Type\"/>\n</head>"
  },
  {
    "original_filename": "1140_fill_pattern_benchmark",
    "header_text": "WPF Fill Pattern Viewer Control Benchmark",
    "local_header_href": "#wpf-fill-pattern-viewer-control-benchmark",
    "chunk_text": "<h3>WPF Fill Pattern Viewer Control Benchmark</h3><p>I recently presented\n\n<a href=\"http://www.facebook.com/profile.php?id=100003616852588\">Victor Chekalin</a>'s\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2014/04/wpf-fill-pattern-viewer-control.html\">WPF control for viewing Revit fill patterns</a>.\n\n<p>In his\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2014/04/wpf-fill-pattern-viewer-control.html#comment-6a00e553e16897883301a5119e101d970c\">\ncomment</a>,\n\nVictor already mentioned some worries about performance of this control and his intention to create a simple benchmark to monitor it.</p>\n<p>Well, here it is.</p>\n<p>At the same time, I also took the opportunity to migrate the fill pattern control to Revit 2015.</p>\n<a name=\"2\"></a>\n<h4>Migrate the Fill Pattern Viewer Control to Revit 2015</h4>\n<p>The migration to the Revit 2015 API was extremely straightforward, just like the previous add-ins I performed it for, e.g.:</p>\n<ul>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2014/04/revitlookup-for-revit-2015.html\">RevitLookup for Revit 2015</a></li>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2014/04/compiling-the-revit-2015-sdk-and-migrating-bc-samples.html\">Compiling the Revit 2015 SDK and Migrating The Building Coder Samples</a></li>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2014/04/migrating-roomeditorapp-to-revit-2015.html\">Migrating RoomEditorApp to Revit 2015</a></li>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2014/04/revitlookup-for-ur1-adn-aec-and-au-news.html\">RevitLookup for Revit 2015 UR1</a></li>\n</ul>\n<p>The source code, Visual Studio solution and add-in manifest of the complete AddMaterials add-in including the fill pattern viewer WPF control is provided in the\n\n<a href=\"https://github.com/jeremytammik/AddMaterials\">AddMaterials GitHub repository</a>,\n\nand the initial migration to the Revit 2015 API is captured in\n\n<a href=\"https://github.com/jeremytammik/AddMaterials/releases/tag/2015.0.0.2\">\nrelease 2015.0.0.2</a>.</p>\n<a name=\"3\"></a>\n<h4>Fill Pattern Viewer Control Benchmark</h4>\n<p>In Victor's own words:</p>\n<blockquote>\n<p>I was interested about benchmark and created it:)</p>\n<p>I created the new command 'AddMaterials - Fill Pattern benchmark' and added it to the AddMaterials Add-In.</p>\n<p>As it turned out, the most complex pattern is 'Concrete'. To create the graphics for it took more that one second.</p>\n</blockquote>\n<p>Displaying any other fill pattern in this control requires only about 10 milliseconds.</p>\n<p>The benchmark implementation is accomplished in a new external command, FillPatternBenchmarkCommand, which retrieves all fill patterns from the model and displays them in a form:</p>\n<pre class=\"code\">\n  [<span class=\"teal\">Transaction</span>( <span class=\"teal\">TransactionMode</span>.ReadOnly )]\n  <span class=\"blue\">public</span> <span class=\"blue\">class</span> <span class=\"teal\">FillPatternBenchmarkCommand</span>\n    : <span class=\"teal\">IExternalCommand</span>\n  {\n    <span class=\"blue\">public</span> <span class=\"teal\">Result</span> Execute(\n      <span class=\"teal\">ExternalCommandData</span> commandData,\n      <span class=\"blue\">ref</span> <span class=\"blue\">string</span> message,\n      <span class=\"teal\">ElementSet</span> elements )\n    {\n      <span class=\"blue\">var</span> doc = commandData.Application\n        .ActiveUIDocument.Document;\n \n      <span class=\"blue\">var</span> fillPatternElements\n        = <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( doc )\n          .OfClass( <span class=\"blue\">typeof</span>( <span class=\"teal\">FillPatternElement</span> ) )\n          .OfType&lt;<span class=\"teal\">FillPatternElement</span>&gt;()\n          .OrderBy( fp =&gt; fp.Name )\n          .ToList();\n \n      <span class=\"blue\">var</span> fillPatterns\n        = fillPatternElements.Select(\n          fpe =&gt; fpe.GetFillPattern() );\n \n      <span class=\"teal\">FillPatternsViewModel</span> fillPatternsViewModel\n        = <span class=\"blue\">new</span> <span class=\"teal\">FillPatternsViewModel</span>( fillPatterns\n          .Select( x =&gt; <span class=\"blue\">new</span> <span class=\"teal\">FillPatternViewModel</span>(\n            x ) ) );\n \n      <span class=\"teal\">FillPatternsView</span> fillPatternsView\n        = <span class=\"blue\">new</span> <span class=\"teal\">FillPatternsView</span>()\n      {\n        DataContext = fillPatternsViewModel\n      };\n \n      fillPatternsView.ShowDialog();\n \n      <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Succeeded;\n    }\n  }\n</pre>\n<p>The form requires two new ViewModel modules to view a simple fill pattern, a list of all fill patterns, and present that list in a WPF form.</p>\n<p>The actual benchmarking is performed by adding a couple of lines to the existing FillPatternViewerControlWpf.xaml.cs module.</p>\n<p>The new code instantiates a stopwatch.</p>\n<p>In debug mode only, the stopwatch elapsed time in milliseconds is displayed in red on top of the fill pattern:</p>\n<pre class=\"code\">\n  <span class=\"blue\">private</span> <span class=\"blue\">void</span> DrawFillPattern( <span class=\"teal\">Graphics</span> g )\n  {\n    <span class=\"teal\">Stopwatch</span> sw = <span class=\"teal\">Stopwatch</span>.StartNew();\n \n    <span class=\"blue\">float</span> matrixScale;\n \n    <span class=\"blue\">var</span> fillPattern = FillPattern;\n \n    <span class=\"blue\">if</span>( fillPattern == <span class=\"blue\">null</span> )\n      <span class=\"blue\">return</span>;\n \n    <span class=\"blue\">if</span>( fillPattern.Target == <span class=\"teal\">FillPatternTarget</span>.Model )\n      matrixScale = Scale;\n    <span class=\"blue\">else</span>\n      matrixScale = Scale * 10;\n \n    <span class=\"blue\">try</span>\n    {\n      <span class=\"blue\">var</span> width =\n      ( ActualWidth == 0 ? Width : ActualWidth ) == 0\n        ? 100\n        : ( ActualWidth == 0 ? Width : ActualWidth );\n \n      <span class=\"blue\">if</span>( <span class=\"blue\">double</span>.IsNaN( width ) )\n        width = 100;\n \n      <span class=\"blue\">var</span> height =\n          ( ActualHeight == 0 ? Height : ActualHeight ) == 0\n            ? 30\n            : ( ActualHeight == 0 ? Height : ActualHeight );\n \n      <span class=\"blue\">if</span>( <span class=\"blue\">double</span>.IsNaN( height ) )\n        height = 30;\n \n      <span class=\"blue\">var</span> rect = <span class=\"blue\">new</span> <span class=\"teal\">Rectangle</span>( 0, 0,\n        (<span class=\"blue\">int</span>) width, (<span class=\"blue\">int</span>) height );\n \n      <span class=\"blue\">var</span> centerX = ( rect.Left + rect.Left\n        + rect.Width ) / 2;\n \n      <span class=\"blue\">var</span> centerY = ( rect.Top + rect.Top\n        + rect.Height ) / 2;\n \n      g.TranslateTransform( centerX, centerY );\n \n      <span class=\"blue\">var</span> rectF = <span class=\"blue\">new</span> <span class=\"teal\">Rectangle</span>( -1, -1, 2, 2 );\n \n      g.FillRectangle( <span class=\"teal\">Brushes</span>.Blue, rectF );\n \n      g.ResetTransform();\n \n      <span class=\"blue\">var</span> fillGrids = fillPattern.GetFillGrids();\n \n      <span class=\"teal\">Debug</span>.Print( <span class=\"maroon\">\"FilPattern name: {0}\"</span>,\n        fillPattern.Name );\n \n      <span class=\"teal\">Debug</span>.Print( <span class=\"maroon\">\"Grids count: {0}\"</span>,\n        fillGrids.Count );\n \n      <span class=\"blue\">foreach</span>( <span class=\"blue\">var</span> fillGrid <span class=\"blue\">in</span> fillGrids )\n      {\n        <span class=\"blue\">var</span> degreeAngle = (<span class=\"blue\">float</span>) RadianToGradus(\n          fillGrid.Angle );\n \n        <span class=\"teal\">Debug</span>.Print( <span class=\"blue\">new</span> <span class=\"blue\">string</span>( <span class=\"maroon\">'-'</span>, 100 ) );\n \n        <span class=\"teal\">Debug</span>.Print( <span class=\"maroon\">\"\\tOrigin: U: {0} V:{1}\"</span>,\n          fillGrid.Origin.U, fillGrid.Origin.V );\n \n        <span class=\"teal\">Debug</span>.Print( <span class=\"maroon\">\"\\tOffset: {0}\"</span>, fillGrid.Offset );\n        <span class=\"teal\">Debug</span>.Print( <span class=\"maroon\">\"\\tAngle: {0}\"</span>, degreeAngle );\n        <span class=\"teal\">Debug</span>.Print( <span class=\"maroon\">\"\\tShift: {0}\"</span>, fillGrid.Shift );\n \n        <span class=\"blue\">var</span> pen = <span class=\"blue\">new</span> <span class=\"teal\">Pen</span>( System.Drawing.<span class=\"teal\">Color</span>.Black )\n        {\n          Width = 1f / matrixScale\n        };\n \n        <span class=\"blue\">float</span> dashLength = 1;\n \n        <span class=\"blue\">var</span> segments = fillGrid.GetSegments();\n \n        <span class=\"blue\">if</span>( segments.Count &gt; 0 )\n        {\n          pen.DashPattern = segments\n              .Select( <span class=\"teal\">Convert</span>.ToSingle )\n              .ToArray();\n \n          <span class=\"teal\">Debug</span>.Print( <span class=\"maroon\">\"\\tSegments:\"</span> );\n \n          <span class=\"blue\">foreach</span>( <span class=\"blue\">var</span> segment <span class=\"blue\">in</span> segments )\n          {\n            <span class=\"teal\">Debug</span>.Print( <span class=\"maroon\">\"\\t\\t{0}\"</span>, segment );\n          }\n \n          dashLength = pen.DashPattern.Sum();\n        }\n \n        g.ResetTransform();\n \n        <span class=\"blue\">var</span> rotateMatrix = <span class=\"blue\">new</span> <span class=\"teal\">Matrix</span>();\n        rotateMatrix.Rotate( degreeAngle );\n \n        <span class=\"blue\">var</span> matrix = <span class=\"blue\">new</span> <span class=\"teal\">Matrix</span>( 1, 0, 0, -1,\n          centerX, centerY );\n \n        matrix.Scale( matrixScale, matrixScale );\n \n        matrix.Translate( (<span class=\"blue\">float</span>) fillGrid.Origin.U,\n          (<span class=\"blue\">float</span>) fillGrid.Origin.V );\n \n        <span class=\"blue\">var</span> backMatrix = matrix.Clone();\n        backMatrix.Multiply( rotateMatrix );\n        matrix.Multiply( rotateMatrix );\n \n        <span class=\"blue\">bool</span> first = <span class=\"blue\">true</span>;\n        <span class=\"blue\">for</span>( <span class=\"blue\">int</span> i = 20; i &gt; 0; i-- )\n        {\n          <span class=\"blue\">if</span>( !first )\n          {\n            matrix.Translate( (<span class=\"blue\">float</span>) fillGrid.Shift,\n              (<span class=\"blue\">float</span>) fillGrid.Offset );\n \n            backMatrix.Translate( (<span class=\"blue\">float</span>) fillGrid.Shift,\n              -(<span class=\"blue\">float</span>) fillGrid.Offset );\n          }\n          <span class=\"blue\">else</span>\n          {\n            first = <span class=\"blue\">false</span>;\n          }\n \n          <span class=\"blue\">var</span> offset = ( -10 ) * dashLength;\n          matrix.Translate( offset, 0 );\n          backMatrix.Translate( offset, 0 );\n \n          g.Transform = matrix;\n \n          g.DrawLine( pen, <span class=\"blue\">new</span> <span class=\"teal\">PointF</span>( 0, 0 ),\n            <span class=\"blue\">new</span> <span class=\"teal\">PointF</span>( 200, 0 ) );\n \n          g.Transform = backMatrix;\n \n          g.DrawLine( pen, <span class=\"blue\">new</span> <span class=\"teal\">PointF</span>( 0, 0 ),\n            <span class=\"blue\">new</span> <span class=\"teal\">PointF</span>( 200, 0 ) );\n        }\n      }\n \n      sw.Stop();\n      g.ResetTransform();\n \n<span class=\"blue\">#if</span> DEBUG\n      g.DrawString( <span class=\"blue\">string</span>.Format( <span class=\"maroon\">\"{0} ms\"</span>,\n        sw.ElapsedMilliseconds),\n        System.Drawing.<span class=\"teal\">SystemFonts</span>.DefaultFont,\n        <span class=\"teal\">Brushes</span>.Red, 0, 0);\n<span class=\"blue\">#endif</span>\n \n    }\n    <span class=\"blue\">catch</span>( <span class=\"teal\">Exception</span> ex )\n    {\n      <span class=\"teal\">Debug</span>.Print( ex.Message );\n    }\n  }\n</pre>\n<p>The result of running the benchmark command in Revit 2015 looks like this:</p>\n<center>\n<img alt=\"AddMaterial fill pattern viewer benchmark\" src=\"img/fill_pattern_viewer_benchmark.png\" width=\"238\"/>\n</center>\n<p>The benchmarking code is added to the\n\n<a href=\"https://github.com/jeremytammik/AddMaterials\">AddMaterials GitHub repository</a> and\n\ncaptured in\n\n<a href=\"https://github.com/jeremytammik/AddMaterials/releases/tag/2015.0.0.3\">\nrelease 2015.0.0.3</a>.</p>\n<p>Many thanks to Victor for the initial implementation and again for this benchmark implementation!</p>\n</p>"
  },
  {
    "original_filename": "1140_fill_pattern_benchmark",
    "header_text": "Migrate the Fill Pattern Viewer Control to Revit 2015",
    "local_header_href": "#migrate-the-fill-pattern-viewer-control-to-revit-2015",
    "chunk_text": "<h4>Migrate the Fill Pattern Viewer Control to Revit 2015</h4><p>The migration to the Revit 2015 API was extremely straightforward, just like the previous add-ins I performed it for, e.g.:</p><ul>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2014/04/revitlookup-for-revit-2015.html\">RevitLookup for Revit 2015</a></li>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2014/04/compiling-the-revit-2015-sdk-and-migrating-bc-samples.html\">Compiling the Revit 2015 SDK and Migrating The Building Coder Samples</a></li>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2014/04/migrating-roomeditorapp-to-revit-2015.html\">Migrating RoomEditorApp to Revit 2015</a></li>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2014/04/revitlookup-for-ur1-adn-aec-and-au-news.html\">RevitLookup for Revit 2015 UR1</a></li>\n</ul><p>The source code, Visual Studio solution and add-in manifest of the complete AddMaterials add-in including the fill pattern viewer WPF control is provided in the\n\n<a href=\"https://github.com/jeremytammik/AddMaterials\">AddMaterials GitHub repository</a>,\n\nand the initial migration to the Revit 2015 API is captured in\n\n<a href=\"https://github.com/jeremytammik/AddMaterials/releases/tag/2015.0.0.2\">\nrelease 2015.0.0.2</a>.</p><a name=\"3\"></a>"
  },
  {
    "original_filename": "1140_fill_pattern_benchmark",
    "header_text": "Fill Pattern Viewer Control Benchmark",
    "local_header_href": "#fill-pattern-viewer-control-benchmark",
    "chunk_text": "<h4>Fill Pattern Viewer Control Benchmark</h4><p>In Victor's own words:</p><blockquote>\n<p>I was interested about benchmark and created it:)</p>\n<p>I created the new command 'AddMaterials - Fill Pattern benchmark' and added it to the AddMaterials Add-In.</p>\n<p>As it turned out, the most complex pattern is 'Concrete'. To create the graphics for it took more that one second.</p>\n</blockquote><p>Displaying any other fill pattern in this control requires only about 10 milliseconds.</p><p>The benchmark implementation is accomplished in a new external command, FillPatternBenchmarkCommand, which retrieves all fill patterns from the model and displays them in a form:</p><pre class=\"code\">\n  [<span class=\"teal\">Transaction</span>( <span class=\"teal\">TransactionMode</span>.ReadOnly )]\n  <span class=\"blue\">public</span> <span class=\"blue\">class</span> <span class=\"teal\">FillPatternBenchmarkCommand</span>\n    : <span class=\"teal\">IExternalCommand</span>\n  {\n    <span class=\"blue\">public</span> <span class=\"teal\">Result</span> Execute(\n      <span class=\"teal\">ExternalCommandData</span> commandData,\n      <span class=\"blue\">ref</span> <span class=\"blue\">string</span> message,\n      <span class=\"teal\">ElementSet</span> elements )\n    {\n      <span class=\"blue\">var</span> doc = commandData.Application\n        .ActiveUIDocument.Document;\n \n      <span class=\"blue\">var</span> fillPatternElements\n        = <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( doc )\n          .OfClass( <span class=\"blue\">typeof</span>( <span class=\"teal\">FillPatternElement</span> ) )\n          .OfType&lt;<span class=\"teal\">FillPatternElement</span>&gt;()\n          .OrderBy( fp =&gt; fp.Name )\n          .ToList();\n \n      <span class=\"blue\">var</span> fillPatterns\n        = fillPatternElements.Select(\n          fpe =&gt; fpe.GetFillPattern() );\n \n      <span class=\"teal\">FillPatternsViewModel</span> fillPatternsViewModel\n        = <span class=\"blue\">new</span> <span class=\"teal\">FillPatternsViewModel</span>( fillPatterns\n          .Select( x =&gt; <span class=\"blue\">new</span> <span class=\"teal\">FillPatternViewModel</span>(\n            x ) ) );\n \n      <span class=\"teal\">FillPatternsView</span> fillPatternsView\n        = <span class=\"blue\">new</span> <span class=\"teal\">FillPatternsView</span>()\n      {\n        DataContext = fillPatternsViewModel\n      };\n \n      fillPatternsView.ShowDialog();\n \n      <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Succeeded;\n    }\n  }\n</pre><p>The form requires two new ViewModel modules to view a simple fill pattern, a list of all fill patterns, and present that list in a WPF form.</p><p>The actual benchmarking is performed by adding a couple of lines to the existing FillPatternViewerControlWpf.xaml.cs module.</p><p>The new code instantiates a stopwatch.</p><p>In debug mode only, the stopwatch elapsed time in milliseconds is displayed in red on top of the fill pattern:</p><pre class=\"code\">\n  <span class=\"blue\">private</span> <span class=\"blue\">void</span> DrawFillPattern( <span class=\"teal\">Graphics</span> g )\n  {\n    <span class=\"teal\">Stopwatch</span> sw = <span class=\"teal\">Stopwatch</span>.StartNew();\n \n    <span class=\"blue\">float</span> matrixScale;\n \n    <span class=\"blue\">var</span> fillPattern = FillPattern;\n \n    <span class=\"blue\">if</span>( fillPattern == <span class=\"blue\">null</span> )\n      <span class=\"blue\">return</span>;\n \n    <span class=\"blue\">if</span>( fillPattern.Target == <span class=\"teal\">FillPatternTarget</span>.Model )\n      matrixScale = Scale;\n    <span class=\"blue\">else</span>\n      matrixScale = Scale * 10;\n \n    <span class=\"blue\">try</span>\n    {\n      <span class=\"blue\">var</span> width =\n      ( ActualWidth == 0 ? Width : ActualWidth ) == 0\n        ? 100\n        : ( ActualWidth == 0 ? Width : ActualWidth );\n \n      <span class=\"blue\">if</span>( <span class=\"blue\">double</span>.IsNaN( width ) )\n        width = 100;\n \n      <span class=\"blue\">var</span> height =\n          ( ActualHeight == 0 ? Height : ActualHeight ) == 0\n            ? 30\n            : ( ActualHeight == 0 ? Height : ActualHeight );\n \n      <span class=\"blue\">if</span>( <span class=\"blue\">double</span>.IsNaN( height ) )\n        height = 30;\n \n      <span class=\"blue\">var</span> rect = <span class=\"blue\">new</span> <span class=\"teal\">Rectangle</span>( 0, 0,\n        (<span class=\"blue\">int</span>) width, (<span class=\"blue\">int</span>) height );\n \n      <span class=\"blue\">var</span> centerX = ( rect.Left + rect.Left\n        + rect.Width ) / 2;\n \n      <span class=\"blue\">var</span> centerY = ( rect.Top + rect.Top\n        + rect.Height ) / 2;\n \n      g.TranslateTransform( centerX, centerY );\n \n      <span class=\"blue\">var</span> rectF = <span class=\"blue\">new</span> <span class=\"teal\">Rectangle</span>( -1, -1, 2, 2 );\n \n      g.FillRectangle( <span class=\"teal\">Brushes</span>.Blue, rectF );\n \n      g.ResetTransform();\n \n      <span class=\"blue\">var</span> fillGrids = fillPattern.GetFillGrids();\n \n      <span class=\"teal\">Debug</span>.Print( <span class=\"maroon\">\"FilPattern name: {0}\"</span>,\n        fillPattern.Name );\n \n      <span class=\"teal\">Debug</span>.Print( <span class=\"maroon\">\"Grids count: {0}\"</span>,\n        fillGrids.Count );\n \n      <span class=\"blue\">foreach</span>( <span class=\"blue\">var</span> fillGrid <span class=\"blue\">in</span> fillGrids )\n      {\n        <span class=\"blue\">var</span> degreeAngle = (<span class=\"blue\">float</span>) RadianToGradus(\n          fillGrid.Angle );\n \n        <span class=\"teal\">Debug</span>.Print( <span class=\"blue\">new</span> <span class=\"blue\">string</span>( <span class=\"maroon\">'-'</span>, 100 ) );\n \n        <span class=\"teal\">Debug</span>.Print( <span class=\"maroon\">\"\\tOrigin: U: {0} V:{1}\"</span>,\n          fillGrid.Origin.U, fillGrid.Origin.V );\n \n        <span class=\"teal\">Debug</span>.Print( <span class=\"maroon\">\"\\tOffset: {0}\"</span>, fillGrid.Offset );\n        <span class=\"teal\">Debug</span>.Print( <span class=\"maroon\">\"\\tAngle: {0}\"</span>, degreeAngle );\n        <span class=\"teal\">Debug</span>.Print( <span class=\"maroon\">\"\\tShift: {0}\"</span>, fillGrid.Shift );\n \n        <span class=\"blue\">var</span> pen = <span class=\"blue\">new</span> <span class=\"teal\">Pen</span>( System.Drawing.<span class=\"teal\">Color</span>.Black )\n        {\n          Width = 1f / matrixScale\n        };\n \n        <span class=\"blue\">float</span> dashLength = 1;\n \n        <span class=\"blue\">var</span> segments = fillGrid.GetSegments();\n \n        <span class=\"blue\">if</span>( segments.Count &gt; 0 )\n        {\n          pen.DashPattern = segments\n              .Select( <span class=\"teal\">Convert</span>.ToSingle )\n              .ToArray();\n \n          <span class=\"teal\">Debug</span>.Print( <span class=\"maroon\">\"\\tSegments:\"</span> );\n \n          <span class=\"blue\">foreach</span>( <span class=\"blue\">var</span> segment <span class=\"blue\">in</span> segments )\n          {\n            <span class=\"teal\">Debug</span>.Print( <span class=\"maroon\">\"\\t\\t{0}\"</span>, segment );\n          }\n \n          dashLength = pen.DashPattern.Sum();\n        }\n \n        g.ResetTransform();\n \n        <span class=\"blue\">var</span> rotateMatrix = <span class=\"blue\">new</span> <span class=\"teal\">Matrix</span>();\n        rotateMatrix.Rotate( degreeAngle );\n \n        <span class=\"blue\">var</span> matrix = <span class=\"blue\">new</span> <span class=\"teal\">Matrix</span>( 1, 0, 0, -1,\n          centerX, centerY );\n \n        matrix.Scale( matrixScale, matrixScale );\n \n        matrix.Translate( (<span class=\"blue\">float</span>) fillGrid.Origin.U,\n          (<span class=\"blue\">float</span>) fillGrid.Origin.V );\n \n        <span class=\"blue\">var</span> backMatrix = matrix.Clone();\n        backMatrix.Multiply( rotateMatrix );\n        matrix.Multiply( rotateMatrix );\n \n        <span class=\"blue\">bool</span> first = <span class=\"blue\">true</span>;\n        <span class=\"blue\">for</span>( <span class=\"blue\">int</span> i = 20; i &gt; 0; i-- )\n        {\n          <span class=\"blue\">if</span>( !first )\n          {\n            matrix.Translate( (<span class=\"blue\">float</span>) fillGrid.Shift,\n              (<span class=\"blue\">float</span>) fillGrid.Offset );\n \n            backMatrix.Translate( (<span class=\"blue\">float</span>) fillGrid.Shift,\n              -(<span class=\"blue\">float</span>) fillGrid.Offset );\n          }\n          <span class=\"blue\">else</span>\n          {\n            first = <span class=\"blue\">false</span>;\n          }\n \n          <span class=\"blue\">var</span> offset = ( -10 ) * dashLength;\n          matrix.Translate( offset, 0 );\n          backMatrix.Translate( offset, 0 );\n \n          g.Transform = matrix;\n \n          g.DrawLine( pen, <span class=\"blue\">new</span> <span class=\"teal\">PointF</span>( 0, 0 ),\n            <span class=\"blue\">new</span> <span class=\"teal\">PointF</span>( 200, 0 ) );\n \n          g.Transform = backMatrix;\n \n          g.DrawLine( pen, <span class=\"blue\">new</span> <span class=\"teal\">PointF</span>( 0, 0 ),\n            <span class=\"blue\">new</span> <span class=\"teal\">PointF</span>( 200, 0 ) );\n        }\n      }\n \n      sw.Stop();\n      g.ResetTransform();\n \n<span class=\"blue\">#if</span> DEBUG\n      g.DrawString( <span class=\"blue\">string</span>.Format( <span class=\"maroon\">\"{0} ms\"</span>,\n        sw.ElapsedMilliseconds),\n        System.Drawing.<span class=\"teal\">SystemFonts</span>.DefaultFont,\n        <span class=\"teal\">Brushes</span>.Red, 0, 0);\n<span class=\"blue\">#endif</span>\n \n    }\n    <span class=\"blue\">catch</span>( <span class=\"teal\">Exception</span> ex )\n    {\n      <span class=\"teal\">Debug</span>.Print( ex.Message );\n    }\n  }\n</pre><p>The result of running the benchmark command in Revit 2015 looks like this:</p><center>\n<img alt=\"AddMaterial fill pattern viewer benchmark\" src=\"img/fill_pattern_viewer_benchmark.png\" width=\"238\"/>\n</center><p>The benchmarking code is added to the\n\n<a href=\"https://github.com/jeremytammik/AddMaterials\">AddMaterials GitHub repository</a> and\n\ncaptured in\n\n<a href=\"https://github.com/jeremytammik/AddMaterials/releases/tag/2015.0.0.3\">\nrelease 2015.0.0.3</a>.</p><p>Many thanks to Victor for the initial implementation and again for this benchmark implementation!</p>"
  }
]