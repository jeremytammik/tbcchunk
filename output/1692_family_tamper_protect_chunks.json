[
  {
    "original_filename": "1692_family_tamper_protect",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n<link rel=\"stylesheet\" type=\"text/css\" href=\"bc.css\">\n<script src=\"https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js\" type=\"text/javascript\"></script>\n</head>\n\n<!---\n\nProtecting a family from tampering and implementing a canonical key for geometrical objects in the #RevitAPI @AutodeskForge @AutodeskRevit #bim #DynamoBim #ForgeDevCon http://bit.ly/familytampering\n\nThe Forge accelerator in Rome is winding down with the demonstrations of what was achieved being recorded as I write.\nAn interesting conversation I had at the celebratory dinner last night gave me an idea for a solution to a longstanding question on family tampering protection\n&ndash; Roma accelerator group photo\n&ndash; Protecting a family from tampering\n&ndash; Implementing a canonical key for geometrical objects...\n\n-->"
  },
  {
    "original_filename": "1692_family_tamper_protect",
    "header_text": "Protecting a Family from Tampering",
    "local_header_href": "#protecting-a-family-from-tampering",
    "chunk_text": "### Protecting a Family from Tampering\n\nThe [Forge](https://autodesk-forge.github.io)\n[accelerator in Rome](http://autodeskcloudaccelerator.com)  is\nwinding down with the demonstrations of what was achieved being recorded as I write.\n\nAn interesting conversation I had at the celebratory dinner last night gave me an idea for a solution to a longstanding question on family tampering protection:\n\n- [Roma accelerator group photo](#2) \n- [Protecting a family from tampering](#3) \n- [Implementing a canonical key for geometrical objects](#4)"
  },
  {
    "original_filename": "1692_family_tamper_protect",
    "header_text": "<a name=\"2\"></a> Roma Accelerator Group Photo",
    "local_header_href": "#a-name2a-roma-accelerator-group-photo",
    "chunk_text": "#### <a name=\"2\"></a> Roma Accelerator Group Photo\n\nI missed the Roma Accelerator group photo by a few seconds:\n\n<center>\n<img src=\"img/accelerator_roma_participants_400x300.jpg\" alt=\"Roma accelerator participants lacking Jeremy\" width=\"400\">\n</center>\n\nIn what certainly must be one of the worst photoshop jobs ever, Jaime very kindly added me to it afterwards:\n\n<center>\n<img src=\"img/accelerator_roma_participants_plus_jeremy_400.jpg\" alt=\"Roma accelerator participants plus Jeremy\" width=\"400\">\n</center>\n\nThank you for that, Jaime! &nbsp; Keep practicing..."
  },
  {
    "original_filename": "1692_family_tamper_protect",
    "header_text": "<a name=\"3\"></a> Protecting a Family from Tampering",
    "local_header_href": "#a-name3a-protecting-a-family-from-tampering",
    "chunk_text": "#### <a name=\"3\"></a> Protecting a Family from Tampering\n\nHere are two different aspects of protecting Revit families:\n\n- Copy protection, to stop the competition from stealing them and the [IP or intellectual property](https://en.wikipedia.org/wiki/Intellectual_property) they contain.\n- Tampering protection, to stop the customer from corrupting her own models, intentionally or not.\n\nOften discussed, various solutions suggested.\n\nFor example, we discussed one example of a copy protection solution  \nby [simplifying nested family instances](http://thebuildingcoder.typepad.com/blog/2018/06/simplifying-nested-family-instances.html) to\nprotect the intellectual property built into a complex hierarchy of nested family instances by replacing them with a flatter and simpler hierarchy, yet retaining all the relevant non-confidential custom data.\n\nHere is an AUGI discussion from 2009 on the pros and cons\nof [protecting Revit families](http://forums.augi.com/showthread.php?73233-Protecting-Revit-Families).\n\nToday, I make a suggestion to protect from tampering, nothing totally safe yet afaik.\n\nYou want a fool-proof method to protect your family definitions from tampering?\n\nYou can encode a secret hash code or something and hide it somewhere.\n\nFor brevity, let's call this secret hash code your <u>key</u>.\n\nHowever, the tamperer might just retain it, either intentionally or not.\n\nHow can you still detect tampering?\n\nWell, you can easily encode bits and pieces of whatever she might want to tamper with into you key as well.\n\nEspecially, you should ensure that you generate a hash key or something that includes references to every single bit of data that is relevant for you.\n\nIf you have an algorithm to rebuild your key at will from the current state of the family, you can check the following:\n\n- Does the original key exist? If not, alarm.\n- Recompute the current key from the current state of the family. does it match the stored key? If not, alarm.\n\n[Creating your own key](http://thebuildingcoder.typepad.com/blog/2012/03/great-ocean-road-and-creating-your-own-key.html#2) can\nbe useful in numerous ways, so I already discussed this topic and suggested doing so back in 2012.\n\nTherefore, I hope that all the families that you care about are already adequately protected against tampering.\n\nIf not, go ahead and do so now."
  },
  {
    "original_filename": "1692_family_tamper_protect",
    "header_text": "<a name=\"4\"></a> Implementing a Canonical Key for Geometrical Objects",
    "local_header_href": "#a-name4a-implementing-a-canonical-key-for-geometrical-objects",
    "chunk_text": "#### <a name=\"4\"></a> Implementing a Canonical Key for Geometrical Objects\n\nTo further illustrate what I mean by the key I mentioned above, let's illustrate how to generate a checksum or hash code from geometry, preferably using\na [canonical form](https://en.wikipedia.org/wiki/Canonical_form).\n\nLet's explore defining a simple canonical form for a point, line (two ordered points), curve, etc.\n\nA very simple and useful way to go is to define your canonical form as a string.\n\nYou can use this string as a dictionary key, if that fits your needs.\n\nYou can also calculate a hash from it, which should ensure that any change in the string will also cause a change in the hash.\n\nTo ensure that this works, you need to create a hash of sufficient length.\n\nIf you care about protection, you might also want to encrypt the hash after you have created it.\n\nHere are some simplistic examples of defining canonical forms for real numbers, points, lines, and curves:\n\n- Real number `a`, using as many decimal places as required to achieve the precision you need:\n\n<pre class=\"code\">\n  <span style=\"color:blue;\">public</span>&nbsp;<span style=\"color:blue;\">static</span>&nbsp;<span style=\"color:blue;\">string</span>&nbsp;RealString(&nbsp;<span style=\"color:blue;\">double</span>&nbsp;a&nbsp;)\n  {\n  &nbsp;&nbsp;<span style=\"color:blue;\">return</span>&nbsp;a.ToString(&nbsp;<span style=\"color:#a31515;\">&quot;0.######&quot;</span>&nbsp;);\n  }\n</pre>\n\n- `XYZ p`:\n\n<pre class=\"code\">\n  <span style=\"color:blue;\">public</span>&nbsp;<span style=\"color:blue;\">static</span>&nbsp;<span style=\"color:blue;\">string</span>&nbsp;PointString(&nbsp;<span style=\"color:#2b91af;\">XYZ</span>&nbsp;p&nbsp;)\n  {\n  &nbsp;&nbsp;<span style=\"color:blue;\">return</span>&nbsp;<span style=\"color:blue;\">string</span>.Format(&nbsp;<span style=\"color:#a31515;\">&quot;({0},{1},{2})&quot;</span>,\n  &nbsp;&nbsp;&nbsp;&nbsp;RealString(&nbsp;p.X&nbsp;),\n  &nbsp;&nbsp;&nbsp;&nbsp;RealString(&nbsp;p.Y&nbsp;),\n  &nbsp;&nbsp;&nbsp;&nbsp;RealString(&nbsp;p.Z&nbsp;)&nbsp;);\n  }\n</pre>\n\n- A sorted array of points:\n\n<pre class=\"code\">\n  <span style=\"color:blue;\">public</span>&nbsp;<span style=\"color:blue;\">static</span>&nbsp;<span style=\"color:blue;\">string</span>&nbsp;PointArrayString(&nbsp;<span style=\"color:#2b91af;\">IList</span>&lt;<span style=\"color:#2b91af;\">XYZ</span>&gt;&nbsp;pts&nbsp;)\n  {\n  &nbsp;&nbsp;<span style=\"color:blue;\">return</span>&nbsp;<span style=\"color:blue;\">string</span>.Join(&nbsp;<span style=\"color:#a31515;\">&quot;,&nbsp;&quot;</span>,\n  &nbsp;&nbsp;&nbsp;&nbsp;pts.Select&lt;<span style=\"color:#2b91af;\">XYZ</span>,&nbsp;<span style=\"color:blue;\">string</span>&gt;(\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p&nbsp;=&gt;&nbsp;PointString(&nbsp;p&nbsp;)&nbsp;)&nbsp;);\n  }\n</pre>\n\n- A bounded line `(p,q)`:\n    - Sort `p` and `q` lexicographically\n    - Return `PointArrayString( [p,q] )`\n- A curve `c`:\n    - Return `PointArrayString( c.Tessellate() )`\n\nMost of these are implemented\nin [The Building Coder samples](https://github.com/jeremytammik/the_building_coder_samples)\n[Util module](https://github.com/jeremytammik/the_building_coder_samples/blob/master/BuildingCoder/BuildingCoder/Util.cs).\n\n\nI'll leave it up to your imagination to improve these and define canonical keys for more complex data as required.\n\nMigliori saluti a Stefano!"
  }
]