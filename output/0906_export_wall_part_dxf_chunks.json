[
  {
    "original_filename": "0906_export_wall_part_dxf",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<html>\n<head>\n<link href=\"bc.css\" rel=\"stylesheet\" type=\"text/css\"/>\n</head>\n<body>\n<h3>Export Wall Parts Individually to DXF</h3>\n<p>I am back from my vacation.\nIt was a wonderful break, and I feel ready and happy to get back to grips with everyday life and work again.\n\n<p>A query from a colleague caught up with me already on the way back, on exporting a whole bunch of selected wall panel parts to individual DXF files.\nThat gave me something nice and interesting to fiddle with during the nightly train ride up from Napoli to Milano and led to the following issues:</p>\n<ul>\n<li><a href=\"#2\">Exporting individual compound wall gyp wallboard parts</a></li>\n<li><a href=\"#3\">Handling and dismissing a warning message</a></li>\n<li><a href=\"#4\">Adding support for both pre- and post- part selection</a></li>\n<li><a href=\"#5\">Handling temporary transactions and regeneration</a></li>\n</ul>\n<p>Before getting to that, though, here are a few final notes on my last vacation day in Napoli.</p>\n<a name=\"1\"></a>\n<h4>Last Day in Napoli</h4>\n<p>I had some wonderful pastry in the\n\n<a href=\"http://www.tripadvisor.com/Restaurant_Review-g187785-d1129216-Reviews-Gran_Bar_Riviera-Naples_Province_of_Naples_Campania.html\">\nGran Bar Riviera</a> pasticceria\n\non the Riviera di Chiaia.\nIncidentally, an old palazzo partially collapsed there last week, just a few hundred meters away from where I was staying.</p>\n<img alt=\"Collapsed palazzo in Riviera di Chiaia\" src=\"file:///j/photo/jeremy/2013/2013-03-08_napoli/p1000534_collapsed_house_cropped.jpg\" width=\"200\"/>\n\n \n\n<img alt=\"Shoemaker Gabriele\" src=\"file:///j/photo/jeremy/2013/2013-03-08_napoli/p1000586_gabriele_shoemaker_cropped.jpg\" width=\"200\"/>\n\n \n\n<img alt=\"Gabriele and Jeremy\" src=\"file:///j/photo/jeremy/2013/2013-03-08_napoli/p1000587_gabriele_jeremy.jpg\" width=\"200\"/>\n<p>Further, I took a pair of old shoes to Gabriele, an extremely sweet and happy 86 years old shoemaker in the Spanish quarter.\nHe repaired them and they look better than new now.\nHe also invited us to coffee and told me his life story.\nIf you ever need a pair of shoes fixed, be sure to look him up in Vico Lungo del Gelso, 108, I-80134 Napoli  :-)</p>\n<p>Two final parting pictures capturing some of the decrepit charm of Naples...</p>\n<img alt=\"Impressions from the Spanish quarter\" src=\"file:///j/photo/jeremy/2013/2013-03-08_napoli/p1000580.jpg\" width=\"200\"/>\n\n \n\n<img alt=\"Impressions from the Spanish quarter\" src=\"file:///j/photo/jeremy/2013/2013-03-08_napoli/p1000592.jpg\" width=\"200\"/>\n<p>Anyway, now I am back at work now again, and we return to the Revit API and my nocturnal dabbling on the train.</p>\n<a name=\"2\"></a>\n<h4>Exporting Individual Compound Wall Gyp Wallboard Parts</h4>\n<p>This query came in from my colleague William Spier, MEP &amp; Design to Fabrication SME at Autodesk\n(<a href=\"http://www.youtube.com/AutodeskMEPTechs\">YouTube</a>,\n<a href=\"http://familyjewels.typepad.com\">Revit Family Jewels</a>).\nHe says:\n\n<p><strong>Question:</strong> I would like to customise two pretty easy things.\n\n<p>The scenario is a compound wall on which I divide the gyp wallboard into standard (4’x8’) sheet size parts.\nI need to export each of those sheets/parts to DXF format, but even though I have divided them into parts, Revit still groups them and exports them as one single DXF file – not as separate ones, like I need.\nThe only way around this is to isolate each part one at a time and export each one individually, which is WAY too laborious.\n\n<p>So I need to customize the export process so that:</p>\n<ol>\n<li>Each part exports as a separate part, even though I globally selected them.</li>\n<li>Each part exports named by its own unique code/identifier – whatever coding keeps each one distinct in the parts schedule.</li>\n</ol>\n<p>Here is a snapshot from a simple sample project:</p>\n<center>\n<img alt=\"Sample wall parts\" src=\"img/sample_wall_parts.png\" width=\"200\"/>\n</center>\n<p><strong>Answer:</strong> A first search for related API methods turn up the following potentially useful items:\n\n<ul>\n<li>Document.Export( string, string, ICollection&lt;ElementId&gt;, DXFExportOptions )\n<li>View.IsolateElementTemporary(\tElementId )\n<li>Part.ParentDividedElementId property (obsolete)\n<li>Part.GetSourceElementOriginalCategoryIds method (obsolete)\n<li>Part.GetSourceElementIds method\n</li></li></li></li></li></ul>\n<p>Skipping the obsolete ones, it turns out to be really easy to implement a first working version that I packaged in an external command named ExportWallboard.\n\n<p>I first check that a valid document is provided and a 3D view is active that we can use for isolating and exporting each part:\n\n<pre class=\"code\">\n  <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == doc )\n  {\n    ErrorMsg( <span class=\"maroon\">\"Please run this command in a valid\"</span>\n      + <span class=\"maroon\">\" Revit project document.\"</span> );\n    <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n  }\n \n  <span class=\"teal\">View</span> view = doc.ActiveView;\n \n  <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == view || !( view <span class=\"blue\">is</span> <span class=\"teal\">View3D</span> ) )\n  {\n    ErrorMsg( <span class=\"maroon\">\"Please run this command in a valid\"</span>\n      + <span class=\"maroon\">\" 3D view.\"</span> );\n    <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n  }\n \n  <span class=\"green\">// Define the list of views to export, </span>\n  <span class=\"green\">// including only the current 3D view</span>\n \n  <span class=\"teal\">List</span>&lt;<span class=\"teal\">ElementId</span>&gt; viewIds = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">ElementId</span>&gt;( 1 );\n  viewIds.Add( view.Id );\n</pre>\n<p>Basically, all that is required is to follow the steps suggested above:</p>\n<ul>\n<li>Isolate each part</li>\n<li>Define the DXF filename</li>\n<li>Call the export method</li>\n</ul>\n<pre class=\"code\">\n  <span class=\"teal\">Element</span> e = doc.GetElement( id );\n \n  <span class=\"teal\">Debug</span>.Assert( e <span class=\"blue\">is</span> <span class=\"teal\">Part</span>,\n    <span class=\"maroon\">\"expected parts only\"</span> );\n \n  <span class=\"teal\">Part</span> part = e <span class=\"blue\">as</span> <span class=\"teal\">Part</span>;\n \n  <span class=\"teal\">ICollection</span>&lt;<span class=\"teal\">LinkElementId</span>&gt; lids\n    = part.GetSourceElementIds();\n \n  <span class=\"teal\">Debug</span>.Assert( 1 == lids.Count,\n    <span class=\"maroon\">\"unexpected multiple part source elements.\"</span> );\n \n  <span class=\"teal\">LinkElementId</span> lid = lids.First&lt;<span class=\"teal\">LinkElementId</span>&gt;();\n  <span class=\"teal\">ElementId</span> hostId = lid.HostElementId;\n  <span class=\"teal\">ElementId</span> linkedId = lid.LinkedElementId;\n  <span class=\"teal\">ElementId</span> parentId = hostId;\n  <span class=\"teal\">ElementId</span> partId = e.Id;\n \n  filename = <span class=\"blue\">string</span>.Format( <span class=\"maroon\">\"{0}_{1}\"</span>,\n    parentId, partId );\n \n  view.IsolateElementTemporary( partId );\n \n  doc.Export( _folder, filename, viewIds, opt );\n</pre>\n<p>The IsolateElementTemporary method requires a transaction, so even though the whole operation is theoretically read-only, we still need to specify manual transaction mode for this command.\nWe encapsulate the isolate and export method in a transaction that is later rolled back, so the model ends up unchanged after all.</p>\n<a name=\"3\"></a>\n<h3>Handling and Dismissing a Warning Message</h3>\n<p>However, a complication arises:\n\n<p>Calling the Export method with an isolated element in the current view displays a task dialogue warning message:\n\n<center>\n<img alt=\"Exporting a view with isolated element warning\" src=\"img/export_with_isolate_warning.png\" width=\"400\"/>\n</center>\n<p>I repeatedly discussed how to automatically handle messages like this in the past, e.g. to\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2012/10/detach-workset-and-taskdialog-command-link-order.html\">\ndetach a workset</a>.</p>\n<p>To be notified of this message, we subscribe to the DialogShowing event:</p>\n<pre class=\"code\">\n  uiapp.DialogBoxShowing\n    += <span class=\"blue\">new</span> <span class=\"teal\">EventHandler</span>&lt;<span class=\"teal\">DialogBoxShowingEventArgs</span>&gt;(\n      OnDialogBoxShowing );\n</pre>\n<p>Do not forget to unsubscribe afterwards.\nIn this case, we can do so at the end of the command.\n\n<p>To ensure that the unsubscription is performed whatever happens, regardless of any potential errors, I encapsulate the whole operation in a try statement and unsubscribe in its 'finally' clause.\n\n<pre class=\"code\">\n  <span class=\"blue\">try</span>\n  {\n    <span class=\"green\">// Register event handler for </span>\n    <span class=\"green\">// \"TaskDialog_Really_Print_Or_Export_Temp_View_Modes\" </span>\n    <span class=\"green\">// dialogue</span>\n \n    uiapp.DialogBoxShowing\n      += <span class=\"blue\">new</span> <span class=\"teal\">EventHandler</span>&lt;<span class=\"teal\">DialogBoxShowingEventArgs</span>&gt;(\n        OnDialogBoxShowing );\n \n    <span class=\"teal\">DXFExportOptions</span> opt = <span class=\"blue\">new</span> <span class=\"teal\">DXFExportOptions</span>();\n \n    <span class=\"blue\">string</span> filename;\n \n    <span class=\"blue\">using</span>( <span class=\"teal\">Transaction</span> tx = <span class=\"blue\">new</span> <span class=\"teal\">Transaction</span>( doc ) )\n    {\n      tx.Start( <span class=\"maroon\">\"Transaction Name\"</span> );\n \n      <span class=\"blue\">foreach</span>( <span class=\"teal\">ElementId</span> id <span class=\"blue\">in</span> ids )\n      {\n        <span class=\"teal\">Element</span> e = doc.GetElement( id );\n \n        <span class=\"green\">// . . .</span>\n \n        view.IsolateElementTemporary( partId );\n \n        doc.Export( _folder, filename, viewIds, opt );\n      }\n \n      <span class=\"green\">// We do not commit the transaction, because</span>\n      <span class=\"green\">// we do not want any modifications saved.</span>\n      <span class=\"green\">// The transaction is only created and started</span>\n      <span class=\"green\">// because it is required by the</span>\n      <span class=\"green\">// IsolateElementTemporary method.</span>\n      <span class=\"green\">// Since the transaction is not committed, </span>\n      <span class=\"green\">// the changes are automatically discarded.</span>\n \n      <span class=\"green\">//tx.Commit();</span>\n    }\n  }\n  <span class=\"blue\">finally</span>\n  {\n    uiapp.DialogBoxShowing\n      -= <span class=\"blue\">new</span> <span class=\"teal\">EventHandler</span>&lt;<span class=\"teal\">DialogBoxShowingEventArgs</span>&gt;(\n        OnDialogBoxShowing );\n  }\n  <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Succeeded;\n</pre>\n<p>Initially, I did not yet know exactly which dialogue id to use to identify this specific message.\nI therefore first implemented a dummy DialogBoxShowing event handler, triggered the event, and determined the dialogue id to use by re-running the command and looking at the event handler argument in the debugger.\n\n<p>As it turns out, the required dialogue id in our case is \"TaskDialog_Really_Print_Or_Export_Temp_View_Modes\".\nWe wish to retain the temporary isolate mode and export, i.e. select the second command link option.\nTherefore, the final dialogue box showing event handler implementation becomes:\n\n<pre class=\"code\">\n<span class=\"blue\">void</span> OnDialogBoxShowing(\n  <span class=\"blue\">object</span> sender,\n  <span class=\"teal\">DialogBoxShowingEventArgs</span> e )\n{\n  <span class=\"teal\">TaskDialogShowingEventArgs</span> e2\n    = e <span class=\"blue\">as</span> <span class=\"teal\">TaskDialogShowingEventArgs</span>;\n \n  <span class=\"blue\">if</span>( <span class=\"blue\">null</span> != e2 &amp;&amp; e2.DialogId.Equals(\n    <span class=\"maroon\">\"TaskDialog_Really_Print_Or_Export_Temp_View_Modes\"</span> ) )\n  {\n    e.OverrideResult(\n      (<span class=\"blue\">int</span>)<span class=\"teal\">TaskDialogResult</span>.CommandLink2 );\n  }\n}\n</pre>\n<a name=\"4\"></a>\n<h3>Adding Support for both Pre- and Post- Part Selection</h3>\n<p>In the initial implementation, I just went ahead and used the pre-selected set of parts defined by the user before launching the external command, accessible via the uidoc.Selection.Elements collection.\n\n<p>However, it is much more user friendly to also support post-selection.\nFor that case, it is also useful to implement a selection filter to simplify easy mass selection of the parts.\n\n<p>In order to handle the elements identically regardless of whether they were pre- or post-selected, I convert the selection set to a list of element ids in both cases.\n\n<p>For the pre-selection, I iterate over the pre-selected elements and test each one as follows:\n\n<pre class=\"code\">\n  <span class=\"green\">// Iterate over all pre-selected parts</span>\n \n  <span class=\"teal\">List</span>&lt;<span class=\"teal\">ElementId</span>&gt; ids = <span class=\"blue\">null</span>;\n \n  <span class=\"teal\">Selection</span> sel = uidoc.Selection;\n \n  <span class=\"blue\">if</span>( 0 &lt; sel.Elements.Size )\n  {\n    <span class=\"blue\">foreach</span>( <span class=\"teal\">Element</span> e <span class=\"blue\">in</span> sel.Elements )\n    {\n      <span class=\"blue\">if</span>( !( e <span class=\"blue\">is</span> <span class=\"teal\">Part</span> ) )\n      {\n        ErrorMsg( <span class=\"maroon\">\"Please pre-select only gyp wallboard\"</span>\n          + <span class=\"maroon\">\" parts before running this command.\"</span> );\n        <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n      }\n \n      <span class=\"teal\">Part</span> part = e <span class=\"blue\">as</span> <span class=\"teal\">Part</span>;\n \n      <span class=\"teal\">ICollection</span>&lt;<span class=\"teal\">LinkElementId</span>&gt; lids\n        = part.GetSourceElementIds();\n \n      <span class=\"blue\">if</span>( 1 != lids.Count )\n      {\n        ErrorMsg( <span class=\"maroon\">\"Gyp wallboard parts has multiple\"</span>\n          + <span class=\"maroon\">\" source elements.\"</span> );\n        <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n      }\n \n      <span class=\"teal\">LinkElementId</span> lid = lids.First&lt;<span class=\"teal\">LinkElementId</span>&gt;();\n      <span class=\"teal\">ElementId</span> hostId = lid.HostElementId;\n      <span class=\"teal\">ElementId</span> linkedId = lid.LinkedElementId;\n      <span class=\"teal\">ElementId</span> parentId = hostId;\n      <span class=\"teal\">ElementId</span> partId = e.Id;\n \n      <span class=\"green\">// Determine parent category</span>\n \n      <span class=\"teal\">Element</span> parent = doc.GetElement( parentId );\n      <span class=\"teal\">Category</span> cat = parent.Category;\n \n      <span class=\"teal\">ICollection</span>&lt;<span class=\"teal\">ElementId</span>&gt; cids\n        = part.GetSourceElementOriginalCategoryIds();\n \n      <span class=\"blue\">if</span>( 1 != cids.Count )\n      {\n        ErrorMsg( <span class=\"maroon\">\"Gyp wallboard parts has multiple\"</span>\n          + <span class=\"maroon\">\" source element categories.\"</span> );\n        <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n      }\n \n      <span class=\"teal\">ElementId</span> cid = cids.First&lt;<span class=\"teal\">ElementId</span>&gt;();\n \n      <span class=\"green\">//cat = doc.GetElement( id ) as Category;</span>\n \n      <span class=\"green\">// Expected parent category is OST_Walls</span>\n \n      <span class=\"teal\">BuiltInCategory</span> bic\n        = (<span class=\"teal\">BuiltInCategory</span>)cid.IntegerValue;\n \n      <span class=\"blue\">if</span>( <span class=\"teal\">BuiltInCategory</span>.OST_Walls != bic )\n      {\n        ErrorMsg( <span class=\"maroon\">\"Pleqase pre-select only \"</span>\n          + <span class=\"maroon\">\" gyp wallboard parts.\"</span> );\n        <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n      }\n \n      <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == ids )\n      {\n        ids = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">ElementId</span>&gt;( 1 );\n      }\n \n      ids.Add( partId );\n    }\n \n    <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == ids )\n    {\n      ErrorMsg( <span class=\"maroon\">\"Please pre-select only gyp wallboard\"</span>\n        + <span class=\"maroon\">\" parts before running this command.\"</span> );\n      <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n    }\n  }\n</pre>\n<p>The category of the source elements can be determined using the Part.GetSourceElementOriginalCategoryIds method, which unsurprisingly turns out to be OST_Walls.</p>\n<p>I use that to check the part source element category like this in the final selection filter implementation:\n\n<pre class=\"code\">\n<span class=\"blue\">class</span> <span class=\"teal\">WallPartSelectionFilter</span> : <span class=\"teal\">ISelectionFilter</span>\n{\n  <span class=\"blue\">public</span> <span class=\"blue\">bool</span> AllowElement( <span class=\"teal\">Element</span> e )\n  {\n    <span class=\"blue\">bool</span> rc = <span class=\"blue\">false</span>;\n \n    <span class=\"teal\">Part</span> part = e <span class=\"blue\">as</span> <span class=\"teal\">Part</span>;\n \n    <span class=\"blue\">if</span>( <span class=\"blue\">null</span> != part )\n    {\n      <span class=\"teal\">ICollection</span>&lt;<span class=\"teal\">ElementId</span>&gt; cids\n        = part.GetSourceElementOriginalCategoryIds();\n \n      <span class=\"blue\">if</span>( 1 == cids.Count )\n      {\n        <span class=\"teal\">ElementId</span> cid = cids.First&lt;<span class=\"teal\">ElementId</span>&gt;();\n \n        <span class=\"teal\">BuiltInCategory</span> bic\n          = (<span class=\"teal\">BuiltInCategory</span>)cid.IntegerValue;\n \n        rc = ( <span class=\"teal\">BuiltInCategory</span>.OST_Walls == bic );\n      }\n    }\n    <span class=\"blue\">return</span> rc;\n  }\n \n  <span class=\"blue\">public</span> <span class=\"blue\">bool</span> AllowReference( <span class=\"teal\">Reference</span> r, <span class=\"teal\">XYZ</span> p )\n  {\n    <span class=\"blue\">return</span> <span class=\"blue\">true</span>;\n  }\n}\n</pre>\n<!--\n<p>Running this test code shows that the desired parent category is OST_Walls, as expected.\n\n<p>Based on that, I implemented the following wall part selection filter:\n-->\n<p>For the post-selection, the selection filter ensures that no inappropriate parts can be selected, so no additional scan is required to test the references returned by the PickObjects method.\n\n<p>I can use a generic LINQ method to convert the collection of resulting references to the list of element ids:\n\n<pre class=\"code\">\n  <span class=\"green\">// If no parts were pre-selected, </span>\n  <span class=\"green\">// prompt for post-selection</span>\n \n  <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == ids )\n  {\n    <span class=\"teal\">IList</span>&lt;<span class=\"teal\">Reference</span>&gt; refs = <span class=\"blue\">null</span>;\n \n    <span class=\"blue\">try</span>\n    {\n      refs = sel.PickObjects( <span class=\"teal\">ObjectType</span>.Element,\n        <span class=\"blue\">new</span> <span class=\"teal\">WallPartSelectionFilter</span>(),\n        <span class=\"maroon\">\"Please select wall parts.\"</span> );\n    }\n    <span class=\"blue\">catch</span>( Autodesk.Revit.Exceptions\n      .<span class=\"teal\">OperationCanceledException</span> )\n    {\n      <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Cancelled;\n    }\n    ids = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">ElementId</span>&gt;(\n      refs.Select&lt;<span class=\"teal\">Reference</span>, <span class=\"teal\">ElementId</span>&gt;(\n        r =&gt; r.ElementId ) );\n  }\n</pre>\n<p>Here is\n\n<a href=\"zip/ExportWallboard03.zip\">\nExportWallboard03.zip</a> including the complete source code, Visual Studio solution and add-in manifest of the current state of this external command.\n\n<p>There are obviously still some implementation details to iron out.\n\n\n\n<a name=\"5\"></a>\n<h3>Handling Temporary Transactions and Regeneration</h3>\n<p>Luckily, I took a closer look at the generated DXF output files before letting this command loose on humanity.</p>\n<p>To my horror, I discovered that all files generated except the first one contain no geometry.</p>\n<p>As it turns out, there is an issue with the regeneration and view settings in my original implementation.</p>\n<p>After quite a bit of experimentation, I found out that I can successfully generate the individual files if I add the following steps:</p>\n<ul>\n<li>Add code to switch off the first temporary isolation before applying the next one.</li>\n<li>Commit the transaction to temporaily isolate each part before calling Export.</li>\n<li>This requires encapsulating all the temporary transactions in a group and rolling back the entire group instead of the individual transactions, as described for the\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2012/11/temporary-transaction-trick-touchup.html\">temporary transaction trick touchup</a>.</li>\n<li>Separate the code to switch off the last temporary isolation and applying the new one into separate transactions.</li>\n</ul>\n<p>The resulting loop exporting all the parts ends up looking like this:</p>\n<pre class=\"code\">\n  <span class=\"blue\">using</span>( <span class=\"teal\">TransactionGroup</span> txg = <span class=\"blue\">new</span> <span class=\"teal\">TransactionGroup</span>( doc ) )\n  {\n    txg.Start( <span class=\"maroon\">\"Export Wall Parts\"</span> );\n \n    <span class=\"blue\">foreach</span>( <span class=\"teal\">ElementId</span> id <span class=\"blue\">in</span> ids )\n    {\n      <span class=\"teal\">Element</span> e = doc.GetElement( id );\n \n      <span class=\"teal\">Debug</span>.Assert( e <span class=\"blue\">is</span> <span class=\"teal\">Part</span>,\n        <span class=\"maroon\">\"expected parts only\"</span> );\n \n      <span class=\"teal\">Part</span> part = e <span class=\"blue\">as</span> <span class=\"teal\">Part</span>;\n \n      <span class=\"teal\">ICollection</span>&lt;<span class=\"teal\">LinkElementId</span>&gt; lids\n        = part.GetSourceElementIds();\n \n      <span class=\"teal\">Debug</span>.Assert( 1 == lids.Count,\n        <span class=\"maroon\">\"unexpected multiple part source elements.\"</span> );\n \n      <span class=\"teal\">LinkElementId</span> lid = lids.First&lt;<span class=\"teal\">LinkElementId</span>&gt;();\n      <span class=\"teal\">ElementId</span> hostId = lid.HostElementId;\n      <span class=\"teal\">ElementId</span> linkedId = lid.LinkedElementId;\n      <span class=\"teal\">ElementId</span> parentId = hostId;\n      <span class=\"teal\">ElementId</span> partId = e.Id;\n \n      filename = <span class=\"blue\">string</span>.Format( <span class=\"maroon\">\"{0}_{1}\"</span>,\n        parentId, partId );\n \n      <span class=\"blue\">if</span>( view.IsTemporaryHideIsolateActive() )\n      {\n        <span class=\"blue\">using</span>( <span class=\"teal\">Transaction</span> tx = <span class=\"blue\">new</span> <span class=\"teal\">Transaction</span>( doc ) )\n        {\n          tx.Start( <span class=\"maroon\">\"Disable Temporary Isolate\"</span> );\n \n          view.DisableTemporaryViewMode(\n            <span class=\"teal\">TemporaryViewMode</span>.TemporaryHideIsolate );\n \n          tx.Commit();\n        }\n \n        <span class=\"teal\">Debug</span>.Assert( !view.IsTemporaryHideIsolateActive(),\n          <span class=\"maroon\">\"expected to turn off temporary hide/isolate\"</span> );\n      }\n \n      <span class=\"blue\">using</span>( <span class=\"teal\">Transaction</span> tx = <span class=\"blue\">new</span> <span class=\"teal\">Transaction</span>( doc ) )\n      {\n        tx.Start( <span class=\"maroon\">\"Export Wall Part \"</span>\n          + partId.ToString() );\n \n        view.IsolateElementTemporary( partId ); <span class=\"green\">// requires transaction</span>\n \n        <span class=\"green\">//List&lt;ElementId&gt; unhideIds = new List&lt;ElementId&gt;( 1 );</span>\n        <span class=\"green\">//unhideIds.Add( partId );</span>\n        <span class=\"green\">//view.UnhideElements( unhideIds );</span>\n \n        <span class=\"green\">//doc.Regenerate(); // this is insufficient</span>\n \n        tx.Commit();\n      }\n \n      doc.Export( _folder, filename, viewIds, opt );\n \n      <span class=\"green\">// We do not commit the transaction group, </span>\n      <span class=\"green\">// because no modifications should be saved.</span>\n      <span class=\"green\">// The transaction group is only created and </span>\n      <span class=\"green\">// started to encapsulate the transactions </span>\n      <span class=\"green\">// required by the IsolateElementTemporary </span>\n      <span class=\"green\">// method. Since the transaction group is not </span>\n      <span class=\"green\">// committed, the changes are automatically </span>\n      <span class=\"green\">// discarded.</span>\n \n      <span class=\"green\">//txg.Commit();</span>\n    }\n  }\n</pre>\n<p>Here is\n\n<a href=\"zip/ExportWallboard04.zip\">\nExportWallboard04.zip</a> including the source code, Visual Studio solution and add-in manifest of the updated version.\n\n<p>I certainly expect more implementation details to crop up that need ironing out.\n\n<p>For instance, I could imagine adding some code to delete the PCP files that are generated together with the DXF output.\nOr is there any reason to keep them?</p>\n<p>I can also imagine that the part identification needs improving.\nCurrently, the command simply uses the part and its source element ids.\nMaybe the part unique id would be better, or the parent element id needs checking, or is unnecessary snd can be completely removed.\n\n<p>Anyway, for a first stab, this implementation now looks pretty good to me.</p>\n</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></body>\n</html>"
  },
  {
    "original_filename": "0906_export_wall_part_dxf",
    "header_text": "Export Wall Parts Individually to DXF",
    "local_header_href": "#export-wall-parts-individually-to-dxf",
    "chunk_text": "<h3>Export Wall Parts Individually to DXF</h3><p>I am back from my vacation.\nIt was a wonderful break, and I feel ready and happy to get back to grips with everyday life and work again.\n\n<p>A query from a colleague caught up with me already on the way back, on exporting a whole bunch of selected wall panel parts to individual DXF files.\nThat gave me something nice and interesting to fiddle with during the nightly train ride up from Napoli to Milano and led to the following issues:</p>\n<ul>\n<li><a href=\"#2\">Exporting individual compound wall gyp wallboard parts</a></li>\n<li><a href=\"#3\">Handling and dismissing a warning message</a></li>\n<li><a href=\"#4\">Adding support for both pre- and post- part selection</a></li>\n<li><a href=\"#5\">Handling temporary transactions and regeneration</a></li>\n</ul>\n<p>Before getting to that, though, here are a few final notes on my last vacation day in Napoli.</p>\n<a name=\"1\"></a>\n<h4>Last Day in Napoli</h4>\n<p>I had some wonderful pastry in the\n\n<a href=\"http://www.tripadvisor.com/Restaurant_Review-g187785-d1129216-Reviews-Gran_Bar_Riviera-Naples_Province_of_Naples_Campania.html\">\nGran Bar Riviera</a> pasticceria\n\non the Riviera di Chiaia.\nIncidentally, an old palazzo partially collapsed there last week, just a few hundred meters away from where I was staying.</p>\n<img alt=\"Collapsed palazzo in Riviera di Chiaia\" src=\"file:///j/photo/jeremy/2013/2013-03-08_napoli/p1000534_collapsed_house_cropped.jpg\" width=\"200\"/>\n\n \n\n<img alt=\"Shoemaker Gabriele\" src=\"file:///j/photo/jeremy/2013/2013-03-08_napoli/p1000586_gabriele_shoemaker_cropped.jpg\" width=\"200\"/>\n\n \n\n<img alt=\"Gabriele and Jeremy\" src=\"file:///j/photo/jeremy/2013/2013-03-08_napoli/p1000587_gabriele_jeremy.jpg\" width=\"200\"/>\n<p>Further, I took a pair of old shoes to Gabriele, an extremely sweet and happy 86 years old shoemaker in the Spanish quarter.\nHe repaired them and they look better than new now.\nHe also invited us to coffee and told me his life story.\nIf you ever need a pair of shoes fixed, be sure to look him up in Vico Lungo del Gelso, 108, I-80134 Napoli  :-)</p>\n<p>Two final parting pictures capturing some of the decrepit charm of Naples...</p>\n<img alt=\"Impressions from the Spanish quarter\" src=\"file:///j/photo/jeremy/2013/2013-03-08_napoli/p1000580.jpg\" width=\"200\"/>\n\n \n\n<img alt=\"Impressions from the Spanish quarter\" src=\"file:///j/photo/jeremy/2013/2013-03-08_napoli/p1000592.jpg\" width=\"200\"/>\n<p>Anyway, now I am back at work now again, and we return to the Revit API and my nocturnal dabbling on the train.</p>\n<a name=\"2\"></a>\n<h4>Exporting Individual Compound Wall Gyp Wallboard Parts</h4>\n<p>This query came in from my colleague William Spier, MEP &amp; Design to Fabrication SME at Autodesk\n(<a href=\"http://www.youtube.com/AutodeskMEPTechs\">YouTube</a>,\n<a href=\"http://familyjewels.typepad.com\">Revit Family Jewels</a>).\nHe says:\n\n<p><strong>Question:</strong> I would like to customise two pretty easy things.\n\n<p>The scenario is a compound wall on which I divide the gyp wallboard into standard (4’x8’) sheet size parts.\nI need to export each of those sheets/parts to DXF format, but even though I have divided them into parts, Revit still groups them and exports them as one single DXF file – not as separate ones, like I need.\nThe only way around this is to isolate each part one at a time and export each one individually, which is WAY too laborious.\n\n<p>So I need to customize the export process so that:</p>\n<ol>\n<li>Each part exports as a separate part, even though I globally selected them.</li>\n<li>Each part exports named by its own unique code/identifier – whatever coding keeps each one distinct in the parts schedule.</li>\n</ol>\n<p>Here is a snapshot from a simple sample project:</p>\n<center>\n<img alt=\"Sample wall parts\" src=\"img/sample_wall_parts.png\" width=\"200\"/>\n</center>\n<p><strong>Answer:</strong> A first search for related API methods turn up the following potentially useful items:\n\n<ul>\n<li>Document.Export( string, string, ICollection&lt;ElementId&gt;, DXFExportOptions )\n<li>View.IsolateElementTemporary(\tElementId )\n<li>Part.ParentDividedElementId property (obsolete)\n<li>Part.GetSourceElementOriginalCategoryIds method (obsolete)\n<li>Part.GetSourceElementIds method\n</li></li></li></li></li></ul>\n<p>Skipping the obsolete ones, it turns out to be really easy to implement a first working version that I packaged in an external command named ExportWallboard.\n\n<p>I first check that a valid document is provided and a 3D view is active that we can use for isolating and exporting each part:\n\n<pre class=\"code\">\n  <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == doc )\n  {\n    ErrorMsg( <span class=\"maroon\">\"Please run this command in a valid\"</span>\n      + <span class=\"maroon\">\" Revit project document.\"</span> );\n    <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n  }\n \n  <span class=\"teal\">View</span> view = doc.ActiveView;\n \n  <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == view || !( view <span class=\"blue\">is</span> <span class=\"teal\">View3D</span> ) )\n  {\n    ErrorMsg( <span class=\"maroon\">\"Please run this command in a valid\"</span>\n      + <span class=\"maroon\">\" 3D view.\"</span> );\n    <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n  }\n \n  <span class=\"green\">// Define the list of views to export, </span>\n  <span class=\"green\">// including only the current 3D view</span>\n \n  <span class=\"teal\">List</span>&lt;<span class=\"teal\">ElementId</span>&gt; viewIds = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">ElementId</span>&gt;( 1 );\n  viewIds.Add( view.Id );\n</pre>\n<p>Basically, all that is required is to follow the steps suggested above:</p>\n<ul>\n<li>Isolate each part</li>\n<li>Define the DXF filename</li>\n<li>Call the export method</li>\n</ul>\n<pre class=\"code\">\n  <span class=\"teal\">Element</span> e = doc.GetElement( id );\n \n  <span class=\"teal\">Debug</span>.Assert( e <span class=\"blue\">is</span> <span class=\"teal\">Part</span>,\n    <span class=\"maroon\">\"expected parts only\"</span> );\n \n  <span class=\"teal\">Part</span> part = e <span class=\"blue\">as</span> <span class=\"teal\">Part</span>;\n \n  <span class=\"teal\">ICollection</span>&lt;<span class=\"teal\">LinkElementId</span>&gt; lids\n    = part.GetSourceElementIds();\n \n  <span class=\"teal\">Debug</span>.Assert( 1 == lids.Count,\n    <span class=\"maroon\">\"unexpected multiple part source elements.\"</span> );\n \n  <span class=\"teal\">LinkElementId</span> lid = lids.First&lt;<span class=\"teal\">LinkElementId</span>&gt;();\n  <span class=\"teal\">ElementId</span> hostId = lid.HostElementId;\n  <span class=\"teal\">ElementId</span> linkedId = lid.LinkedElementId;\n  <span class=\"teal\">ElementId</span> parentId = hostId;\n  <span class=\"teal\">ElementId</span> partId = e.Id;\n \n  filename = <span class=\"blue\">string</span>.Format( <span class=\"maroon\">\"{0}_{1}\"</span>,\n    parentId, partId );\n \n  view.IsolateElementTemporary( partId );\n \n  doc.Export( _folder, filename, viewIds, opt );\n</pre>\n<p>The IsolateElementTemporary method requires a transaction, so even though the whole operation is theoretically read-only, we still need to specify manual transaction mode for this command.\nWe encapsulate the isolate and export method in a transaction that is later rolled back, so the model ends up unchanged after all.</p>\n<a name=\"3\"></a>\n<h3>Handling and Dismissing a Warning Message</h3>\n<p>However, a complication arises:\n\n<p>Calling the Export method with an isolated element in the current view displays a task dialogue warning message:\n\n<center>\n<img alt=\"Exporting a view with isolated element warning\" src=\"img/export_with_isolate_warning.png\" width=\"400\"/>\n</center>\n<p>I repeatedly discussed how to automatically handle messages like this in the past, e.g. to\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2012/10/detach-workset-and-taskdialog-command-link-order.html\">\ndetach a workset</a>.</p>\n<p>To be notified of this message, we subscribe to the DialogShowing event:</p>\n<pre class=\"code\">\n  uiapp.DialogBoxShowing\n    += <span class=\"blue\">new</span> <span class=\"teal\">EventHandler</span>&lt;<span class=\"teal\">DialogBoxShowingEventArgs</span>&gt;(\n      OnDialogBoxShowing );\n</pre>\n<p>Do not forget to unsubscribe afterwards.\nIn this case, we can do so at the end of the command.\n\n<p>To ensure that the unsubscription is performed whatever happens, regardless of any potential errors, I encapsulate the whole operation in a try statement and unsubscribe in its 'finally' clause.\n\n<pre class=\"code\">\n  <span class=\"blue\">try</span>\n  {\n    <span class=\"green\">// Register event handler for </span>\n    <span class=\"green\">// \"TaskDialog_Really_Print_Or_Export_Temp_View_Modes\" </span>\n    <span class=\"green\">// dialogue</span>\n \n    uiapp.DialogBoxShowing\n      += <span class=\"blue\">new</span> <span class=\"teal\">EventHandler</span>&lt;<span class=\"teal\">DialogBoxShowingEventArgs</span>&gt;(\n        OnDialogBoxShowing );\n \n    <span class=\"teal\">DXFExportOptions</span> opt = <span class=\"blue\">new</span> <span class=\"teal\">DXFExportOptions</span>();\n \n    <span class=\"blue\">string</span> filename;\n \n    <span class=\"blue\">using</span>( <span class=\"teal\">Transaction</span> tx = <span class=\"blue\">new</span> <span class=\"teal\">Transaction</span>( doc ) )\n    {\n      tx.Start( <span class=\"maroon\">\"Transaction Name\"</span> );\n \n      <span class=\"blue\">foreach</span>( <span class=\"teal\">ElementId</span> id <span class=\"blue\">in</span> ids )\n      {\n        <span class=\"teal\">Element</span> e = doc.GetElement( id );\n \n        <span class=\"green\">// . . .</span>\n \n        view.IsolateElementTemporary( partId );\n \n        doc.Export( _folder, filename, viewIds, opt );\n      }\n \n      <span class=\"green\">// We do not commit the transaction, because</span>\n      <span class=\"green\">// we do not want any modifications saved.</span>\n      <span class=\"green\">// The transaction is only created and started</span>\n      <span class=\"green\">// because it is required by the</span>\n      <span class=\"green\">// IsolateElementTemporary method.</span>\n      <span class=\"green\">// Since the transaction is not committed, </span>\n      <span class=\"green\">// the changes are automatically discarded.</span>\n \n      <span class=\"green\">//tx.Commit();</span>\n    }\n  }\n  <span class=\"blue\">finally</span>\n  {\n    uiapp.DialogBoxShowing\n      -= <span class=\"blue\">new</span> <span class=\"teal\">EventHandler</span>&lt;<span class=\"teal\">DialogBoxShowingEventArgs</span>&gt;(\n        OnDialogBoxShowing );\n  }\n  <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Succeeded;\n</pre>\n<p>Initially, I did not yet know exactly which dialogue id to use to identify this specific message.\nI therefore first implemented a dummy DialogBoxShowing event handler, triggered the event, and determined the dialogue id to use by re-running the command and looking at the event handler argument in the debugger.\n\n<p>As it turns out, the required dialogue id in our case is \"TaskDialog_Really_Print_Or_Export_Temp_View_Modes\".\nWe wish to retain the temporary isolate mode and export, i.e. select the second command link option.\nTherefore, the final dialogue box showing event handler implementation becomes:\n\n<pre class=\"code\">\n<span class=\"blue\">void</span> OnDialogBoxShowing(\n  <span class=\"blue\">object</span> sender,\n  <span class=\"teal\">DialogBoxShowingEventArgs</span> e )\n{\n  <span class=\"teal\">TaskDialogShowingEventArgs</span> e2\n    = e <span class=\"blue\">as</span> <span class=\"teal\">TaskDialogShowingEventArgs</span>;\n \n  <span class=\"blue\">if</span>( <span class=\"blue\">null</span> != e2 &amp;&amp; e2.DialogId.Equals(\n    <span class=\"maroon\">\"TaskDialog_Really_Print_Or_Export_Temp_View_Modes\"</span> ) )\n  {\n    e.OverrideResult(\n      (<span class=\"blue\">int</span>)<span class=\"teal\">TaskDialogResult</span>.CommandLink2 );\n  }\n}\n</pre>\n<a name=\"4\"></a>\n<h3>Adding Support for both Pre- and Post- Part Selection</h3>\n<p>In the initial implementation, I just went ahead and used the pre-selected set of parts defined by the user before launching the external command, accessible via the uidoc.Selection.Elements collection.\n\n<p>However, it is much more user friendly to also support post-selection.\nFor that case, it is also useful to implement a selection filter to simplify easy mass selection of the parts.\n\n<p>In order to handle the elements identically regardless of whether they were pre- or post-selected, I convert the selection set to a list of element ids in both cases.\n\n<p>For the pre-selection, I iterate over the pre-selected elements and test each one as follows:\n\n<pre class=\"code\">\n  <span class=\"green\">// Iterate over all pre-selected parts</span>\n \n  <span class=\"teal\">List</span>&lt;<span class=\"teal\">ElementId</span>&gt; ids = <span class=\"blue\">null</span>;\n \n  <span class=\"teal\">Selection</span> sel = uidoc.Selection;\n \n  <span class=\"blue\">if</span>( 0 &lt; sel.Elements.Size )\n  {\n    <span class=\"blue\">foreach</span>( <span class=\"teal\">Element</span> e <span class=\"blue\">in</span> sel.Elements )\n    {\n      <span class=\"blue\">if</span>( !( e <span class=\"blue\">is</span> <span class=\"teal\">Part</span> ) )\n      {\n        ErrorMsg( <span class=\"maroon\">\"Please pre-select only gyp wallboard\"</span>\n          + <span class=\"maroon\">\" parts before running this command.\"</span> );\n        <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n      }\n \n      <span class=\"teal\">Part</span> part = e <span class=\"blue\">as</span> <span class=\"teal\">Part</span>;\n \n      <span class=\"teal\">ICollection</span>&lt;<span class=\"teal\">LinkElementId</span>&gt; lids\n        = part.GetSourceElementIds();\n \n      <span class=\"blue\">if</span>( 1 != lids.Count )\n      {\n        ErrorMsg( <span class=\"maroon\">\"Gyp wallboard parts has multiple\"</span>\n          + <span class=\"maroon\">\" source elements.\"</span> );\n        <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n      }\n \n      <span class=\"teal\">LinkElementId</span> lid = lids.First&lt;<span class=\"teal\">LinkElementId</span>&gt;();\n      <span class=\"teal\">ElementId</span> hostId = lid.HostElementId;\n      <span class=\"teal\">ElementId</span> linkedId = lid.LinkedElementId;\n      <span class=\"teal\">ElementId</span> parentId = hostId;\n      <span class=\"teal\">ElementId</span> partId = e.Id;\n \n      <span class=\"green\">// Determine parent category</span>\n \n      <span class=\"teal\">Element</span> parent = doc.GetElement( parentId );\n      <span class=\"teal\">Category</span> cat = parent.Category;\n \n      <span class=\"teal\">ICollection</span>&lt;<span class=\"teal\">ElementId</span>&gt; cids\n        = part.GetSourceElementOriginalCategoryIds();\n \n      <span class=\"blue\">if</span>( 1 != cids.Count )\n      {\n        ErrorMsg( <span class=\"maroon\">\"Gyp wallboard parts has multiple\"</span>\n          + <span class=\"maroon\">\" source element categories.\"</span> );\n        <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n      }\n \n      <span class=\"teal\">ElementId</span> cid = cids.First&lt;<span class=\"teal\">ElementId</span>&gt;();\n \n      <span class=\"green\">//cat = doc.GetElement( id ) as Category;</span>\n \n      <span class=\"green\">// Expected parent category is OST_Walls</span>\n \n      <span class=\"teal\">BuiltInCategory</span> bic\n        = (<span class=\"teal\">BuiltInCategory</span>)cid.IntegerValue;\n \n      <span class=\"blue\">if</span>( <span class=\"teal\">BuiltInCategory</span>.OST_Walls != bic )\n      {\n        ErrorMsg( <span class=\"maroon\">\"Pleqase pre-select only \"</span>\n          + <span class=\"maroon\">\" gyp wallboard parts.\"</span> );\n        <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n      }\n \n      <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == ids )\n      {\n        ids = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">ElementId</span>&gt;( 1 );\n      }\n \n      ids.Add( partId );\n    }\n \n    <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == ids )\n    {\n      ErrorMsg( <span class=\"maroon\">\"Please pre-select only gyp wallboard\"</span>\n        + <span class=\"maroon\">\" parts before running this command.\"</span> );\n      <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n    }\n  }\n</pre>\n<p>The category of the source elements can be determined using the Part.GetSourceElementOriginalCategoryIds method, which unsurprisingly turns out to be OST_Walls.</p>\n<p>I use that to check the part source element category like this in the final selection filter implementation:\n\n<pre class=\"code\">\n<span class=\"blue\">class</span> <span class=\"teal\">WallPartSelectionFilter</span> : <span class=\"teal\">ISelectionFilter</span>\n{\n  <span class=\"blue\">public</span> <span class=\"blue\">bool</span> AllowElement( <span class=\"teal\">Element</span> e )\n  {\n    <span class=\"blue\">bool</span> rc = <span class=\"blue\">false</span>;\n \n    <span class=\"teal\">Part</span> part = e <span class=\"blue\">as</span> <span class=\"teal\">Part</span>;\n \n    <span class=\"blue\">if</span>( <span class=\"blue\">null</span> != part )\n    {\n      <span class=\"teal\">ICollection</span>&lt;<span class=\"teal\">ElementId</span>&gt; cids\n        = part.GetSourceElementOriginalCategoryIds();\n \n      <span class=\"blue\">if</span>( 1 == cids.Count )\n      {\n        <span class=\"teal\">ElementId</span> cid = cids.First&lt;<span class=\"teal\">ElementId</span>&gt;();\n \n        <span class=\"teal\">BuiltInCategory</span> bic\n          = (<span class=\"teal\">BuiltInCategory</span>)cid.IntegerValue;\n \n        rc = ( <span class=\"teal\">BuiltInCategory</span>.OST_Walls == bic );\n      }\n    }\n    <span class=\"blue\">return</span> rc;\n  }\n \n  <span class=\"blue\">public</span> <span class=\"blue\">bool</span> AllowReference( <span class=\"teal\">Reference</span> r, <span class=\"teal\">XYZ</span> p )\n  {\n    <span class=\"blue\">return</span> <span class=\"blue\">true</span>;\n  }\n}\n</pre>\n<!--\n<p>Running this test code shows that the desired parent category is OST_Walls, as expected.\n\n<p>Based on that, I implemented the following wall part selection filter:\n-->\n<p>For the post-selection, the selection filter ensures that no inappropriate parts can be selected, so no additional scan is required to test the references returned by the PickObjects method.\n\n<p>I can use a generic LINQ method to convert the collection of resulting references to the list of element ids:\n\n<pre class=\"code\">\n  <span class=\"green\">// If no parts were pre-selected, </span>\n  <span class=\"green\">// prompt for post-selection</span>\n \n  <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == ids )\n  {\n    <span class=\"teal\">IList</span>&lt;<span class=\"teal\">Reference</span>&gt; refs = <span class=\"blue\">null</span>;\n \n    <span class=\"blue\">try</span>\n    {\n      refs = sel.PickObjects( <span class=\"teal\">ObjectType</span>.Element,\n        <span class=\"blue\">new</span> <span class=\"teal\">WallPartSelectionFilter</span>(),\n        <span class=\"maroon\">\"Please select wall parts.\"</span> );\n    }\n    <span class=\"blue\">catch</span>( Autodesk.Revit.Exceptions\n      .<span class=\"teal\">OperationCanceledException</span> )\n    {\n      <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Cancelled;\n    }\n    ids = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">ElementId</span>&gt;(\n      refs.Select&lt;<span class=\"teal\">Reference</span>, <span class=\"teal\">ElementId</span>&gt;(\n        r =&gt; r.ElementId ) );\n  }\n</pre>\n<p>Here is\n\n<a href=\"zip/ExportWallboard03.zip\">\nExportWallboard03.zip</a> including the complete source code, Visual Studio solution and add-in manifest of the current state of this external command.\n\n<p>There are obviously still some implementation details to iron out.\n\n\n\n<a name=\"5\"></a>\n<h3>Handling Temporary Transactions and Regeneration</h3>\n<p>Luckily, I took a closer look at the generated DXF output files before letting this command loose on humanity.</p>\n<p>To my horror, I discovered that all files generated except the first one contain no geometry.</p>\n<p>As it turns out, there is an issue with the regeneration and view settings in my original implementation.</p>\n<p>After quite a bit of experimentation, I found out that I can successfully generate the individual files if I add the following steps:</p>\n<ul>\n<li>Add code to switch off the first temporary isolation before applying the next one.</li>\n<li>Commit the transaction to temporaily isolate each part before calling Export.</li>\n<li>This requires encapsulating all the temporary transactions in a group and rolling back the entire group instead of the individual transactions, as described for the\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2012/11/temporary-transaction-trick-touchup.html\">temporary transaction trick touchup</a>.</li>\n<li>Separate the code to switch off the last temporary isolation and applying the new one into separate transactions.</li>\n</ul>\n<p>The resulting loop exporting all the parts ends up looking like this:</p>\n<pre class=\"code\">\n  <span class=\"blue\">using</span>( <span class=\"teal\">TransactionGroup</span> txg = <span class=\"blue\">new</span> <span class=\"teal\">TransactionGroup</span>( doc ) )\n  {\n    txg.Start( <span class=\"maroon\">\"Export Wall Parts\"</span> );\n \n    <span class=\"blue\">foreach</span>( <span class=\"teal\">ElementId</span> id <span class=\"blue\">in</span> ids )\n    {\n      <span class=\"teal\">Element</span> e = doc.GetElement( id );\n \n      <span class=\"teal\">Debug</span>.Assert( e <span class=\"blue\">is</span> <span class=\"teal\">Part</span>,\n        <span class=\"maroon\">\"expected parts only\"</span> );\n \n      <span class=\"teal\">Part</span> part = e <span class=\"blue\">as</span> <span class=\"teal\">Part</span>;\n \n      <span class=\"teal\">ICollection</span>&lt;<span class=\"teal\">LinkElementId</span>&gt; lids\n        = part.GetSourceElementIds();\n \n      <span class=\"teal\">Debug</span>.Assert( 1 == lids.Count,\n        <span class=\"maroon\">\"unexpected multiple part source elements.\"</span> );\n \n      <span class=\"teal\">LinkElementId</span> lid = lids.First&lt;<span class=\"teal\">LinkElementId</span>&gt;();\n      <span class=\"teal\">ElementId</span> hostId = lid.HostElementId;\n      <span class=\"teal\">ElementId</span> linkedId = lid.LinkedElementId;\n      <span class=\"teal\">ElementId</span> parentId = hostId;\n      <span class=\"teal\">ElementId</span> partId = e.Id;\n \n      filename = <span class=\"blue\">string</span>.Format( <span class=\"maroon\">\"{0}_{1}\"</span>,\n        parentId, partId );\n \n      <span class=\"blue\">if</span>( view.IsTemporaryHideIsolateActive() )\n      {\n        <span class=\"blue\">using</span>( <span class=\"teal\">Transaction</span> tx = <span class=\"blue\">new</span> <span class=\"teal\">Transaction</span>( doc ) )\n        {\n          tx.Start( <span class=\"maroon\">\"Disable Temporary Isolate\"</span> );\n \n          view.DisableTemporaryViewMode(\n            <span class=\"teal\">TemporaryViewMode</span>.TemporaryHideIsolate );\n \n          tx.Commit();\n        }\n \n        <span class=\"teal\">Debug</span>.Assert( !view.IsTemporaryHideIsolateActive(),\n          <span class=\"maroon\">\"expected to turn off temporary hide/isolate\"</span> );\n      }\n \n      <span class=\"blue\">using</span>( <span class=\"teal\">Transaction</span> tx = <span class=\"blue\">new</span> <span class=\"teal\">Transaction</span>( doc ) )\n      {\n        tx.Start( <span class=\"maroon\">\"Export Wall Part \"</span>\n          + partId.ToString() );\n \n        view.IsolateElementTemporary( partId ); <span class=\"green\">// requires transaction</span>\n \n        <span class=\"green\">//List&lt;ElementId&gt; unhideIds = new List&lt;ElementId&gt;( 1 );</span>\n        <span class=\"green\">//unhideIds.Add( partId );</span>\n        <span class=\"green\">//view.UnhideElements( unhideIds );</span>\n \n        <span class=\"green\">//doc.Regenerate(); // this is insufficient</span>\n \n        tx.Commit();\n      }\n \n      doc.Export( _folder, filename, viewIds, opt );\n \n      <span class=\"green\">// We do not commit the transaction group, </span>\n      <span class=\"green\">// because no modifications should be saved.</span>\n      <span class=\"green\">// The transaction group is only created and </span>\n      <span class=\"green\">// started to encapsulate the transactions </span>\n      <span class=\"green\">// required by the IsolateElementTemporary </span>\n      <span class=\"green\">// method. Since the transaction group is not </span>\n      <span class=\"green\">// committed, the changes are automatically </span>\n      <span class=\"green\">// discarded.</span>\n \n      <span class=\"green\">//txg.Commit();</span>\n    }\n  }\n</pre>\n<p>Here is\n\n<a href=\"zip/ExportWallboard04.zip\">\nExportWallboard04.zip</a> including the source code, Visual Studio solution and add-in manifest of the updated version.\n\n<p>I certainly expect more implementation details to crop up that need ironing out.\n\n<p>For instance, I could imagine adding some code to delete the PCP files that are generated together with the DXF output.\nOr is there any reason to keep them?</p>\n<p>I can also imagine that the part identification needs improving.\nCurrently, the command simply uses the part and its source element ids.\nMaybe the part unique id would be better, or the parent element id needs checking, or is unnecessary snd can be completely removed.\n\n<p>Anyway, for a first stab, this implementation now looks pretty good to me.</p>\n</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p>"
  },
  {
    "original_filename": "0906_export_wall_part_dxf",
    "header_text": "Last Day in Napoli",
    "local_header_href": "#last-day-in-napoli",
    "chunk_text": "<h4>Last Day in Napoli</h4><p>I had some wonderful pastry in the\n\n<a href=\"http://www.tripadvisor.com/Restaurant_Review-g187785-d1129216-Reviews-Gran_Bar_Riviera-Naples_Province_of_Naples_Campania.html\">\nGran Bar Riviera</a> pasticceria\n\non the Riviera di Chiaia.\nIncidentally, an old palazzo partially collapsed there last week, just a few hundred meters away from where I was staying.</p><img alt=\"Collapsed palazzo in Riviera di Chiaia\" src=\"file:///j/photo/jeremy/2013/2013-03-08_napoli/p1000534_collapsed_house_cropped.jpg\" width=\"200\"/><img alt=\"Shoemaker Gabriele\" src=\"file:///j/photo/jeremy/2013/2013-03-08_napoli/p1000586_gabriele_shoemaker_cropped.jpg\" width=\"200\"/><img alt=\"Gabriele and Jeremy\" src=\"file:///j/photo/jeremy/2013/2013-03-08_napoli/p1000587_gabriele_jeremy.jpg\" width=\"200\"/><p>Further, I took a pair of old shoes to Gabriele, an extremely sweet and happy 86 years old shoemaker in the Spanish quarter.\nHe repaired them and they look better than new now.\nHe also invited us to coffee and told me his life story.\nIf you ever need a pair of shoes fixed, be sure to look him up in Vico Lungo del Gelso, 108, I-80134 Napoli  :-)</p><p>Two final parting pictures capturing some of the decrepit charm of Naples...</p><img alt=\"Impressions from the Spanish quarter\" src=\"file:///j/photo/jeremy/2013/2013-03-08_napoli/p1000580.jpg\" width=\"200\"/><img alt=\"Impressions from the Spanish quarter\" src=\"file:///j/photo/jeremy/2013/2013-03-08_napoli/p1000592.jpg\" width=\"200\"/><p>Anyway, now I am back at work now again, and we return to the Revit API and my nocturnal dabbling on the train.</p><a name=\"2\"></a>"
  },
  {
    "original_filename": "0906_export_wall_part_dxf",
    "header_text": "Exporting Individual Compound Wall Gyp Wallboard Parts",
    "local_header_href": "#exporting-individual-compound-wall-gyp-wallboard-parts",
    "chunk_text": "<h4>Exporting Individual Compound Wall Gyp Wallboard Parts</h4><p>This query came in from my colleague William Spier, MEP &amp; Design to Fabrication SME at Autodesk\n(<a href=\"http://www.youtube.com/AutodeskMEPTechs\">YouTube</a>,\n<a href=\"http://familyjewels.typepad.com\">Revit Family Jewels</a>).\nHe says:\n\n<p><strong>Question:</strong> I would like to customise two pretty easy things.\n\n<p>The scenario is a compound wall on which I divide the gyp wallboard into standard (4’x8’) sheet size parts.\nI need to export each of those sheets/parts to DXF format, but even though I have divided them into parts, Revit still groups them and exports them as one single DXF file – not as separate ones, like I need.\nThe only way around this is to isolate each part one at a time and export each one individually, which is WAY too laborious.\n\n<p>So I need to customize the export process so that:</p>\n<ol>\n<li>Each part exports as a separate part, even though I globally selected them.</li>\n<li>Each part exports named by its own unique code/identifier – whatever coding keeps each one distinct in the parts schedule.</li>\n</ol>\n<p>Here is a snapshot from a simple sample project:</p>\n<center>\n<img alt=\"Sample wall parts\" src=\"img/sample_wall_parts.png\" width=\"200\"/>\n</center>\n<p><strong>Answer:</strong> A first search for related API methods turn up the following potentially useful items:\n\n<ul>\n<li>Document.Export( string, string, ICollection&lt;ElementId&gt;, DXFExportOptions )\n<li>View.IsolateElementTemporary(\tElementId )\n<li>Part.ParentDividedElementId property (obsolete)\n<li>Part.GetSourceElementOriginalCategoryIds method (obsolete)\n<li>Part.GetSourceElementIds method\n</li></li></li></li></li></ul>\n<p>Skipping the obsolete ones, it turns out to be really easy to implement a first working version that I packaged in an external command named ExportWallboard.\n\n<p>I first check that a valid document is provided and a 3D view is active that we can use for isolating and exporting each part:\n\n<pre class=\"code\">\n  <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == doc )\n  {\n    ErrorMsg( <span class=\"maroon\">\"Please run this command in a valid\"</span>\n      + <span class=\"maroon\">\" Revit project document.\"</span> );\n    <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n  }\n \n  <span class=\"teal\">View</span> view = doc.ActiveView;\n \n  <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == view || !( view <span class=\"blue\">is</span> <span class=\"teal\">View3D</span> ) )\n  {\n    ErrorMsg( <span class=\"maroon\">\"Please run this command in a valid\"</span>\n      + <span class=\"maroon\">\" 3D view.\"</span> );\n    <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n  }\n \n  <span class=\"green\">// Define the list of views to export, </span>\n  <span class=\"green\">// including only the current 3D view</span>\n \n  <span class=\"teal\">List</span>&lt;<span class=\"teal\">ElementId</span>&gt; viewIds = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">ElementId</span>&gt;( 1 );\n  viewIds.Add( view.Id );\n</pre>\n<p>Basically, all that is required is to follow the steps suggested above:</p>\n<ul>\n<li>Isolate each part</li>\n<li>Define the DXF filename</li>\n<li>Call the export method</li>\n</ul>\n<pre class=\"code\">\n  <span class=\"teal\">Element</span> e = doc.GetElement( id );\n \n  <span class=\"teal\">Debug</span>.Assert( e <span class=\"blue\">is</span> <span class=\"teal\">Part</span>,\n    <span class=\"maroon\">\"expected parts only\"</span> );\n \n  <span class=\"teal\">Part</span> part = e <span class=\"blue\">as</span> <span class=\"teal\">Part</span>;\n \n  <span class=\"teal\">ICollection</span>&lt;<span class=\"teal\">LinkElementId</span>&gt; lids\n    = part.GetSourceElementIds();\n \n  <span class=\"teal\">Debug</span>.Assert( 1 == lids.Count,\n    <span class=\"maroon\">\"unexpected multiple part source elements.\"</span> );\n \n  <span class=\"teal\">LinkElementId</span> lid = lids.First&lt;<span class=\"teal\">LinkElementId</span>&gt;();\n  <span class=\"teal\">ElementId</span> hostId = lid.HostElementId;\n  <span class=\"teal\">ElementId</span> linkedId = lid.LinkedElementId;\n  <span class=\"teal\">ElementId</span> parentId = hostId;\n  <span class=\"teal\">ElementId</span> partId = e.Id;\n \n  filename = <span class=\"blue\">string</span>.Format( <span class=\"maroon\">\"{0}_{1}\"</span>,\n    parentId, partId );\n \n  view.IsolateElementTemporary( partId );\n \n  doc.Export( _folder, filename, viewIds, opt );\n</pre>\n<p>The IsolateElementTemporary method requires a transaction, so even though the whole operation is theoretically read-only, we still need to specify manual transaction mode for this command.\nWe encapsulate the isolate and export method in a transaction that is later rolled back, so the model ends up unchanged after all.</p>\n<a name=\"3\"></a>\n<h3>Handling and Dismissing a Warning Message</h3>\n<p>However, a complication arises:\n\n<p>Calling the Export method with an isolated element in the current view displays a task dialogue warning message:\n\n<center>\n<img alt=\"Exporting a view with isolated element warning\" src=\"img/export_with_isolate_warning.png\" width=\"400\"/>\n</center>\n<p>I repeatedly discussed how to automatically handle messages like this in the past, e.g. to\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2012/10/detach-workset-and-taskdialog-command-link-order.html\">\ndetach a workset</a>.</p>\n<p>To be notified of this message, we subscribe to the DialogShowing event:</p>\n<pre class=\"code\">\n  uiapp.DialogBoxShowing\n    += <span class=\"blue\">new</span> <span class=\"teal\">EventHandler</span>&lt;<span class=\"teal\">DialogBoxShowingEventArgs</span>&gt;(\n      OnDialogBoxShowing );\n</pre>\n<p>Do not forget to unsubscribe afterwards.\nIn this case, we can do so at the end of the command.\n\n<p>To ensure that the unsubscription is performed whatever happens, regardless of any potential errors, I encapsulate the whole operation in a try statement and unsubscribe in its 'finally' clause.\n\n<pre class=\"code\">\n  <span class=\"blue\">try</span>\n  {\n    <span class=\"green\">// Register event handler for </span>\n    <span class=\"green\">// \"TaskDialog_Really_Print_Or_Export_Temp_View_Modes\" </span>\n    <span class=\"green\">// dialogue</span>\n \n    uiapp.DialogBoxShowing\n      += <span class=\"blue\">new</span> <span class=\"teal\">EventHandler</span>&lt;<span class=\"teal\">DialogBoxShowingEventArgs</span>&gt;(\n        OnDialogBoxShowing );\n \n    <span class=\"teal\">DXFExportOptions</span> opt = <span class=\"blue\">new</span> <span class=\"teal\">DXFExportOptions</span>();\n \n    <span class=\"blue\">string</span> filename;\n \n    <span class=\"blue\">using</span>( <span class=\"teal\">Transaction</span> tx = <span class=\"blue\">new</span> <span class=\"teal\">Transaction</span>( doc ) )\n    {\n      tx.Start( <span class=\"maroon\">\"Transaction Name\"</span> );\n \n      <span class=\"blue\">foreach</span>( <span class=\"teal\">ElementId</span> id <span class=\"blue\">in</span> ids )\n      {\n        <span class=\"teal\">Element</span> e = doc.GetElement( id );\n \n        <span class=\"green\">// . . .</span>\n \n        view.IsolateElementTemporary( partId );\n \n        doc.Export( _folder, filename, viewIds, opt );\n      }\n \n      <span class=\"green\">// We do not commit the transaction, because</span>\n      <span class=\"green\">// we do not want any modifications saved.</span>\n      <span class=\"green\">// The transaction is only created and started</span>\n      <span class=\"green\">// because it is required by the</span>\n      <span class=\"green\">// IsolateElementTemporary method.</span>\n      <span class=\"green\">// Since the transaction is not committed, </span>\n      <span class=\"green\">// the changes are automatically discarded.</span>\n \n      <span class=\"green\">//tx.Commit();</span>\n    }\n  }\n  <span class=\"blue\">finally</span>\n  {\n    uiapp.DialogBoxShowing\n      -= <span class=\"blue\">new</span> <span class=\"teal\">EventHandler</span>&lt;<span class=\"teal\">DialogBoxShowingEventArgs</span>&gt;(\n        OnDialogBoxShowing );\n  }\n  <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Succeeded;\n</pre>\n<p>Initially, I did not yet know exactly which dialogue id to use to identify this specific message.\nI therefore first implemented a dummy DialogBoxShowing event handler, triggered the event, and determined the dialogue id to use by re-running the command and looking at the event handler argument in the debugger.\n\n<p>As it turns out, the required dialogue id in our case is \"TaskDialog_Really_Print_Or_Export_Temp_View_Modes\".\nWe wish to retain the temporary isolate mode and export, i.e. select the second command link option.\nTherefore, the final dialogue box showing event handler implementation becomes:\n\n<pre class=\"code\">\n<span class=\"blue\">void</span> OnDialogBoxShowing(\n  <span class=\"blue\">object</span> sender,\n  <span class=\"teal\">DialogBoxShowingEventArgs</span> e )\n{\n  <span class=\"teal\">TaskDialogShowingEventArgs</span> e2\n    = e <span class=\"blue\">as</span> <span class=\"teal\">TaskDialogShowingEventArgs</span>;\n \n  <span class=\"blue\">if</span>( <span class=\"blue\">null</span> != e2 &amp;&amp; e2.DialogId.Equals(\n    <span class=\"maroon\">\"TaskDialog_Really_Print_Or_Export_Temp_View_Modes\"</span> ) )\n  {\n    e.OverrideResult(\n      (<span class=\"blue\">int</span>)<span class=\"teal\">TaskDialogResult</span>.CommandLink2 );\n  }\n}\n</pre>\n<a name=\"4\"></a>\n<h3>Adding Support for both Pre- and Post- Part Selection</h3>\n<p>In the initial implementation, I just went ahead and used the pre-selected set of parts defined by the user before launching the external command, accessible via the uidoc.Selection.Elements collection.\n\n<p>However, it is much more user friendly to also support post-selection.\nFor that case, it is also useful to implement a selection filter to simplify easy mass selection of the parts.\n\n<p>In order to handle the elements identically regardless of whether they were pre- or post-selected, I convert the selection set to a list of element ids in both cases.\n\n<p>For the pre-selection, I iterate over the pre-selected elements and test each one as follows:\n\n<pre class=\"code\">\n  <span class=\"green\">// Iterate over all pre-selected parts</span>\n \n  <span class=\"teal\">List</span>&lt;<span class=\"teal\">ElementId</span>&gt; ids = <span class=\"blue\">null</span>;\n \n  <span class=\"teal\">Selection</span> sel = uidoc.Selection;\n \n  <span class=\"blue\">if</span>( 0 &lt; sel.Elements.Size )\n  {\n    <span class=\"blue\">foreach</span>( <span class=\"teal\">Element</span> e <span class=\"blue\">in</span> sel.Elements )\n    {\n      <span class=\"blue\">if</span>( !( e <span class=\"blue\">is</span> <span class=\"teal\">Part</span> ) )\n      {\n        ErrorMsg( <span class=\"maroon\">\"Please pre-select only gyp wallboard\"</span>\n          + <span class=\"maroon\">\" parts before running this command.\"</span> );\n        <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n      }\n \n      <span class=\"teal\">Part</span> part = e <span class=\"blue\">as</span> <span class=\"teal\">Part</span>;\n \n      <span class=\"teal\">ICollection</span>&lt;<span class=\"teal\">LinkElementId</span>&gt; lids\n        = part.GetSourceElementIds();\n \n      <span class=\"blue\">if</span>( 1 != lids.Count )\n      {\n        ErrorMsg( <span class=\"maroon\">\"Gyp wallboard parts has multiple\"</span>\n          + <span class=\"maroon\">\" source elements.\"</span> );\n        <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n      }\n \n      <span class=\"teal\">LinkElementId</span> lid = lids.First&lt;<span class=\"teal\">LinkElementId</span>&gt;();\n      <span class=\"teal\">ElementId</span> hostId = lid.HostElementId;\n      <span class=\"teal\">ElementId</span> linkedId = lid.LinkedElementId;\n      <span class=\"teal\">ElementId</span> parentId = hostId;\n      <span class=\"teal\">ElementId</span> partId = e.Id;\n \n      <span class=\"green\">// Determine parent category</span>\n \n      <span class=\"teal\">Element</span> parent = doc.GetElement( parentId );\n      <span class=\"teal\">Category</span> cat = parent.Category;\n \n      <span class=\"teal\">ICollection</span>&lt;<span class=\"teal\">ElementId</span>&gt; cids\n        = part.GetSourceElementOriginalCategoryIds();\n \n      <span class=\"blue\">if</span>( 1 != cids.Count )\n      {\n        ErrorMsg( <span class=\"maroon\">\"Gyp wallboard parts has multiple\"</span>\n          + <span class=\"maroon\">\" source element categories.\"</span> );\n        <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n      }\n \n      <span class=\"teal\">ElementId</span> cid = cids.First&lt;<span class=\"teal\">ElementId</span>&gt;();\n \n      <span class=\"green\">//cat = doc.GetElement( id ) as Category;</span>\n \n      <span class=\"green\">// Expected parent category is OST_Walls</span>\n \n      <span class=\"teal\">BuiltInCategory</span> bic\n        = (<span class=\"teal\">BuiltInCategory</span>)cid.IntegerValue;\n \n      <span class=\"blue\">if</span>( <span class=\"teal\">BuiltInCategory</span>.OST_Walls != bic )\n      {\n        ErrorMsg( <span class=\"maroon\">\"Pleqase pre-select only \"</span>\n          + <span class=\"maroon\">\" gyp wallboard parts.\"</span> );\n        <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n      }\n \n      <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == ids )\n      {\n        ids = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">ElementId</span>&gt;( 1 );\n      }\n \n      ids.Add( partId );\n    }\n \n    <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == ids )\n    {\n      ErrorMsg( <span class=\"maroon\">\"Please pre-select only gyp wallboard\"</span>\n        + <span class=\"maroon\">\" parts before running this command.\"</span> );\n      <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n    }\n  }\n</pre>\n<p>The category of the source elements can be determined using the Part.GetSourceElementOriginalCategoryIds method, which unsurprisingly turns out to be OST_Walls.</p>\n<p>I use that to check the part source element category like this in the final selection filter implementation:\n\n<pre class=\"code\">\n<span class=\"blue\">class</span> <span class=\"teal\">WallPartSelectionFilter</span> : <span class=\"teal\">ISelectionFilter</span>\n{\n  <span class=\"blue\">public</span> <span class=\"blue\">bool</span> AllowElement( <span class=\"teal\">Element</span> e )\n  {\n    <span class=\"blue\">bool</span> rc = <span class=\"blue\">false</span>;\n \n    <span class=\"teal\">Part</span> part = e <span class=\"blue\">as</span> <span class=\"teal\">Part</span>;\n \n    <span class=\"blue\">if</span>( <span class=\"blue\">null</span> != part )\n    {\n      <span class=\"teal\">ICollection</span>&lt;<span class=\"teal\">ElementId</span>&gt; cids\n        = part.GetSourceElementOriginalCategoryIds();\n \n      <span class=\"blue\">if</span>( 1 == cids.Count )\n      {\n        <span class=\"teal\">ElementId</span> cid = cids.First&lt;<span class=\"teal\">ElementId</span>&gt;();\n \n        <span class=\"teal\">BuiltInCategory</span> bic\n          = (<span class=\"teal\">BuiltInCategory</span>)cid.IntegerValue;\n \n        rc = ( <span class=\"teal\">BuiltInCategory</span>.OST_Walls == bic );\n      }\n    }\n    <span class=\"blue\">return</span> rc;\n  }\n \n  <span class=\"blue\">public</span> <span class=\"blue\">bool</span> AllowReference( <span class=\"teal\">Reference</span> r, <span class=\"teal\">XYZ</span> p )\n  {\n    <span class=\"blue\">return</span> <span class=\"blue\">true</span>;\n  }\n}\n</pre>\n<!--\n<p>Running this test code shows that the desired parent category is OST_Walls, as expected.\n\n<p>Based on that, I implemented the following wall part selection filter:\n-->\n<p>For the post-selection, the selection filter ensures that no inappropriate parts can be selected, so no additional scan is required to test the references returned by the PickObjects method.\n\n<p>I can use a generic LINQ method to convert the collection of resulting references to the list of element ids:\n\n<pre class=\"code\">\n  <span class=\"green\">// If no parts were pre-selected, </span>\n  <span class=\"green\">// prompt for post-selection</span>\n \n  <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == ids )\n  {\n    <span class=\"teal\">IList</span>&lt;<span class=\"teal\">Reference</span>&gt; refs = <span class=\"blue\">null</span>;\n \n    <span class=\"blue\">try</span>\n    {\n      refs = sel.PickObjects( <span class=\"teal\">ObjectType</span>.Element,\n        <span class=\"blue\">new</span> <span class=\"teal\">WallPartSelectionFilter</span>(),\n        <span class=\"maroon\">\"Please select wall parts.\"</span> );\n    }\n    <span class=\"blue\">catch</span>( Autodesk.Revit.Exceptions\n      .<span class=\"teal\">OperationCanceledException</span> )\n    {\n      <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Cancelled;\n    }\n    ids = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">ElementId</span>&gt;(\n      refs.Select&lt;<span class=\"teal\">Reference</span>, <span class=\"teal\">ElementId</span>&gt;(\n        r =&gt; r.ElementId ) );\n  }\n</pre>\n<p>Here is\n\n<a href=\"zip/ExportWallboard03.zip\">\nExportWallboard03.zip</a> including the complete source code, Visual Studio solution and add-in manifest of the current state of this external command.\n\n<p>There are obviously still some implementation details to iron out.\n\n\n\n<a name=\"5\"></a>\n<h3>Handling Temporary Transactions and Regeneration</h3>\n<p>Luckily, I took a closer look at the generated DXF output files before letting this command loose on humanity.</p>\n<p>To my horror, I discovered that all files generated except the first one contain no geometry.</p>\n<p>As it turns out, there is an issue with the regeneration and view settings in my original implementation.</p>\n<p>After quite a bit of experimentation, I found out that I can successfully generate the individual files if I add the following steps:</p>\n<ul>\n<li>Add code to switch off the first temporary isolation before applying the next one.</li>\n<li>Commit the transaction to temporaily isolate each part before calling Export.</li>\n<li>This requires encapsulating all the temporary transactions in a group and rolling back the entire group instead of the individual transactions, as described for the\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2012/11/temporary-transaction-trick-touchup.html\">temporary transaction trick touchup</a>.</li>\n<li>Separate the code to switch off the last temporary isolation and applying the new one into separate transactions.</li>\n</ul>\n<p>The resulting loop exporting all the parts ends up looking like this:</p>\n<pre class=\"code\">\n  <span class=\"blue\">using</span>( <span class=\"teal\">TransactionGroup</span> txg = <span class=\"blue\">new</span> <span class=\"teal\">TransactionGroup</span>( doc ) )\n  {\n    txg.Start( <span class=\"maroon\">\"Export Wall Parts\"</span> );\n \n    <span class=\"blue\">foreach</span>( <span class=\"teal\">ElementId</span> id <span class=\"blue\">in</span> ids )\n    {\n      <span class=\"teal\">Element</span> e = doc.GetElement( id );\n \n      <span class=\"teal\">Debug</span>.Assert( e <span class=\"blue\">is</span> <span class=\"teal\">Part</span>,\n        <span class=\"maroon\">\"expected parts only\"</span> );\n \n      <span class=\"teal\">Part</span> part = e <span class=\"blue\">as</span> <span class=\"teal\">Part</span>;\n \n      <span class=\"teal\">ICollection</span>&lt;<span class=\"teal\">LinkElementId</span>&gt; lids\n        = part.GetSourceElementIds();\n \n      <span class=\"teal\">Debug</span>.Assert( 1 == lids.Count,\n        <span class=\"maroon\">\"unexpected multiple part source elements.\"</span> );\n \n      <span class=\"teal\">LinkElementId</span> lid = lids.First&lt;<span class=\"teal\">LinkElementId</span>&gt;();\n      <span class=\"teal\">ElementId</span> hostId = lid.HostElementId;\n      <span class=\"teal\">ElementId</span> linkedId = lid.LinkedElementId;\n      <span class=\"teal\">ElementId</span> parentId = hostId;\n      <span class=\"teal\">ElementId</span> partId = e.Id;\n \n      filename = <span class=\"blue\">string</span>.Format( <span class=\"maroon\">\"{0}_{1}\"</span>,\n        parentId, partId );\n \n      <span class=\"blue\">if</span>( view.IsTemporaryHideIsolateActive() )\n      {\n        <span class=\"blue\">using</span>( <span class=\"teal\">Transaction</span> tx = <span class=\"blue\">new</span> <span class=\"teal\">Transaction</span>( doc ) )\n        {\n          tx.Start( <span class=\"maroon\">\"Disable Temporary Isolate\"</span> );\n \n          view.DisableTemporaryViewMode(\n            <span class=\"teal\">TemporaryViewMode</span>.TemporaryHideIsolate );\n \n          tx.Commit();\n        }\n \n        <span class=\"teal\">Debug</span>.Assert( !view.IsTemporaryHideIsolateActive(),\n          <span class=\"maroon\">\"expected to turn off temporary hide/isolate\"</span> );\n      }\n \n      <span class=\"blue\">using</span>( <span class=\"teal\">Transaction</span> tx = <span class=\"blue\">new</span> <span class=\"teal\">Transaction</span>( doc ) )\n      {\n        tx.Start( <span class=\"maroon\">\"Export Wall Part \"</span>\n          + partId.ToString() );\n \n        view.IsolateElementTemporary( partId ); <span class=\"green\">// requires transaction</span>\n \n        <span class=\"green\">//List&lt;ElementId&gt; unhideIds = new List&lt;ElementId&gt;( 1 );</span>\n        <span class=\"green\">//unhideIds.Add( partId );</span>\n        <span class=\"green\">//view.UnhideElements( unhideIds );</span>\n \n        <span class=\"green\">//doc.Regenerate(); // this is insufficient</span>\n \n        tx.Commit();\n      }\n \n      doc.Export( _folder, filename, viewIds, opt );\n \n      <span class=\"green\">// We do not commit the transaction group, </span>\n      <span class=\"green\">// because no modifications should be saved.</span>\n      <span class=\"green\">// The transaction group is only created and </span>\n      <span class=\"green\">// started to encapsulate the transactions </span>\n      <span class=\"green\">// required by the IsolateElementTemporary </span>\n      <span class=\"green\">// method. Since the transaction group is not </span>\n      <span class=\"green\">// committed, the changes are automatically </span>\n      <span class=\"green\">// discarded.</span>\n \n      <span class=\"green\">//txg.Commit();</span>\n    }\n  }\n</pre>\n<p>Here is\n\n<a href=\"zip/ExportWallboard04.zip\">\nExportWallboard04.zip</a> including the source code, Visual Studio solution and add-in manifest of the updated version.\n\n<p>I certainly expect more implementation details to crop up that need ironing out.\n\n<p>For instance, I could imagine adding some code to delete the PCP files that are generated together with the DXF output.\nOr is there any reason to keep them?</p>\n<p>I can also imagine that the part identification needs improving.\nCurrently, the command simply uses the part and its source element ids.\nMaybe the part unique id would be better, or the parent element id needs checking, or is unnecessary snd can be completely removed.\n\n<p>Anyway, for a first stab, this implementation now looks pretty good to me.</p>\n</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p>"
  },
  {
    "original_filename": "0906_export_wall_part_dxf",
    "header_text": "Handling and Dismissing a Warning Message",
    "local_header_href": "#handling-and-dismissing-a-warning-message",
    "chunk_text": "<h3>Handling and Dismissing a Warning Message</h3><p>However, a complication arises:\n\n<p>Calling the Export method with an isolated element in the current view displays a task dialogue warning message:\n\n<center>\n<img alt=\"Exporting a view with isolated element warning\" src=\"img/export_with_isolate_warning.png\" width=\"400\"/>\n</center>\n<p>I repeatedly discussed how to automatically handle messages like this in the past, e.g. to\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2012/10/detach-workset-and-taskdialog-command-link-order.html\">\ndetach a workset</a>.</p>\n<p>To be notified of this message, we subscribe to the DialogShowing event:</p>\n<pre class=\"code\">\n  uiapp.DialogBoxShowing\n    += <span class=\"blue\">new</span> <span class=\"teal\">EventHandler</span>&lt;<span class=\"teal\">DialogBoxShowingEventArgs</span>&gt;(\n      OnDialogBoxShowing );\n</pre>\n<p>Do not forget to unsubscribe afterwards.\nIn this case, we can do so at the end of the command.\n\n<p>To ensure that the unsubscription is performed whatever happens, regardless of any potential errors, I encapsulate the whole operation in a try statement and unsubscribe in its 'finally' clause.\n\n<pre class=\"code\">\n  <span class=\"blue\">try</span>\n  {\n    <span class=\"green\">// Register event handler for </span>\n    <span class=\"green\">// \"TaskDialog_Really_Print_Or_Export_Temp_View_Modes\" </span>\n    <span class=\"green\">// dialogue</span>\n \n    uiapp.DialogBoxShowing\n      += <span class=\"blue\">new</span> <span class=\"teal\">EventHandler</span>&lt;<span class=\"teal\">DialogBoxShowingEventArgs</span>&gt;(\n        OnDialogBoxShowing );\n \n    <span class=\"teal\">DXFExportOptions</span> opt = <span class=\"blue\">new</span> <span class=\"teal\">DXFExportOptions</span>();\n \n    <span class=\"blue\">string</span> filename;\n \n    <span class=\"blue\">using</span>( <span class=\"teal\">Transaction</span> tx = <span class=\"blue\">new</span> <span class=\"teal\">Transaction</span>( doc ) )\n    {\n      tx.Start( <span class=\"maroon\">\"Transaction Name\"</span> );\n \n      <span class=\"blue\">foreach</span>( <span class=\"teal\">ElementId</span> id <span class=\"blue\">in</span> ids )\n      {\n        <span class=\"teal\">Element</span> e = doc.GetElement( id );\n \n        <span class=\"green\">// . . .</span>\n \n        view.IsolateElementTemporary( partId );\n \n        doc.Export( _folder, filename, viewIds, opt );\n      }\n \n      <span class=\"green\">// We do not commit the transaction, because</span>\n      <span class=\"green\">// we do not want any modifications saved.</span>\n      <span class=\"green\">// The transaction is only created and started</span>\n      <span class=\"green\">// because it is required by the</span>\n      <span class=\"green\">// IsolateElementTemporary method.</span>\n      <span class=\"green\">// Since the transaction is not committed, </span>\n      <span class=\"green\">// the changes are automatically discarded.</span>\n \n      <span class=\"green\">//tx.Commit();</span>\n    }\n  }\n  <span class=\"blue\">finally</span>\n  {\n    uiapp.DialogBoxShowing\n      -= <span class=\"blue\">new</span> <span class=\"teal\">EventHandler</span>&lt;<span class=\"teal\">DialogBoxShowingEventArgs</span>&gt;(\n        OnDialogBoxShowing );\n  }\n  <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Succeeded;\n</pre>\n<p>Initially, I did not yet know exactly which dialogue id to use to identify this specific message.\nI therefore first implemented a dummy DialogBoxShowing event handler, triggered the event, and determined the dialogue id to use by re-running the command and looking at the event handler argument in the debugger.\n\n<p>As it turns out, the required dialogue id in our case is \"TaskDialog_Really_Print_Or_Export_Temp_View_Modes\".\nWe wish to retain the temporary isolate mode and export, i.e. select the second command link option.\nTherefore, the final dialogue box showing event handler implementation becomes:\n\n<pre class=\"code\">\n<span class=\"blue\">void</span> OnDialogBoxShowing(\n  <span class=\"blue\">object</span> sender,\n  <span class=\"teal\">DialogBoxShowingEventArgs</span> e )\n{\n  <span class=\"teal\">TaskDialogShowingEventArgs</span> e2\n    = e <span class=\"blue\">as</span> <span class=\"teal\">TaskDialogShowingEventArgs</span>;\n \n  <span class=\"blue\">if</span>( <span class=\"blue\">null</span> != e2 &amp;&amp; e2.DialogId.Equals(\n    <span class=\"maroon\">\"TaskDialog_Really_Print_Or_Export_Temp_View_Modes\"</span> ) )\n  {\n    e.OverrideResult(\n      (<span class=\"blue\">int</span>)<span class=\"teal\">TaskDialogResult</span>.CommandLink2 );\n  }\n}\n</pre>\n<a name=\"4\"></a>\n<h3>Adding Support for both Pre- and Post- Part Selection</h3>\n<p>In the initial implementation, I just went ahead and used the pre-selected set of parts defined by the user before launching the external command, accessible via the uidoc.Selection.Elements collection.\n\n<p>However, it is much more user friendly to also support post-selection.\nFor that case, it is also useful to implement a selection filter to simplify easy mass selection of the parts.\n\n<p>In order to handle the elements identically regardless of whether they were pre- or post-selected, I convert the selection set to a list of element ids in both cases.\n\n<p>For the pre-selection, I iterate over the pre-selected elements and test each one as follows:\n\n<pre class=\"code\">\n  <span class=\"green\">// Iterate over all pre-selected parts</span>\n \n  <span class=\"teal\">List</span>&lt;<span class=\"teal\">ElementId</span>&gt; ids = <span class=\"blue\">null</span>;\n \n  <span class=\"teal\">Selection</span> sel = uidoc.Selection;\n \n  <span class=\"blue\">if</span>( 0 &lt; sel.Elements.Size )\n  {\n    <span class=\"blue\">foreach</span>( <span class=\"teal\">Element</span> e <span class=\"blue\">in</span> sel.Elements )\n    {\n      <span class=\"blue\">if</span>( !( e <span class=\"blue\">is</span> <span class=\"teal\">Part</span> ) )\n      {\n        ErrorMsg( <span class=\"maroon\">\"Please pre-select only gyp wallboard\"</span>\n          + <span class=\"maroon\">\" parts before running this command.\"</span> );\n        <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n      }\n \n      <span class=\"teal\">Part</span> part = e <span class=\"blue\">as</span> <span class=\"teal\">Part</span>;\n \n      <span class=\"teal\">ICollection</span>&lt;<span class=\"teal\">LinkElementId</span>&gt; lids\n        = part.GetSourceElementIds();\n \n      <span class=\"blue\">if</span>( 1 != lids.Count )\n      {\n        ErrorMsg( <span class=\"maroon\">\"Gyp wallboard parts has multiple\"</span>\n          + <span class=\"maroon\">\" source elements.\"</span> );\n        <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n      }\n \n      <span class=\"teal\">LinkElementId</span> lid = lids.First&lt;<span class=\"teal\">LinkElementId</span>&gt;();\n      <span class=\"teal\">ElementId</span> hostId = lid.HostElementId;\n      <span class=\"teal\">ElementId</span> linkedId = lid.LinkedElementId;\n      <span class=\"teal\">ElementId</span> parentId = hostId;\n      <span class=\"teal\">ElementId</span> partId = e.Id;\n \n      <span class=\"green\">// Determine parent category</span>\n \n      <span class=\"teal\">Element</span> parent = doc.GetElement( parentId );\n      <span class=\"teal\">Category</span> cat = parent.Category;\n \n      <span class=\"teal\">ICollection</span>&lt;<span class=\"teal\">ElementId</span>&gt; cids\n        = part.GetSourceElementOriginalCategoryIds();\n \n      <span class=\"blue\">if</span>( 1 != cids.Count )\n      {\n        ErrorMsg( <span class=\"maroon\">\"Gyp wallboard parts has multiple\"</span>\n          + <span class=\"maroon\">\" source element categories.\"</span> );\n        <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n      }\n \n      <span class=\"teal\">ElementId</span> cid = cids.First&lt;<span class=\"teal\">ElementId</span>&gt;();\n \n      <span class=\"green\">//cat = doc.GetElement( id ) as Category;</span>\n \n      <span class=\"green\">// Expected parent category is OST_Walls</span>\n \n      <span class=\"teal\">BuiltInCategory</span> bic\n        = (<span class=\"teal\">BuiltInCategory</span>)cid.IntegerValue;\n \n      <span class=\"blue\">if</span>( <span class=\"teal\">BuiltInCategory</span>.OST_Walls != bic )\n      {\n        ErrorMsg( <span class=\"maroon\">\"Pleqase pre-select only \"</span>\n          + <span class=\"maroon\">\" gyp wallboard parts.\"</span> );\n        <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n      }\n \n      <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == ids )\n      {\n        ids = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">ElementId</span>&gt;( 1 );\n      }\n \n      ids.Add( partId );\n    }\n \n    <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == ids )\n    {\n      ErrorMsg( <span class=\"maroon\">\"Please pre-select only gyp wallboard\"</span>\n        + <span class=\"maroon\">\" parts before running this command.\"</span> );\n      <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n    }\n  }\n</pre>\n<p>The category of the source elements can be determined using the Part.GetSourceElementOriginalCategoryIds method, which unsurprisingly turns out to be OST_Walls.</p>\n<p>I use that to check the part source element category like this in the final selection filter implementation:\n\n<pre class=\"code\">\n<span class=\"blue\">class</span> <span class=\"teal\">WallPartSelectionFilter</span> : <span class=\"teal\">ISelectionFilter</span>\n{\n  <span class=\"blue\">public</span> <span class=\"blue\">bool</span> AllowElement( <span class=\"teal\">Element</span> e )\n  {\n    <span class=\"blue\">bool</span> rc = <span class=\"blue\">false</span>;\n \n    <span class=\"teal\">Part</span> part = e <span class=\"blue\">as</span> <span class=\"teal\">Part</span>;\n \n    <span class=\"blue\">if</span>( <span class=\"blue\">null</span> != part )\n    {\n      <span class=\"teal\">ICollection</span>&lt;<span class=\"teal\">ElementId</span>&gt; cids\n        = part.GetSourceElementOriginalCategoryIds();\n \n      <span class=\"blue\">if</span>( 1 == cids.Count )\n      {\n        <span class=\"teal\">ElementId</span> cid = cids.First&lt;<span class=\"teal\">ElementId</span>&gt;();\n \n        <span class=\"teal\">BuiltInCategory</span> bic\n          = (<span class=\"teal\">BuiltInCategory</span>)cid.IntegerValue;\n \n        rc = ( <span class=\"teal\">BuiltInCategory</span>.OST_Walls == bic );\n      }\n    }\n    <span class=\"blue\">return</span> rc;\n  }\n \n  <span class=\"blue\">public</span> <span class=\"blue\">bool</span> AllowReference( <span class=\"teal\">Reference</span> r, <span class=\"teal\">XYZ</span> p )\n  {\n    <span class=\"blue\">return</span> <span class=\"blue\">true</span>;\n  }\n}\n</pre>\n<!--\n<p>Running this test code shows that the desired parent category is OST_Walls, as expected.\n\n<p>Based on that, I implemented the following wall part selection filter:\n-->\n<p>For the post-selection, the selection filter ensures that no inappropriate parts can be selected, so no additional scan is required to test the references returned by the PickObjects method.\n\n<p>I can use a generic LINQ method to convert the collection of resulting references to the list of element ids:\n\n<pre class=\"code\">\n  <span class=\"green\">// If no parts were pre-selected, </span>\n  <span class=\"green\">// prompt for post-selection</span>\n \n  <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == ids )\n  {\n    <span class=\"teal\">IList</span>&lt;<span class=\"teal\">Reference</span>&gt; refs = <span class=\"blue\">null</span>;\n \n    <span class=\"blue\">try</span>\n    {\n      refs = sel.PickObjects( <span class=\"teal\">ObjectType</span>.Element,\n        <span class=\"blue\">new</span> <span class=\"teal\">WallPartSelectionFilter</span>(),\n        <span class=\"maroon\">\"Please select wall parts.\"</span> );\n    }\n    <span class=\"blue\">catch</span>( Autodesk.Revit.Exceptions\n      .<span class=\"teal\">OperationCanceledException</span> )\n    {\n      <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Cancelled;\n    }\n    ids = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">ElementId</span>&gt;(\n      refs.Select&lt;<span class=\"teal\">Reference</span>, <span class=\"teal\">ElementId</span>&gt;(\n        r =&gt; r.ElementId ) );\n  }\n</pre>\n<p>Here is\n\n<a href=\"zip/ExportWallboard03.zip\">\nExportWallboard03.zip</a> including the complete source code, Visual Studio solution and add-in manifest of the current state of this external command.\n\n<p>There are obviously still some implementation details to iron out.\n\n\n\n<a name=\"5\"></a>\n<h3>Handling Temporary Transactions and Regeneration</h3>\n<p>Luckily, I took a closer look at the generated DXF output files before letting this command loose on humanity.</p>\n<p>To my horror, I discovered that all files generated except the first one contain no geometry.</p>\n<p>As it turns out, there is an issue with the regeneration and view settings in my original implementation.</p>\n<p>After quite a bit of experimentation, I found out that I can successfully generate the individual files if I add the following steps:</p>\n<ul>\n<li>Add code to switch off the first temporary isolation before applying the next one.</li>\n<li>Commit the transaction to temporaily isolate each part before calling Export.</li>\n<li>This requires encapsulating all the temporary transactions in a group and rolling back the entire group instead of the individual transactions, as described for the\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2012/11/temporary-transaction-trick-touchup.html\">temporary transaction trick touchup</a>.</li>\n<li>Separate the code to switch off the last temporary isolation and applying the new one into separate transactions.</li>\n</ul>\n<p>The resulting loop exporting all the parts ends up looking like this:</p>\n<pre class=\"code\">\n  <span class=\"blue\">using</span>( <span class=\"teal\">TransactionGroup</span> txg = <span class=\"blue\">new</span> <span class=\"teal\">TransactionGroup</span>( doc ) )\n  {\n    txg.Start( <span class=\"maroon\">\"Export Wall Parts\"</span> );\n \n    <span class=\"blue\">foreach</span>( <span class=\"teal\">ElementId</span> id <span class=\"blue\">in</span> ids )\n    {\n      <span class=\"teal\">Element</span> e = doc.GetElement( id );\n \n      <span class=\"teal\">Debug</span>.Assert( e <span class=\"blue\">is</span> <span class=\"teal\">Part</span>,\n        <span class=\"maroon\">\"expected parts only\"</span> );\n \n      <span class=\"teal\">Part</span> part = e <span class=\"blue\">as</span> <span class=\"teal\">Part</span>;\n \n      <span class=\"teal\">ICollection</span>&lt;<span class=\"teal\">LinkElementId</span>&gt; lids\n        = part.GetSourceElementIds();\n \n      <span class=\"teal\">Debug</span>.Assert( 1 == lids.Count,\n        <span class=\"maroon\">\"unexpected multiple part source elements.\"</span> );\n \n      <span class=\"teal\">LinkElementId</span> lid = lids.First&lt;<span class=\"teal\">LinkElementId</span>&gt;();\n      <span class=\"teal\">ElementId</span> hostId = lid.HostElementId;\n      <span class=\"teal\">ElementId</span> linkedId = lid.LinkedElementId;\n      <span class=\"teal\">ElementId</span> parentId = hostId;\n      <span class=\"teal\">ElementId</span> partId = e.Id;\n \n      filename = <span class=\"blue\">string</span>.Format( <span class=\"maroon\">\"{0}_{1}\"</span>,\n        parentId, partId );\n \n      <span class=\"blue\">if</span>( view.IsTemporaryHideIsolateActive() )\n      {\n        <span class=\"blue\">using</span>( <span class=\"teal\">Transaction</span> tx = <span class=\"blue\">new</span> <span class=\"teal\">Transaction</span>( doc ) )\n        {\n          tx.Start( <span class=\"maroon\">\"Disable Temporary Isolate\"</span> );\n \n          view.DisableTemporaryViewMode(\n            <span class=\"teal\">TemporaryViewMode</span>.TemporaryHideIsolate );\n \n          tx.Commit();\n        }\n \n        <span class=\"teal\">Debug</span>.Assert( !view.IsTemporaryHideIsolateActive(),\n          <span class=\"maroon\">\"expected to turn off temporary hide/isolate\"</span> );\n      }\n \n      <span class=\"blue\">using</span>( <span class=\"teal\">Transaction</span> tx = <span class=\"blue\">new</span> <span class=\"teal\">Transaction</span>( doc ) )\n      {\n        tx.Start( <span class=\"maroon\">\"Export Wall Part \"</span>\n          + partId.ToString() );\n \n        view.IsolateElementTemporary( partId ); <span class=\"green\">// requires transaction</span>\n \n        <span class=\"green\">//List&lt;ElementId&gt; unhideIds = new List&lt;ElementId&gt;( 1 );</span>\n        <span class=\"green\">//unhideIds.Add( partId );</span>\n        <span class=\"green\">//view.UnhideElements( unhideIds );</span>\n \n        <span class=\"green\">//doc.Regenerate(); // this is insufficient</span>\n \n        tx.Commit();\n      }\n \n      doc.Export( _folder, filename, viewIds, opt );\n \n      <span class=\"green\">// We do not commit the transaction group, </span>\n      <span class=\"green\">// because no modifications should be saved.</span>\n      <span class=\"green\">// The transaction group is only created and </span>\n      <span class=\"green\">// started to encapsulate the transactions </span>\n      <span class=\"green\">// required by the IsolateElementTemporary </span>\n      <span class=\"green\">// method. Since the transaction group is not </span>\n      <span class=\"green\">// committed, the changes are automatically </span>\n      <span class=\"green\">// discarded.</span>\n \n      <span class=\"green\">//txg.Commit();</span>\n    }\n  }\n</pre>\n<p>Here is\n\n<a href=\"zip/ExportWallboard04.zip\">\nExportWallboard04.zip</a> including the source code, Visual Studio solution and add-in manifest of the updated version.\n\n<p>I certainly expect more implementation details to crop up that need ironing out.\n\n<p>For instance, I could imagine adding some code to delete the PCP files that are generated together with the DXF output.\nOr is there any reason to keep them?</p>\n<p>I can also imagine that the part identification needs improving.\nCurrently, the command simply uses the part and its source element ids.\nMaybe the part unique id would be better, or the parent element id needs checking, or is unnecessary snd can be completely removed.\n\n<p>Anyway, for a first stab, this implementation now looks pretty good to me.</p>\n</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p>"
  },
  {
    "original_filename": "0906_export_wall_part_dxf",
    "header_text": "Adding Support for both Pre- and Post- Part Selection",
    "local_header_href": "#adding-support-for-both-pre-and-post-part-selection",
    "chunk_text": "<h3>Adding Support for both Pre- and Post- Part Selection</h3><p>In the initial implementation, I just went ahead and used the pre-selected set of parts defined by the user before launching the external command, accessible via the uidoc.Selection.Elements collection.\n\n<p>However, it is much more user friendly to also support post-selection.\nFor that case, it is also useful to implement a selection filter to simplify easy mass selection of the parts.\n\n<p>In order to handle the elements identically regardless of whether they were pre- or post-selected, I convert the selection set to a list of element ids in both cases.\n\n<p>For the pre-selection, I iterate over the pre-selected elements and test each one as follows:\n\n<pre class=\"code\">\n  <span class=\"green\">// Iterate over all pre-selected parts</span>\n \n  <span class=\"teal\">List</span>&lt;<span class=\"teal\">ElementId</span>&gt; ids = <span class=\"blue\">null</span>;\n \n  <span class=\"teal\">Selection</span> sel = uidoc.Selection;\n \n  <span class=\"blue\">if</span>( 0 &lt; sel.Elements.Size )\n  {\n    <span class=\"blue\">foreach</span>( <span class=\"teal\">Element</span> e <span class=\"blue\">in</span> sel.Elements )\n    {\n      <span class=\"blue\">if</span>( !( e <span class=\"blue\">is</span> <span class=\"teal\">Part</span> ) )\n      {\n        ErrorMsg( <span class=\"maroon\">\"Please pre-select only gyp wallboard\"</span>\n          + <span class=\"maroon\">\" parts before running this command.\"</span> );\n        <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n      }\n \n      <span class=\"teal\">Part</span> part = e <span class=\"blue\">as</span> <span class=\"teal\">Part</span>;\n \n      <span class=\"teal\">ICollection</span>&lt;<span class=\"teal\">LinkElementId</span>&gt; lids\n        = part.GetSourceElementIds();\n \n      <span class=\"blue\">if</span>( 1 != lids.Count )\n      {\n        ErrorMsg( <span class=\"maroon\">\"Gyp wallboard parts has multiple\"</span>\n          + <span class=\"maroon\">\" source elements.\"</span> );\n        <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n      }\n \n      <span class=\"teal\">LinkElementId</span> lid = lids.First&lt;<span class=\"teal\">LinkElementId</span>&gt;();\n      <span class=\"teal\">ElementId</span> hostId = lid.HostElementId;\n      <span class=\"teal\">ElementId</span> linkedId = lid.LinkedElementId;\n      <span class=\"teal\">ElementId</span> parentId = hostId;\n      <span class=\"teal\">ElementId</span> partId = e.Id;\n \n      <span class=\"green\">// Determine parent category</span>\n \n      <span class=\"teal\">Element</span> parent = doc.GetElement( parentId );\n      <span class=\"teal\">Category</span> cat = parent.Category;\n \n      <span class=\"teal\">ICollection</span>&lt;<span class=\"teal\">ElementId</span>&gt; cids\n        = part.GetSourceElementOriginalCategoryIds();\n \n      <span class=\"blue\">if</span>( 1 != cids.Count )\n      {\n        ErrorMsg( <span class=\"maroon\">\"Gyp wallboard parts has multiple\"</span>\n          + <span class=\"maroon\">\" source element categories.\"</span> );\n        <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n      }\n \n      <span class=\"teal\">ElementId</span> cid = cids.First&lt;<span class=\"teal\">ElementId</span>&gt;();\n \n      <span class=\"green\">//cat = doc.GetElement( id ) as Category;</span>\n \n      <span class=\"green\">// Expected parent category is OST_Walls</span>\n \n      <span class=\"teal\">BuiltInCategory</span> bic\n        = (<span class=\"teal\">BuiltInCategory</span>)cid.IntegerValue;\n \n      <span class=\"blue\">if</span>( <span class=\"teal\">BuiltInCategory</span>.OST_Walls != bic )\n      {\n        ErrorMsg( <span class=\"maroon\">\"Pleqase pre-select only \"</span>\n          + <span class=\"maroon\">\" gyp wallboard parts.\"</span> );\n        <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n      }\n \n      <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == ids )\n      {\n        ids = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">ElementId</span>&gt;( 1 );\n      }\n \n      ids.Add( partId );\n    }\n \n    <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == ids )\n    {\n      ErrorMsg( <span class=\"maroon\">\"Please pre-select only gyp wallboard\"</span>\n        + <span class=\"maroon\">\" parts before running this command.\"</span> );\n      <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n    }\n  }\n</pre>\n<p>The category of the source elements can be determined using the Part.GetSourceElementOriginalCategoryIds method, which unsurprisingly turns out to be OST_Walls.</p>\n<p>I use that to check the part source element category like this in the final selection filter implementation:\n\n<pre class=\"code\">\n<span class=\"blue\">class</span> <span class=\"teal\">WallPartSelectionFilter</span> : <span class=\"teal\">ISelectionFilter</span>\n{\n  <span class=\"blue\">public</span> <span class=\"blue\">bool</span> AllowElement( <span class=\"teal\">Element</span> e )\n  {\n    <span class=\"blue\">bool</span> rc = <span class=\"blue\">false</span>;\n \n    <span class=\"teal\">Part</span> part = e <span class=\"blue\">as</span> <span class=\"teal\">Part</span>;\n \n    <span class=\"blue\">if</span>( <span class=\"blue\">null</span> != part )\n    {\n      <span class=\"teal\">ICollection</span>&lt;<span class=\"teal\">ElementId</span>&gt; cids\n        = part.GetSourceElementOriginalCategoryIds();\n \n      <span class=\"blue\">if</span>( 1 == cids.Count )\n      {\n        <span class=\"teal\">ElementId</span> cid = cids.First&lt;<span class=\"teal\">ElementId</span>&gt;();\n \n        <span class=\"teal\">BuiltInCategory</span> bic\n          = (<span class=\"teal\">BuiltInCategory</span>)cid.IntegerValue;\n \n        rc = ( <span class=\"teal\">BuiltInCategory</span>.OST_Walls == bic );\n      }\n    }\n    <span class=\"blue\">return</span> rc;\n  }\n \n  <span class=\"blue\">public</span> <span class=\"blue\">bool</span> AllowReference( <span class=\"teal\">Reference</span> r, <span class=\"teal\">XYZ</span> p )\n  {\n    <span class=\"blue\">return</span> <span class=\"blue\">true</span>;\n  }\n}\n</pre>\n<!--\n<p>Running this test code shows that the desired parent category is OST_Walls, as expected.\n\n<p>Based on that, I implemented the following wall part selection filter:\n-->\n<p>For the post-selection, the selection filter ensures that no inappropriate parts can be selected, so no additional scan is required to test the references returned by the PickObjects method.\n\n<p>I can use a generic LINQ method to convert the collection of resulting references to the list of element ids:\n\n<pre class=\"code\">\n  <span class=\"green\">// If no parts were pre-selected, </span>\n  <span class=\"green\">// prompt for post-selection</span>\n \n  <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == ids )\n  {\n    <span class=\"teal\">IList</span>&lt;<span class=\"teal\">Reference</span>&gt; refs = <span class=\"blue\">null</span>;\n \n    <span class=\"blue\">try</span>\n    {\n      refs = sel.PickObjects( <span class=\"teal\">ObjectType</span>.Element,\n        <span class=\"blue\">new</span> <span class=\"teal\">WallPartSelectionFilter</span>(),\n        <span class=\"maroon\">\"Please select wall parts.\"</span> );\n    }\n    <span class=\"blue\">catch</span>( Autodesk.Revit.Exceptions\n      .<span class=\"teal\">OperationCanceledException</span> )\n    {\n      <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Cancelled;\n    }\n    ids = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">ElementId</span>&gt;(\n      refs.Select&lt;<span class=\"teal\">Reference</span>, <span class=\"teal\">ElementId</span>&gt;(\n        r =&gt; r.ElementId ) );\n  }\n</pre>\n<p>Here is\n\n<a href=\"zip/ExportWallboard03.zip\">\nExportWallboard03.zip</a> including the complete source code, Visual Studio solution and add-in manifest of the current state of this external command.\n\n<p>There are obviously still some implementation details to iron out.\n\n\n\n<a name=\"5\"></a>\n<h3>Handling Temporary Transactions and Regeneration</h3>\n<p>Luckily, I took a closer look at the generated DXF output files before letting this command loose on humanity.</p>\n<p>To my horror, I discovered that all files generated except the first one contain no geometry.</p>\n<p>As it turns out, there is an issue with the regeneration and view settings in my original implementation.</p>\n<p>After quite a bit of experimentation, I found out that I can successfully generate the individual files if I add the following steps:</p>\n<ul>\n<li>Add code to switch off the first temporary isolation before applying the next one.</li>\n<li>Commit the transaction to temporaily isolate each part before calling Export.</li>\n<li>This requires encapsulating all the temporary transactions in a group and rolling back the entire group instead of the individual transactions, as described for the\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2012/11/temporary-transaction-trick-touchup.html\">temporary transaction trick touchup</a>.</li>\n<li>Separate the code to switch off the last temporary isolation and applying the new one into separate transactions.</li>\n</ul>\n<p>The resulting loop exporting all the parts ends up looking like this:</p>\n<pre class=\"code\">\n  <span class=\"blue\">using</span>( <span class=\"teal\">TransactionGroup</span> txg = <span class=\"blue\">new</span> <span class=\"teal\">TransactionGroup</span>( doc ) )\n  {\n    txg.Start( <span class=\"maroon\">\"Export Wall Parts\"</span> );\n \n    <span class=\"blue\">foreach</span>( <span class=\"teal\">ElementId</span> id <span class=\"blue\">in</span> ids )\n    {\n      <span class=\"teal\">Element</span> e = doc.GetElement( id );\n \n      <span class=\"teal\">Debug</span>.Assert( e <span class=\"blue\">is</span> <span class=\"teal\">Part</span>,\n        <span class=\"maroon\">\"expected parts only\"</span> );\n \n      <span class=\"teal\">Part</span> part = e <span class=\"blue\">as</span> <span class=\"teal\">Part</span>;\n \n      <span class=\"teal\">ICollection</span>&lt;<span class=\"teal\">LinkElementId</span>&gt; lids\n        = part.GetSourceElementIds();\n \n      <span class=\"teal\">Debug</span>.Assert( 1 == lids.Count,\n        <span class=\"maroon\">\"unexpected multiple part source elements.\"</span> );\n \n      <span class=\"teal\">LinkElementId</span> lid = lids.First&lt;<span class=\"teal\">LinkElementId</span>&gt;();\n      <span class=\"teal\">ElementId</span> hostId = lid.HostElementId;\n      <span class=\"teal\">ElementId</span> linkedId = lid.LinkedElementId;\n      <span class=\"teal\">ElementId</span> parentId = hostId;\n      <span class=\"teal\">ElementId</span> partId = e.Id;\n \n      filename = <span class=\"blue\">string</span>.Format( <span class=\"maroon\">\"{0}_{1}\"</span>,\n        parentId, partId );\n \n      <span class=\"blue\">if</span>( view.IsTemporaryHideIsolateActive() )\n      {\n        <span class=\"blue\">using</span>( <span class=\"teal\">Transaction</span> tx = <span class=\"blue\">new</span> <span class=\"teal\">Transaction</span>( doc ) )\n        {\n          tx.Start( <span class=\"maroon\">\"Disable Temporary Isolate\"</span> );\n \n          view.DisableTemporaryViewMode(\n            <span class=\"teal\">TemporaryViewMode</span>.TemporaryHideIsolate );\n \n          tx.Commit();\n        }\n \n        <span class=\"teal\">Debug</span>.Assert( !view.IsTemporaryHideIsolateActive(),\n          <span class=\"maroon\">\"expected to turn off temporary hide/isolate\"</span> );\n      }\n \n      <span class=\"blue\">using</span>( <span class=\"teal\">Transaction</span> tx = <span class=\"blue\">new</span> <span class=\"teal\">Transaction</span>( doc ) )\n      {\n        tx.Start( <span class=\"maroon\">\"Export Wall Part \"</span>\n          + partId.ToString() );\n \n        view.IsolateElementTemporary( partId ); <span class=\"green\">// requires transaction</span>\n \n        <span class=\"green\">//List&lt;ElementId&gt; unhideIds = new List&lt;ElementId&gt;( 1 );</span>\n        <span class=\"green\">//unhideIds.Add( partId );</span>\n        <span class=\"green\">//view.UnhideElements( unhideIds );</span>\n \n        <span class=\"green\">//doc.Regenerate(); // this is insufficient</span>\n \n        tx.Commit();\n      }\n \n      doc.Export( _folder, filename, viewIds, opt );\n \n      <span class=\"green\">// We do not commit the transaction group, </span>\n      <span class=\"green\">// because no modifications should be saved.</span>\n      <span class=\"green\">// The transaction group is only created and </span>\n      <span class=\"green\">// started to encapsulate the transactions </span>\n      <span class=\"green\">// required by the IsolateElementTemporary </span>\n      <span class=\"green\">// method. Since the transaction group is not </span>\n      <span class=\"green\">// committed, the changes are automatically </span>\n      <span class=\"green\">// discarded.</span>\n \n      <span class=\"green\">//txg.Commit();</span>\n    }\n  }\n</pre>\n<p>Here is\n\n<a href=\"zip/ExportWallboard04.zip\">\nExportWallboard04.zip</a> including the source code, Visual Studio solution and add-in manifest of the updated version.\n\n<p>I certainly expect more implementation details to crop up that need ironing out.\n\n<p>For instance, I could imagine adding some code to delete the PCP files that are generated together with the DXF output.\nOr is there any reason to keep them?</p>\n<p>I can also imagine that the part identification needs improving.\nCurrently, the command simply uses the part and its source element ids.\nMaybe the part unique id would be better, or the parent element id needs checking, or is unnecessary snd can be completely removed.\n\n<p>Anyway, for a first stab, this implementation now looks pretty good to me.</p>\n</p></p></p></p></p></p></p></p></p></p></p></p>"
  },
  {
    "original_filename": "0906_export_wall_part_dxf",
    "header_text": "Handling Temporary Transactions and Regeneration",
    "local_header_href": "#handling-temporary-transactions-and-regeneration",
    "chunk_text": "<h3>Handling Temporary Transactions and Regeneration</h3><p>Luckily, I took a closer look at the generated DXF output files before letting this command loose on humanity.</p><p>To my horror, I discovered that all files generated except the first one contain no geometry.</p><p>As it turns out, there is an issue with the regeneration and view settings in my original implementation.</p><p>After quite a bit of experimentation, I found out that I can successfully generate the individual files if I add the following steps:</p><ul>\n<li>Add code to switch off the first temporary isolation before applying the next one.</li>\n<li>Commit the transaction to temporaily isolate each part before calling Export.</li>\n<li>This requires encapsulating all the temporary transactions in a group and rolling back the entire group instead of the individual transactions, as described for the\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2012/11/temporary-transaction-trick-touchup.html\">temporary transaction trick touchup</a>.</li>\n<li>Separate the code to switch off the last temporary isolation and applying the new one into separate transactions.</li>\n</ul><p>The resulting loop exporting all the parts ends up looking like this:</p><pre class=\"code\">\n  <span class=\"blue\">using</span>( <span class=\"teal\">TransactionGroup</span> txg = <span class=\"blue\">new</span> <span class=\"teal\">TransactionGroup</span>( doc ) )\n  {\n    txg.Start( <span class=\"maroon\">\"Export Wall Parts\"</span> );\n \n    <span class=\"blue\">foreach</span>( <span class=\"teal\">ElementId</span> id <span class=\"blue\">in</span> ids )\n    {\n      <span class=\"teal\">Element</span> e = doc.GetElement( id );\n \n      <span class=\"teal\">Debug</span>.Assert( e <span class=\"blue\">is</span> <span class=\"teal\">Part</span>,\n        <span class=\"maroon\">\"expected parts only\"</span> );\n \n      <span class=\"teal\">Part</span> part = e <span class=\"blue\">as</span> <span class=\"teal\">Part</span>;\n \n      <span class=\"teal\">ICollection</span>&lt;<span class=\"teal\">LinkElementId</span>&gt; lids\n        = part.GetSourceElementIds();\n \n      <span class=\"teal\">Debug</span>.Assert( 1 == lids.Count,\n        <span class=\"maroon\">\"unexpected multiple part source elements.\"</span> );\n \n      <span class=\"teal\">LinkElementId</span> lid = lids.First&lt;<span class=\"teal\">LinkElementId</span>&gt;();\n      <span class=\"teal\">ElementId</span> hostId = lid.HostElementId;\n      <span class=\"teal\">ElementId</span> linkedId = lid.LinkedElementId;\n      <span class=\"teal\">ElementId</span> parentId = hostId;\n      <span class=\"teal\">ElementId</span> partId = e.Id;\n \n      filename = <span class=\"blue\">string</span>.Format( <span class=\"maroon\">\"{0}_{1}\"</span>,\n        parentId, partId );\n \n      <span class=\"blue\">if</span>( view.IsTemporaryHideIsolateActive() )\n      {\n        <span class=\"blue\">using</span>( <span class=\"teal\">Transaction</span> tx = <span class=\"blue\">new</span> <span class=\"teal\">Transaction</span>( doc ) )\n        {\n          tx.Start( <span class=\"maroon\">\"Disable Temporary Isolate\"</span> );\n \n          view.DisableTemporaryViewMode(\n            <span class=\"teal\">TemporaryViewMode</span>.TemporaryHideIsolate );\n \n          tx.Commit();\n        }\n \n        <span class=\"teal\">Debug</span>.Assert( !view.IsTemporaryHideIsolateActive(),\n          <span class=\"maroon\">\"expected to turn off temporary hide/isolate\"</span> );\n      }\n \n      <span class=\"blue\">using</span>( <span class=\"teal\">Transaction</span> tx = <span class=\"blue\">new</span> <span class=\"teal\">Transaction</span>( doc ) )\n      {\n        tx.Start( <span class=\"maroon\">\"Export Wall Part \"</span>\n          + partId.ToString() );\n \n        view.IsolateElementTemporary( partId ); <span class=\"green\">// requires transaction</span>\n \n        <span class=\"green\">//List&lt;ElementId&gt; unhideIds = new List&lt;ElementId&gt;( 1 );</span>\n        <span class=\"green\">//unhideIds.Add( partId );</span>\n        <span class=\"green\">//view.UnhideElements( unhideIds );</span>\n \n        <span class=\"green\">//doc.Regenerate(); // this is insufficient</span>\n \n        tx.Commit();\n      }\n \n      doc.Export( _folder, filename, viewIds, opt );\n \n      <span class=\"green\">// We do not commit the transaction group, </span>\n      <span class=\"green\">// because no modifications should be saved.</span>\n      <span class=\"green\">// The transaction group is only created and </span>\n      <span class=\"green\">// started to encapsulate the transactions </span>\n      <span class=\"green\">// required by the IsolateElementTemporary </span>\n      <span class=\"green\">// method. Since the transaction group is not </span>\n      <span class=\"green\">// committed, the changes are automatically </span>\n      <span class=\"green\">// discarded.</span>\n \n      <span class=\"green\">//txg.Commit();</span>\n    }\n  }\n</pre><p>Here is\n\n<a href=\"zip/ExportWallboard04.zip\">\nExportWallboard04.zip</a> including the source code, Visual Studio solution and add-in manifest of the updated version.\n\n<p>I certainly expect more implementation details to crop up that need ironing out.\n\n<p>For instance, I could imagine adding some code to delete the PCP files that are generated together with the DXF output.\nOr is there any reason to keep them?</p>\n<p>I can also imagine that the part identification needs improving.\nCurrently, the command simply uses the part and its source element ids.\nMaybe the part unique id would be better, or the parent element id needs checking, or is unnecessary snd can be completely removed.\n\n<p>Anyway, for a first stab, this implementation now looks pretty good to me.</p>\n</p></p></p>"
  }
]