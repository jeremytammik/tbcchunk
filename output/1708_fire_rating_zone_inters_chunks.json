[
  {
    "original_filename": "1708_fire_rating_zone_inters",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n<link rel=\"stylesheet\" type=\"text/css\" href=\"bc.css\">\n<script src=\"https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js\" type=\"text/javascript\"></script>\n</head>\n\n<!---\n\n- [Automatic Creation of Void Extrusion Element/ Retrieve Cut Area from element](https://forums.autodesk.com/t5/revit-api-forum/automatic-creation-of-void-extrusion-element-retrieve-cut-area/m-p/8451742)\n\nFire rating zone intersection in the #RevitAPI @AutodeskForge @AutodeskRevit #bim #DynamoBim #ForgeDevCon http://bit.ly/zoneintersect\n\nOther tweet:\n\nPetar Penchev \nhttps://s2.gifyu.com/images/PatternDims.gif\n/a/doc/revit/tbc/git/a/img/patterndims.jpeg\n@PetarPPenchev used #RevitAPI voodoo to extract surface pattern layout dimensions into #DynamoBim #Dynamo #Python @AutodeskForge @AutodeskRevit #bim #ForgeDevCon http://bit.ly/patterndims \n\nLet's tackle a 2D fire rating zone intersection task.\nActually, it was originally raised a 3D intersection task.\nReducing it to 2D makes it much more tractable\n&ndash; 3D solid extrusion creation and intersection task\n&ndash; 2D area intersection task\n&ndash; Jack's sample and description\n&ndash; Soffit subdivision sample code\n&ndash; Cleanup and GitHub repository...\n\n-->"
  },
  {
    "original_filename": "1708_fire_rating_zone_inters",
    "header_text": "Fire Rating Zone Intersection",
    "local_header_href": "#fire-rating-zone-intersection",
    "chunk_text": "### Fire Rating Zone Intersection\n\nLast week, we looked at some [3D intersection and filtering tasks](https://thebuildingcoder.typepad.com/blog/2018/12/using-an-intersection-filter-for-linked-elements.html).\n\nNow, let's tackle a 2D intersection one, brought up and solved \nby [Jack Bird](https://forums.autodesk.com/t5/user/viewprofilepage/user-id/6830764) in\nthe [Revit API discussion forum](http://forums.autodesk.com/t5/revit-api-forum/bd-p/160) thread\non [automatic creation of void extrusion and retrieval of cut area from element](https://forums.autodesk.com/t5/revit-api-forum/automatic-creation-of-void-extrusion-element-retrieve-cut-area/m-p/8451742):\n\nActually, it was originally raised a 3D intersection task.\n\nReducing it to 2D makes it much more tractable:\n\n- [3D solid extrusion creation and intersection task](#3) \n- [2D area intersection task](#4) \n- [Jack's sample and description](#5) \n- [Soffit subdivision sample code](#6) \n- [Cleanup and GitHub repository](#7)"
  },
  {
    "original_filename": "1708_fire_rating_zone_inters",
    "header_text": "<a name=\"3\"></a> 3D Solid Extrusion Creation and Intersection Task",
    "local_header_href": "#a-name3a-3d-solid-extrusion-creation-and-intersection-task",
    "chunk_text": "#### <a name=\"3\"></a> 3D Solid Extrusion Creation and Intersection Task\n\n**Question:** I’m finding it difficult to find any informative material on a subject in the API that I was hoping might have already been explored.\n\nSpecifically, I was hoping there would be an instance where a “model in place” void element is programmatically created in the model using given parameters for shape and dimensions.\n\nFor my purposes I was hoping to find a way to use an existing Solid Extrusion Element’s Geometry to define the geometry of this void as I create it.\n\nThe overall point would be to:\n\n- Have a Transparent extrusion hidden in the model that represents the Property Boundary for the Site of the Building, and the area 900 mm in from it (like a 3D cubic Object that represents the legal fire rating zone).\n- Create a list of elements from the exterior of the building that need to be tested for needing a fire proof layer; (such as Walls, Soffits ETC).\n\nThen in the same transaction:\n\n- Create a void Extrusion element the same shape and size as the Solid extrusion,\n- Iterate through each of the elements in need of testing and attempt to cut them with the void,\n- If the cut is successful record the cut area of the element that is being tested,\n- Keep that as the area of that element that needs to be fire rated,\n- Then, having tested all the relevant elements, Rolling back the transaction.\n\nI don’t know if that is even possible, but I thought it might allow me to automatically store the required fire rated area for each element. All the drafts person has to do is draw in a Solid extrusion 900 mm wide and as tall as the building based on the plan of subdivision and hide it in the model.\n\nI would be really stoked for any advice, references or links that seem relevant to the task. it would be much appreciated.\n\nHere is an image that may help with visualizing the problem:\n\n<center>\n<img src=\"img/fire_rating_zone_intersection.png\" alt=\"Fire rating zone intersection and subdivision\" width=\"1104\">\n</center>\n\n**Answer:** Here are some discussions dealing with various aspects of voids:\n\n- [Boolean operations and `InstanceVoidCutUtils`](http://thebuildingcoder.typepad.com/blog/2011/06/boolean-operations-and-instancevoidcututils.html)\n- [Beam maker using a void extrusion to cut](http://thebuildingcoder.typepad.com/blog/2010/07/beam-maker-using-a-void-extrusion-to-cut.html)\n- [Transaction group regeneration for `InstanceVoidCutUtils`](http://thebuildingcoder.typepad.com/blog/2014/04/instancevoidcututils-and-need-for-regeneration.html)\n- [Voids in the family editor](https://thebuildingcoder.typepad.com/blog/2014/10/brussels-hackathon-and-determining-pipe-wall-thickness.html#4)\n- [TTT for provision for voids](http://thebuildingcoder.typepad.com/blog/2017/03/wta-mech-and-ttt-for-provision-for-voids.html)\n- [`FindInserts` determines void instances cutting floor](https://thebuildingcoder.typepad.com/blog/2017/06/findinserts-determines-void-instances-cutting-a-floor.html)"
  },
  {
    "original_filename": "1708_fire_rating_zone_inters",
    "header_text": "<a name=\"4\"></a> 2D Area Intersection Task",
    "local_header_href": "#a-name4a-2d-area-intersection-task",
    "chunk_text": "#### <a name=\"4\"></a> 2D Area Intersection Task\n\nLooking more closely at your descriptive image, the problem seems quite simple to me.\n\nYou have a certain area of interest, and certain elements that partially intersect the volume above it.\n\nInstead of determining the intersecting volume, I would suggest retaining the area of interest in 2D, in the XY plane, and projecting the elements onto the XY plane as well.\n\nOnce you have everything in 2D in the XY plane, you have reduced the problem to a simple 2D Boolean intersection task.\n\nThat can be perfectly and completely addressed using a library to\ncompute [Boolean Operations for 2D Polygons](https://thebuildingcoder.typepad.com/blog/about-the-author.html#5.2).\n\n**Response:** That  RvtClipper.zip  was a very useful resource thank you.\nI had a play with the clipperlib on a previous task but did not consider putting it to use here.\n\nI am currently working on adapting it to my aim and will update this post as soon as I've figured it out.\n\n**Answer:** Great! I am very glad it helped.\nI think this can be used to create a very optimal solution to the ask you describe.\nI look forward very much to hearing what you come up with.\n\n**Response:** Thanks again, that worked out really well.\n\nIn the end I swapped out the RvtClipper `Result` `Execute` method to return a <code>List&lt;CurveArray&gt;</code> and substituted the `doc.Selection` based component for two element parameters that I pass in when calling it: the boundary element and whichever element I am currently testing for an intersection as I iterate through them.\n\nI then loop through the resulting `CurveArray` instances that it returns and:\n\n- Subject the curve arrays to your `SortCurvesContiguous` method\n- Convert them to CurveLoops,\n- Check if the CurveLoop is open,\n- If it is; I take the start of the first Curve and the end of the last Curve and add a new Curve to the loop using these vertices as its start and end,\n- Convert the loop back to the Array,\n- Apply your `SortCurvesContiguous` method again just to be sure,\n- Lastly, just create a floor of a previously prepared type named \"Fire Rated Layer\" using these curves that sits just on top of the soffit that was being tested.\n\nAll in all, I'm chuffed with the outcome.\n\nAll the best and Thank You.\n\nI would be glad to share the code and sample &ndash; I wonder though &ndash; as I have utilized this function as a component of a bigger two-part method &ndash; and have to some degree intertwined the two functions, would you still like to have it?\n\nFurthermore, I have developed it to be reliant on several other methods, so it may seem somewhat verbose as a sample.\n\nWith all this taken into account, I wasn't sure if you would like to retract your offer as the sample will be quite large and not entirely focused on the topics touched on in this conversation.\n\nI will outline the whole thing so you may consider.\n\nThe overall method now takes all of the soffits of a specific type (Named \"Eave\") and:\n\n- First, spends some time breaking them into segments that replace the initial elements.\n- Secondly, collects and subjects the new elements to the boundary overlap query, creating the fire rating layer elements.\n\nStep one not being entirely relevant to step two, but contingent none the less.\n\nHaving gone back through and doing a bit of housekeeping, it is not as bad as I had apprehended.\n\nPlease forgive my habit of notating via regions, I have a bit of a thing for abstraction whilst I work.\n\nIt is all attached below."
  },
  {
    "original_filename": "1708_fire_rating_zone_inters",
    "header_text": "<a name=\"5\"></a> Jack's Sample and Description",
    "local_header_href": "#a-name5a-jacks-sample-and-description",
    "chunk_text": "#### <a name=\"5\"></a> Jack's Sample and Description\n\nBased on that discussion, Jack very kindly shared\na [complete soffit subdivision and fire rating sample](zip/jb_soffit_subdivision_and_fire_rating.zip) including\na [sample model](zip/jb_soffit_subdivision_and_fire_rating_example.rvt),\nthe [sample C# code below](#4) and the following description:\n\nThe notation within the sample will hopefully take care of most of the describing,\n\nI would however like to make note of the fact that any time I use the term 'Soffit', it is because that is what \nthe element in question represents as far as function goes. Where in reality the 'Soffits' are all floors.\n\nThe three types that are used in this sample are a floor named \"Boundary\", a floor named \"Eave\" and a floor named\n\"Fire Rated Layer\". They have no particular properties that are essential to the method other than their names, \nas that is how I identify and collect them.\n\nOther than that, the view in the model called \"Isolated\" is just the \"Soffit\" and the boundary by themselves;\nthat is the best view to test in, I find.\n\nAll the best.\n\nThanks."
  },
  {
    "original_filename": "1708_fire_rating_zone_inters",
    "header_text": "<a name=\"6\"></a> Soffit Subdivision Sample Code",
    "local_header_href": "#a-name6a-soffit-subdivision-sample-code",
    "chunk_text": "#### <a name=\"6\"></a> Soffit Subdivision Sample Code\n\n<pre class=\"code\">\nusing System;\nusing System.Collections.Generic;\nusing System.ComponentModel;\nusing System.Data;\nusing System.Data.SqlClient;\nusing System.IO;\nusing System.Linq;\nusing System.Text.RegularExpressions;\nusing Autodesk.Revit.DB;\nusing Autodesk.Revit.DB.Architecture;\nusing Autodesk.Revit.UI;\nusing Autodesk.Revit.UI.Selection;\nusing Microsoft.Win32;\nusing System.Windows.Forms;\nusing AddPanel.Classes;\nusing Autodesk.Revit.DB.Structure;\nusing Autodesk.Revit.DB.Analysis;\nusing System.Diagnostics;\nusing ClipperLib;\nusing Polygon = System.Collections.Generic.List&lt;ClipperLib.IntPoint&gt;;\nusing Polygons = System.Collections.Generic.List&lt;System.Collections.Generic.List&lt;ClipperLib.IntPoint&gt;&gt;;\nusing Microsoft.JScript.Vsa;\n\nnamespace AddPanel.Classes\n{\n  class Example\n  {\n    private void SubDivideSoffits_CreateFireRatedLayers(ExternalCommandData revit, Document doc)\n    {\n      try\n      {\n        #region Get Soffits\n        List&lt;Element&gt; Soffits = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Floors).ToElements().Where(m =&gt; !(m is ElementType)).ToList();\n\n        #endregion\n\n        //Subdivide\n        foreach (Element Soffit in Soffits.Where(m =&gt; m.Name.ToLower().Contains(\"eave\")))\n        {\n          #region Get Soffit Geometry\n          Options ops = new Options();\n          ops.DetailLevel = ViewDetailLevel.Fine;\n          ops.IncludeNonVisibleObjects = true;\n          GeometryElement Geo = Soffit.get_Geometry(ops);\n\n          #endregion\n\n          foreach (var item in Geo)\n          {\n            if (item is Solid)\n            {\n              #region Get one of the Main Faces, it doesn't really matter if it is top or bottom\n              Solid GSol = item as Solid;\n              List&lt;Face&gt; Fs = new List&lt;Face&gt;();\n              foreach (Face f in GSol.Faces)\n              {\n                Fs.Add(f);\n              }\n              Face F = Fs.Where(m =&gt; m.Area == Fs.Max(a =&gt; a.Area)).First();\n              #endregion\n\n              #region Triangulate the Face with max detail\n              Mesh M = F.Triangulate(1);\n              #endregion\n\n              #region Create Variables for: the curves that will define the new Soffits, List of Custom Triangle Class, List of Custom Pair of Triangle Class\n              List&lt;List&lt;Curve&gt;&gt; LLC = new List&lt;List&lt;Curve&gt;&gt;();\n              List&lt;Triangle&gt; Triangles = new List&lt;Triangle&gt;();\n              List&lt;TrianglePair&gt; TPairs = new List&lt;TrianglePair&gt;();\n\n              #endregion\n\n              #region Loop Through Triangles & Add Them to the list of My Triangle Class\n              for (int i = 0; i &lt; M.NumTriangles; i++)\n              {\n                List&lt;Curve&gt; LC = new List&lt;Curve&gt;();\n\n                #region Make List of Curves From Triangle\n                MeshTriangle MT = M.get_Triangle(i);\n                List&lt;Curve&gt; Curves = new List&lt;Curve&gt;();\n                Curve C = Line.CreateBound(MT.get_Vertex(0), MT.get_Vertex(1)) as Curve;\n                Curves.Add(C);\n                C = Line.CreateBound(MT.get_Vertex(1), MT.get_Vertex(2)) as Curve;\n                Curves.Add(C);\n                C = Line.CreateBound(MT.get_Vertex(2), MT.get_Vertex(0)) as Curve;\n                Curves.Add(C);\n                #endregion\n\n                Triangle T = new Triangle();\n                T.Sides = new List&lt;Curve&gt;();\n                T.Sides = Curves;\n\n                T.Vertices = new List&lt;XYZ&gt;();\n                T.Vertices.Add(MT.get_Vertex(0));\n                T.Vertices.Add(MT.get_Vertex(1));\n                T.Vertices.Add(MT.get_Vertex(2));\n                Triangles.Add(T);\n              }\n              #endregion\n\n              #region Loop Through Triangles And Create Trapezoid Pairs To Catch The Segments, Getting Rid of The Shared sides\n              bool GO = true;\n              do\n              {\n                Triangle TKeeper1 = new Triangle();\n                Triangle TKeeper2 = new Triangle();\n\n                foreach (Triangle T in Triangles)\n                {\n                  TKeeper1 = new Triangle();\n                  foreach (Triangle T2 in Triangles)\n                  {\n                    TKeeper2 = new Triangle();\n                    if (T != T2)\n                    {\n                      if (FindCurvesFacing(T, T2) != null)\n                      {\n                        if (FindCurvesFacing(T, T2)[0].Length == T.Sides.Min(c =&gt; c.Length) ||\n                          FindCurvesFacing(T, T2)[1].Length == T2.Sides.Min(c =&gt; c.Length))\n                        {\n                          continue;\n                        }\n                        Curve[] Cs = FindCurvesFacing(T, T2);\n                        T.Sides.Remove(Cs[0]);\n                        T2.Sides.Remove(Cs[1]);\n                        if (T.Sides.Count() == 2 && T2.Sides.Count() == 2)\n                        {\n                          TKeeper1 = T;\n                          TKeeper2 = T2;\n                          goto ADDANDGOROUND;\n                        }\n                      }\n                    }\n                  }\n                }\n                GO = false;\n                ADDANDGOROUND:\n                if (GO)\n                {\n                  Triangles.Remove(TKeeper1);\n                  Triangles.Remove(TKeeper2);\n                  TrianglePair TP = new TrianglePair();\n                  TP.T1 = TKeeper1;\n                  TP.T2 = TKeeper2;\n                  TPairs.Add(TP);\n                }\n              } while (GO);\n\n              #endregion\n\n              #region Create Curve Loops From Triangle Pairs\n              foreach (TrianglePair TPair in TPairs)\n              {\n                List&lt;Curve&gt; Cs = new List&lt;Curve&gt;();\n\n                Cs.AddRange(TPair.T1.Sides);\n                Cs.AddRange(TPair.T2.Sides);\n\n                LLC.Add(Cs);\n              }\n              #endregion\n\n              double Offset = Convert.ToDouble(Soffit.LookupParameter(\"Height Offset From Level\").AsValueString());\n              FloorType FT = (Soffit as Floor).FloorType;\n              Level Lvl = doc.GetElement((Soffit as Floor).LevelId) as Level;\n\n              #region Delete Old Soffit If All Went Well\n              using (Transaction T = new Transaction(doc, \"Delete Soffit\"))\n              {\n                T.Start();\n                try\n                {\n                  doc.Delete(Soffit.Id);\n                }\n                catch (Exception ex)\n                {\n                  T.RollBack();\n                }\n                doc.Regenerate();\n                T.Commit();\n              }\n              #endregion\n\n              #region Sort The Lists of Curves and Create The New Segments\n              foreach (List&lt;Curve&gt; LC in LLC)\n              {\n                List&lt;Curve&gt; LCSorted = new List&lt;Curve&gt;();\n                try\n                {\n                  LCSorted = SortCurvesContiguous(LC, false);\n                }\n\n                #region Exception Details if Curves Could not be sorted\n                catch (Exception EXC)\n                {\n                  string exmsge = EXC.Message;\n                }\n\n                #endregion\n\n                CurveArray CA = new CurveArray();\n                foreach (Curve C in LCSorted)\n                {\n                  CA.Append(C);\n                }\n\n                using (Transaction T = new Transaction(doc, \"Make Segment\"))\n                {\n                  T.Start();\n                  try\n                  {\n                    Floor newFloor = doc.Create.NewFloor(CA, FT, Lvl, false);\n\n                    newFloor.LookupParameter(\"Height Offset From Level\").SetValueString(Offset.ToString());\n                  }\n                  catch (Exception ex)\n                  {\n                    T.RollBack();\n                  }\n                  doc.Regenerate();\n                  T.Commit();\n                }\n\n              }\n              #endregion\n            }\n          }\n        }\n        //refresh collection\n        Soffits = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Floors).ToElements().Where(m =&gt; !(m is ElementType)).ToList();\n        //test soffits for needing fire rating\n        foreach (Element Soffit in Soffits.Where(m =&gt; m.Name.ToLower().Contains(\"eave\")))\n        {\n          #region Get Soffit Geometry\n          Options ops = new Options();\n          ops.DetailLevel = ViewDetailLevel.Fine;\n          ops.IncludeNonVisibleObjects = true;\n          GeometryElement Geo = Soffit.get_Geometry(ops);\n\n          #endregion\n\n          foreach (var item in Geo)\n          {\n            if (item is Solid)\n            {\n              #region Find boundary Void Element\n              List&lt;Element&gt; MaybeBoundary = new FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Floors).ToElements().Where(m =&gt; !(m is ElementType)).ToList();\n              Element BoundryElement = MaybeBoundary.Where(m =&gt; !(m is FloorType) && m.Name == \"Boundary\").First();\n\n              #endregion\n\n              #region Get Intersection of Boundary and eave\n              PolygonAnyliser com = new PolygonAnyliser();\n              string RefString = \"\";\n              List&lt;CurveArray&gt; CArray = com.Execute(revit, ref RefString, BoundryElement as Floor, Soffit as Floor);\n\n              Level L = doc.GetElement(Soffit.LevelId) as Level;\n\n              #endregion\n\n              foreach (CurveArray CA in CArray)\n              {\n                #region Sort The Curves \n                IList&lt;Curve&gt; CAL = new List&lt;Curve&gt;();\n                foreach (Curve C in CA)\n                {\n                  CAL.Add(C);\n                }\n\n                List&lt;Curve&gt; Curves = SortCurvesContiguous(CAL, false);\n                List&lt;XYZ&gt; NewCurveEnds = new List&lt;XYZ&gt;();\n\n                #endregion\n\n                #region Close the loop if nesesary\n                CurveLoop CL = new CurveLoop();\n                int a = 0;\n                foreach (Curve curv in Curves)\n                {\n                  CL.Append(curv);\n                }\n                if (CL.IsOpen())\n                {\n                  Curves.Add(Line.CreateBound(CL.First().GetEndPoint(0), CL.Last().GetEndPoint(1)) as Curve);\n                }\n                #endregion\n\n                #region Recreate a Curve Array\n                Curves = SortCurvesContiguous(Curves, false);\n\n                CurveArray CA2 = new CurveArray();\n\n                int i = 0;\n                foreach (Curve c in Curves)\n                {\n                  CA2.Insert(c, i);\n                  i += 1;\n                }\n\n                #endregion\n\n                #region Create The New Fire Rated Layer element\n                FloorType ft = new FilteredElementCollector(doc).WhereElementIsElementType().OfCategory(BuiltInCategory.OST_Floors).ToElements().Where(m =&gt; m.Name == \"Fire Rated Layer\").First() as FloorType;\n                Transaction T = new Transaction(doc, \"Fire Rated Layer Creation\");\n                try\n                {\n                  T.Start();\n                  Floor F = doc.Create.NewFloor(CA2, ft, L, false);\n                  string s = Soffit.LookupParameter(\"Height Offset From Level\").AsValueString();\n                  double si = Convert.ToDouble(s);\n                  si = si + (Convert.ToDouble(Soffit.LookupParameter(\"Thickness\").AsValueString()));\n                  F.LookupParameter(\"Height Offset From Level\").SetValueString(si.ToString());\n                  T.Commit();\n                }\n                catch (Exception EX)\n                {\n                  T.RollBack();\n                  string EXmsg = EX.Message;\n                }\n\n                #endregion\n              }\n            }\n          }\n        }\n      }\n      catch (Exception ex)\n      {\n        string mesg = ex.Message;\n      }\n    }\n\n    //T0 will get it's curve that faces T1 as index 0 and T1 get it's curve that faces T0 as index 1\n    Curve[] FindCurvesFacing(Triangle T0, Triangle T1)\n    {\n      Curve[] FacingCurves = null;\n      XYZ outerVert0 = new XYZ();\n      XYZ outerVert1 = new XYZ();\n      int workedforvertice = 0;\n      int workedforLine = 0;\n      foreach (XYZ T0vertice in T0.Vertices)\n      {\n        foreach (XYZ T1Vertice in T1.Vertices)\n        {\n          if (T0vertice.IsAlmostEqualTo(T1Vertice))\n          {\n            continue;\n          }\n          if (T0.Sides.Where(m =&gt; m.GetEndPoint(0).IsAlmostEqualTo(T0vertice) && m.GetEndPoint(1).IsAlmostEqualTo(T1Vertice)).Count() == 0\n            && T0.Sides.Where(m =&gt; m.GetEndPoint(1).IsAlmostEqualTo(T0vertice) && m.GetEndPoint(0).IsAlmostEqualTo(T1Vertice)).Count() == 0)\n          {\n            outerVert0 = T0vertice;\n            outerVert1 = T1Vertice;\n            workedforvertice += 1;\n          }\n          else\n          {\n            workedforLine += 1;\n          }\n        }\n        if (workedforvertice == 1 && workedforLine == 2)\n        {\n          break;\n        }\n        else\n        {\n          workedforvertice = 0;\n          workedforLine = 0;\n        }\n      }\n\n      if (workedforvertice == 1 && workedforLine == 2)\n      {\n        FacingCurves = new Curve[2];\n\n        Curve Hyp0 = null;\n        Curve Hyp1 = null;\n\n        foreach (Curve side in T0.Sides)\n        {\n          List&lt;XYZ&gt; ends = new List&lt;XYZ&gt;();\n          ends.Add(side.GetEndPoint(0));\n          ends.Add(side.GetEndPoint(1));\n\n          if (ends.Where(m =&gt; m.IsAlmostEqualTo(outerVert0)).Count() == 0)\n          {\n            Hyp0 = side;\n            break;\n          }\n        }\n        foreach (Curve side in T1.Sides)\n        {\n          List&lt;XYZ&gt; ends = new List&lt;XYZ&gt;();\n          ends.Add(side.GetEndPoint(0));\n          ends.Add(side.GetEndPoint(1));\n\n          if (ends.Where(m =&gt; m.IsAlmostEqualTo(outerVert1)).Count() == 0)\n          {\n            Hyp1 = side;\n            break;\n          }\n        }\n\n        FacingCurves[0] = Hyp0;\n        FacingCurves[1] = Hyp1;\n\n      }\n\n      return FacingCurves;\n    }\n\n    const double _inch = 1.0 / 12.0;\n    const double _sixteenth = _inch / 16.0;\n    static Curve CreateReversedCurve(\n\n    Curve orig)\n    {\n\n      if (orig is Line || orig is Curve)\n      {\n        return Line.CreateBound(\n          orig.GetEndPoint(1),\n          orig.GetEndPoint(0));\n      }\n      else\n      {\n        throw new Exception(\n          \"CreateReversedCurve - Unreachable\");\n      }\n    }\n    public List&lt;Curve&gt; SortCurvesContiguous(\n    IList&lt;Curve&gt; curves,\n    bool debug_output)\n    {\n      int n = curves.Count;\n\n      // Walk through each curve (after the first) \n      // to match up the curves in order\n\n      for (int i = 0; i &lt; n; ++i)\n      {\n        Curve curve = curves[i];\n        XYZ endPoint = curve.GetEndPoint(1);\n\n        if (debug_output)\n        {\n          Debug.Print(\"{0} endPoint {1}\", i,\n            Util.PointString(endPoint));\n        }\n\n        XYZ p;\n\n        // Find curve with start point = end point\n\n        bool found = (i + 1 &gt;= n);\n\n        for (int j = i + 1; j &lt; n; ++j)\n        {\n          p = curves[j].GetEndPoint(0);\n\n          // If there is a match end-&gt;start, \n          // this is the next curve\n\n          if (_sixteenth &gt; p.DistanceTo(endPoint))\n          {\n            if (debug_output)\n            {\n              Debug.Print(\n                \"{0} start point, swap with {1}\",\n                j, i + 1);\n            }\n\n            if (i + 1 != j)\n            {\n              Curve tmp = curves[i + 1];\n              curves[i + 1] = curves[j];\n              curves[j] = tmp;\n            }\n            found = true;\n            break;\n          }\n\n          p = curves[j].GetEndPoint(1);\n\n          // If there is a match end-&gt;end, \n          // reverse the next curve\n\n          if (_sixteenth &gt; p.DistanceTo(endPoint))\n          {\n            if (i + 1 == j)\n            {\n              if (debug_output)\n              {\n                Debug.Print(\n                  \"{0} end point, reverse {1}\",\n                  j, i + 1);\n              }\n\n              curves[i + 1] = CreateReversedCurve(\n                 curves[j]);\n            }\n            else\n            {\n              if (debug_output)\n              {\n                Debug.Print(\n                  \"{0} end point, swap with reverse {1}\",\n                  j, i + 1);\n              }\n\n              Curve tmp = curves[i + 1];\n              curves[i + 1] = CreateReversedCurve(\n                 curves[j]);\n              curves[j] = tmp;\n            }\n            found = true;\n            break;\n          }\n        }\n        if (!found)\n        {\n          throw new Exception(\"SortCurvesContiguous:\"\n            + \" non-contiguous input curves\");\n        }\n      }\n      return curves.ToList();\n\n    }\n\n    public class PolygonAnyliser\n    {\n      //Nearly Entirely the Work of The Builder Coder\n\n      /// &lt;summary&gt;\n      /// Consider a Revit length zero \n      /// if is smaller than this.\n      /// &lt;/summary&gt;\n      const double _eps = 1.0e-9;\n\n      /// &lt;summary&gt;\n      /// Conversion factor from feet to millimetres.\n      /// &lt;/summary&gt;\n      const double _feet_to_mm = 25.4 * 12;\n\n      /// &lt;summary&gt;\n      /// Conversion a given length value \n      /// from feet to millimetres.\n      /// &lt;/summary&gt;\n      static long ConvertFeetToMillimetres(double d)\n      {\n        if (0 &lt; d)\n        {\n          return _eps &gt; d\n            ? 0\n            : (long)(_feet_to_mm * d + 0.5);\n\n        }\n        else\n        {\n          return _eps &gt; -d\n            ? 0\n            : (long)(_feet_to_mm * d - 0.5);\n\n        }\n      }\n\n      /// &lt;summary&gt;\n      /// Conversion a given length value \n      /// from millimetres to feet.\n      /// &lt;/summary&gt;\n      static double ConvertMillimetresToFeet(long d)\n      {\n        return d / _feet_to_mm;\n      }\n\n      /// &lt;summary&gt;\n      /// Return a clipper integer point \n      /// from a Revit model space one.\n      /// Do so by dropping the Z coordinate\n      /// and converting from imperial feet \n      /// to millimetres.\n      /// &lt;/summary&gt;\n      public IntPoint GetIntPoint(XYZ p)\n      {\n        return new IntPoint(\n          ConvertFeetToMillimetres(p.X),\n          ConvertFeetToMillimetres(p.Y));\n      }\n\n      /// &lt;summary&gt;\n      /// Return a Revit model space point \n      /// from a clipper integer one.\n      /// Do so by adding a zero Z coordinate\n      /// and converting from millimetres to\n      /// imperial feet.\n      /// &lt;/summary&gt;\n      public XYZ GetXyzPoint(IntPoint p)\n      {\n        return new XYZ(\n          ConvertMillimetresToFeet(p.X),\n          ConvertMillimetresToFeet(p.Y),\n          0.0);\n      }\n\n      /// &lt;summary&gt;\n      /// Retrieve the boundary loops of the given slab \n      /// top face, which is assumed to be horizontal.\n      /// &lt;/summary&gt;\n      Polygons GetBoundaryLoops(CeilingAndFloor slab)\n      {\n        int n;\n        Polygons polys = null;\n        Document doc = slab.Document;\n        Autodesk.Revit.ApplicationServices.Application app = doc.Application;\n\n        Options opt = app.Create.NewGeometryOptions();\n\n        GeometryElement geo = slab.get_Geometry(opt);\n\n        foreach (GeometryObject obj in geo)\n        {\n          Solid solid = obj as Solid;\n          if (null != solid)\n          {\n            foreach (Face face in solid.Faces)\n            {\n              PlanarFace pf = face as PlanarFace;\n              if (null != pf\n                && pf.FaceNormal.IsAlmostEqualTo(XYZ.BasisZ))\n              {\n                EdgeArrayArray loops = pf.EdgeLoops;\n\n                n = loops.Size;\n                polys = new Polygons(n);\n\n                foreach (EdgeArray loop in loops)\n                {\n                  n = loop.Size;\n                  Polygon poly = new Polygon(n);\n\n                  foreach (Edge edge in loop)\n                  {\n                    IList&lt;XYZ&gt; pts = edge.Tessellate();\n\n                    n = pts.Count;\n\n                    foreach (XYZ p in pts)\n                    {\n                      poly.Add(GetIntPoint(p));\n                    }\n                  }\n                  polys.Add(poly);\n                }\n              }\n            }\n          }\n        }\n        return polys;\n      }\n\n      public List&lt;CurveArray&gt; Execute(\n        ExternalCommandData commandData,\n        ref string message, Floor boundary, Floor eave)\n      {\n        List&lt;CurveArray&gt; Results = new List&lt;CurveArray&gt;();\n\n        UIApplication uiapp = commandData.Application;\n        UIDocument uidoc = uiapp.ActiveUIDocument;\n        Autodesk.Revit.ApplicationServices.Application app = uiapp.Application;\n        Document doc = uidoc.Document;\n\n        // Two slabs to intersect.\n\n        CeilingAndFloor[] slab\n          = new CeilingAndFloor[2] { eave, boundary };\n\n        // Retrieve the two slabs' boundary loops\n\n        Polygons subj = GetBoundaryLoops(slab[0]);\n        Polygons clip = GetBoundaryLoops(slab[1]);\n\n        // Calculate the intersection\n\n        Polygons intersection = new Polygons();\n\n        Clipper c = new Clipper();\n\n        c.AddPolygons(subj, PolyType.ptSubject);\n\n        c.AddPolygons(clip, PolyType.ptClip);\n\n        c.Execute(ClipType.ctIntersection, intersection,\n          PolyFillType.pftEvenOdd, PolyFillType.pftEvenOdd);\n\n        // Check for a valid intersection\n\n        if (0 &lt; intersection.Count)\n        {\n\n          foreach (Polygon poly in intersection)\n          {\n\n            CurveArray curves = app.Create.NewCurveArray();\n            IntPoint? p0 = null; // first\n            IntPoint? p = null; // previous\n\n            foreach (IntPoint q in poly)\n            {\n              if (null == p0)\n              {\n                p0 = q;\n              }\n              if (null != p)\n              {\n                curves.Append(\n                  Line.CreateBound(\n                    GetXyzPoint(p.Value),\n                    GetXyzPoint(q)));\n              }\n              p = q;\n            }\n\n            Results.Add(curves);\n          }\n\n        }\n        return Results;\n      }\n    }\n  }\n}\n</pre>"
  },
  {
    "original_filename": "1708_fire_rating_zone_inters",
    "header_text": "<a name=\"7\"></a> Cleanup and GitHub Repository",
    "local_header_href": "#a-name7a-cleanup-and-github-repository",
    "chunk_text": "#### <a name=\"7\"></a> Cleanup and GitHub Repository\n\nVery many thanks to Jack for creating, cleaning up and sharing this.\n\nVery cool indeed.\n\nI set it up and tested it by performing the following steps:\n\n- Cleaned up the sample code\n- Added minimal implementations for the missing `Triangle` and `TrianglePair` classes\n- Downloaded and installed the [Clipper open source freeware library for clipping and offsetting lines and polygons](http://angusj.com/delphi/clipper.php)\n- Implemented an external command to drive the code\n- Tested it in the sample model\n\nHere is a picture of the model:\n\n<center>\n<img src=\"img/fire_rating_zone_intersection_model.png\" alt=\"Fire rating zone intersection model\" width=\"477\">\n</center>\n\nThe result is a bunch of new floor elements:\n\n<center>\n<img src=\"img/fire_rating_zone_intersection_result.png\" alt=\"Fire rating zone intersection result\" width=\"691\">\n</center>\n\nI published the cleaned-up sample in its own\nnew [FireRatingZoneIntersection GitHub repository](https://github.com/jeremytammik/FireRatingZoneIntersection).\n\nSome things could be cleaned up further, I believe:\n\n- Why convert the filtered element collectors to `List`?\n- Why create floor elements? Wouldn't a simple model curve polyline do the job?\n- Use a built-in parameter enumeration value and `get_Parameter` instead of `LookupParameter`.\n- I tend to avoid `SetValueString` and use `Set` instead.\n\nStill, I hope others find it useful as well, and look forward to seeing your pull requests for these and further enhancements."
  }
]