[
  {
    "original_filename": "0334_anonymous_methods_vb",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<head>\n<link href=\"bc.css\" rel=\"stylesheet\" type=\"text/css\"/>\n</head>"
  },
  {
    "original_filename": "0334_anonymous_methods_vb",
    "header_text": "Anonymous Methods in VB",
    "local_header_href": "#anonymous-methods-in-vb",
    "chunk_text": "<h3>Anonymous Methods in VB</h3><p>By the time you read this, I will be well on my way to the Revit API training that I am giving in Warsaw.\nThe Revit API introduction labs that I am using for that include a few examples of post-processing the results of a Revit filtered collector query.\nI discussed several examples of such post-processing before Easter when \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/04/collector-benchmark.html\">\nprofiling the collector performance</a>.\n\nI and my colleagues were having some trouble converting the code from C# to VB, and I thought I would share some of our insights with you here.\nFor instance, our command Lab3_7_DeleteFamilyType selects and deletes a specific hard-coded column type named \"475 x 610mm\":</p><center>\n<img alt=\"Column types\" src=\"img/column_types.png\"/>\n</center><p>We were using the following C# code and helper methods:\n\n<ul>\n<li>GetElementsOfType –\n     Return all elements of the requested class,\n     i.e. System.Type, matching the given built-in\n     category in the given document.\n<li>GetFamilySymbols –\n     Return all family symbols in the given document\n     matching the given built-in category.\n</li></li></ul>\n<p>Here are the helper method implementations:\n\n<pre class=\"code\">\n<span class=\"blue\">public</span> <span class=\"blue\">static</span> <span class=\"teal\">FilteredElementCollector</span>\n  GetElementsOfType(\n    <span class=\"teal\">Document</span> doc,\n    <span class=\"teal\">Type</span> type,\n    <span class=\"teal\">BuiltInCategory</span> bic )\n{\n  <span class=\"teal\">FilteredElementCollector</span> collector\n    = <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( doc );\n \n  collector.OfCategory( bic );\n  collector.OfClass( type );\n \n  <span class=\"blue\">return</span> collector;\n}\n\n<span class=\"blue\">public</span> <span class=\"blue\">static</span> <span class=\"teal\">FilteredElementCollector</span>\n  GetFamilySymbols(\n    <span class=\"teal\">Document</span> doc,\n    <span class=\"teal\">BuiltInCategory</span> bic )\n{\n  <span class=\"blue\">return</span> GetElementsOfType( doc,\n    <span class=\"blue\">typeof</span>( <span class=\"teal\">FamilySymbol</span> ), bic );\n}\n</pre>\n<p>Here is the trivial command mainline Execute method implementation making use of these to first retrieve all family symbols of the specified category, and then post-process the results to extract one specific instance matching the hard-coded name \"475 x 610mm\" and delete that specific individual type from the column family.\n\n<p>Actually, since we are still in the process of getting used to the new Revit 2011 API attributes and other paraphernalia, here is the complete command class implementation:\n\n<pre class=\"code\">\n[<span class=\"teal\">Transaction</span>( <span class=\"teal\">TransactionMode</span>.Automatic )]\n[<span class=\"teal\">Regeneration</span>( <span class=\"teal\">RegenerationOption</span>.Manual )]\n<span class=\"blue\">public</span> <span class=\"blue\">class</span> <span class=\"teal\">Lab3_7_DeleteFamilyType</span> : <span class=\"teal\">IExternalCommand</span>\n{\n  <span class=\"blue\">public</span> <span class=\"teal\">Result</span> Execute(\n    <span class=\"teal\">ExternalCommandData</span> commandData,\n    <span class=\"blue\">ref</span> <span class=\"blue\">string</span> message,\n    <span class=\"teal\">ElementSet</span> elements )\n  {\n    <span class=\"teal\">UIApplication</span> app = commandData.Application;\n    <span class=\"teal\">Document</span> doc = app.ActiveUIDocument.Document;\n \n    <span class=\"teal\">FilteredElementCollector</span> collector\n      = <span class=\"teal\">LabUtils</span>.GetFamilySymbols( doc,\n        <span class=\"teal\">BuiltInCategory</span>.OST_Columns );\n \n    <span class=\"blue\">var</span> column_types = <span class=\"blue\">from</span> element <span class=\"blue\">in</span> collector\n      <span class=\"blue\">where</span> element.Name.Equals( <span class=\"maroon\">\"475 x 610mm\"</span> )\n      <span class=\"blue\">select</span> element;\n \n    <span class=\"teal\">FamilySymbol</span> symbol = column_types\n      .Cast&lt;<span class=\"teal\">FamilySymbol</span>&gt;()\n      .First&lt;<span class=\"teal\">FamilySymbol</span>&gt;();\n \n    doc.Delete( symbol );\n \n    <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Succeeded;\n  }\n}\n</pre>\n<p>As you can see, we are still deriving the command class from our beloved IExternalCommand interface.\nWe are also adding the new non-optional attributes defining its transaction mode and regeneration option.\n\n<p>GetFamilySymbols returns a FilteredElementCollector, and we process that collection using\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2009/07/language-integrated-query-linq.html\">\nLINQ</a>\n\nto extract the one and only symbol matching our target name in order to demonstrate deleting the symbol from the model.\n\n<p>The same code ported to VB.NET looks like this:\n\n<pre class=\"code\">\n&lt;Transaction(TransactionMode.Automatic)&gt; _\n&lt;Regeneration(RegenerationOption.Manual)&gt; _\n<span class=\"blue\">Public</span> <span class=\"blue\">Class</span> Lab3_7_DeleteFamilyType\n  <span class=\"blue\">Implements</span> IExternalCommand\n\n  <span class=\"blue\">Public</span> <span class=\"blue\">Function</span> Execute( _\n    <span class=\"blue\">ByVal</span> commandData <span class=\"blue\">As</span> ExternalCommandData, _\n    <span class=\"blue\">ByRef</span> message <span class=\"blue\">As</span> <span class=\"blue\">String</span>, _\n    <span class=\"blue\">ByVal</span> elements <span class=\"blue\">As</span> ElementSet) <span class=\"blue\">As</span> Result _\n    <span class=\"blue\">Implements</span> IExternalCommand.Execute\n\n    <span class=\"blue\">Dim</span> app <span class=\"blue\">As</span> UIApplication = commandData.Application\n    <span class=\"blue\">Dim</span> doc <span class=\"blue\">As</span> Document = app.ActiveUIDocument.Document\n\n    <span class=\"blue\">Dim</span> collector <span class=\"blue\">As</span> FilteredElementCollector _\n      = LabUtils.GetFamilySymbols( _\n        doc, BuiltInCategory.OST_Columns)\n\n    <span class=\"blue\">Dim</span> column_types = <span class=\"blue\">From</span> element <span class=\"blue\">In</span> collector _\n      <span class=\"blue\">Where</span> element.Name.<span class=\"blue\">Equals</span>(<span class=\"maroon\">\"475 x 610mm\"</span>) _\n      <span class=\"blue\">Select</span> element\n\n    <span class=\"blue\">Dim</span> column_types_ienum <span class=\"blue\">As</span> IEnumerable(<span class=\"blue\">Of</span> Element)\n    column_types_ienum = <span class=\"blue\">CType</span>(column_types, IEnumerable(<span class=\"blue\">Of</span> Element))\n\n    <span class=\"blue\">Dim</span> column_types_famsym <span class=\"blue\">As</span> IEnumerable(<span class=\"blue\">Of</span> FamilySymbol)\n    column_types_famsym = column_types_ienum.Cast(<span class=\"blue\">Of</span> FamilySymbol)()\n\n    <span class=\"blue\">Dim</span> symbol <span class=\"blue\">As</span> FamilySymbol = column_types_famsym.First()\n\n    doc.Delete(symbol)\n\n    <span class=\"blue\">Return</span> Result.Succeeded\n  <span class=\"blue\">End</span> <span class=\"blue\">Function</span>\n\n<span class=\"blue\">End</span> <span class=\"blue\">Class</span>\n</pre>\n<p>We added several extraneous lines of casting code to circumvent some runtime casting exceptions thrown when executing the VB code.</p>\n<p>Since I did not like all those extra lines of casting code, I suggested making use of an anonymous method instead of the explicit LINQ statement.\nHere is my suggestion to reduce the length of code and casts.\nPlease note that it does not work, as we will explain below:</p>\n<pre class=\"code\">\n  <span class=\"blue\">Dim</span> collector <span class=\"blue\">As</span> FilteredElementCollector _\n    = LabUtils.GetFamilySymbols( _\n      doc, BuiltInCategory.OST_Columns)\n\n  <span class=\"blue\">Dim</span> name_equals = <span class=\"blue\">Function</span>(e) e.Name.Equals(<span class=\"maroon\">\"475 x 610mm\"</span>)\n\n  <span class=\"blue\">Dim</span> element <span class=\"blue\">As</span> Element = collector.First(name_equals)\n\n  <span class=\"blue\">Dim</span> symbol <span class=\"blue\">As</span> FamilySymbol = <span class=\"blue\">CType</span>(element, FamilySymbol)\n\n  doc.Delete(symbol)\n</pre>\n<p>This is much shorter and easy to read.\nIt also compiles perfectly well.\nUnfortunately, it throws the following exception during runtime:</p>\n<pre>\nUnable to cast object\n  of type 'VB$AnonymousDelegate_0`2[System.Object,System.Boolean]'\n  to type 'System.Func`2[Autodesk.Revit.DB.Element,System.Boolean]'.\n</pre>\n<p>What does this mean?\nWell, apparently the definition of 'name_equals' using 'Function(e)' is generating an anonymous VB delegate, whereas the generic First method is expecting a more specialised System.Func delegate.\nAs a first step, I replaced 'Function(e)' by 'Function(e As Element)'.\nThat improved things somewhat, because now at least the argument has the correct type, but the delegate is still an anonymous VB delegate and not a System.Func one.\nIn a second step, I corrected that as well, and now I have the following, which works fine and is nice and short:</p>\n<pre class=\"code\">\n  <span class=\"blue\">Dim</span> name_equals <span class=\"blue\">As</span> Func(<span class=\"blue\">Of</span> Element, <span class=\"blue\">Boolean</span>) _\n    = <span class=\"blue\">Function</span>(e <span class=\"blue\">As</span> Element) e.Name.Equals(<span class=\"maroon\">\"475 x 610mm\"</span>)\n</pre>\n<p>This prompted me to return to the C# version and try to shorten that a bit more as well.\nMy first step was to replace the from-where-select statement by the generic algorithm First, like this:</p>\n<pre class=\"code\">\n  <span class=\"teal\">FilteredElementCollector</span> collector\n    = <span class=\"teal\">LabUtils</span>.GetFamilySymbols( doc,\n      <span class=\"teal\">BuiltInCategory</span>.OST_Columns );\n \n  <span class=\"teal\">FamilySymbol</span> symbol = collector.First&lt;<span class=\"teal\">Element</span>&gt;(\n    e =&gt; e.Name.Equals( <span class=\"maroon\">\"475 x 610mm\"</span> ) )\n      <span class=\"blue\">as</span> <span class=\"teal\">FamilySymbol</span>;\n \n  doc.Delete( symbol );\n</pre>\n<p>On second thoughts, I noticed that the doc.Delete method does not really care what kind of element I am passing in, so there is no need even to cast the retrieved symbol from Element to FamilySymbol, i.e. this shorter code does the job equally well:</p>\n<pre class=\"code\">\n  <span class=\"teal\">FilteredElementCollector</span> collector\n    = <span class=\"teal\">LabUtils</span>.GetFamilySymbols( doc,\n      <span class=\"teal\">BuiltInCategory</span>.OST_Columns );\n \n  <span class=\"teal\">Element</span> symbol = collector.First&lt;<span class=\"teal\">Element</span>&gt;(\n    e =&gt; e.Name.Equals( <span class=\"maroon\">\"475 x 610mm\"</span> ) );\n \n  doc.Delete( symbol );\n</pre>\n<p>Finally, let's take that insight back to the VB version and minimalise that also as follows:</p>\n<pre class=\"code\">\n  <span class=\"blue\">Dim</span> collector <span class=\"blue\">As</span> FilteredElementCollector _\n    = LabUtils.GetFamilySymbols( _\n      doc, BuiltInCategory.OST_Columns)\n\n  <span class=\"blue\">Dim</span> name_equals <span class=\"blue\">As</span> Func(<span class=\"blue\">Of</span> Element, <span class=\"blue\">Boolean</span>) _\n    = <span class=\"blue\">Function</span>(e <span class=\"blue\">As</span> Element) e.Name.Equals(<span class=\"maroon\">\"475 x 610mm\"</span>)\n\n  <span class=\"blue\">Dim</span> symbol <span class=\"blue\">As</span> Element = collector.First(name_equals)\n\n  doc.Delete(symbol)\n</pre>\n<p>Even more finally, we can make true use of the anonymous function facility in VB as well and eliminate the intermediate named functor like this:</p>\n<pre class=\"code\">\n  <span class=\"blue\">Dim</span> symbol <span class=\"blue\">As</span> Element = collector.First( _\n    <span class=\"blue\">Function</span>(e <span class=\"blue\">As</span> Element) e.Name.Equals(<span class=\"maroon\">\"475 x 610mm\"</span>))\n</pre>\n<p>Now we have the same succinct sweetness in both versions.</p>\n<p>As we noticed when \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/04/collector-benchmark.html\">\nbenchmarking collector performance</a>,\n\nthe speed of the anonymous method is exactly the same as using LINQ.\n\n<p>More importantly, what we also noticed was that using a parameter filter and the Revit filtering API instead of the explicit post-processing we are discussing here was much faster still, by almost a factor of two. \nThe fact is that filtering for a specific element name can just as well be achieved by a parameter filter, and an example was given in that discussion, and it used half the time that the comparable LINQ query does.\n\n<p>Still, I hope this helps make the anonymous functions and the power of the Revit 2011 filtering API more accessible to all you VB folks as well.\nGood luck and much success with that to you!</p>\n</p></p></p></p></p></p></p></p></p>"
  }
]