[
  {
    "original_filename": "1085_rolling_offset",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<head>\n<link href=\"bc.css\" rel=\"stylesheet\" type=\"text/css\"/>\n<meta content=\"text/html; charset=utf-8\" http-equiv=\"Content-Type\"/>\n</head>"
  },
  {
    "original_filename": "1085_rolling_offset",
    "header_text": "Calculating a Rolling Offset Between Two Pipes",
    "local_header_href": "#calculating-a-rolling-offset-between-two-pipes",
    "chunk_text": "<h3>Calculating a Rolling Offset Between Two Pipes</h3><p>Here is a nice little MEP related external command that I implemented to\n\n<a href=\"http://www.plumbinghelp.ca/plumbing-math-rolling-offsets.php\">\ncalculate</a> a\n\n<a href=\"http://602apprentice.blogspot.ch/2011/01/rolling-offsets.html\">\nrolling offset</a> for\n\npipes at the\n\n<a href=\"http://content.case-inc.com/au-hackathon-2013\">\nCASE BIM Hackathon</a> at\n\nAU, prompted by a suggestion by Harry Mattison and Matthew Nelson.</p><p>It calculates the rolling offset between two selected pipes and generates a model line in the Revit model to display the result.</p><p>In brief, a rolling offset is an angled pipe segment that connects two pipes with each other.</p><p>For instance, imagine a situation with two parallel horizontal pipes, offset from each other in all three directions, X, Y and Z.</p><p>The task consists in calculating the appropriate angled segment to connect the two.</p><p>Maybe the best way to explain the task is to show the solution in action before looking at the detailed implementation.</p><p>Given the two parallel offset pipes, one needs to decide how far along the axis defined by their common direction to place the angled segment.</p><p>I decided to choose the midpoint defined by the two pipes' endpoints that are farthest apart, and place the angled segment so that its midpoint coincides with that.</p><p>Here is a 52-second <a href=\"http://youtu.be/huxn3ga2Ly4\">video</a> of the rolling offset add-in recorded live in situ at the CASE BIM Hackathon:</p><center>\n<iframe allowfullscreen=\"\" frameborder=\"0\" height=\"315\" src=\"http://www.youtube.com/embed/huxn3ga2Ly4\" width=\"420\"></iframe>\n</center><p>In case you prefer stills, here are six screen snapshots highlighting the situation, three before and three after executing the command:</p><center>\n<img alt=\"3D situation before calculating rolling offset\" src=\"img/rolling_offset_1_3d.png\" width=\"450\"/>\n<p style=\"text-align:center\"><i>3D view before</i></p>\n<img alt=\"East elevation before calculating rolling offset\" src=\"img/rolling_offset_2_east_cropped.png\"/>\n<p style=\"text-align:center\"><i>East view before</i></p>\n<img alt=\"North elevation before calculating rolling offset\" src=\"img/rolling_offset_3_north_cropped.png\"/>\n<p style=\"text-align:center\"><i>North view before</i></p>\n<img alt=\"3D situation after calculating rolling offset\" src=\"img/rolling_offset_4_3d.png\" width=\"481\"/>\n<p style=\"text-align:center\"><i>3D view after</i></p>\n<img alt=\"East elevation after calculating rolling offset\" src=\"img/rolling_offset_5_east.png\"/>\n<p style=\"text-align:center\"><i>East view after</i></p>\n<img alt=\"North elevation after calculating rolling offset\" src=\"img/rolling_offset_6_north.png\"/>\n<p style=\"text-align:center\"><i>North view after</i></p>\n</center><p>If you look carefully, you will notice that both selected pipes are shortened by the external command.\nA model line is drawn at a 45-degree angle to the existing pipes to connect the two correspondingly adjusted endpoints.</p><p>The algorithm supports any other angle as well, of course, e.g. 30 or 60 degrees; it is currently hard coded.</p><a name=\"2\"></a>"
  },
  {
    "original_filename": "1085_rolling_offset",
    "header_text": "Rolling Offset Calculation Implementation",
    "local_header_href": "#rolling-offset-calculation-implementation",
    "chunk_text": "<h4>Rolling Offset Calculation Implementation</h4><p>I implemented the external code calculating the rolling offset and generating a model line to represent the result as a new external command CmdRollingOffset in The Building Coder samples.</p><p>For a maximum of flexibility, comfort and efficiency in testing it, it supports three different possibilities for selecting the two pipes:</p><ul>\n<li>Run in a model containing exactly two parallel offset pipe elements, they will be automatically selected.</li>\n<li>Pre-select two pipes before launching the command.</li>\n<li>Post-select them when prompted.</li>\n</ul><p>Here is the entire command implementation:</p><pre class=\"code\">\n[<span class=\"teal\">Transaction</span>( <span class=\"teal\">TransactionMode</span>.Manual )]\n<span class=\"blue\">class</span> <span class=\"teal\">CmdRollingOffset</span> : <span class=\"teal\">IExternalCommand</span>\n{\n  <span class=\"blue\">const</span> <span class=\"blue\">string</span> _prompt\n    = <span class=\"maroon\">\"Please run this in a model containing \"</span>\n    + <span class=\"maroon\">\"exactly two parallel offset pipe elements, \"</span>\n    + <span class=\"maroon\">\"and they will be \"</span>\n    + <span class=\"maroon\">\"automatically selected. Alternatively, pre-\"</span>\n    + <span class=\"maroon\">\"select two pipe elements before launching \"</span>\n    + <span class=\"maroon\">\"this command, or post-select them when \"</span>\n    + <span class=\"maroon\">\"prompted.\"</span>;\n \n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n  <span class=\"gray\">///</span><span class=\"green\"> Allow selection of curve elements only.</span>\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n  <span class=\"blue\">class</span> <span class=\"teal\">PipeElementSelectionFilter</span> : <span class=\"teal\">ISelectionFilter</span>\n  {\n    <span class=\"blue\">public</span> <span class=\"blue\">bool</span> AllowElement( <span class=\"teal\">Element</span> e )\n    {\n      <span class=\"blue\">return</span> e <span class=\"blue\">is</span> <span class=\"teal\">Pipe</span>;\n    }\n \n    <span class=\"blue\">public</span> <span class=\"blue\">bool</span> AllowReference( <span class=\"teal\">Reference</span> r, <span class=\"teal\">XYZ</span> p )\n    {\n      <span class=\"blue\">return</span> <span class=\"blue\">true</span>;\n    }\n  }\n \n  <span class=\"blue\">public</span> <span class=\"teal\">Result</span> Execute(\n    <span class=\"teal\">ExternalCommandData</span> commandData,\n    <span class=\"blue\">ref</span> <span class=\"blue\">string</span> message,\n    <span class=\"teal\">ElementSet</span> elements )\n  {\n    <span class=\"teal\">UIApplication</span> uiapp = commandData.Application;\n    <span class=\"teal\">UIDocument</span> uidoc = uiapp.ActiveUIDocument;\n    <span class=\"teal\">Application</span> app = uiapp.Application;\n    <span class=\"teal\">Document</span> doc = uidoc.Document;\n \n    <span class=\"green\">// Select all pipes in the entire model.</span>\n \n    <span class=\"teal\">List</span>&lt;<span class=\"teal\">Pipe</span>&gt; pipes = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">Pipe</span>&gt;(\n      <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( doc )\n        .OfClass( <span class=\"blue\">typeof</span>( <span class=\"teal\">Pipe</span> ) )\n        .ToElements()\n        .Cast&lt;<span class=\"teal\">Pipe</span>&gt;() );\n \n    <span class=\"blue\">int</span> n = pipes.Count;\n \n    <span class=\"green\">// If there are less than two, </span>\n    <span class=\"green\">// there is nothing we can do.</span>\n \n    <span class=\"blue\">if</span>( 2 &gt; n )\n    {\n      message = _prompt;\n      <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n    }\n \n    <span class=\"green\">// If there are exactly two, pick those.</span>\n \n    <span class=\"blue\">if</span>( 2 &lt; n )\n    {\n      <span class=\"green\">// Else, check for a pre-selection.</span>\n \n      pipes.Clear();\n \n      <span class=\"teal\">Selection</span> sel = uidoc.Selection;\n \n      n = sel.Elements.Size;\n \n      <span class=\"teal\">Debug</span>.Print( <span class=\"maroon\">\"{0} pre-selected elements.\"</span>,\n        n );\n \n      <span class=\"green\">// If two or more model pipes were pre-</span>\n      <span class=\"green\">// selected, use the first two encountered.</span>\n \n      <span class=\"blue\">if</span>( 1 &lt; n )\n      {\n        <span class=\"blue\">foreach</span>( <span class=\"teal\">Element</span> e <span class=\"blue\">in</span> sel.Elements )\n        {\n          <span class=\"teal\">Pipe</span> c = e <span class=\"blue\">as</span> <span class=\"teal\">Pipe</span>;\n \n          <span class=\"blue\">if</span>( <span class=\"blue\">null</span> != c )\n          {\n            pipes.Add( c );\n \n            <span class=\"blue\">if</span>( 2 == pipes.Count )\n            {\n              <span class=\"teal\">Debug</span>.Print( <span class=\"maroon\">\"Found two model pipes, \"</span>\n                + <span class=\"maroon\">\"ignoring everything else.\"</span> );\n \n              <span class=\"blue\">break</span>;\n            }\n          }\n        }\n      }\n \n      <span class=\"green\">// Else, prompt for an </span>\n      <span class=\"green\">// interactive post-selection.</span>\n \n      <span class=\"blue\">if</span>( 2 != pipes.Count )\n      {\n        pipes.Clear();\n \n        <span class=\"blue\">try</span>\n        {\n          <span class=\"teal\">Reference</span> r = sel.PickObject(\n            <span class=\"teal\">ObjectType</span>.Element,\n            <span class=\"blue\">new</span> <span class=\"teal\">PipeElementSelectionFilter</span>(),\n            <span class=\"maroon\">\"Please pick first pipe.\"</span> );\n \n          pipes.Add( doc.GetElement( r.ElementId )\n            <span class=\"blue\">as</span> <span class=\"teal\">Pipe</span> );\n        }\n        <span class=\"blue\">catch</span>( Autodesk.Revit.Exceptions\n          .<span class=\"teal\">OperationCanceledException</span> )\n        {\n          <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Cancelled;\n        }\n \n        <span class=\"blue\">try</span>\n        {\n          <span class=\"teal\">Reference</span> r = sel.PickObject(\n            <span class=\"teal\">ObjectType</span>.Element,\n            <span class=\"blue\">new</span> <span class=\"teal\">PipeElementSelectionFilter</span>(),\n            <span class=\"maroon\">\"Please pick second pipe.\"</span> );\n \n          pipes.Add( doc.GetElement( r.ElementId )\n            <span class=\"blue\">as</span> <span class=\"teal\">Pipe</span> );\n        }\n        <span class=\"blue\">catch</span>( Autodesk.Revit.Exceptions\n          .<span class=\"teal\">OperationCanceledException</span> )\n        {\n          <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Cancelled;\n        }\n      }\n    }\n \n    <span class=\"green\">// Extract data from the two selected pipes.</span>\n \n    <span class=\"teal\">Curve</span> c0 = (pipes[0].Location <span class=\"blue\">as</span> <span class=\"teal\">LocationCurve</span>).Curve;\n    <span class=\"teal\">Curve</span> c1 = (pipes[1].Location <span class=\"blue\">as</span> <span class=\"teal\">LocationCurve</span>).Curve;\n \n    <span class=\"blue\">if</span>( !(c0 <span class=\"blue\">is</span> <span class=\"teal\">Line</span>) || !(c1 <span class=\"blue\">is</span> <span class=\"teal\">Line</span>) )\n    {\n      message = _prompt\n        + <span class=\"maroon\">\" Expected straight pipes.\"</span>;\n \n      <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n    }\n \n    <span class=\"teal\">XYZ</span> p00 = c0.GetEndPoint( 0 );\n    <span class=\"teal\">XYZ</span> p01 = c0.GetEndPoint( 1 );\n \n    <span class=\"teal\">XYZ</span> p10 = c1.GetEndPoint( 0 );\n    <span class=\"teal\">XYZ</span> p11 = c1.GetEndPoint( 1 );\n \n    <span class=\"teal\">XYZ</span> v0 = p01 - p00;\n    <span class=\"teal\">XYZ</span> v1 = p11 - p10;\n \n    <span class=\"blue\">if</span>( !<span class=\"teal\">Util</span>.IsParallel( v0, v1 ) )\n    {\n      message = _prompt\n        + <span class=\"maroon\">\" Expected parallel pipes.\"</span>;\n \n      <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n    }\n \n    <span class=\"green\">// Select the two pipe endpoints that are </span>\n    <span class=\"green\">// farthest apart.</span>\n \n    <span class=\"teal\">XYZ</span> p0 = p00.DistanceTo( p10 ) &gt; p01.DistanceTo( p10 )\n      ? p00\n      : p01;\n \n    <span class=\"teal\">XYZ</span> p1 = p10.DistanceTo( p0 ) &gt; p11.DistanceTo( p0 )\n      ? p10\n      : p11;\n \n    <span class=\"teal\">XYZ</span> pm = 0.5 * ( p0 + p1 );\n \n    <span class=\"teal\">XYZ</span> v = p1 - p0;\n \n    <span class=\"blue\">if</span>( <span class=\"teal\">Util</span>.IsParallel( v, v0 ) )\n    {\n      message = <span class=\"maroon\">\"The selected pipes are colinear.\"</span>;\n      <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n    }\n \n    <span class=\"teal\">XYZ</span> z = v.CrossProduct( v1 );\n    <span class=\"teal\">XYZ</span> w = z.CrossProduct( v1 ).Normalize();\n \n    <span class=\"green\">// Offset distance perpendicular to pipe direction</span>\n \n    <span class=\"blue\">double</span> distanceAcross = <span class=\"teal\">Math</span>.Abs(\n      v.DotProduct( w ) );\n \n    <span class=\"green\">// Distance between endpoints parallel </span>\n    <span class=\"green\">// to pipe direction</span>\n \n    <span class=\"blue\">double</span> distanceAlong = <span class=\"teal\">Math</span>.Abs(\n      v.DotProduct( v1.Normalize() ) );\n \n    <span class=\"teal\">Debug</span>.Assert( <span class=\"teal\">Util</span>.IsEqual( v.GetLength(),\n      <span class=\"teal\">Math</span>.Sqrt( distanceAcross * distanceAcross\n        + distanceAlong * distanceAlong ) ),\n      <span class=\"maroon\">\"expected Pythagorean equality here\"</span> );\n \n    <span class=\"green\">// The required offset pipe angle.</span>\n \n    <span class=\"blue\">double</span> angle = 45 * <span class=\"teal\">Math</span>.PI / 180.0;\n \n    <span class=\"green\">// The angle on the other side.</span>\n \n    <span class=\"blue\">double</span> angle2 = 0.5 * <span class=\"teal\">Math</span>.PI - angle;\n \n    <span class=\"blue\">double</span> length = distanceAcross * <span class=\"teal\">Math</span>.Tan( angle2 );\n \n    <span class=\"blue\">double</span> halfLength = 0.5 * length;\n \n    <span class=\"green\">// How long should the pipe stubs become?</span>\n \n    <span class=\"blue\">double</span> remainingPipeLength\n      = 0.5 * (distanceAlong - length);\n \n    <span class=\"blue\">if</span>( 0 &gt; v1.DotProduct( v ) )\n    {\n      v1.Negate();\n    }\n \n    v1 = v1.Normalize();\n \n    <span class=\"teal\">XYZ</span> q0 = p0 + remainingPipeLength * v1;\n \n    <span class=\"teal\">XYZ</span> q1 = p1 - remainingPipeLength * v1;\n \n    <span class=\"blue\">using</span>( <span class=\"teal\">Transaction</span> tx = <span class=\"blue\">new</span> <span class=\"teal\">Transaction</span>( doc ) )\n    {\n      tx.Start( <span class=\"maroon\">\"Rolling Offset\"</span> );\n \n      <span class=\"green\">// Trim or extend existing pipes</span>\n \n      (pipes[0].Location <span class=\"blue\">as</span> <span class=\"teal\">LocationCurve</span>).Curve\n        = <span class=\"teal\">Line</span>.CreateBound( p0, q0 );\n \n      (pipes[1].Location <span class=\"blue\">as</span> <span class=\"teal\">LocationCurve</span>).Curve\n        = <span class=\"teal\">Line</span>.CreateBound( p1, q1 );\n \n      <span class=\"green\">// Add a model line for the rolling offset pipe</span>\n \n      <span class=\"teal\">Creator</span> creator = <span class=\"blue\">new</span> <span class=\"teal\">Creator</span>( doc );\n \n      <span class=\"teal\">Line</span> line = <span class=\"teal\">Line</span>.CreateBound( q0, q1 );\n \n      creator.CreateModelCurve( line );\n \n      tx.Commit();\n    }\n    <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Succeeded;\n  }\n}\n</pre><p>I hope you find this interesting and useful.</p><p>Here are two comments I received on this from Harry and Matt:</p><ul>\n<li>I'm pretty sure this is the most bad-ass thing anyone did at the Hackathon. Nice work Jeremy!</li>\n<li>I second that! I wasn't there but I will pretend I was!</li>\n</ul><p>The code presented above is available from\n\n<a href=\"https://github.com/jeremytammik/the_building_coder_samples\">\nThe Building Coder samples</a> GitHub\n\nrepository, and the version discussed here is\n\n<a href=\"https://github.com/jeremytammik/the_building_coder_samples/releases/tag/2014.0.106.1\">\nrelease 2014.0.106.1</a>.</p><p>Tere hommikust!</p>"
  }
]