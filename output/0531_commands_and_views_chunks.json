[
  {
    "original_filename": "0531_commands_and_views",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<head>\n<link href=\"bc.css\" rel=\"stylesheet\" type=\"text/css\"/>\n</head>"
  },
  {
    "original_filename": "0531_commands_and_views",
    "header_text": "Command and Conquer When Switching Views",
    "local_header_href": "#command-and-conquer-when-switching-views",
    "chunk_text": "<h3>Command and Conquer When Switching Views</h3><p>Today, February 3, is the first day of the \n\n<a href=\"http://en.wikipedia.org/wiki/Chinese_New_Year\">\nChinese New Year</a> and the beginning of the spring festival, which lasts for fifteen days.\n\nThis is a year of the \n\n<a href=\"http://en.wikipedia.org/wiki/Rabbit_%28zodiac%29\">\nRabbit zodiac sign</a>.\n\nHere is a \n\n<a href=\"http://en.wikipedia.org/wiki/Chunlian\">\nduilian</a>, \n\na pair of lines of poetry, or actually a special form called \n\n<a href=\"http://en.wikipedia.org/wiki/Chunlian\">\nchunlian</a>, used \n\nas a New Year's decoration that expresses happy and hopeful thoughts for the coming year sent us by Joe Ye from Beijing:</p><center>\n<img alt=\"Year of the rabbit chunlian\" src=\"img/year_of_the_rabbit_1.png\"/>\n</center><p>The meanings of these lines are:\n\n<ul>\n<li>Top: Lucky Star is shining.\n<li>Left: Good family, good person, and good luck.\n<li>Right: Abundant happiness, abundant fortune, and prosperous day.\n</li></li></li></ul>\n<p>Continuing our exploration of ways to automate Revit, Rudolf Honke of\n\n<a href=\"http://www.acadgraph.de\">\nacadGraph CADstudio GmbH</a> recently \n\npresented his results of exploring the Revit ribbon internals using UISpy,\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2011/01/ribbon-spying-and-ui-automation.html\">\ndriving Revit using UI Automation</a>, \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2011/01/subscribing-to-ui-automation-events.html\">\nsubscribing to UI Automation events</a>, and\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2011/01/further-ideas-for-using-ui-automation.html\">\nautomating Revit window switching</a>.\n\nIt is fascinating to be able to drive Revit pretty reliably from outside by simulating the user interaction with the ribbon and other user interface elements.\n\n<p>Here is the source code and Visual Studio project for the sample application \n\n<a href=\"zip/DrivingRevitViaUiAutomation.zip\">\nDrivingRevitViaUIAutomation</a> that \n\nRudolf used to implement the following three functionalities from a \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2011/01/ribbon-spying-and-ui-automation.html#app\">\nstand-alone executable</a>:\n\n<ul>\n<li>Open a Revit document.\n<li>Close the active document with or without saving it.\n<li>Switch the current ribbon tab.\n</li></li></li></ul>\n<center>\n<img alt=\"UI automation sample application with populated ribbon tabs\" src=\"img/rh_ui_automation_sample_populated.png\"/>\n</center>\n<p>He continues with some more thoughts on setting active windows and views:\n\n<p>I suppose that setting the active view via GUI cannot be performed on command level, so it must be performed at application level.\nJust imagine this situation: \nFirst, you press your button to call your command. \nThen, this command changes the view or the document.\nIf your command changes your document, your transaction (which is per document – also the undo stack is per document, of course) may become invalid.\nIn Revit, changing the view affects the availability of the 'ADD_INS_TAB'.\n\n<p>In addition, it makes sense to invalidate the command context after switching the active view, situations can occur where the new view is of ViewType.Schedule.\nIn this sort of view, neither can external commands be executed nor will the OnIdling event be fired.\n\n<p>So, how can we perform this, though?\n\n<p>I suggest an approach which invokes a command twice, in fact.\n\n<p>The idea is to provide an OnIdling event handler that invokes commands after setting the new active view or document.\nFor example, first you invoke your command.\nIn this command, you have two possibilities.\nIf the active view (and/or the active document) is right, do the work as usual.\nIf not, activate the OnIdling event and fill a global variable of type 'AutomationElement' with your corresponding command button. \nNext time Revit idles, this button will be invoked, so your command will be performed in the right document and view, without violating the transaction mechanism.\n\n<p>After this, the global variable can be set to null and the OnIdling event handler can be deactivated again.\n\n<p>It would of course also be possible to let the event remain alive all the time while Revit is running, but why waste performance?\n\n<p>Another point:\n\n<p>Invoking commands can be performed in other ways than by pressing buttons.\nUsing the IExternalCommand interface just means that an Execute method with the appropriate signature must be implemented:\n\n<pre class=\"code\">\n<span class=\"blue\">public</span> <span class=\"teal\">Result</span> Execute(\n  <span class=\"teal\">ExternalCommandData</span> revit,\n  <span class=\"blue\">ref</span> <span class=\"teal\">String</span> message,\n  <span class=\"teal\">ElementSet</span> elements )\n{\n  <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Succeeded;\n}\n</pre>\n<p>You could just as well define a placeholder Execute method and call another method with different parameters from it, such as this:\n\n<pre class=\"code\">\n<span class=\"blue\">public</span> <span class=\"teal\">Result</span> Execute( <span class=\"teal\">UIApplication</span> revit )\n{\n  <span class=\"green\">// do some useful stuff here…</span>\n \n  <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Succeeded;\n}\n</pre>\n<p>It could be invoked like this:\n\n<pre class=\"code\">\n<span class=\"blue\">void</span> application_Idling( \n  <span class=\"blue\">object</span> sender, \n  IdlingEventArgs e )\n{\n  <span class=\"teal\">Application</span> app = sender <span class=\"blue\">as</span> <span class=\"teal\">Application</span>;\n \n  <span class=\"teal\">UIApplication</span> uiApp = <span class=\"blue\">new</span> <span class=\"teal\">UIApplication</span>( app );\n \n  Command_Example cmdExample = <span class=\"blue\">new</span> Command_Example();\n \n  cmdExample.Execute( uiApp ); <span class=\"green\">// invoke command here</span>\n}\n</pre>\n<p>So, instead of a global 'AutomationElement' for the next button to be pressed, another type could be chosen, and no button needs to be pressed, which may be faster, by the way.\nIt may be necessary to set a pause between ending the first command and invoking the second one.\nTo be continued...</p>\n<center>\n<img alt=\"Happy New Year of the Rabbit\" src=\"img/year_of_the_rabbit_2.png\"/>\n</center>\n<p>Happy New Year of the Rabbit!\n\n<p><strong>Addendum:</strong> Arnošt Löbel adds that an alternative and simpler solution would be to subscribe to the ViewActivated event instead of Idling.  \nThis event is much better suited for this particular problem.\nIn addition, it is much less of a performance hit, because ViewActivated is raised only when a view is actually activated, while Idling can be raised several times per second.\nEven if the handler does nothing at all, simply the fact that the code needs to go from native to managed and back to native again means a significant slowdown.\n</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p>"
  }
]