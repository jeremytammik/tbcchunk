[
  {
    "original_filename": "0133_transform_element",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<style>\n.blue { color: blue; }\n.teal { color: teal; }\n.maroon { color: maroon; }\n.green { color: green; }\n</style>"
  },
  {
    "original_filename": "0133_transform_element",
    "header_text": "Transform an Element",
    "local_header_href": "#transform-an-element",
    "chunk_text": "<h3>Transform an Element</h3><p><strong>Question:</strong>\nHow can I apply a transformation to a Revit element or family instance?\n\n<p>I used to work in the AutoCAD API, where I could apply a transformation using the transformBy() method.\nIt takes an AcGeMatrix3d parameter, which can represent a composed transformation including rotation, scaling, translation and mirroring.</p>\n<p>In the Revit API, I see the use of the 4x3 matrix represented by the Transform class, which I suppose serves the same purpose.\nHowever, I am unable to find a method like transformBy() to apply this transformation to a FamilyInstance or any other graphic element.</p>\n<p>Therefore, my questions are:</p>\n<ol>\n<li>Is there a way to apply a transformation matrix to a Revit element?</li>\n<li>Can this matrix be applied containing simultaneous rotation, translation and mirroring transformations?</li>\n<li>If there is no such function, how can I decompose a Transform to apply the transformation through the Move, Rotate and Mirror document commands?</li>\n</ol>\n<p><strong>Answer:</strong>\nAs much as possible I would recommend to avoid comparing the AutoCAD and Revit APIs.\nIn AutoCAD, everything is disconnected and anything can be done.\nIn Revit, everything is totally parameterised and connected, and almost no independent manipulation of objects is possible, because almost everything affects almost everything else.</p>\n<p>For instance, imagine the effect of a transformation including a non-unit scale factor on a Revit element.\nIn the case of a wall, the wall type includes information on the wall thickness.\nBlindly applying such a transformation to the wall would change its thickness, which would require it to change its type.\nThis is a rather far-reaching modification, more than you might have expected, coming from an environment like AutoCAD.\nTherefore, the Revit API does not provide any method for scaling elements, or more generally applying general transformations to them.</p>\n<p>The FamilyInstance class provides a property Location, which can be used to find the physical location of an instance within project. It overrides the base class Element.Location, which provides the same functionality for generic elements. As the description says, it is a read-only property.</p>\n<p>The location object provides the ability to translate and rotate elements. More detailed location information and control can be found by using the derivatives of this object, such as LocationPoint and LocationCurve.</p>\n<p>You might be able to make use of the Location.Move and Rotate methods for your purposes:</p>\n<ul>\n<li>Move: move the element within the project by a specified vector.</li>\n<li>Rotate: rotate the element within the project by a specified number of degrees around a given axis.</li>\n</ul>\n<p>The document class provides similar methods to manipulate several elements simultaneously:</p>\n<ul>\n<li>Move: overloaded, moves one or more elements within the document by a specified vector.</li>\n<li>Rotate: overloaded, rotates one or more elements within the document by a specified number of degrees around a given axis.</li>\n</ul>\n<p>The overloads are provided so you can specify the affected elements by individual element or element id, or by a whole set of each respectively.</p>\n<p>The Document and Element classes also provide analogous methods to mirror one or more elements.</p>\n<p>In exact details of what you can and cannot do will obviously depend on the circumstances, such as what kind of elements you are manipulating and what transformations you wish to apply.</p>\n<p>The Revit API does not provide methods to decompose an arbitrary Transform instance, beyond the ones listed in the help file. For instance, you can check whether a transformation is a translation using IsTranslation, in which case the translation vector can be obtained from the Origin property.</p>\n<p>Decomposing a matrix in the manner you describe is not a trivial task. Here is some old Silicon Graphics C++ code I found which achieves this and also includes some documentation and references for further reading and research. More references and background information is provided by the Wikipedia article on\n\n<a href=\"http://en.wikipedia.org/wiki/Matrix_decomposition\">\nmatrix decomposition</a>:</p>\n<pre class=\"code\">\n<span class=\"green\">//</span>\n<span class=\"green\">// Decompose a rotation into translation etc, based on scale</span>\n<span class=\"green\">//</span>\n<span class=\"green\">// Decomposes the matrix into a translation, rotation, scale,</span>\n<span class=\"green\">// and scale orientation.  Any projection information is discarded.</span>\n<span class=\"green\">// The decomposition depends upon choice of center point for</span>\n<span class=\"green\">// rotation and scaling, which is optional as the last parameter.</span>\n<span class=\"green\">// Note that if the center is 0, decompose() is the same as</span>\n<span class=\"green\">// factor() where \"t\" is translation, \"u\" is rotation, \"s\" is scaleFactor,</span>\n<span class=\"green\">// and \"r\" is ScaleOrientattion.</span>\n<span class=\"green\">//</span>\n<span class=\"blue\">void</span>\nSbMatrix::getTransform(\n  SbVec3f &amp; translation,\n  SbRotation &amp; rotation,\n  SbVec3f &amp; scaleFactor,\n  SbRotation &amp; scaleOrientation,\n  <span class=\"blue\">const</span> SbVec3f &amp;center ) <span class=\"blue\">const</span>\n{\n  SbMatrix so, rot, proj;\n  <span class=\"blue\">if</span> (center != SbVec3f(0,0,0)) {\n    <span class=\"green\">// to get fields for a non-0 center, we</span>\n    <span class=\"green\">// need to decompose a new matrix \"m\" such</span>\n    <span class=\"green\">// that [-center][m][center] = [this]</span>\n    <span class=\"green\">// i.e., [m] = [center][this][-center]</span>\n    <span class=\"green\">// (this trick stolen from Showcase code)</span>\n    SbMatrix m,c;\n    m.setTranslate(-center);\n    m.multLeft(*<span class=\"blue\">this</span>);\n    c.setTranslate(center);\n    m.multLeft(c);\n    m.factor(so,scaleFactor,rot,translation,proj);\n  }\n  <span class=\"blue\">else</span> {\n    <span class=\"blue\">this</span>-&gt;factor(so,scaleFactor,rot,translation,proj);\n  }\n  scaleOrientation = so.transpose();  <span class=\"green\">// have to transpose because factor gives us transpose of correct answer.</span>\n  rotation = rot;\n}\n\n<span class=\"green\">//</span>\n<span class=\"green\">// Factors a matrix m into 5 pieces: m = r s r^ u t, where r^</span>\n<span class=\"green\">// means transpose of r, and r and u are rotations, s is a scale,</span>\n<span class=\"green\">// and t is a translation. Any projection information is returned</span>\n<span class=\"green\">// in proj.</span>\n<span class=\"green\">//</span>\n<span class=\"green\">// routines for matrix factorization taken from BAGS code, written by</span>\n<span class=\"green\">// John Hughes (?).  Original comment follows:</span>\n<span class=\"green\">//</span>\n<span class=\"green\">/* Copyright 1988, Brown Computer Graphics Group.  All Rights Reserved. */</span>\n<span class=\"green\">/* --------------------------------------------------------------------------</span>\n<span class=\"green\"> * This file contains routines to do the MAT3factor operation, which</span>\n<span class=\"green\"> * factors a matrix m:</span>\n<span class=\"green\"> *    m = r s r^ u t, where r^ means transpose of r, and r and u are</span>\n<span class=\"green\"> * rotations, s is a scale, and t is a translation.</span>\n<span class=\"green\"> *</span>\n<span class=\"green\"> * It is based on the Jacobi method for diagonalizing real symmetric</span>\n<span class=\"green\"> * matrices, taken from Linear Algebra, Wilkenson and Reinsch, Springer-Verlag</span>\n<span class=\"green\"> * math series, Volume II, 1971, page 204.  Call number QA251W623.</span>\n<span class=\"green\"> * In ALGOL!</span>\n<span class=\"green\"> * -------------------------------------------------------------------------*/</span>\n<span class=\"green\">/*</span>\n<span class=\"green\"> * Variable declarations from the original source:</span>\n<span class=\"green\"> *</span>\n<span class=\"green\"> * n  : order of matrix A</span>\n<span class=\"green\"> * eivec: true if eigenvectors are desired, false otherwise.</span>\n<span class=\"green\"> * a  : Array [1:n, 1:n] of numbers, assumed symmetric!</span>\n<span class=\"green\"> *</span>\n<span class=\"green\"> * a  : Superdiagonal elements of the original array a are destroyed.</span>\n<span class=\"green\"> *    Diagonal and subdiagonal elements are untouched.</span>\n<span class=\"green\"> * d  : Array [1:n] of eigenvalues of a.</span>\n<span class=\"green\"> * v  : Array [1:n, 1:n] containing (if eivec = TRUE), the eigenvectors of</span>\n<span class=\"green\"> *    a, with the kth column being the normalized eigenvector with</span>\n<span class=\"green\"> *    eigenvalue d[k].</span>\n<span class=\"green\"> * rot  : The number of jacobi rotations required to perform the operation.</span>\n<span class=\"green\"> */</span>\nSbBool\nSbMatrix::factor(\n  SbMatrix &amp; r,\n  SbVec3f &amp; s,\n  SbMatrix &amp; u,\n  SbVec3f &amp; t,\n  SbMatrix &amp; proj ) <span class=\"blue\">const</span>\n{\n  <span class=\"blue\">double</span>    det;        <span class=\"green\">/* Determinant of matrix A    */</span>\n  <span class=\"blue\">double</span>    det_sign;    <span class=\"green\">/* -1 if det &lt; 0, 1 if det &gt; 0    */</span>\n  <span class=\"blue\">double</span>    scratch;\n  <span class=\"blue\">int</span>        i, j;\n  <span class=\"blue\">int</span>        junk;\n  SbMatrix    a, b, si;\n  <span class=\"blue\">float</span>    evalues[3];\n  SbVec3f    evectors[3];\n \n  a = *<span class=\"blue\">this</span>;\n  proj.makeIdentity();\n  scratch = 1.0;\n \n  <span class=\"blue\">for</span> (i = 0; i &lt; 3; i++) {\n    <span class=\"blue\">for</span> (j = 0; j &lt; 3; j++) {\n      a.matrix[i][j] *= scratch;\n    }\n    t[i] = matrix[3][i] * scratch;\n    a.matrix[3][i] = a.matrix[i][3] = 0.0;\n  }\n  a.matrix[3][3] = 1.0;\n \n  <span class=\"green\">/* (3) Compute det A. If negative, set sign = -1, else sign = 1 */</span>\n  det = a.det3();\n  det_sign = (det &lt; 0.0 ? -1.0 : 1.0);\n  <span class=\"blue\">if</span> (det_sign * det &lt; 1e-12)\n    <span class=\"blue\">return</span>(FALSE);        <span class=\"green\">// singular</span>\n \n  <span class=\"green\">/* (4) B = A * A^  (here A^ means A transpose) */</span>\n  b = a * a.transpose();\n \n  b.jacobi3(evalues, evectors, junk);\n \n  <span class=\"green\">// find min / max eigenvalues and do ratio test to determine singularity</span>\n \n  r = SbMatrix(evectors[0][0], evectors[0][1], evectors[0][2], 0.0,\n         evectors[1][0], evectors[1][1], evectors[1][2], 0.0,\n         evectors[2][0], evectors[2][1], evectors[2][2], 0.0,\n         0.0, 0.0, 0.0, 1.0);\n \n  <span class=\"green\">/* Compute s = sqrt(evalues), with sign. Set si = s-inverse */</span>\n  si.makeIdentity();\n  <span class=\"blue\">for</span> (i = 0; i &lt; 3; i++) {\n    s[i] = det_sign * sqrt(evalues[i]);\n    si.matrix[i][i] = 1.0 / s[i];\n  }\n \n  <span class=\"green\">/* (5) Compute U = R^ S! R A. */</span>\n  u = r * si * r.transpose() * a;\n \n  <span class=\"blue\">return</span>(TRUE);\n}\n</pre>\n<p>I believe that if the matrix is mirroring, then the scaling vector produced by the decomposition above will have one or two negative and one or two positive components. If all three are either positive or negative, then it is not a mirroring.</p>\n<p>An easy way to determine whether a matrix is a mirroring transformation or not is to check its\n<a href=\"http://en.wikipedia.org/wiki/Determinant\">\ndeterminant</a>.\n\nIf it is negative, the transformation is a mirroring, I believe. Happily, the determinant is provided directly by the Revit API as a property of the Transform class.</p>\n<p>In Revit 2010, we have some updated API functionality affecting this area, specifically the Instance.Transformed method and geometry of Instances. There is a paragraph in the What's New section of the help file on this topic:</p>\n<span style=\"color:darkslateblue\">\n<h4>Instance.Transformed[Transform] and geometry of Instances</h4>\n<p>This property has been removed.  Obtain the transformed geometry of the instance using Instance.GetInstanceGeometry(), Instance.GetSymbolGeometry(Transform) and Instance.GetInstanceGeometry(Transform).</p>\n</span>\n<p>The two overloads compute the geometric representation of the instance and a transformation it, respectively.</p>\n</p>"
  },
  {
    "original_filename": "0133_transform_element",
    "header_text": "Instance.Transformed[Transform] and geometry of Instances",
    "local_header_href": "#instancetransformedtransform-and-geometry-of-instances",
    "chunk_text": "<h4>Instance.Transformed[Transform] and geometry of Instances</h4><p>This property has been removed.  Obtain the transformed geometry of the instance using Instance.GetInstanceGeometry(), Instance.GetSymbolGeometry(Transform) and Instance.GetInstanceGeometry(Transform).</p>"
  }
]