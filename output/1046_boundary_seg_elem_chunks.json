[
  {
    "original_filename": "1046_boundary_seg_elem",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<head>\n<meta content=\"text/html; charset=utf-8\" http-equiv=\"Content-Type\"/>\n<link href=\"bc.css\" rel=\"stylesheet\" type=\"text/css\"/>\n</head>"
  },
  {
    "original_filename": "1046_boundary_seg_elem",
    "header_text": "Determining Room Boundary Segment Generating Element",
    "local_header_href": "#determining-room-boundary-segment-generating-element",
    "chunk_text": "<h3>Determining Room Boundary Segment Generating Element</h3><p>Today we look at how to determine the neighbouring BIM element of a room boundary segment using the ReferenceIntersector to shoot a ray from the room interior into the bounding element.</p><p>There should not really be any need to implement such functionality ourselves, because the BoundarySegment class already provides an Element property that should return the BIM element generating the given boundary segment.</p><p>However, unfortunately, the BoundarySegment.Element may erroneously return null under certain specific conditions, and we present a nice little Revit API workaround that can be triggered when the Element property fails.</p><p>Here are a couple of examples of retrieving room boundaries that we discussed in the past:</p><ul>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2011/11/accessing-room-data.html\">Accessing room data</a></li>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2012/08/graphically-display-area-boundary-loops.html\">Graphically display area boundary loops</a></li>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2012/08/room-in-area-predicate-via-point-in-polygon-test.html\">Room in area predicate via point in polygon test</a></li>\n<li>Analysis of Room and Space 3D geometry in the <a href=\"http://thebuildingcoder.typepad.com/blog/2013/02/whats-new-in-the-revit-2012-api.html\">Revit 2012 API news</a></li>\n<li>New GetBoundarySegments method in the <a href=\"http://thebuildingcoder.typepad.com/blog/2013/03/whats-new-in-the-revit-2013-api.html\">Revit 2013 API news</a></li>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2013/03/revit-2014-api-and-room-plan-view-boundary-polygon-loops.html#3\">Retrieving plan view room boundary polygon loops</a></li>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2013/09/room-neighbours.html\">Room neighbours</a></li>\n</ul><p>We also looked at several ray shooting examples to discover neighbouring elements, e.g.</p><ul>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2012/01/identifying-wall-compound-layers-and-parts.html\">Identifying wall compound layers and parts</a></li>\n<li>The <a href=\"http://thebuildingcoder.typepad.com/blog/2012/03/revit-2013-and-its-api.html#3\">ReferenceIntersector class</a></li>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2012/10/wall-footing-relationship-revisited.html\">Wall footing relationship</a></li>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2012/10/uiview-windows-coordinates-referenceintersector-and-my-own-tooltip.html\">UIView, Windows Coordinates, ReferenceIntersector and My Own Tooltip</a></li>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2013/03/supporting-columns.html#2\">Determining the columns supporting a beam</a> by\n<a href=\"http://thebuildingcoder.typepad.com/blog/2013/03/supporting-columns.html#8\">ray casting</a>\n</li>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2013/07/football-and-space-adjacency-for-heat-load-calculation.html#3\">Space adjacency for heat load calculation</a></li>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2013/09/room-neighbours.html\">Room neighbours</a></li>\n</ul><p>Note that the recent\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2013/09/room-neighbours.html\">\nroom neighbour</a> discussion\n\nbelongs to both of these two groups and is actually very similar to the bounding element sample we discuss here.</p><p>The former shoots a ray from the room through the midpoint of each boundary segment to find the neighbouring room, whereas this example stops a bit shorter and determines the element in between instead.</p><p>Rudolf Honke of\n\n<a href=\"http://www.acadgraph.de\">\nMensch und Maschine acadGraph</a> raised\n\nthis issue in his interminable list of what he calls unreliable properties:</p><p><strong>Question:</strong> I want to retrieve each Element alongside a room’s boundary.</p><p>However, I have an issue with all walls protruding into a room like this:</p><center>\n<img alt=\"Boundary segment lacking Element\" src=\"img/GetBoundarySegmentElement.png\" width=\"400\"/>\n</center><p>The marked boundary segment has no Element associated with it, according to the BoundarySegment.Element property, which returns null for it.</p><p>I can reproduce this behaviour in several files, so I think this is the API default behaviour.</p><p><strong>Answer:</strong> Let's look for a workaround.</p><p>For instance, if you look at the ordered list of segments going around the room, and the preceding and succeeding segments both belong to the same element, then you can assume that the segment in between with a null element pointer also belongs to that same element?</p><p><strong>Response:</strong> No, there can be situations like this, where predecessor and successor are different elements:</p><center>\n<img alt=\"Boundary segment lacking Element\" src=\"img/GetBoundarySegmentElement2.png\" width=\"400\"/>\n</center><p><strong>Answer:</strong> OK, I see that your example cannot be solved looking at the predecessor and successor segments.</p><p>Next suggestion, also very simple to implement:</p><ol>\n<li>For each segment with a null element pointer:</li>\n<li>Determine which direction faces into the room</li>\n<li>Determine a point in the room, slightly inside, offset from the segment midpoint.</li>\n<li>Shoot a ray from that point through the segment midpoint.</li>\n<li>Ensure that an element is hit in the segment midpoint. If not, something is strange.</li>\n<li>The element hit is the element you are looking for.</li>\n</ol><p><strong>Response:</strong> Thank you for the hint; I already had nearly the same idea of shooting laser rays ;-)</p><p>Using your approach, I finally got it.</p><p>No need to look at the neighbouring BoundarySegments any more.</p><a name=\"2\"></a>"
  },
  {
    "original_filename": "1046_boundary_seg_elem",
    "header_text": "GetElementByRay Implementation",
    "local_header_href": "#getelementbyray-implementation",
    "chunk_text": "<h4>GetElementByRay Implementation</h4><p>Rudolf provided this implementation of the suggested algorithm:</p><pre class=\"code\">\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n  <span class=\"gray\">///</span><span class=\"green\"> Return direction turning 90 degrees </span>\n  <span class=\"gray\">///</span><span class=\"green\"> left from given input vector.</span>\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n  <span class=\"blue\">public</span> <span class=\"teal\">XYZ</span> GetLeftDirection( <span class=\"teal\">XYZ</span> direction )\n  {\n    <span class=\"blue\">double</span> x = -direction.Y;\n    <span class=\"blue\">double</span> y = direction.X;\n    <span class=\"blue\">double</span> z = direction.Z;\n    <span class=\"blue\">return</span> <span class=\"blue\">new</span> <span class=\"teal\">XYZ</span>( x, y, z );\n  }\n \n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n  <span class=\"gray\">///</span><span class=\"green\"> Return direction turning 90 degrees </span>\n  <span class=\"gray\">///</span><span class=\"green\"> right from given input vector.</span>\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n  <span class=\"blue\">public</span> <span class=\"teal\">XYZ</span> GetRightDirection( <span class=\"teal\">XYZ</span> direction )\n  {\n    <span class=\"blue\">return</span> GetLeftDirection( direction.Negate() );\n  }\n \n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n  <span class=\"gray\">///</span><span class=\"green\"> Return the neighbouring BIM element generating </span>\n  <span class=\"gray\">///</span><span class=\"green\"> the given room boundary curve c, assuming it</span>\n  <span class=\"gray\">///</span><span class=\"green\"> is oriented counter-clockwise around the room</span>\n  <span class=\"gray\">///</span><span class=\"green\"> if part of an interior loop, and vice versa.</span>\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n  <span class=\"blue\">public</span> <span class=\"teal\">Element</span> GetElementByRay(\n    <span class=\"teal\">UIApplication</span> app,\n    <span class=\"teal\">Document</span> doc,\n    <span class=\"teal\">View3D</span> view3d,\n    <span class=\"teal\">Curve</span> c )\n  {\n    <span class=\"teal\">Element</span> boundaryElement = <span class=\"blue\">null</span>;\n \n    <span class=\"green\">// Tolerances</span>\n \n    <span class=\"blue\">const</span> <span class=\"blue\">double</span> minTolerance = 0.00000001;\n    <span class=\"blue\">const</span> <span class=\"blue\">double</span> maxTolerance = 0.01;\n \n    <span class=\"green\">// Height of ray above room level:</span>\n    <span class=\"green\">// ray starts from one foot above room level</span>\n \n    <span class=\"blue\">const</span> <span class=\"blue\">double</span> elevation = 1;\n \n    <span class=\"green\">// Ray starts not directly from the room border</span>\n    <span class=\"green\">// but from a point offset slightly into it.</span>\n \n    <span class=\"blue\">const</span> <span class=\"blue\">double</span> stepInRoom = 0.1;\n \n    <span class=\"green\">// We could use Line.Direction if Curve c is a </span>\n    <span class=\"green\">// Line, but since c also might be an Arc, we </span>\n    <span class=\"green\">// calculate direction like this:</span>\n \n    <span class=\"teal\">XYZ</span> lineDirection\n      = ( c.GetEndPoint( 1 ) - c.GetEndPoint( 0 ) )\n        .Normalize();\n \n    <span class=\"teal\">XYZ</span> upDir = elevation * <span class=\"teal\">XYZ</span>.BasisZ;\n \n    <span class=\"green\">// Assume that the room is on the left side of </span>\n    <span class=\"green\">// the room boundary curve and wall on the right.</span>\n    <span class=\"green\">// This is valid for both outer and inner room </span>\n    <span class=\"green\">// boundaries (outer are counter-clockwise, inner </span>\n    <span class=\"green\">// are clockwise). Start point is slightly inside </span>\n    <span class=\"green\">// the room, one foot above room level.</span>\n \n    <span class=\"teal\">XYZ</span> toRoomVec = stepInRoom * GetLeftDirection(\n      lineDirection );\n \n    <span class=\"teal\">XYZ</span> pointBottomInRoom = c.Evaluate( 0.5, <span class=\"blue\">true</span> )\n      + toRoomVec;\n \n    <span class=\"teal\">XYZ</span> startPoint = pointBottomInRoom + upDir;\n \n    <span class=\"green\">// We are searching for walls only</span>\n \n    <span class=\"teal\">ElementFilter</span> wallFilter\n      = <span class=\"blue\">new</span> <span class=\"teal\">ElementCategoryFilter</span>(\n        <span class=\"teal\">BuiltInCategory</span>.OST_Walls );\n \n    <span class=\"teal\">ReferenceIntersector</span> intersector\n      = <span class=\"blue\">new</span> <span class=\"teal\">ReferenceIntersector</span>( wallFilter,\n        <span class=\"teal\">FindReferenceTarget</span>.Element, view3d );\n \n    <span class=\"green\">// We don't want to find elements in linked files</span>\n \n    intersector.FindReferencesInRevitLinks = <span class=\"blue\">false</span>;\n \n    <span class=\"teal\">XYZ</span> toWallDir = GetRightDirection(\n      lineDirection );\n \n    <span class=\"teal\">ReferenceWithContext</span> context = intersector\n      .FindNearest( startPoint, toWallDir );\n \n    <span class=\"teal\">Reference</span> closestReference = <span class=\"blue\">null</span>;\n \n    <span class=\"blue\">if</span>( context != <span class=\"blue\">null</span> )\n    {\n      <span class=\"blue\">if</span>( ( context.Proximity &gt; minTolerance )\n        &amp;&amp; ( context.Proximity &lt; maxTolerance\n          + stepInRoom ) )\n      {\n        closestReference = context.GetReference();\n \n        <span class=\"blue\">if</span>( closestReference != <span class=\"blue\">null</span> )\n        {\n          boundaryElement = doc.GetElement(\n            closestReference );\n        }\n      }\n    }\n    <span class=\"blue\">return</span> boundaryElement;\n  }\n</pre><a name=\"3\"></a>"
  },
  {
    "original_filename": "1046_boundary_seg_elem",
    "header_text": "GetBoundarySegmentElement External Command Implementation",
    "local_header_href": "#getboundarysegmentelement-external-command-implementation",
    "chunk_text": "<h4>GetBoundarySegmentElement External Command Implementation</h4><p>I implemented an add-in named GetBoundarySegmentElement and added the following read-only external command implementation to drive it:</p><pre class=\"code\">\n<span class=\"blue\">public</span> <span class=\"teal\">Result</span> Execute(\n  <span class=\"teal\">ExternalCommandData</span> commandData,\n  <span class=\"blue\">ref</span> <span class=\"blue\">string</span> message,\n  <span class=\"teal\">ElementSet</span> elements )\n{\n  <span class=\"teal\">UIApplication</span> uiapp = commandData.Application;\n  <span class=\"teal\">UIDocument</span> uidoc = uiapp.ActiveUIDocument;\n  <span class=\"teal\">Application</span> app = uiapp.Application;\n  <span class=\"teal\">Document</span> doc = uidoc.Document;\n  <span class=\"teal\">Selection</span> sel = uidoc.Selection;\n \n  <span class=\"teal\">List</span>&lt;<span class=\"teal\">Room</span>&gt; rooms = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">Room</span>&gt;(\n    sel.Elements.Cast&lt;<span class=\"teal\">Room</span>&gt;() );\n \n  <span class=\"blue\">if</span>( 1 != rooms.Count )\n  {\n    message = <span class=\"maroon\">\"Please select exactly one room.\"</span>;\n \n    <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n  }\n \n  <span class=\"teal\">View3D</span> view3d\n    = <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( doc )\n      .OfClass( <span class=\"blue\">typeof</span>( <span class=\"teal\">View3D</span> ) )\n      .Cast&lt;<span class=\"teal\">View3D</span>&gt;()\n      .FirstOrDefault&lt;<span class=\"teal\">View3D</span>&gt;(\n        e =&gt; e.Name.Equals( <span class=\"maroon\">\"{3D}\"</span> ) );\n \n  <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == view3d )\n  {\n    message = <span class=\"maroon\">\"No 3D view named '{3D}' found.\"</span>;\n \n    <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n  }\n \n  <span class=\"blue\">foreach</span>( <span class=\"teal\">Room</span> room <span class=\"blue\">in</span> rooms )\n  {\n    <span class=\"teal\">IList</span>&lt;<span class=\"teal\">IList</span>&lt;<span class=\"teal\">BoundarySegment</span>&gt;&gt; loops\n      = room.GetBoundarySegments(\n        <span class=\"blue\">new</span> <span class=\"teal\">SpatialElementBoundaryOptions</span>() );\n \n    <span class=\"blue\">int</span> n = loops.Count;\n \n    <span class=\"teal\">Debug</span>.Print(\n      <span class=\"maroon\">\"Room {0} has {1} loop{2}{3}\"</span>,\n      room.Name, n, PluralSuffix( n ),\n      DotOrColon( n ) );\n \n    <span class=\"blue\">int</span> i = 0;\n \n    <span class=\"blue\">foreach</span>( <span class=\"teal\">IList</span>&lt;<span class=\"teal\">BoundarySegment</span>&gt; loop <span class=\"blue\">in</span> loops )\n    {\n      n = loop.Count;\n \n      <span class=\"teal\">Debug</span>.Print(\n        <span class=\"maroon\">\"  Loop {0} has {1} segment{2}{3}\"</span>,\n        i++, n, PluralSuffix( n ),\n        DotOrColon( n ) );\n \n      <span class=\"blue\">int</span> j = 0;\n \n      <span class=\"blue\">foreach</span>( <span class=\"teal\">BoundarySegment</span> seg <span class=\"blue\">in</span> loop )\n      {\n        <span class=\"teal\">Element</span> e = seg.Element;\n \n        <span class=\"blue\">string</span> s = <span class=\"maroon\">\"Element property\"</span>;\n \n        <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == e )\n        {\n          s = <span class=\"maroon\">\"GetElementByRay\"</span>;\n \n          e = GetElementByRay( uiapp, doc, view3d,\n            seg.Curve );\n        }\n \n        <span class=\"teal\">Debug</span>.Print(\n          <span class=\"maroon\">\"    Segment {0}: {1} element {2} returned by {3}\"</span>,\n          j++, CurveString( seg.Curve ),\n          ElementDescription( e ), s );\n      }\n    }\n  }\n  <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Succeeded;\n}\n</pre><p>As always, 45% of the code is input validation, 45% output reporting, and about 10% or less the real thing.\nThat's life.</p><p>Here is the result of running the GetBoundarySegmentElement command on the simple sample model shown above:</p><pre>\nRoom Test 1 has 1 loop:\n  Loop 0 has 8 segments:\n    Segment 0: line (-13.95,23.02,0) --&gt; (-21.99,23.02,0)\n      wall 326988 MW 24.0 WD 12.0 returned by Element property\n    Segment 1: line (-21.99,23.02,0) --&gt; (-21.99,13.04,0)\n      wall 327085 MW 24.0 WD 12.0 returned by Element property\n    Segment 2: line (-21.99,13.04,0) --&gt; (-3.81,13.04,0)\n      wall 327055 MW 24.0 WD 12.0 returned by Element property\n    Segment 3: line (-3.81,13.04,0) --&gt; (-3.81,23.02,0)\n      wall 327018 MW 24.0 WD 12.0 returned by Element property\n    Segment 4: line (-3.81,23.02,0) --&gt; (-12.97,23.02,0)\n      wall 326988 MW 24.0 WD 12.0 returned by Element property\n    Segment 5: line (-12.97,23.02,0) --&gt; (-12.97,17.44,0)\n      wall 327196 STB 30.0 returned by Element property\n    Segment 6: line (-12.97,17.44,0) --&gt; (-13.95,17.44,0)\n      wall 327196 STB 30.0 <b>returned by GetElementByRay</b>\n    Segment 7: line (-13.95,17.44,0) --&gt; (-13.95,23.02,0)\n      wall 327196 STB 30.0 returned by Element property\n</pre><p>Note that the BoundarySegment Element property returned null for the next to last segment 6, and the GetElementByRay method was used instead to retrieve the correct wall.</p><a name=\"4\"></a>"
  },
  {
    "original_filename": "1046_boundary_seg_elem",
    "header_text": "SpatialElementBoundaryLocation Enumeration",
    "local_header_href": "#spatialelementboundarylocation-enumeration",
    "chunk_text": "<h4>SpatialElementBoundaryLocation Enumeration</h4><p><strong>Response:</strong> When reading the blog post draft, I see:</p><pre class=\"code\">\n  <span class=\"blue\">foreach</span>( <span class=\"teal\">Room</span> room <span class=\"blue\">in</span> rooms )\n  {\n    <span class=\"teal\">IList</span>&lt;<span class=\"teal\">IList</span>&lt;<span class=\"teal\">BoundarySegment</span>&gt;&gt; loops\n      = room.GetBoundarySegments(\n        <span class=\"blue\">new</span> <span class=\"teal\">SpatialElementBoundaryOptions</span>() );\n</pre><p>I would have thought that we need to tell the SpatialElementBoundaryOptions what sort of SpatialElementBoundaryLocation we want; we need Finish:</p><center>\n<img alt=\"SpatialElementBoundaryLocation enumeration\" src=\"img/GetBoundarySegmentElement3.png\" width=\"460\"/>\n</center><p>Here is a suitable code snippet:</p><pre class=\"code\">\n  <span class=\"teal\">SpatialElementBoundaryOptions</span> opt\n    = <span class=\"blue\">new</span> <span class=\"teal\">SpatialElementBoundaryOptions</span>();\n \n  opt.SpatialElementBoundaryLocation\n    = <span class=\"teal\">SpatialElementBoundaryLocation</span>.Finish;\n \n  <span class=\"teal\">IList</span>&lt;<span class=\"teal\">IList</span>&lt;<span class=\"teal\">BoundarySegment</span>&gt;&gt; loops\n    = room.GetBoundarySegments( opt );\n</pre><p>Of course it may be that SpatialElementBoundaryOptions are already initialized with Finish by default, but the Revit API help file RevitAPI.chm does not mention that in the object’s constructor documentation.</p><p>Otherwise, room boundaries might be inside the boundary elements, which would affect the result.</p><p>SpatialElementBoundaryLocation.Center might return something like these red lines:</p><center>\n<img alt=\"Room boundaries at SpatialElementBoundaryLocation.Center\" src=\"img/GetBoundarySegmentElement4.png\" width=\"400\"/>\n</center><p>In this case, there would be no line to get the wall’s small front face from.</p><p><strong>Answer:</strong> I added the suggested setting and re-ran the test, producing the following output:</p><pre>\nRoom Test 1 has 1 loop:\n  Loop 0 has 8 segments:\n    Segment 0: line (-13.95,23.02,0) --&gt; (-21.99,23.02,0)\n      wall 326988 MW 24.0 WD 12.0 returned by Element property\n    Segment 1: line (-21.99,23.02,0) --&gt; (-21.99,13.04,0)\n      wall 327085 MW 24.0 WD 12.0 returned by Element property\n    Segment 2: line (-21.99,13.04,0) --&gt; (-3.81,13.04,0)\n      wall 327055 MW 24.0 WD 12.0 returned by Element property\n    Segment 3: line (-3.81,13.04,0) --&gt; (-3.81,23.02,0)\n      wall 327018 MW 24.0 WD 12.0 returned by Element property\n    Segment 4: line (-3.81,23.02,0) --&gt; (-12.97,23.02,0)\n      wall 326988 MW 24.0 WD 12.0 returned by Element property\n    Segment 5: line (-12.97,23.02,0) --&gt; (-12.97,17.44,0)\n      wall 327196 STB 30.0 returned by Element property\n    Segment 6: line (-12.97,17.44,0) --&gt; (-13.95,17.44,0)\n      wall 327196 STB 30.0 returned by GetElementByRay\n    Segment 7: line (-13.95,17.44,0) --&gt; (-13.95,23.02,0)\n      wall 327196 STB 30.0 returned by Element property\n</pre><p>The results and the coordinates look exactly the same, so apparently the interior finish is indeed the default setting for the spatial element boundary location.</p><p><strong>Response:</strong> Yes, Finish is the default value.</p><p>Just after creating a new SpatialElementBoundaryOptions object, I see the following in the Visual Studio debugger:</p><center>\n<img alt=\"SpatialElementBoundaryLocation.Finish default setting\" src=\"img/GetBoundarySegmentElement5.png\"/>\n</center><a name=\"5\"></a>"
  },
  {
    "original_filename": "1046_boundary_seg_elem",
    "header_text": "Download",
    "local_header_href": "#download",
    "chunk_text": "<h4>Download</h4><p>To see the whole thing in context and try it out for yourself, here is\n\n<a href=\"zip/GetBoundarySegmentElement.zip\">GetBoundarySegmentElement.zip</a> containing\n\nthe full source code, Visual Studio solution and add-in manifest for the GetBoundarySegmentElement external command.</p><p>Many thanks to Rudolf for pointing out this flaw in the BoundarySegment.Element property, implementing and testing the workaround, and the fruitful discussion!</p>"
  }
]