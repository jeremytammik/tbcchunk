[
  {
    "original_filename": "0039_wall_elevation_profile",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<style>\n.blue { color: blue; }\n.teal { color: teal; }\n.maroon { color: maroon; }\n.green { color: green; }\n</style>"
  },
  {
    "original_filename": "0039_wall_elevation_profile",
    "header_text": "Wall Elevation Profile",
    "local_header_href": "#wall-elevation-profile",
    "chunk_text": "<h3>Wall Elevation Profile</h3><p>In this post, we explore how to determine the wall elevation boundary polygons, similarly to the\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2008/10/slab-boundary.html\">\nfloor boundary polygon</a> \n\nalgorithm.\n\nThis functionality is frequently requested, last but not least in a\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2008/10/slab-boundary.html#comments\">\ncomment by Art</a>.\n\n<p>The approach is similar to the one for the floor boundary polygons, with some small additional twists.\nTo determine the floor boundary, we simply searched for one of its two horizontal faces and queried it for its edge loops.\nFor a wall, it is slightly more complicated to decide which face we want to query, since we cannot expect it to be aligned with any of the cardinal coordinate axes.\nWhat we can expect, however, for simple walls, is that the normal vector of the face we are interested in is perpendicular to both the wall location line and the Z axis.\nThen, we just have to decide whether we are interested in the face on the interior or exterior wall side.\nThe preceding post on the\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2008/11/wall-compound-layers.html\">\nwall layers</a>\n\ndiscussed some analysis concerning the wall location line and its Flipped property to help determine which face is interior and exterior.</p>\n<p>The implementation is similar to the floor boundary one and has the following main steps:</p>\n<ul>\n<li>Select wall elements to process.</li>\n<li>Query each wall for its location curve and solid.</li>\n<li>From these, determine its exterior face.</li>\n<li>Query the face for its edge loops and collect the polygon data from them.</li>\n<li>Draw model lines representing the boundary loops, offset from the wall by one foot.</li>\n</ul>\n<p>Here is an example of running this algorithm on a couple of walls, showing the original walls and the resulting model lines representing the boundary loops, offset by one foot outwards from their exterior faces, and including the interior hole loops:</p>\n<img alt=\"Wall elevation profile boundary loops\" src=\"img/wall_profiles.png\"/>\n<p>Determining the exterior face from the solid and assembling the polygon data from its edge loops is performed by the GetProfile helper method. It also includes some debugging sanity checks to ensure that the loops obtained are in fact closed loops, i.e. that subsequent edges join and the last vertex equals the first:</p>\n<pre class=\"code\">\n<span class=\"blue\">const</span> <span class=\"blue\">double</span> _offset = 1.0;\n\n<span class=\"blue\">bool</span> GetProfile(\n  <span class=\"teal\">List</span>&lt;<span class=\"teal\">List</span>&lt;<span class=\"teal\">XYZ</span>&gt;&gt; polygons,\n  <span class=\"teal\">Solid</span> solid,\n  <span class=\"teal\">XYZ</span> v,\n  <span class=\"teal\">XYZ</span> w )\n{\n  <span class=\"blue\">double</span> d, dmax = 0;\n  <span class=\"teal\">PlanarFace</span> outermost = <span class=\"blue\">null</span>;\n  <span class=\"teal\">FaceArray</span> faces = solid.Faces;\n  <span class=\"blue\">foreach</span>( <span class=\"teal\">Face</span> f <span class=\"blue\">in</span> faces )\n  {\n    <span class=\"teal\">PlanarFace</span> pf = f <span class=\"blue\">as</span> <span class=\"teal\">PlanarFace</span>;\n    <span class=\"blue\">if</span>( <span class=\"blue\">null</span> != pf\n      &amp;&amp; <span class=\"teal\">Util</span>.IsVertical( pf )\n      &amp;&amp; <span class=\"teal\">Util</span>.IsZero( v.Dot( pf.Normal ) ) )\n    {\n      d = pf.Origin.Dot( w );\n      <span class=\"blue\">if</span>( ( <span class=\"blue\">null</span> == outermost )\n        || ( dmax &lt; d ) )\n      {\n        outermost = pf;\n        dmax = d;\n      }\n    }\n  }\n\n  <span class=\"blue\">if</span>( <span class=\"blue\">null</span> != outermost )\n  {\n    <span class=\"teal\">XYZ</span> voffset = _offset * w;\n    <span class=\"teal\">XYZ</span> p, q = <span class=\"teal\">XYZ</span>.Zero;\n    <span class=\"blue\">bool</span> first;\n    <span class=\"blue\">int</span> i, n;\n    <span class=\"teal\">EdgeArrayArray</span> loops = outermost.EdgeLoops;\n    <span class=\"blue\">foreach</span>( <span class=\"teal\">EdgeArray</span> loop <span class=\"blue\">in</span> loops )\n    {\n      <span class=\"teal\">List</span>&lt;<span class=\"teal\">XYZ</span>&gt; vertices = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">XYZ</span>&gt;();\n      first = <span class=\"blue\">true</span>;\n      <span class=\"blue\">foreach</span>( <span class=\"teal\">Edge</span> e <span class=\"blue\">in</span> loop )\n      {\n        <span class=\"teal\">XYZArray</span> points = e.Tessellate();\n        p = points.get_Item( 0 );\n        <span class=\"blue\">if</span>( !first )\n        {\n          <span class=\"teal\">Debug</span>.Assert( p.AlmostEqual( q ),\n            <span class=\"maroon\">\"expected subsequent start point\"</span>\n            + <span class=\"maroon\">\" to equal previous end point\"</span> );\n        }\n        n = points.Size;\n        q = points.get_Item( n - 1 );\n        <span class=\"blue\">for</span>( i = 0; i &lt; n - 1; ++i )\n        {\n          <span class=\"teal\">XYZ</span> a = points.get_Item( i );\n          a += voffset;\n          vertices.Add( a );\n        }\n      }\n      q += voffset;\n      <span class=\"teal\">Debug</span>.Assert( q.AlmostEqual( vertices[0] ),\n        <span class=\"maroon\">\"expected last end point to equal\"</span>\n        + <span class=\"maroon\">\" first start point\"</span> );\n      polygons.Add( vertices );\n    }\n  }\n  <span class=\"blue\">return</span> <span class=\"blue\">null</span> != outermost;\n}\n</pre>\n<p>Here is the CmdWallProfile mainline source code, making the call to GetProfile:</p>\n<pre class=\"code\">\n<span class=\"blue\">public</span> <span class=\"teal\">CmdResult</span> Execute(\n  <span class=\"teal\">ExternalCommandData</span> commandData,\n  <span class=\"blue\">ref</span> <span class=\"blue\">string</span> message,\n  <span class=\"teal\">ElementSet</span> elements )\n{\n  <span class=\"teal\">Application</span> app = commandData.Application;\n  <span class=\"teal\">Document</span> doc = app.ActiveDocument;\n \n  <span class=\"teal\">List</span>&lt;<span class=\"teal\">RvtElement</span>&gt; walls = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">RvtElement</span>&gt;();\n  <span class=\"blue\">if</span>( !<span class=\"teal\">Util</span>.GetSelectedElementsOrAll(\n    walls, doc, <span class=\"blue\">typeof</span>( <span class=\"teal\">Wall</span> ) ) )\n  {\n    <span class=\"teal\">Selection</span> sel = doc.Selection;\n    message = ( 0 &lt; sel.Elements.Size )\n      ? <span class=\"maroon\">\"Please select some wall elements.\"</span>\n      : <span class=\"maroon\">\"No wall elements found.\"</span>;\n    <span class=\"blue\">return</span> <span class=\"teal\">CmdResult</span>.Failed;\n  }\n \n  <span class=\"teal\">XYZ</span> p, q, v, w;\n  <span class=\"teal\">List</span>&lt;<span class=\"teal\">List</span>&lt;<span class=\"teal\">XYZ</span>&gt;&gt; polygons = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">List</span>&lt;<span class=\"teal\">XYZ</span>&gt;&gt;();\n  <span class=\"teal\">Options</span> opt = app.Create.NewGeometryOptions();\n \n  <span class=\"blue\">foreach</span>( <span class=\"teal\">Wall</span> wall <span class=\"blue\">in</span> walls )\n  {\n    <span class=\"blue\">string</span> desc = <span class=\"teal\">Util</span>.ElementDescription( wall );\n \n    <span class=\"teal\">LocationCurve</span> curve\n      = wall.Location <span class=\"blue\">as</span> <span class=\"teal\">LocationCurve</span>;\n \n    <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == curve )\n    {\n      message = desc + <span class=\"maroon\">\": No wall curve found.\"</span>;\n      <span class=\"blue\">return</span> <span class=\"teal\">CmdResult</span>.Failed;\n    }\n    p = curve.Curve.get_EndPoint( 0 );\n    q = curve.Curve.get_EndPoint( 1 );\n    v = q - p;\n    v = v.Normalized;\n    w = <span class=\"teal\">XYZ</span>.BasisZ.Cross( v ).Normalized;\n    <span class=\"blue\">if</span>( wall.Flipped ) { w = -w; }\n \n    <span class=\"teal\">GeoElement</span> geo = wall.get_Geometry( opt );\n    <span class=\"teal\">GeometryObjectArray</span> objects = geo.Objects;\n    <span class=\"blue\">foreach</span>( <span class=\"teal\">GeometryObject</span> obj <span class=\"blue\">in</span> objects )\n    {\n      <span class=\"teal\">Solid</span> solid = obj <span class=\"blue\">as</span> <span class=\"teal\">Solid</span>;\n      <span class=\"blue\">if</span>( solid != <span class=\"blue\">null</span> )\n      {\n        GetProfile( polygons, solid, v, w );\n      }\n    }\n  }\n \n  <span class=\"blue\">int</span> n = polygons.Count;\n \n  <span class=\"teal\">Debug</span>.WriteLine( <span class=\"blue\">string</span>.Format(\n    <span class=\"maroon\">\"{0} boundary loop{1} found.\"</span>,\n    n, <span class=\"teal\">Util</span>.PluralSuffix( n ) ) );\n \n  <span class=\"teal\">Creator</span> creator = <span class=\"blue\">new</span> <span class=\"teal\">Creator</span>( app );\n  creator.DrawPolygons( polygons );\n \n  <span class=\"blue\">return</span> <span class=\"teal\">CmdResult</span>.Succeeded;\n}\n</pre>\n<p>Here is an updated \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/files/bc10013.zip\">\nversion 1.0.0.13</a>\n\nof the complete Visual Studio solution,\n\nincluding the new CmdWallProfile and all other commands discussed so far.</p>\n</p>"
  }
]