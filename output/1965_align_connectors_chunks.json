[
  {
    "original_filename": "1965_align_connectors",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n<link rel=\"stylesheet\" type=\"text/css\" href=\"bc.css\">\n<script src=\"https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js\" type=\"text/javascript\"></script>\n</head>\n\n<!---\n\n- Top 10 Dynamo Blogs\n  The Building Coder has been selected by our panelist as one of the Top 10 Dynamo Blogs on the web.\n  https://blog.feedspot.com/dynamo_blogs/\n  Anuj Agarwal, Feedspot\n  Email: agarwal.anuj@feedspot.com\n\n- Haluk Uzuner\n  Align conectors in 3D space\n  https://forums.autodesk.com/t5/revit-api-forum/align-conectors-in-3d-space/m-p/11412155\n\ntwitter:\n\nA nice illustrative C++ sample demonstrating how to align MEP connectors in the #RevitAPI @AutodeskForge @AutodeskRevit #bim #DynamoBim #ForgeDevCon https://autode.sk/alignconnectors\n\nA C++ sample demonstrating how to align connectors, an impressive modern platform for implementing and streamlining online API processes, and my impressions of Harari's book on the history of mankind\n&ndash; Align connectors in C++\n&ndash; Pipedream serverless API workflow\n&ndash; Harari: Sapiens...\n\nlinkedin:\n\nA nice illustrative C++ sample demonstrating how to align MEP connectors in the #RevitAPI\n\nhttps://autode.sk/alignconnectors\n\nAlso, an impressive modern platform for implementing and streamlining online API processes, and my impressions of Harari's book on the history of mankind:\n\n- Align connectors in C++\n- Pipedream serverless API workflow\n- Harari: Sapiens...\n\n#bim #DynamoBim #ForgeDevCon #Revit #API #IFC #SDK #AI #VisualStudio #Autodesk #AEC #adsk\n\nthe [Revit API discussion forum](http://forums.autodesk.com/t5/revit-api-forum/bd-p/160) thread\n\n<center>\n<img src=\"img/\" alt=\"\" title=\"\" width=\"600\" height=\"\"/>\n<p style=\"font-size: 80%; font-style:italic\"></p>\n</center>\n\n<pre class=\"code\">\n</pre>\n\n-->"
  },
  {
    "original_filename": "1965_align_connectors",
    "header_text": "Aligning Connectors",
    "local_header_href": "#aligning-connectors",
    "chunk_text": "### Aligning Connectors\n\nA nice little C++ sample demonstrating how to align connectors, an impressive modern platform for implementing and streamlining online API processes, and my impressions of Harari's book on the history of mankind:\n\n- [Align connectors in C++](#2)\n- [Pipedream serverless API workflow](#3)\n- [Harari: Sapiens](#4)\n- [Afterword: The Animal that Became a God](#5)\n\nBy the way, The Building Coder was selected by feedspot as one of\nthe [Top 10 Dynamo Blogs](https://blog.feedspot.com/dynamo_blogs).\nThank you for the recognition."
  },
  {
    "original_filename": "1965_align_connectors",
    "header_text": "Align Connectors",
    "local_header_href": "#2",
    "chunk_text": "####<a name=\"2\"></a> Align Connectors\n\nHaluk Uzuner raised and solved the interesting issue of\nhow to [align connectors in 3D space](https://forums.autodesk.com/t5/revit-api-forum/align-conectors-in-3d-space/m-p/11412155),\nsharing his C++ implementation:\n\n**Question:** I want to align two families by their connectors.\n\nFamilies can be placed in any direction in 3D space.\nAny axis of any element is not to parallel to each other and project coordinates.\nGraphically, it might look like this:\n\n<center>\n<img src=\"img/align_connectors_1.png\" alt=\"Elements and connectors not aligned\" title=\"Elements and connectors not aligned\" width=\"600\"/> <! 1229 x 733 -->\n</center>\n\nMy code is below.\nIt works when the element is located parallel to project axes, but not in the general situation.\n\nAm I in the wrong path?\nIs there a better way to do it?\n\n<pre class=\"prettyprint\">\nprivate: static void rotate(UIApplication^ uiapp, elmstoreplace^ elms)\n{\n  // Select some elements in Revit before invoking this command\n\n  // Get the handle of current document.\n  UIDocument^ uidoc = uiapp->ActiveUIDocument;\n  Document^ doc = uidoc->Document;\n\n  // Elelements are stored in other header. We will read from there.\n  // We saved them there by selecting in GUI.\n  Element^ elmfrom = doc->GetElement(elmstoreplace::elmFrom); // Element will be aligned.\n  Element^ elmto = doc->GetElement(elmstoreplace::elmTo); // Element will be aligned to.\n\n  // 1. Cast Element to FamilyInstance\n  FamilyInstance^ faminstfrom = (FamilyInstance^)elmfrom;\n  FamilyInstance^ faminstto = (FamilyInstance^)elmto;\n\n  // 2. Get MEPModel Property\n  MEPModel^ mepmodelfrom = faminstfrom->MEPModel;\n  MEPModel^ mepmodelto = faminstto->MEPModel;\n\n  // 3. Get connector set of MEPModel\n  ConnectorSet^ connectorSetfrom = mepmodelfrom->ConnectorManager->Connectors;\n  ConnectorSet^ connectorSetto = mepmodelto->ConnectorManager->Connectors;\n\n  // Connector numbers to be aligned to each other are stored in other file.\n  // We saved them there by selecting in GUI.\n  Connector^ connFrom =nullptr; // Connector will be aligned.\n  Connector^ connTo = nullptr; // Connector to be aligned to.\n\n  // Get connector by iterating in connectorset.\n  for each (Connector ^ connector in connectorSetfrom)\n  {\n    if (connector->Id == elmstoreplace::connNoFrom)\n    {\n    connFrom = connector;\n    }\n  }\n\n  // Get connector by iterating in connectorset.\n  for each (Connector ^ connector in connectorSetto)\n  {\n    if (connector->Id == elmstoreplace::connNoTo)\n    {\n     connTo = connector;\n    }\n  }\n\n  // Get the element current location\n  LocationPoint^ elmfromLoc = (LocationPoint^)elmfrom->Location;\n\n  // Create vector based on element location and connector location.\n  XYZ^ diffvec1 = connFrom->Origin->Subtract(elmfromLoc->Point);\n  // Subtract element location which will be moved.\n  XYZ^ diffvec2 = connTo->Origin->Subtract(elmfromLoc->Point);\n  // Bring two connectors to same point\n  ElementTransformUtils::MoveElement(doc, elmfrom->Id, diffvec2->Add(diffvec1->Negate()));\n\n  // Get basisZ of connectors.\n  XYZ^ basisZTo = connTo->CoordinateSystem->BasisZ;\n  // Transform vector.\n  XYZ^ getOfbasisZTo = getOfVector(basisZTo);\n  // Get basisZ of connectors.\n  XYZ^ basisZFrom = connFrom->CoordinateSystem->BasisZ;\n  // Transform vector.\n  XYZ^ getOfbasisZFrom = getOfVector(basisZFrom);\n\n  // Calculate angle between connectors.\n  double angle  = getOfbasisZTo->AngleTo(getOfbasisZFrom);\n\n  // Calculate crossproduct of two vectors.\n  XYZ^ crossprod = getOfbasisZTo->CrossProduct(getOfbasisZFrom);\n  // Calculate crossproduct of two vectors.\n  // Somehow this always give unit vectors\n  // BasisX(1,0,0), BasisY(0,1,0), BasisX(0,0,1)\n  // I think that is my problem.\n  XYZ^ getOfcrossprod = getOfVector(crossprod);\n\n  // Create rotation axis.\n  Line^ rotationaxis = Line::CreateUnbound(connTo->Origin, crossprod->BasisZ);\n\n  // Rotate element around axis.\n  ElementTransformUtils::RotateElement(doc, elmfrom->Id, rotationaxis, Math::PI - angle);\n}\n\npublic: static XYZ^ getOfVector(XYZ^ xyz)\n{\n  XYZ^ OfVector(xyz);\n  return xyz;\n}\n</pre>\n\n**Answer:** To align the connectors, given two elements E and F containing connectors A and B with locations P and Q:\n\nDetermine the difference between P and Q, the vector V = Q - P.\nIf you translate the element E containing A by V, A will lie in exactly the same spot as B.\nIf you don't want it in the exact same spot, but only vertically or horizontally aligned in some way, you need to adapt some of the coordinates of V accordingly.\nThe translation can be accomplished using the [MoveElement method](https://www.revitapidocs.com/2023/aaddd413-01b0-2878-3f79-a281abb6d364.htm).\nWatch out that other attached elements are not moved as well.\n\n**Response:** I added some improved pictures below.\nAs far as understood, move element moves families/elements only.\nSo, I find U vector and subtract P from it and find the V vector you mentioned.\nIn the way you mentioned, it works if two families placed in the same plane and orientation.\nIn my case, none of axes are parallel.\nMy problem starts after moving element.\nMy aim is finding cross product of two Z axes that is perpendicular to both axes.\nAnd rotate it by angle.\nI am stuck in creating a rotation axis along Z axis of cross product.\nAs shown in the picture, cross product BasisX, Y, Z always give unit vectors.\n\n<center>\n<img src=\"img/align_connectors_2.png\" alt=\"Align connectors\" title=\"Align connectors\" width=\"387\"/> <!-- 387 x 108 -->\n<br/>\n<img src=\"img/align_connectors_3.png\" alt=\"Align connectors\" title=\"Align connectors\" width=\"600\"/> <!-- 1248 x 742-->\n<br/>\n<img src=\"img/align_connectors_4.png\" alt=\"Align connectors\" title=\"Align connectors\" width=\"600\"/> <!-- 1280 x 798 -->\n</center>\n\nLater:\nI finally got it to work.\nMy problem was understanding the `Basis` vectors.\nMy final code is below.\nIt worked perfectly for me.\nI additionally draw rotation axis and rotation arc to visualize rotation.\n\nBesides, I was surprised there are no similar code samples on the Internet.\nThere are many samples, but they all work on parallel planes.\nRevit itself already does the action which I am after.\nBut apparently, API developers didn't need it.\n\n<pre class=\"prettyprint\">\nprivate: static void RotateOnConnector(UIApplication^ uiapp, elmstoreplace^ elms)\n{\n  try\n  {\n    // Select some elements in Revit before invoking this command\n    \n    // Get the handle of current document.\n    UIDocument^ uidoc = uiapp->ActiveUIDocument;\n    Document^ doc = uidoc->Document;\n    \n    // Elelements are stored in other header. They will be read from there.\n    // They are saved there by selecting in GUI.\n    Element^ elmfrom = doc->GetElement(elmstoreplace::elmFrom);\n    Element^ elmto = doc->GetElement(elmstoreplace::elmTo);\n   \n    // 1. Cast Element to FamilyInstance\n    FamilyInstance^ faminstfrom = (FamilyInstance^)elmfrom;\n    FamilyInstance^ faminstto = (FamilyInstance^)elmto;\n    \n    // 2. Get MEPModel Property\n    MEPModel^ mepmodelfrom = faminstfrom->MEPModel;\n    MEPModel^ mepmodelto = faminstto->MEPModel;\n    \n    // 3. Get connector set of MEPModel\n    ConnectorSet^ connectorSetfrom = mepmodelfrom->ConnectorManager->Connectors;\n    ConnectorSet^ connectorSetto = mepmodelto->ConnectorManager->Connectors;\n    \n    // Connector numbers to be aligned to each other are stored in other file.\n    // They saved there by selecting in GUI.\n    Connector^ connFrom =nullptr; // Connector will be aligned.\n    Connector^ connTo = nullptr; // Connector to be aligned to.\n    \n    // Get connector by iterating in connectorset.\n    for each (Connector ^ connector in connectorSetfrom)\n    {\n      if (connector->Id == elmstoreplace::connNoFrom)\n      {\n        connFrom = connector;\n        String^ message = \"Connector is owned by: \" + connector->Owner->Name;\n      }\n    }\n\n    // Get connector by iterating in connectorset.\n    for each (Connector ^ connector in connectorSetto)\n    {\n      if (connector->Id == elmstoreplace::connNoTo)\n      {\n        connTo = connector;\n      }\n    }\n    \n    // Get the element current location\n    LocationPoint^ elmfromLoc = (LocationPoint^)elmfrom->Location;\n    \n    // Create vector based on element location and connector location.\n    XYZ^ diffvec1 = connFrom->Origin->Subtract(elmfromLoc->Point);\n    // Subtract element location which will be moved.\n    XYZ^ diffvec2 = connTo->Origin->Subtract(elmfromLoc->Point);\n    // Bring two connectors to same point\n    ElementTransformUtils::MoveElement(doc, elmfrom->Id, diffvec2->Add(diffvec1->Negate()));\n    \n    // Get BasisZ of connectors.\n    XYZ^ basisZTo = connTo->CoordinateSystem->BasisZ;\n    XYZ^ basisZFrom = connFrom->CoordinateSystem->BasisZ;\n    \n    // Calculate angle between connectors.\n    double angle  = basisZTo->AngleTo(basisZFrom);\n    \n    // Calculate cross product of two vectors.\n    XYZ^ crossprod = basisZTo->CrossProduct(basisZFrom);\n    \n    // Create rotation axis.\n    Line^ rotationaxis = Line::CreateBound(connTo->Origin,\n      gcnew XYZ(connTo->Origin->X+crossprod->X,\n      connTo->Origin->Y+crossprod->Y,\n      connTo->Origin->Z+crossprod->Z));\n    \n    // Rotate element around axis.\n    ElementTransformUtils::RotateElement(doc, elmfrom->Id,\n      rotationaxis, Math::PI-angle);\n    \n    // get handle to application from document\n    Autodesk::Revit::ApplicationServices::Application^ application\n      = doc->Application;\n    \n    // Create a geometry line in Revit application\n    XYZ^ startPoint = connTo->Origin;\n    XYZ^ endPoint = gcnew XYZ(connTo->Origin->X + crossprod->X,\n     connTo->Origin->Y + crossprod->Y,\n     connTo->Origin->Z + crossprod->Z);\n    Line^ geomLine = Line::CreateBound(startPoint, endPoint);\n    \n    // Create a geometry plane in Revit application\n    Plane^ linePlane = Plane::CreateByThreePoints(\n    connTo->Origin,\n    gcnew XYZ(connTo->Origin->X,\n    connTo->Origin->Y,\n    connTo->Origin->Z + connTo->CoordinateSystem->BasisZ->Z),\n    gcnew XYZ(connTo->Origin->X + crossprod->X,\n    connTo->Origin->Y + crossprod->Y,\n    connTo->Origin->Z + crossprod->Z));\n    Plane^ arcPlane = Plane::CreateByNormalAndOrigin(crossprod->Normalize(),\n      connTo->Origin);\n    Arc^ geomArc = Arc::Create(arcPlane, 0.5, 0, angle);\n    \n    // Create a sketch plane in current document\n    SketchPlane^ linesketch = SketchPlane::Create(doc, linePlane);\n    SketchPlane^ arcsketch = SketchPlane::Create(doc, arcPlane);\n    \n    // Create a ModelLine element using the created geometry line and sketch plane\n    ModelLine^ line = (ModelLine^)doc->Create->NewModelCurve(geomLine, linesketch);\n    \n    // Create a ModelArc element using the created geometry arc and sketch plane\n    ModelArc^ arc = (ModelArc^)doc->Create->NewModelCurve(geomArc, arcsketch);\n  }\n  catch (Exception^ ex)\n  {\n    TaskDialog::Show(\"!!! \", ex->Message->ToString());\n  }\n}\n</pre>\n\nMany thanks to Haluk for rectifying that and sharing this nice topic and C++ solution."
  },
  {
    "original_filename": "1965_align_connectors",
    "header_text": "Pipedream Serverless API Workflow",
    "local_header_href": "#3",
    "chunk_text": "####<a name=\"3\"></a> Pipedream Serverless API Workflow\n\n[Pipedream](https://pipedream.com) is a fast way to automate any process that connects APIs.\nBuild and run workflows with code-level control when you need it, and no code when you don't.\n\nThe Pipedream platform includes:\n\n- A serverless runtime and workflow service\n- Open source triggers and actions for hundreds of integrated apps\n- One-click OAuth and key-based authentication for hundreds of APIs\n\nCheck out the impressive [7-minute demo](https://youtu.be/pRHsQyyfYl0) using:\n\n- Pre-built, open source components for Twitter and Google Sheets\n- Node.js with the axios npm package and Pipedream managed authentication for Google Translate\n- Python and the nltk pypi package"
  },
  {
    "original_filename": "1965_align_connectors",
    "header_text": "Harari: Sapiens",
    "local_header_href": "#4",
    "chunk_text": "####<a name=\"4\"></a> Harari: Sapiens\n\nI read [Sapiens: A Brief History of Humankind](https://en.wikipedia.org/wiki/Sapiens:_A_Brief_History_of_Humankind)\nby [Yuval Noah Harari](https://en.wikipedia.org/wiki/Yuval_Noah_Harari).\n\nJudging from\nthe [very critical scholarly reception](https://en.wikipedia.org/wiki/Sapiens:_A_Brief_History_of_Humankind#Scholarly_reception) of\nthe book, I must be naive to enjoy it so much.\n\nJudging from the [enthusiastic popular reception](https://en.wikipedia.org/wiki/Sapiens:_A_Brief_History_of_Humankind#Popular_reception),\nthough, I guess I am average after all."
  },
  {
    "original_filename": "1965_align_connectors",
    "header_text": "Afterword: The Animal that Became a God",
    "local_header_href": "#5",
    "chunk_text": "####<a name=\"5\"></a> Afterword: The Animal that Became a God\n\nSEVENTY THOUSAND YEARS AGO, HOMO sapiens was still an insignificant animal minding its own business in a corner of Africa. In the following millennia it transformed itself into the master of the entire planet and the terror of the ecosystem. Today it stands on the verge of becoming a god, poised to acquire not only eternal youth, but also the divine abilities of creation and destruction.\n\nUnfortunately, the Sapiens regime on earth has so far produced little that we can be proud of. We have mastered our surroundings, increased food production, built cities, established empires and created far-flung trade networks. But did we decrease the amount of suffering in the world? Time and again, massive increases in human power did not necessarily improve the well-being of individual Sapiens, and usually caused immense misery to other animals.\n\nIn the last few decades we have at last made some real progress as far as the human condition is concerned, with the reduction of famine, plague and war. Yet the situation of other animals is deteriorating more rapidly than ever before, and the improvement in the lot of humanity is too recent and fragile to be certain of.\n\nMoreover, despite the astonishing things that humans are capable of doing, we remain unsure of our goals and we seem to be as discontented as ever. We have advanced from canoes to galleys to steamships to space shuttles – but nobody knows where we’re going. We are more powerful than ever before, but have very little idea what to do with all that power. Worse still, humans seem to be more irresponsible than ever. Self-made gods with only the laws of physics to keep us company, we are accountable to no one. We are consequently wreaking havoc on our fellow animals and on the surrounding ecosystem, seeking little more than our own comfort and amusement, yet never finding satisfaction.\n\nIs there anything more dangerous than dissatisfied and irresponsible gods who don’t know what they want?\n\n<p style=\"text-align:right; font-style: italic\">&ndash;\nPublished online by <a href=\"https://erenow.net/common/sapiensbriefhistory/112.php\">Erenow</a></p>"
  }
]