[
  {
    "original_filename": "0443_idling_selection_watcher",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<head>\n<link href=\"bc.css\" rel=\"stylesheet\" type=\"text/css\"/>\n</head>"
  },
  {
    "original_filename": "0443_idling_selection_watcher",
    "header_text": "Selection Watcher Using Idling Event",
    "local_header_href": "#selection-watcher-using-idling-event",
    "chunk_text": "<h3>Selection Watcher Using Idling Event</h3><p>Here is a pretty cool example by Ken Goulding of using the Idling event to work around a little gap in the current Revit API.\nKen posted a \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/04/element-level-events.html?cid=6a00e553e16897883301348655bd79970c#comment-6a00e553e16897883301348655bd79970c\">\ncomment</a> which \n\ntriggered a pretty interesting conversation and culminated in the \n\n<a href=\"zip/SelectionWatcher.zip\">SelectionWatcher</a> sample.\n\n<p>Another interesting item that cropped up was the possibility to use \n\n<a href=\"http://visualstudio.pastebin.com\">PasteBin</a> to\n\nshare snippets of source code, as Ken did for parts of his initial implementation:\n\n<ul>\n<li><a href=\"http://visualstudio.pastebin.com/X5rBXSA6\">Class implementation</a>\n<li><a href=\"http://visualstudio.pastebin.com/aNwEFRkZ\">Sample usage</a>\n</li></li></ul>\n<p>The code listed there is now obsolete, though.\n\n<p>Here are some excerpts from our conversation that led up to this sample:\n\n<p><strong>Ken:</strong> When you mentioned \"Element Level\", I was hoping that included element selection events, but that does not seem to be the case. \n\nAs a work-around, I created a class that subscribes to the application Idling event and checks for selection changes. Given that the Idling event is called very frequently, I tried to be as efficient as possible at figuring out whether a change has happened, but there may be a simpler way? \n\n<p><strong>Jeremy:</strong> Thank you for your query with the interesting idea and the source code. \nThank you also for the interesting PasteBin URLs. I was not previously aware of this possibility.\n\n<p>Regarding the element selection events, you are correct in your assessment that these are currently not provided by the Revit API.\n\n<p>Your use of the Idling event to implement a work-around sounds like a brilliant idea to me.\n\n<p><strong>Ken:</strong> I'm glad you see potential for the selection watcher class. \nI was using it to link additional data (e.g. photographs) to room objects, but I'm sure your readers can find far more interesting uses for context-sensitive functionality.\nI added a few comments inline.\nPlease let me know if anything is not clear,\n\n<p><strong>Jeremy:</strong> Thank you very much for the illuminating sample.\nI like it very much!\nI fixed two details which simplify things:\n \n<ol>\n<li>You need to set the 'Copy Local' flag to false on the references to the Revit API DLLs.\n<li>You can obtain the application object from the Idling event arguments, so there is no need for a global variable and a DocumentOpening event handler to set it.\n</li></li></ol>\n<p><strong>Ken:</strong> Thanks for the suggestions. \nIt is good to know that you don't need to copy the Revit API DLLs locally, since they are big.\n\n<p><strong>Jeremy:</strong> Here are some screen snapshots from an example run testing this.\nThe selection watcher is an external application and defines its own ribbon panel.\nHere it is ripped off the ribbon bar and placed over the graphics area, so that it remains visible through a ribbon context switch:</p>\n<center>\n<img alt=\"Selection Watcher ribbon panel\" src=\"img/SelectionChanged0.png\"/>\n</center>\n<p>Here we have selected Room 5, which is displayed immediately by the selection watcher:</p>\n<center>\n<img alt=\"One room selected\" src=\"img/SelectionChanged1.png\"/>\n</center>\n<p>In this simple implementation, selection of multiple rooms is simply listed as such with no further details:</p>\n<center>\n<img alt=\"Multiple rooms selected\" src=\"img/SelectionChanged2.png\"/>\n</center>\n<p>For further details including some comments, please look at the source code in the archive file \n\n<a href=\"zip/SelectionWatcher.zip\">SelectionWatcher.zip</a>.\n\nIt includes the full source code, complete Visual Studio solution and an add-in manifest file to load the application.\n\n<p>Here are a few implementation details to whet your appetite:\n\n<ul>\n<li>A standalone SelectionChangedWatcher class implementation which is completely separate from the external application.\n<li>The external application instantiates an instance of the SelectionChangedWatcher class and subscribes to its SelectionChanged event. \n<li>The external application does not need to know how the SelectionChanged event is implemented, or that it is internally triggered by the Idling event.\n</li></li></li></ul>\n<p>This allows the following minimalistic implementation of the external application class, which just needs to set up its ribbon panel and text box to display the results, instantiate and subscribe to the selection watcher, and update the text box when changes occur:\n\n<pre class=\"code\">\n[<span class=\"teal\">Transaction</span>( <span class=\"teal\">TransactionMode</span>.Manual )]\n[<span class=\"teal\">Regeneration</span>( <span class=\"teal\">RegenerationOption</span>.Manual )]\n[<span class=\"teal\">Journaling</span>( <span class=\"teal\">JournalingMode</span>.NoCommandData )]\n \n<span class=\"blue\">public</span> <span class=\"blue\">class</span> <span class=\"teal\">SelectionChangedExampleApp</span>\n  : <span class=\"teal\">IExternalApplication</span>\n{\n  <span class=\"blue\">private</span> <span class=\"teal\">SelectionChangedWatcher</span>\n    _selectionChangedWatcher;\n \n  <span class=\"blue\">private</span> <span class=\"teal\">TextBox</span> _tb;\n \n  <span class=\"blue\">public</span> <span class=\"teal\">Result</span> OnShutdown(\n    <span class=\"teal\">UIControlledApplication</span> a )\n  {\n    <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Succeeded;\n  }\n \n  <span class=\"blue\">public</span> <span class=\"teal\">Result</span> OnStartup(\n    <span class=\"teal\">UIControlledApplication</span> a )\n  {\n    _selectionChangedWatcher\n      = <span class=\"blue\">new</span> <span class=\"teal\">SelectionChangedWatcher</span>( a );\n \n    _selectionChangedWatcher.SelectionChanged\n      += <span class=\"blue\">new</span> <span class=\"teal\">EventHandler</span>(\n        OnSelectionChanged );\n \n    <span class=\"green\">// it does not seem to be possible to add items </span>\n    <span class=\"green\">// to context-sensitive ribbon panels.</span>\n    <span class=\"green\">// however the user can detach this panel from </span>\n    <span class=\"green\">// the main ribbon so that it is not hidden by </span>\n    <span class=\"green\">// context-sensitive panels.</span>\n \n    <span class=\"teal\">RibbonPanel</span> rpSelectionWatcher\n      = a.CreateRibbonPanel( <span class=\"maroon\">\"Selection Watcher\"</span> );\n \n    <span class=\"blue\">var</span> t1 = <span class=\"blue\">new</span> <span class=\"teal\">TextBoxData</span>( <span class=\"maroon\">\"txtInfo\"</span> );\n \n    _tb = rpSelectionWatcher.AddItem( t1 ) <span class=\"blue\">as</span> <span class=\"teal\">TextBox</span>;\n \n    <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Succeeded;\n  }\n \n  <span class=\"blue\">void</span> OnSelectionChanged(\n    <span class=\"blue\">object</span> sender,\n    <span class=\"teal\">EventArgs</span> e )\n  {\n    <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == _selectionChangedWatcher.Selection )\n    {\n      ShowInfo( <span class=\"maroon\">\"No selection\"</span> );\n      <span class=\"blue\">return</span>;\n    }\n \n    <span class=\"green\">// this example just reports the name of the </span>\n    <span class=\"green\">// room that is selected. Obviously any other</span>\n    <span class=\"green\">// kind of element can be handled instead.</span>\n \n    <span class=\"teal\">List</span>&lt;<span class=\"teal\">Room</span>&gt; rooms = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">Room</span>&gt;(\n      _selectionChangedWatcher.Selection.OfType&lt;<span class=\"teal\">Room</span>&gt;() );\n \n    <span class=\"blue\">if</span>( 0 == rooms.Count )\n    {\n      ShowInfo( <span class=\"maroon\">\"No rooms selected\"</span> );\n    }\n    <span class=\"blue\">else</span> <span class=\"blue\">if</span>( 1 == rooms.Count )\n    {\n      ShowInfo( <span class=\"maroon\">\"Room \"</span> + rooms[0].Number );\n    }\n    <span class=\"blue\">else</span>\n    {\n      ShowInfo( <span class=\"maroon\">\"Multiple rooms selected\"</span> );\n    }\n  }\n \n  <span class=\"blue\">private</span> <span class=\"blue\">void</span> ShowInfo( <span class=\"blue\">string</span> p )\n  {\n    _tb.PromptText = p;\n  }\n}\n</pre>\n<p>The SelectionChangedExample class is more interesting, of course.\n\n<ul>\n<li>It takes the UIControlledApplication as an argument, so that it can subscribe to the Idling event.\n<li>It manages the subscription to the Idling event internally, with no need for the client to be aware of that.\n<li>It uses an auto-implemented property to store a list of all currently selected elements.\n<li>Every selection change is registered in the Idling event handler, updates the selection property, and triggers the SelectionChanged event.\n</li></li></li></li></ul>\n<p>Here it is in all its glory:\n\n<pre class=\"code\">\n<span class=\"blue\">public</span> <span class=\"blue\">class</span> <span class=\"teal\">SelectionChangedWatcher</span>\n{\n  <span class=\"blue\">public</span> <span class=\"blue\">event</span> <span class=\"teal\">EventHandler</span> SelectionChanged;\n \n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n  <span class=\"gray\">///</span><span class=\"green\"> Auto-implemented property storing a list </span>\n  <span class=\"gray\">///</span><span class=\"green\"> of all currently selected elements.</span>\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n  <span class=\"blue\">public</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt; Selection\n  {\n    <span class=\"blue\">get</span>;\n    <span class=\"blue\">set</span>;\n  }\n \n  <span class=\"blue\">private</span> <span class=\"teal\">List</span>&lt;<span class=\"blue\">int</span>&gt; _lastSelIds;\n \n  <span class=\"blue\">public</span> SelectionChangedWatcher(\n    <span class=\"teal\">UIControlledApplication</span> a )\n  {\n    a.Idling\n      += <span class=\"blue\">new</span> <span class=\"teal\">EventHandler</span>&lt;<span class=\"teal\">IdlingEventArgs</span>&gt;(\n        OnIdling );\n  }\n \n  <span class=\"blue\">void</span> OnIdling(\n    <span class=\"blue\">object</span> sender,\n    <span class=\"teal\">IdlingEventArgs</span> e )\n  {\n    <span class=\"green\">// Idling events happen when the application has </span>\n    <span class=\"green\">// nothing else to do,</span>\n    <span class=\"green\">// They can happen very frequently and the user </span>\n    <span class=\"green\">// will experience a lag if this code takes a </span>\n    <span class=\"green\">// significant amount of time to execute.</span>\n \n    <span class=\"teal\">Application</span> app = sender <span class=\"blue\">as</span> <span class=\"teal\">Application</span>;\n \n    <span class=\"teal\">UIApplication</span> uiApplication\n      = <span class=\"blue\">new</span> <span class=\"teal\">UIApplication</span>( app );\n \n    <span class=\"teal\">SelElementSet</span> selected = uiApplication\n      .ActiveUIDocument.Selection.Elements;\n \n    <span class=\"blue\">if</span>( 0 == selected.Size )\n    {\n      <span class=\"blue\">if</span>( <span class=\"blue\">null</span> != Selection &amp;&amp; 0 &lt; Selection.Count )\n      {\n        <span class=\"green\">// if something was selected previously, and </span>\n        <span class=\"green\">// now the selection is empty, report change</span>\n \n        HandleSelectionChange( selected );\n      }\n    }\n    <span class=\"blue\">else</span> <span class=\"green\">// elements are selected</span>\n    {\n      <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == Selection )\n      {\n        <span class=\"green\">// previous selection was null, report change</span>\n \n        HandleSelectionChange( selected );\n      }\n      <span class=\"blue\">else</span>\n      {\n        <span class=\"blue\">if</span>( Selection.Count != selected.Size )\n        {\n          <span class=\"green\">// size has changed, no need to check </span>\n          <span class=\"green\">// selection IDs, report the change</span>\n \n          HandleSelectionChange( selected );\n        }\n        <span class=\"blue\">else</span>\n        {\n          <span class=\"green\">// count is the same... </span>\n          <span class=\"green\">// compare IDs to see if selection has changed</span>\n          <span class=\"blue\">if</span>( SelectionHasChanged( selected ) )\n          {\n            HandleSelectionChange( selected );\n          }\n        }\n      }\n    }\n  }\n \n  <span class=\"blue\">private</span> <span class=\"blue\">bool</span> SelectionHasChanged(\n    <span class=\"teal\">SelElementSet</span> selected )\n  {\n    <span class=\"green\">// we have already determined that the size of </span>\n    <span class=\"green\">// \"selected\" is the same as the last selection...</span>\n \n    <span class=\"blue\">int</span> i = 0;\n    <span class=\"blue\">foreach</span>( <span class=\"teal\">Element</span> e <span class=\"blue\">in</span> selected )\n    {\n      <span class=\"blue\">if</span>( _lastSelIds[i] != e.Id.IntegerValue )\n      {\n        <span class=\"blue\">return</span> <span class=\"blue\">true</span>;\n      }\n      ++i;\n    }\n    <span class=\"blue\">return</span> <span class=\"blue\">false</span>;\n  }\n \n  <span class=\"blue\">private</span> <span class=\"blue\">void</span> HandleSelectionChange(\n    <span class=\"teal\">SelElementSet</span> selected )\n  {\n    <span class=\"green\">// store the current list of elements in the </span>\n    <span class=\"green\">// Selection property and populate _lastSelIds </span>\n    <span class=\"green\">// with the current selection's ids</span>\n \n    Selection = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt;();\n    _lastSelIds = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"blue\">int</span>&gt;();\n \n    <span class=\"blue\">foreach</span>( <span class=\"teal\">Element</span> e <span class=\"blue\">in</span> selected )\n    {\n      Selection.Add( e );\n      _lastSelIds.Add( e.Id.IntegerValue );\n    }\n    Call_SelectionChanged();\n  }\n \n  <span class=\"blue\">private</span> <span class=\"blue\">void</span> Call_SelectionChanged()\n  {\n    <span class=\"blue\">if</span>( SelectionChanged != <span class=\"blue\">null</span> )\n    {\n      SelectionChanged( <span class=\"blue\">this</span>, <span class=\"blue\">new</span> <span class=\"teal\">EventArgs</span>() );\n    }\n  }\n}\n</pre>\n<p>Very many thanks to Ken for this idea and implementation and the fruitful discussion!\n</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p>"
  }
]