[
  {
    "original_filename": "1397_track_changes",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n<link rel=\"stylesheet\" type=\"text/css\" href=\"bc.css\">\n<script src=\"run_prettify.js\" type=\"text/javascript\"></script>\n<!---\n<script src=\"https://google-code-prettify.googlecode.com/svn/loader/run_prettify.js\" type=\"text/javascript\"></script>\n-->\n</head>\n\n<!---\n\n- create a module to identify whether changes have been made to specific elements:\n  on document load: or all relevant elements, grab all relevant element data, encode into a string, create a hash\n  on document save: repeat and check for differences: result: modified elements\n  0739_create_own_key.htm\n  [Revit project identification](http://the3dwebcoder.typepad.com/blog/2015/07/fireratingcloud-round-trip-and-on-mongolab.html#2)\n\n#dotnet #csharp\n#fsharp #python\n#grevit\n#responsivedesign #typepad\n#ah8 #augi #dotnet\n#stingray #rendering\n#3dweb #3dviewAPI #html5 #threejs #webgl #3d #mobile #vr #ecommerce\n#Markdown #Fusion360 #Fusion360Hackathon\n#javascript\n#RestSharp #restAPI\n#mongoosejs #mongodb #nodejs\n#rtceur\n#xaml\n#3dweb #a360 #3dwebaccel #webgl @adskForge\n@AutodeskReCap @Adsk3dsMax\n#revitAPI #bim #aec #3dwebcoder #adsk #adskdevnetwrk @jimquanci @keanw\n#au2015 #rtceur\n#eraofconnection\n\nRevit API, Jeremy Tammik, akn_include\n\nTracking Element Modification #revitAPI #bim #aec #3dwebcoder #adsk @AutodeskRevit #adskdevnetwrk\n\nHow to determine and track element modification?\nI implemented a solution!\n&ndash; Two approaches\n&ndash; Task analysis\n&ndash; Modification tracker\n&ndash; Creating an element state snapshot\n&ndash; Determining which elements to track\n&ndash; Implementation\n&ndash; Geometrical comparison\n&ndash; String formatting\n&ndash; Retrieve solid vertices\n&ndash; GetTrackedElements &ndash; retrieve elements of interest\n&ndash; GetElementState &ndash; store element state\n&ndash; Creating a database state snapshot\n&ndash; Report differences\n&ndash; External command mainline Execute method\n&ndash; Sample runs\n&ndash; Demo recording\n&ndash; Download...\n\n-->"
  },
  {
    "original_filename": "1397_track_changes",
    "header_text": "Tracking Element Modification",
    "local_header_href": "#tracking-element-modification",
    "chunk_text": "### Tracking Element Modification\n\nSeveral people asked me recently about how to determine and track element modification, and I have heard this same question dozens of times in the more distant past as well.\n\nNow it was brought up again here at the Munich Cloud Accelerator by John Allan-Jones of [Atkins](http://atkinsglobal.com), and I was motivated to implement a solution:\n\n- [Two approaches](#0)\n- [Task analysis](#1)\n- [Modification tracker](#2)\n- [Creating an element state snapshot](#3)\n- [Determining which elements to track](#4)\n- [Implementation](#5)\n    - [Geometrical comparison](#5.1)\n    - [String formatting](#5.2)\n    - [Retrieve solid vertices](#5.3)\n    - [GetTrackedElements &ndash; retrieve elements of interest](#5.4)\n    - [GetElementState &ndash; store element state](#5.5)\n    - [Creating a database state snapshot](#5.6)\n    - [Report differences](#5.7)\n    - [External command mainline Execute method](#5.8)\n- [Sample runs](#6)\n- [Demo recording](#7)\n- [Download](#8)\n\nFor a quick first impression, you can jump to the [two-and-a-half minute video recording](#7) showing it in action and read [an initial comment or two](http://forums.autodesk.com/t5/revit-api/tracking-revit-bim-database-and-individual-element-property/m-p/5998729)."
  },
  {
    "original_filename": "1397_track_changes",
    "header_text": "<a name=\"0\"></a>Two Approaches",
    "local_header_href": "#a-name0atwo-approaches",
    "chunk_text": "#### <a name=\"0\"></a>Two Approaches\n\nMost ideas for approaches to this I heard so far were pretty fixed on tracking individual events in the Revit database, e.g. using the DocumentChanged event or a DMU framework dynamic model updater and keeping track of every modification.\n\nIn both cases, the add-in will be receiving and processing huge amounts of useless data and struggling to filter out what is really needed.\n\nI suggest a radically different approach that is completely independent of events, Revit internals, real-time analysis and continuous tracking.\n\nI suggest simply creating a snapshot that captures all the properties of interest and reporting the differences between two such snapshots."
  },
  {
    "original_filename": "1397_track_changes",
    "header_text": "<a name=\"1\"></a>Task Analysis",
    "local_header_href": "#a-name1atask-analysis",
    "chunk_text": "#### <a name=\"1\"></a>Task Analysis\n\nLet's take a step back and think about what we really are after.\n\nTo track changes, you need to consider what kind of changes you are interested in.\n\nThese changes have to do with two things:\n\n- Which BIM elements are of interest?\n- What defines the BIM element state that is of interest?\n\nThe former issue is a simple and pretty obvious matter of defining the correct filtered element collector filters to apply.\n\nThe second aspect is one that I'll address in more depth.\n\nIt is hopefully possible to capture the BIM element state that is of interest by querying its properties, e.g.:\n\n- Name\n- Class, family, type\n- Location\n- Geometry\n- Parameter data\n- Etc.\n\nIf somebody makes a change to the BIM model that you wish to track, how and where will that change affect the model?\n\nCertainly there must be a property somewhere in the database that you can use to determine the state before and after and identify that the modification happened.\n\nSo let's use these thoughts to define a super simple and efficient modification tracker."
  },
  {
    "original_filename": "1397_track_changes",
    "header_text": "<a name=\"2\"></a>Modification Tracker",
    "local_header_href": "#a-name2amodification-tracker",
    "chunk_text": "#### <a name=\"2\"></a>Modification Tracker\n\nI suggest the following approach to implement a simple and efficient modification tracker:\n\n- Start tracking by capturing and storing the relevant state of all elements of interest.\n- Stop tracking by capturing an updated version of that data.\n- Report changes by comparing the two snapshots.\n\nNo need for events!\n\nNo need for cumbersome instrumentation!\n\nNo continuous data collection overhead!\n\nMy sample implements one single command, which alternates between two actions:\n\nCreate and store a snapshot of the current database state if none is already present.\nIf a previous snapshot is already present, create a new one, compare them, and report the modifications.\n\nYou obviously might, if you wish, automatically execute the first action on document load and the second on document save.\n\nIf you create an external application to host a button triggering these two action, you would obviously make use of the possibility\nto [roll your own toggle button](http://thebuildingcoder.typepad.com/blog/2012/11/roll-your-own-toggle-button.html)."
  },
  {
    "original_filename": "1397_track_changes",
    "header_text": "<a name=\"3\"></a>Creating an Element State Snapshot",
    "local_header_href": "#a-name3acreating-an-element-state-snapshot",
    "chunk_text": "#### <a name=\"3\"></a>Creating an Element State Snapshot\n\nRetrieve all the element data that you need to capture the state of the element of interest to you, e.g., its location, geometry, parameter data or any other characteristics that you would like to track.\n\nEncode that information into a string.\n\nCompute a hash code for that string.\n\nWe use the hash code to determine whether the state has been modified compared to a new element state snapshot made at a later time.\n\nWe could obviously also store the entire original string representation instead of using a hash code. The hash code is small and handy, whereas the entire string contains all the original data. It is up to you to choose which you would like to use.\n\nYou need to ensure that every relevant change made to the tracked element really does make a difference to the string representation that you generate, and that the hash code you compute really is affected by every modification made.\n\nThis concept is similar to my appeal\nto [create your own key](http://thebuildingcoder.typepad.com/blog/2012/03/great-ocean-road-and-creating-your-own-key.html#2),\nand touches on some aspects of my more\nrecent [Revit project identification](http://the3dwebcoder.typepad.com/blog/2015/07/fireratingcloud-round-trip-and-on-mongolab.html#2).\n\nOne interesting sub-topic here is also how to create a sensible and useful canonical snapshot of the element geometry.\n\nI had a stab back in 2009 analysing [nested instance geometry](http://thebuildingcoder.typepad.com/blog/2009/05/nested-instance-geometry.html) and implementing the `GetVertices` method that simply returns a sorted list of all unique vertices of a given solid in lexicographical order.\n\nSince the element geometry can contain multiple solids, and they can be nested in a whole hierarchy of transformed instances, I need to traverse the element geometry, retrieve the solids from each level and apply the appropriate transformations to them, similarly to the approach used\nto retrieve [real-world concrete corner coordinates](http://thebuildingcoder.typepad.com/blog/2012/06/real-world-concrete-corner-coordinates.html).\n\nFor family instances, however, I chose to ignore the symbol geometry. The family type or symbol should be considered a constant. Any change to the geometry in a family instance should be reflected in a corresponding change to the family type.\nTherefore, I skip the geometry traversal and analysis for family instances and assume that these kind of changes to the family definition will be tracked elsewhere.\n\nFor a family instance, the snapshot just stores the family name, type and category instead of the geometry vertices.\n\nThe current initial implementation grabs the following element properties to create a snapshot of its state:\n\n- Location\n- Parameter names and values\n- Family instance: family, type and category\n- Not a family instance: bounding box and geometry vertices\n\nThe parameter retrieval and storage is based on similar code that I implemented and used in\nthe [RoomEditorApp](https://github.com/jeremytammik/RoomEditorApp) and\nthe [CompHound](https://github.com/CompHound/CompHound.github.io)\nuploader [add-in](https://github.com/CompHound/CompHoundRvt).\n\nNote that a parameter set is unordered. We need to sort the parameters by name to ensure a canonical reproducible representation, just like we need to sort the geometry vertices lexicographically for the same purpose. If we do not, they might be retrieved in an arbitrary different order later on and our string comparison would fail, even though the element data has not really changed.\n\nAs an example, here is the first element state string representation we generated:\n\n<pre>\nLocation=(0,0,0), (22.97,0,0),\nBox=((-0.33,-0.33,0),(23.29,0.33,13.12)),\nVertices=(-0.33,-0.33,0), (-0.33,-0.33,13.12), (-0.33,0.33,0), (-0.33,0.33,13.12), (0.33,0.33,0), (0.33,0.33,13.12), (5.08,-0.33,3.94), (5.08,-0.33,5.94), (5.08,0.33,3.94), (5.08,0.33,5.94), (6.41,-0.33,3.94), (6.41,-0.33,5.94), (6.41,0.33,3.94), (6.41,0.33,5.94), (9.98,-0.33,0), (9.98,-0.33,7), (9.98,0.33,0), (9.98,0.33,7), (12.98,-0.33,0), (12.98,-0.33,7), (12.98,0.33,0), (12.98,0.33,7), (16.56,-0.33,3.94), (16.56,-0.33,5.94), (16.56,0.33,3.94), (16.56,0.33,5.94), (17.89,-0.33,3.94), (17.89,-0.33,5.94), (17.89,0.33,3.94), (17.89,0.33,5.94), (22.64,0.33,0), (22.64,0.33,13.12), (23.29,-0.33,0), (23.29,-0.33,13.12), (23.29,0.33,0), (23.29,0.33,13.12),\nParameters={\"Area\":\"26 m²\",\"Base Constraint\":\"Level 1\",\"Base Extension Distance\":\"0\",\"Base is Attached\":\"No\",\"Base Offset\":\"0\",\"Comments\":\"\",\"Enable Analytical Model\":\"No\",\"Image\":\"<None>\",\"Length\":\"7000\",\"Location Line\":\"Wall Centerline\",\"Mark\":\"\",\"Phase Created\":\"New Construction\",\"Phase Demolished\":\"None\",\"Related to Mass\":\"No\",\"Room Bounding\":\"Yes\",\"Structural Usage\":\"Non-bearing\",\"Structural\":\"No\",\"Top Constraint\":\"Up to level: Level 2\",\"Top Extension Distance\":\"0\",\"Top is Attached\":\"No\",\"Top Offset\":\"0\",\"Unconnected Height\":\"4000\",\"Volume\":\"5.27 m³\"}\n</pre>\n\nFor the current final implementation, please refer to the [GetElementState method implementation](5.5) below."
  },
  {
    "original_filename": "1397_track_changes",
    "header_text": "<a name=\"4\"></a>Determining Which Elements to Track",
    "local_header_href": "#a-name4adetermining-which-elements-to-track",
    "chunk_text": "#### <a name=\"4\"></a>Determining Which Elements to Track\n\nElement retrieval from the database is always achieved using a filtered element collector.\n\nDetermining which elements to track is just a matter of defining the appropriate filters to apply to the collector.\n\nWe already looked at numerous different filtering examples in the past.\n\nIn this case, we may be interested in all or just certain sets of elements.\n\nYou will need to define that in detail for yourself depending on your exact needs.\n\nHere are some of the existing examples and discussions on this topic:\n\n<!--- /a/doc/revit/tbc/ $ blmd 1392 0398 0404 -->\n\n- [Retrieving all elements](http://thebuildingcoder.typepad.com/blog/about-the-author.html#5.9)\n- [Retrieving all model elements](http://thebuildingcoder.typepad.com/blog/2016/01/retrieving-all-model-elements.html)\n- [Retrieving MEP elements and connectors](http://thebuildingcoder.typepad.com/blog/2010/06/retrieve-mep-elements-and-connectors.html)\n- [Retrieving structural elements](http://thebuildingcoder.typepad.com/blog/2010/07/retrieve-structural-elements.html)\n- [Recent thread on model categories](http://forums.autodesk.com/t5/revit-api/all-model-elements-in-project/m-p/5972035)\n\nThe current implementation selects all elements that:\n\n- Are not ElementType objects\n- Are view independent\n- Have a category whose category type is `CategoryType.Model`\n- Have a non-null bounding box\n- Have non-null geometry\n\nFor the current final implementation, please refer to the [GetTrackedElements method implementation](5.4) below."
  },
  {
    "original_filename": "1397_track_changes",
    "header_text": "<a name=\"5\"></a>Implementation",
    "local_header_href": "#a-name5aimplementation",
    "chunk_text": "#### <a name=\"5\"></a>Implementation\n\nI created the [TrackChanges GitHub repository](https://github.com/jeremytammik/TrackChanges) to host this project, including the entire source code, Visual Studio project and add-in manifest.\n\nThe version discussed here is [release 2016.0.0.1](https://github.com/jeremytammik/TrackChanges/releases/tag/2016.0.0.1).\n\nIf you are seriously interested in taking a deeper look, you will obviously fork and clone that repository for yourself and explore the code directly in the Visual Studio IDE.\n\nOtherwise, for the sake of completeness and to help the Internet search engines find this discussion, let's present and discuss the complete source code for the external command and its various helper methods right here, divided into the following code regions:\n\n- [Geometrical Comparison](#5.1)\n- [String formatting](#5.2)\n- [Retrieve solid vertices](#5.3)\n- [Retrieve elements of interest](#5.4)\n- [Store element state](#5.5)\n- [Creating a Database State Snapshot](#5.6)\n- [Report Differences](#5.7)\n- [External Command Mainline Execute Method](#5.8)"
  },
  {
    "original_filename": "1397_track_changes",
    "header_text": "<a name=\"5.1\"></a>Geometrical Comparison",
    "local_header_href": "#a-name51ageometrical-comparison",
    "chunk_text": "#### <a name=\"5.1\"></a>Geometrical Comparison\n\nDefine helper functions  and other support for geometrical comparisons:\n\n<pre class=\"code\">\n&nbsp; <span class=\"blue\">const</span> <span class=\"blue\">double</span> _eps = 1.0e-9;\n&nbsp;\n&nbsp; <span class=\"blue\">public</span> <span class=\"blue\">static</span> <span class=\"blue\">double</span> Eps\n&nbsp; {\n&nbsp; &nbsp; <span class=\"blue\">get</span>\n&nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; <span class=\"blue\">return</span> _eps;\n&nbsp; &nbsp; }\n&nbsp; }\n&nbsp;\n&nbsp; <span class=\"blue\">public</span> <span class=\"blue\">static</span> <span class=\"blue\">double</span> MinLineLength\n&nbsp; {\n&nbsp; &nbsp; <span class=\"blue\">get</span>\n&nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; <span class=\"blue\">return</span> _eps;\n&nbsp; &nbsp; }\n&nbsp; }\n&nbsp;\n&nbsp; <span class=\"blue\">public</span> <span class=\"blue\">static</span> <span class=\"blue\">double</span> TolPointOnPlane\n&nbsp; {\n&nbsp; &nbsp; <span class=\"blue\">get</span>\n&nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; <span class=\"blue\">return</span> _eps;\n&nbsp; &nbsp; }\n&nbsp; }\n&nbsp;\n&nbsp; <span class=\"blue\">public</span> <span class=\"blue\">static</span> <span class=\"blue\">bool</span> IsZero(\n&nbsp; &nbsp; <span class=\"blue\">double</span> a,\n&nbsp; &nbsp; <span class=\"blue\">double</span> tolerance )\n&nbsp; {\n&nbsp; &nbsp; <span class=\"blue\">return</span> tolerance &gt; <span class=\"teal\">Math</span>.Abs( a );\n&nbsp; }\n&nbsp;\n&nbsp; <span class=\"blue\">public</span> <span class=\"blue\">static</span> <span class=\"blue\">bool</span> IsZero( <span class=\"blue\">double</span> a )\n&nbsp; {\n&nbsp; &nbsp; <span class=\"blue\">return</span> IsZero( a, _eps );\n&nbsp; }\n&nbsp;\n&nbsp; <span class=\"blue\">public</span> <span class=\"blue\">static</span> <span class=\"blue\">bool</span> IsEqual( <span class=\"blue\">double</span> a, <span class=\"blue\">double</span> b )\n&nbsp; {\n&nbsp; &nbsp; <span class=\"blue\">return</span> IsZero( b - a );\n&nbsp; }\n&nbsp;\n&nbsp; <span class=\"blue\">public</span> <span class=\"blue\">static</span> <span class=\"blue\">int</span> Compare( <span class=\"blue\">double</span> a, <span class=\"blue\">double</span> b )\n&nbsp; {\n&nbsp; &nbsp; <span class=\"blue\">return</span> IsEqual( a, b ) ? 0 : ( a &lt; b ? -1 : 1 );\n&nbsp; }\n&nbsp;\n&nbsp; <span class=\"blue\">public</span> <span class=\"blue\">static</span> <span class=\"blue\">int</span> Compare( <span class=\"teal\">XYZ</span> p, <span class=\"teal\">XYZ</span> q )\n&nbsp; {\n&nbsp; &nbsp; <span class=\"blue\">int</span> d = Compare( p.X, q.X );\n&nbsp;\n&nbsp; &nbsp; <span class=\"blue\">if</span>( 0 == d )\n&nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; d = Compare( p.Y, q.Y );\n&nbsp;\n&nbsp; &nbsp; &nbsp; <span class=\"blue\">if</span>( 0 == d )\n&nbsp; &nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; &nbsp; d = Compare( p.Z, q.Z );\n&nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n&nbsp; &nbsp; <span class=\"blue\">return</span> d;\n&nbsp; }\n</pre>"
  },
  {
    "original_filename": "1397_track_changes",
    "header_text": "<a name=\"5.2\"></a>String Formatting",
    "local_header_href": "#a-name52astring-formatting",
    "chunk_text": "#### <a name=\"5.2\"></a>String Formatting\n\nDefine a bunch of helper functions to generate string representations of various objects:\n\n<pre class=\"code\">\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> Convert a string to a byte array.</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n&nbsp; <span class=\"blue\">static</span> <span class=\"blue\">byte</span>[] GetBytes( <span class=\"blue\">string</span> str )\n&nbsp; {\n&nbsp; &nbsp; <span class=\"blue\">byte</span>[] bytes = <span class=\"blue\">new</span> <span class=\"blue\">byte</span>[str.Length\n&nbsp; &nbsp; &nbsp; * <span class=\"blue\">sizeof</span>( <span class=\"blue\">char</span> )];\n&nbsp;\n&nbsp; &nbsp; System.<span class=\"teal\">Buffer</span>.BlockCopy( str.ToCharArray(),\n&nbsp; &nbsp; &nbsp; 0, bytes, 0, bytes.Length );\n&nbsp;\n&nbsp; &nbsp; <span class=\"blue\">return</span> bytes;\n&nbsp; }\n&nbsp;\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> Return a string for a real number</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> formatted to two decimal places.</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n&nbsp; <span class=\"blue\">public</span> <span class=\"blue\">static</span> <span class=\"blue\">string</span> RealString( <span class=\"blue\">double</span> a )\n&nbsp; {\n&nbsp; &nbsp; <span class=\"blue\">return</span> a.ToString( <span class=\"maroon\">&quot;0.##&quot;</span> );\n&nbsp; }\n&nbsp;\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> Return a string for an XYZ point</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> or vector with its coordinates</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> formatted to two decimal places.</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n&nbsp; <span class=\"blue\">public</span> <span class=\"blue\">static</span> <span class=\"blue\">string</span> PointString( <span class=\"teal\">XYZ</span> p )\n&nbsp; {\n&nbsp; &nbsp; <span class=\"blue\">return</span> <span class=\"blue\">string</span>.Format( <span class=\"maroon\">&quot;({0},{1},{2})&quot;</span>,\n&nbsp; &nbsp; &nbsp; RealString( p.X ),\n&nbsp; &nbsp; &nbsp; RealString( p.Y ),\n&nbsp; &nbsp; &nbsp; RealString( p.Z ) );\n&nbsp; }\n&nbsp;\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> Return a string for this bounding box</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> with its coordinates formatted to two</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> decimal places.</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n&nbsp; <span class=\"blue\">public</span> <span class=\"blue\">static</span> <span class=\"blue\">string</span> BoundingBoxString(\n&nbsp; &nbsp; <span class=\"teal\">BoundingBoxXYZ</span> bb )\n&nbsp; {\n&nbsp; &nbsp; <span class=\"blue\">return</span> <span class=\"blue\">string</span>.Format( <span class=\"maroon\">&quot;({0},{1})&quot;</span>,\n&nbsp; &nbsp; &nbsp; PointString( bb.Min ),\n&nbsp; &nbsp; &nbsp; PointString( bb.Max ) );\n&nbsp; }\n&nbsp;\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> Return a string for this point array</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> with its coordinates formatted to two</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> decimal places.</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n&nbsp; <span class=\"blue\">public</span> <span class=\"blue\">static</span> <span class=\"blue\">string</span> PointArrayString( <span class=\"teal\">IList</span>&lt;<span class=\"teal\">XYZ</span>&gt; pts )\n&nbsp; {\n&nbsp; &nbsp; <span class=\"blue\">return</span> <span class=\"blue\">string</span>.Join( <span class=\"maroon\">&quot;, &quot;</span>,\n&nbsp; &nbsp; &nbsp; pts.Select&lt;<span class=\"teal\">XYZ</span>, <span class=\"blue\">string</span>&gt;(\n&nbsp; &nbsp; &nbsp; &nbsp; p =&gt; PointString( p ) ) );\n&nbsp; }\n&nbsp;\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> Return a string for this curve with its</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> tessellated point coordinates formatted</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> to two decimal places.</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n&nbsp; <span class=\"blue\">public</span> <span class=\"blue\">static</span> <span class=\"blue\">string</span> CurveTessellateString(\n&nbsp; &nbsp; <span class=\"teal\">Curve</span> curve )\n&nbsp; {\n&nbsp; &nbsp; <span class=\"blue\">return</span> PointArrayString( curve.Tessellate() );\n&nbsp; }\n&nbsp;\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> Return a string for this curve with its</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> tessellated point coordinates formatted</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> to two decimal places.</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n&nbsp; <span class=\"blue\">public</span> <span class=\"blue\">static</span> <span class=\"blue\">string</span> LocationString(\n&nbsp; &nbsp; <span class=\"teal\">Location</span> location )\n&nbsp; {\n&nbsp; &nbsp; <span class=\"teal\">LocationPoint</span> lp = location <span class=\"blue\">as</span> <span class=\"teal\">LocationPoint</span>;\n&nbsp; &nbsp; <span class=\"teal\">LocationCurve</span> lc = ( <span class=\"blue\">null</span> == lp )\n&nbsp; &nbsp; &nbsp; ? location <span class=\"blue\">as</span> <span class=\"teal\">LocationCurve</span>\n&nbsp; &nbsp; &nbsp; : <span class=\"blue\">null</span>;\n&nbsp;\n&nbsp; &nbsp; <span class=\"blue\">return</span> <span class=\"blue\">null</span> == lp\n&nbsp; &nbsp; &nbsp; ? ( <span class=\"blue\">null</span> == lc\n&nbsp; &nbsp; &nbsp; &nbsp; ? <span class=\"blue\">null</span>\n&nbsp; &nbsp; &nbsp; &nbsp; : CurveTessellateString( lc.Curve ) )\n&nbsp; &nbsp; &nbsp; : PointString( lp.Point );\n&nbsp; }\n&nbsp;\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> Return a JSON string representing a dictionary</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> of the given parameter names and values.</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n&nbsp; <span class=\"blue\">public</span> <span class=\"blue\">static</span> <span class=\"blue\">string</span> GetPropertiesJson(\n&nbsp; &nbsp; <span class=\"teal\">IList</span>&lt;<span class=\"teal\">Parameter</span>&gt; parameters )\n&nbsp; {\n&nbsp; &nbsp; <span class=\"blue\">int</span> n = parameters.Count;\n&nbsp; &nbsp; <span class=\"teal\">List</span>&lt;<span class=\"blue\">string</span>&gt; a = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"blue\">string</span>&gt;( n );\n&nbsp; &nbsp; <span class=\"blue\">foreach</span>( <span class=\"teal\">Parameter</span> p <span class=\"blue\">in</span> parameters )\n&nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; a.Add( <span class=\"blue\">string</span>.Format( <span class=\"maroon\">&quot;\\&quot;{0}\\&quot;:\\&quot;{1}\\&quot;&quot;</span>,\n&nbsp; &nbsp; &nbsp; &nbsp; p.Definition.Name, p.AsValueString() ) );\n&nbsp; &nbsp; }\n&nbsp; &nbsp; a.Sort();\n&nbsp; &nbsp; <span class=\"blue\">string</span> s = <span class=\"blue\">string</span>.Join( <span class=\"maroon\">&quot;,&quot;</span>, a );\n&nbsp; &nbsp; <span class=\"blue\">return</span> <span class=\"maroon\">&quot;{&quot;</span> + s + <span class=\"maroon\">&quot;}&quot;</span>;\n&nbsp; }\n&nbsp;\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> Return a string describing the given element:</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> .NET type name,</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> category name,</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> family and symbol name for a family instance,</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> element id and element name.</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n&nbsp; <span class=\"blue\">public</span> <span class=\"blue\">static</span> <span class=\"blue\">string</span> ElementDescription(\n&nbsp; &nbsp; <span class=\"teal\">Element</span> e )\n&nbsp; {\n&nbsp; &nbsp; <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == e )\n&nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; <span class=\"blue\">return</span> <span class=\"maroon\">&quot;&lt;null&gt;&quot;</span>;\n&nbsp; &nbsp; }\n&nbsp;\n&nbsp; &nbsp; <span class=\"green\">// For a wall, the element name equals the</span>\n&nbsp; &nbsp; <span class=\"green\">// wall type name, which is equivalent to the</span>\n&nbsp; &nbsp; <span class=\"green\">// family name ...</span>\n&nbsp;\n&nbsp; &nbsp; <span class=\"teal\">FamilyInstance</span> fi = e <span class=\"blue\">as</span> <span class=\"teal\">FamilyInstance</span>;\n&nbsp;\n&nbsp; &nbsp; <span class=\"blue\">string</span> typeName = e.GetType().Name;\n&nbsp;\n&nbsp; &nbsp; <span class=\"blue\">string</span> categoryName = ( <span class=\"blue\">null</span> == e.Category )\n&nbsp; &nbsp; &nbsp; ? <span class=\"blue\">string</span>.Empty\n&nbsp; &nbsp; &nbsp; : e.Category.Name + <span class=\"maroon\">&quot; &quot;</span>;\n&nbsp;\n&nbsp; &nbsp; <span class=\"blue\">string</span> familyName = ( <span class=\"blue\">null</span> == fi )\n&nbsp; &nbsp; &nbsp; ? <span class=\"blue\">string</span>.Empty\n&nbsp; &nbsp; &nbsp; : fi.Symbol.Family.Name + <span class=\"maroon\">&quot; &quot;</span>;\n&nbsp;\n&nbsp; &nbsp; <span class=\"blue\">string</span> symbolName = ( <span class=\"blue\">null</span> == fi\n&nbsp; &nbsp; &nbsp; || e.Name.Equals( fi.Symbol.Name ) )\n&nbsp; &nbsp; &nbsp; &nbsp; ? <span class=\"blue\">string</span>.Empty\n&nbsp; &nbsp; &nbsp; &nbsp; : fi.Symbol.Name + <span class=\"maroon\">&quot; &quot;</span>;\n&nbsp;\n&nbsp; &nbsp; <span class=\"blue\">return</span> <span class=\"blue\">string</span>.Format( <span class=\"maroon\">&quot;{0} {1}{2}{3}&lt;{4} {5}&gt;&quot;</span>,\n&nbsp; &nbsp; &nbsp; typeName, categoryName, familyName,\n&nbsp; &nbsp; &nbsp; symbolName, e.Id.IntegerValue, e.Name );\n&nbsp; }\n&nbsp;\n&nbsp; <span class=\"blue\">public</span> <span class=\"blue\">static</span> <span class=\"blue\">string</span> ElementDescription(\n&nbsp; &nbsp; <span class=\"teal\">Document</span> doc,\n&nbsp; &nbsp; <span class=\"blue\">int</span> element_id )\n&nbsp; {\n&nbsp; &nbsp; <span class=\"blue\">return</span> ElementDescription( doc.GetElement(\n&nbsp; &nbsp; &nbsp; <span class=\"blue\">new</span> <span class=\"teal\">ElementId</span>( element_id ) ) );\n&nbsp; }\n</pre>"
  },
  {
    "original_filename": "1397_track_changes",
    "header_text": "<a name=\"5.3\"></a>Retrieve Solid Vertices",
    "local_header_href": "#a-name53aretrieve-solid-vertices",
    "chunk_text": "#### <a name=\"5.3\"></a>Retrieve Solid Vertices\n\nRetrieve solid vertices and sort them lexicographically to define an extremely simplified form of a partial canonical element geometry representation.\n\n<pre class=\"code\">\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> Define equality between XYZ objects, ensuring </span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> that almost equal points compare equal.</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n&nbsp; <span class=\"blue\">class</span> <span class=\"teal\">XyzEqualityComparer</span> : <span class=\"teal\">IEqualityComparer</span>&lt;<span class=\"teal\">XYZ</span>&gt;\n&nbsp; {\n&nbsp; &nbsp; <span class=\"blue\">public</span> <span class=\"blue\">bool</span> Equals( <span class=\"teal\">XYZ</span> p, <span class=\"teal\">XYZ</span> q )\n&nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; <span class=\"blue\">return</span> p.IsAlmostEqualTo( q );\n&nbsp; &nbsp; }\n&nbsp;\n&nbsp; &nbsp; <span class=\"blue\">public</span> <span class=\"blue\">int</span> GetHashCode( <span class=\"teal\">XYZ</span> p )\n&nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; <span class=\"blue\">return</span> PointString( p ).GetHashCode();\n&nbsp; &nbsp; }\n&nbsp; }\n&nbsp;\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> Add the vertices of the given solid to </span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> the vertex lookup dictionary.</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n&nbsp; <span class=\"blue\">static</span> <span class=\"blue\">void</span> AddVertices(\n&nbsp; &nbsp; <span class=\"teal\">Dictionary</span>&lt;<span class=\"teal\">XYZ</span>, <span class=\"blue\">int</span>&gt; vertexLookup,\n&nbsp; &nbsp; <span class=\"teal\">Transform</span> t,\n&nbsp; &nbsp; <span class=\"teal\">Solid</span> s )\n&nbsp; {\n&nbsp; &nbsp; <span class=\"teal\">Debug</span>.Assert( 0 &lt; s.Edges.Size,\n&nbsp; &nbsp; &nbsp; <span class=\"maroon\">&quot;expected a non-empty solid&quot;</span> );\n&nbsp;\n&nbsp; &nbsp; <span class=\"blue\">foreach</span>( <span class=\"teal\">Face</span> f <span class=\"blue\">in</span> s.Faces )\n&nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; <span class=\"teal\">Mesh</span> m = f.Triangulate();\n&nbsp;\n&nbsp; &nbsp; &nbsp; <span class=\"blue\">foreach</span>( <span class=\"teal\">XYZ</span> p <span class=\"blue\">in</span> m.Vertices )\n&nbsp; &nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; &nbsp; <span class=\"teal\">XYZ</span> q = t.OfPoint( p );\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; <span class=\"blue\">if</span>( !vertexLookup.ContainsKey( q ) )\n&nbsp; &nbsp; &nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vertexLookup.Add( q, 1 );\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; <span class=\"blue\">else</span>\n&nbsp; &nbsp; &nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ++vertexLookup[q];\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n&nbsp; }\n&nbsp;\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> Recursively add vertices of all solids found</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> in the given geometry to the vertex lookup.</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> Untested!</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n&nbsp; <span class=\"blue\">static</span> <span class=\"blue\">void</span> AddVertices(\n&nbsp; &nbsp; <span class=\"teal\">Dictionary</span>&lt;<span class=\"teal\">XYZ</span>, <span class=\"blue\">int</span>&gt; vertexLookup,\n&nbsp; &nbsp; <span class=\"teal\">Transform</span> t,\n&nbsp; &nbsp; <span class=\"teal\">GeometryElement</span> geo )\n&nbsp; {\n&nbsp; &nbsp; <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == geo )\n&nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; <span class=\"teal\">Debug</span>.Assert( <span class=\"blue\">null</span> != geo, <span class=\"maroon\">&quot;null GeometryElement&quot;</span> );\n&nbsp; &nbsp; &nbsp; <span class=\"blue\">throw</span> <span class=\"blue\">new</span> System.<span class=\"teal\">ArgumentException</span>( <span class=\"maroon\">&quot;null GeometryElement&quot;</span> );\n&nbsp; &nbsp; }\n&nbsp;\n&nbsp; &nbsp; <span class=\"blue\">foreach</span>( <span class=\"teal\">GeometryObject</span> obj <span class=\"blue\">in</span> geo )\n&nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; <span class=\"teal\">Solid</span> solid = obj <span class=\"blue\">as</span> <span class=\"teal\">Solid</span>;\n&nbsp;\n&nbsp; &nbsp; &nbsp; <span class=\"blue\">if</span>( <span class=\"blue\">null</span> != solid )\n&nbsp; &nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; &nbsp; <span class=\"blue\">if</span>( 0 &lt; solid.Faces.Size )\n&nbsp; &nbsp; &nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AddVertices( vertexLookup, t, solid );\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; <span class=\"blue\">else</span>\n&nbsp; &nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; &nbsp; <span class=\"teal\">GeometryInstance</span> inst = obj <span class=\"blue\">as</span> <span class=\"teal\">GeometryInstance</span>;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; <span class=\"blue\">if</span>( <span class=\"blue\">null</span> != inst )\n&nbsp; &nbsp; &nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class=\"green\">//GeometryElement geoi = inst.GetInstanceGeometry();</span>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class=\"teal\">GeometryElement</span> geos = inst.GetSymbolGeometry();\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class=\"green\">//Debug.Assert( null == geoi || null == geos,</span>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class=\"green\">//&nbsp; &quot;expected either symbol or instance geometry, not both&quot; );</span>\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class=\"teal\">Debug</span>.Assert( <span class=\"blue\">null</span> != inst.Transform,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class=\"maroon\">&quot;null inst.Transform&quot;</span> );\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class=\"green\">//Debug.Assert( null != inst.GetSymbolGeometry(),</span>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class=\"green\">//&nbsp; &quot;null inst.GetSymbolGeometry&quot; );</span>\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class=\"blue\">if</span>( <span class=\"blue\">null</span> != geos )\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AddVertices( vertexLookup,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inst.Transform.Multiply( t ),\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; geos );\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n&nbsp; }\n&nbsp;\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> Return a sorted list of all unique vertices </span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> of all solids in the given element's geometry</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> in lexicographical order.</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n&nbsp; <span class=\"blue\">static</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">XYZ</span>&gt; GetCanonicVertices( <span class=\"teal\">Element</span> e )\n&nbsp; {\n&nbsp; &nbsp; <span class=\"teal\">GeometryElement</span> geo = e.get_Geometry( <span class=\"blue\">new</span> <span class=\"teal\">Options</span>() );\n&nbsp; &nbsp; <span class=\"teal\">Transform</span> t = <span class=\"teal\">Transform</span>.Identity;\n&nbsp;\n&nbsp; &nbsp; <span class=\"teal\">Dictionary</span>&lt;<span class=\"teal\">XYZ</span>, <span class=\"blue\">int</span>&gt; vertexLookup\n&nbsp; &nbsp; &nbsp; = <span class=\"blue\">new</span> <span class=\"teal\">Dictionary</span>&lt;<span class=\"teal\">XYZ</span>, <span class=\"blue\">int</span>&gt;(\n&nbsp; &nbsp; &nbsp; &nbsp; <span class=\"blue\">new</span> <span class=\"teal\">XyzEqualityComparer</span>() );\n&nbsp;\n&nbsp; &nbsp; AddVertices( vertexLookup, t, geo );\n&nbsp;\n&nbsp; &nbsp; <span class=\"teal\">List</span>&lt;<span class=\"teal\">XYZ</span>&gt; keys = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">XYZ</span>&gt;( vertexLookup.Keys );\n&nbsp;\n&nbsp; &nbsp; keys.Sort( Compare );\n&nbsp;\n&nbsp; &nbsp; <span class=\"blue\">return</span> keys;\n&nbsp; }\n</pre>"
  },
  {
    "original_filename": "1397_track_changes",
    "header_text": "<a name=\"5.4\"></a>GetTrackedElements &ndash; Retrieve Elements of Interest",
    "local_header_href": "#a-name54agettrackedelements-ndash-retrieve-elements-of-interest",
    "chunk_text": "#### <a name=\"5.4\"></a>GetTrackedElements &ndash; Retrieve Elements of Interest\n\nRetrieve all the elements of interest:\n\n<pre class=\"code\">\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> Retrieve all elements to track.</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> It is up to you to decide which elements</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> are of interest to you.</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n&nbsp; <span class=\"blue\">static</span> <span class=\"teal\">IEnumerable</span>&lt;<span class=\"teal\">Element</span>&gt; GetTrackedElements(\n&nbsp; &nbsp; <span class=\"teal\">Document</span> doc )\n&nbsp; {\n&nbsp; &nbsp; <span class=\"teal\">Categories</span> cats = doc.Settings.Categories;\n&nbsp;\n&nbsp; &nbsp; <span class=\"teal\">List</span>&lt;<span class=\"teal\">ElementFilter</span>&gt; a = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">ElementFilter</span>&gt;();\n&nbsp;\n&nbsp; &nbsp; <span class=\"blue\">foreach</span>( <span class=\"teal\">Category</span> c <span class=\"blue\">in</span> cats )\n&nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; <span class=\"blue\">if</span>( <span class=\"teal\">CategoryType</span>.Model == c.CategoryType )\n&nbsp; &nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; &nbsp; a.Add( <span class=\"blue\">new</span> <span class=\"teal\">ElementCategoryFilter</span>( c.Id ) );\n&nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n&nbsp;\n&nbsp; &nbsp; <span class=\"teal\">ElementFilter</span> isModelCategory\n&nbsp; &nbsp; &nbsp; = <span class=\"blue\">new</span> <span class=\"teal\">LogicalOrFilter</span>( a );\n&nbsp;\n&nbsp; &nbsp; <span class=\"teal\">Options</span> opt = <span class=\"blue\">new</span> <span class=\"teal\">Options</span>();\n&nbsp;\n&nbsp; &nbsp; <span class=\"blue\">return</span> <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( doc )\n&nbsp; &nbsp; &nbsp; .WhereElementIsNotElementType()\n&nbsp; &nbsp; &nbsp; .WhereElementIsViewIndependent()\n&nbsp; &nbsp; &nbsp; .WherePasses( isModelCategory )\n&nbsp; &nbsp; &nbsp; .Where&lt;<span class=\"teal\">Element</span>&gt;( e =&gt;\n&nbsp; &nbsp; &nbsp; &nbsp; ( <span class=\"blue\">null</span> != e.get_BoundingBox( <span class=\"blue\">null</span> ) )\n&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; ( <span class=\"blue\">null</span> != e.get_Geometry( opt ) ) );\n&nbsp; }\n</pre>"
  },
  {
    "original_filename": "1397_track_changes",
    "header_text": "<a name=\"5.5\"></a>GetElementState &ndash; Store Element State",
    "local_header_href": "#a-name55agetelementstate-ndash-store-element-state",
    "chunk_text": "#### <a name=\"5.5\"></a>GetElementState &ndash; Store Element State\n\nDetermine the state of an element and encode it as a string:\n\n<pre class=\"code\">\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> Return a string representing the given element</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> state. This is the information you wish to track.</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> It is up to you to ensure that all data you are</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> interested in really is included in this snapshot.</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> In this case, we ignore all elements that do not</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> have a valid bounding box.</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n&nbsp; <span class=\"blue\">static</span> <span class=\"blue\">string</span> GetElementState( <span class=\"teal\">Element</span> e )\n&nbsp; {\n&nbsp; &nbsp; <span class=\"blue\">string</span> s = <span class=\"blue\">null</span>;\n&nbsp;\n&nbsp; &nbsp; <span class=\"teal\">BoundingBoxXYZ</span> bb = e.get_BoundingBox( <span class=\"blue\">null</span> );\n&nbsp;\n&nbsp; &nbsp; <span class=\"blue\">if</span>( <span class=\"blue\">null</span> != bb )\n&nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; <span class=\"teal\">List</span>&lt;<span class=\"blue\">string</span>&gt; properties = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"blue\">string</span>&gt;();\n&nbsp;\n&nbsp; &nbsp; &nbsp; properties.Add( ElementDescription( e )\n&nbsp; &nbsp; &nbsp; &nbsp; + <span class=\"maroon\">&quot; at &quot;</span> + LocationString( e.Location ) );\n&nbsp;\n&nbsp; &nbsp; &nbsp; <span class=\"blue\">if</span>( !( e <span class=\"blue\">is</span> <span class=\"teal\">FamilyInstance</span> ) )\n&nbsp; &nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; &nbsp; properties.Add( <span class=\"maroon\">&quot;Box=&quot;</span>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; + BoundingBoxString( bb ) );\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; properties.Add( <span class=\"maroon\">&quot;Vertices=&quot;</span>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; + PointArrayString( GetCanonicVertices( e ) ) );\n&nbsp; &nbsp; &nbsp; }\n&nbsp;\n&nbsp; &nbsp; &nbsp; properties.Add( <span class=\"maroon\">&quot;Parameters=&quot;</span>\n&nbsp; &nbsp; &nbsp; &nbsp; + GetPropertiesJson( e.GetOrderedParameters() ) );\n&nbsp;\n&nbsp; &nbsp; &nbsp; s = <span class=\"blue\">string</span>.Join( <span class=\"maroon\">&quot;, &quot;</span>, properties );\n&nbsp;\n&nbsp; &nbsp; &nbsp; <span class=\"green\">//Debug.Print( s );</span>\n&nbsp; &nbsp; }\n&nbsp; &nbsp; <span class=\"blue\">return</span> s;\n&nbsp; }\n</pre>"
  },
  {
    "original_filename": "1397_track_changes",
    "header_text": "<a name=\"5.6\"></a>Creating a Database State Snapshot",
    "local_header_href": "#a-name56acreating-a-database-state-snapshot",
    "chunk_text": "#### <a name=\"5.6\"></a>Creating a Database State Snapshot\n\nRetrieve each element's state, encode it as a string and store their resulting hash codes in a dictionary mapping element id to hash code:\n\n<pre class=\"code\">\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> Return a dictionary mapping element id values</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> to hash codes of the element state strings. </span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> This represents a snapshot of the current </span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> database state.</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n&nbsp; <span class=\"blue\">static</span> <span class=\"teal\">Dictionary</span>&lt;<span class=\"blue\">int</span>, <span class=\"blue\">string</span>&gt; GetSnapshot(\n&nbsp; &nbsp; <span class=\"teal\">IEnumerable</span>&lt;<span class=\"teal\">Element</span>&gt; a )\n&nbsp; {\n&nbsp; &nbsp; <span class=\"teal\">Dictionary</span>&lt;<span class=\"blue\">int</span>, <span class=\"blue\">string</span>&gt; d\n&nbsp; &nbsp; &nbsp; = <span class=\"blue\">new</span> <span class=\"teal\">Dictionary</span>&lt;<span class=\"blue\">int</span>, <span class=\"blue\">string</span>&gt;();\n&nbsp;\n&nbsp; &nbsp; <span class=\"teal\">SHA256</span> hasher = <span class=\"teal\">SHA256Managed</span>.Create();\n&nbsp;\n&nbsp; &nbsp; <span class=\"blue\">foreach</span>( <span class=\"teal\">Element</span> e <span class=\"blue\">in</span> a )\n&nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; <span class=\"green\">//Debug.Print( e.Id.IntegerValue.ToString() </span>\n&nbsp; &nbsp; &nbsp; <span class=\"green\">//&nbsp; + &quot; &quot; + e.GetType().Name );</span>\n&nbsp;\n&nbsp; &nbsp; &nbsp; <span class=\"blue\">string</span> s = GetElementState( e );\n&nbsp;\n&nbsp; &nbsp; &nbsp; <span class=\"blue\">if</span>( <span class=\"blue\">null</span> != s )\n&nbsp; &nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; &nbsp; <span class=\"blue\">string</span> hashb64 = <span class=\"teal\">Convert</span>.ToBase64String(\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hasher.ComputeHash( GetBytes( s ) ) );\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; d.Add( e.Id.IntegerValue, hashb64 );\n&nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n&nbsp; &nbsp; <span class=\"blue\">return</span> d;\n&nbsp; }\n</pre>"
  },
  {
    "original_filename": "1397_track_changes",
    "header_text": "<a name=\"5.7\"></a>Report differences",
    "local_header_href": "#a-name57areport-differences",
    "chunk_text": "#### <a name=\"5.7\"></a>Report differences\n\nDetermine and report the differences between the two states at the start and end of the tracking period:\n\n<pre class=\"code\">\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> Compare the start and end states and report the </span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> differences found. In this implementation, we</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> just store a hash code of the element state.</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> If you choose to store the full string </span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> representation, you can use that for comparison,</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> and then report exactly what changed and the</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> original values as well.</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n&nbsp; <span class=\"blue\">static</span> <span class=\"blue\">void</span> ReportDifferences(\n&nbsp; &nbsp; <span class=\"teal\">Document</span> doc,\n&nbsp; &nbsp; <span class=\"teal\">Dictionary</span>&lt;<span class=\"blue\">int</span>, <span class=\"blue\">string</span>&gt; start_state,\n&nbsp; &nbsp; <span class=\"teal\">Dictionary</span>&lt;<span class=\"blue\">int</span>, <span class=\"blue\">string</span>&gt; end_state )\n&nbsp; {\n&nbsp; &nbsp; <span class=\"blue\">int</span> n1 = start_state.Keys.Count;\n&nbsp; &nbsp; <span class=\"blue\">int</span> n2 = end_state.Keys.Count;\n&nbsp;\n&nbsp; &nbsp; <span class=\"teal\">List</span>&lt;<span class=\"blue\">int</span>&gt; keys = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"blue\">int</span>&gt;( start_state.Keys );\n&nbsp;\n&nbsp; &nbsp; <span class=\"blue\">foreach</span>( <span class=\"blue\">int</span> id <span class=\"blue\">in</span> end_state.Keys )\n&nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; <span class=\"blue\">if</span>( !keys.Contains( id ) )\n&nbsp; &nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; &nbsp; keys.Add( id );\n&nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n&nbsp;\n&nbsp; &nbsp; keys.Sort();\n&nbsp;\n&nbsp; &nbsp; <span class=\"blue\">int</span> n = keys.Count;\n&nbsp;\n&nbsp; &nbsp; <span class=\"teal\">Debug</span>.Print(\n&nbsp; &nbsp; &nbsp; <span class=\"maroon\">&quot;{0} elements before, {1} elements after, {2} total&quot;</span>,\n&nbsp; &nbsp; &nbsp; n1, n2, n );\n&nbsp;\n&nbsp; &nbsp; <span class=\"blue\">int</span> nAdded = 0;\n&nbsp; &nbsp; <span class=\"blue\">int</span> nDeleted = 0;\n&nbsp; &nbsp; <span class=\"blue\">int</span> nModified = 0;\n&nbsp; &nbsp; <span class=\"blue\">int</span> nIdentical = 0;\n&nbsp; &nbsp; <span class=\"teal\">List</span>&lt;<span class=\"blue\">string</span>&gt; report = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"blue\">string</span>&gt;();\n&nbsp;\n&nbsp; &nbsp; <span class=\"blue\">foreach</span>( <span class=\"blue\">int</span> id <span class=\"blue\">in</span> keys )\n&nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; <span class=\"blue\">if</span>( !start_state.ContainsKey( id ) )\n&nbsp; &nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; &nbsp; ++nAdded;\n&nbsp; &nbsp; &nbsp; &nbsp; report.Add( id.ToString() + <span class=\"maroon\">&quot; added &quot;</span>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; + ElementDescription( doc, id ) );\n&nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; <span class=\"blue\">else</span> <span class=\"blue\">if</span>( !end_state.ContainsKey( id ) )\n&nbsp; &nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; &nbsp; ++nDeleted;\n&nbsp; &nbsp; &nbsp; &nbsp; report.Add( id.ToString() + <span class=\"maroon\">&quot; deleted&quot;</span> );\n&nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; <span class=\"blue\">else</span> <span class=\"blue\">if</span>( start_state[id] != end_state[id] )\n&nbsp; &nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; &nbsp; ++nModified;\n&nbsp; &nbsp; &nbsp; &nbsp; report.Add( id.ToString() + <span class=\"maroon\">&quot; modified &quot;</span>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; + ElementDescription( doc, id ) );\n&nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; <span class=\"blue\">else</span>\n&nbsp; &nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; &nbsp; ++nIdentical;\n&nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n&nbsp;\n&nbsp; &nbsp; <span class=\"blue\">string</span> msg = <span class=\"blue\">string</span>.Format(\n&nbsp; &nbsp; &nbsp; <span class=\"maroon\">&quot;Stopped tracking changes now.\\r\\n&quot;</span>\n&nbsp; &nbsp; &nbsp; + <span class=\"maroon\">&quot;{0} deleted, {1} added, {2} modified, &quot;</span>\n&nbsp; &nbsp; &nbsp; + <span class=\"maroon\">&quot;{3} identical elements:&quot;</span>,\n&nbsp; &nbsp; &nbsp; nDeleted, nAdded, nModified, nIdentical );\n&nbsp;\n&nbsp; &nbsp; <span class=\"blue\">string</span> s = <span class=\"blue\">string</span>.Join( <span class=\"maroon\">&quot;\\r\\n&quot;</span>, report );\n&nbsp;\n&nbsp; &nbsp; <span class=\"teal\">Debug</span>.Print( msg + <span class=\"maroon\">&quot;\\r\\n&quot;</span> + s );\n&nbsp; &nbsp; <span class=\"teal\">TaskDialog</span> dlg = <span class=\"blue\">new</span> <span class=\"teal\">TaskDialog</span>( <span class=\"maroon\">&quot;Track Changes&quot;</span> );\n&nbsp; &nbsp; dlg.MainInstruction = msg;\n&nbsp; &nbsp; dlg.MainContent = s;\n&nbsp; &nbsp; dlg.Show();\n&nbsp; }\n</pre>"
  },
  {
    "original_filename": "1397_track_changes",
    "header_text": "<a name=\"5.8\"></a>External Command Mainline Execute Method",
    "local_header_href": "#a-name58aexternal-command-mainline-execute-method",
    "chunk_text": "#### <a name=\"5.8\"></a>External Command Mainline Execute Method\n\nNote that this command makes no modifications to the Revit database, so it uses the `ReadOnly` transaction mode.\n\nThe static variable `_start_state` stores the initial snapshot when we start tracking changes:\n\n<pre class=\"code\">\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> Current snapshot of database state.</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> You could also store the entire element state </span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> strings here, not just their hash code, to</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> report their complete original and modified </span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> values.</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n&nbsp; <span class=\"blue\">static</span> <span class=\"teal\">Dictionary</span>&lt;<span class=\"blue\">int</span>, <span class=\"blue\">string</span>&gt; _start_state = <span class=\"blue\">null</span>;\n</pre>\n\nThe mainline checks whether `_start_state` has been initialised.\n\nIf not, we create a snapshot to start tracking changes and report so to the user.\n\nOtherwise, a new snapshot of the end state is created and the differences are reported:\n\n<pre class=\"code\">\n&nbsp; <span class=\"blue\">public</span> <span class=\"teal\">Result</span> Execute(\n&nbsp; &nbsp; <span class=\"teal\">ExternalCommandData</span> commandData,\n&nbsp; &nbsp; <span class=\"blue\">ref</span> <span class=\"blue\">string</span> message,\n&nbsp; &nbsp; <span class=\"teal\">ElementSet</span> elements )\n&nbsp; {\n&nbsp; &nbsp; <span class=\"teal\">UIApplication</span> uiapp = commandData.Application;\n&nbsp; &nbsp; <span class=\"teal\">UIDocument</span> uidoc = uiapp.ActiveUIDocument;\n&nbsp; &nbsp; <span class=\"teal\">Application</span> app = uiapp.Application;\n&nbsp; &nbsp; <span class=\"teal\">Document</span> doc = uidoc.Document;\n&nbsp;\n&nbsp; &nbsp; <span class=\"teal\">IEnumerable</span>&lt;<span class=\"teal\">Element</span>&gt; a = GetTrackedElements( doc );\n&nbsp;\n&nbsp; &nbsp; <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == _start_state )\n&nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; _start_state = GetSnapshot( a );\n&nbsp; &nbsp; &nbsp; <span class=\"teal\">TaskDialog</span>.Show( <span class=\"maroon\">&quot;Track Changes&quot;</span>,\n&nbsp; &nbsp; &nbsp; &nbsp; <span class=\"maroon\">&quot;Started tracking changes now.&quot;</span> );\n&nbsp; &nbsp; }\n&nbsp; &nbsp; <span class=\"blue\">else</span>\n&nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; <span class=\"teal\">Dictionary</span>&lt;<span class=\"blue\">int</span>, <span class=\"blue\">string</span>&gt; end_state = GetSnapshot( a );\n&nbsp; &nbsp; &nbsp; ReportDifferences( doc, _start_state, end_state );\n&nbsp; &nbsp; &nbsp; _start_state = <span class=\"blue\">null</span>;\n&nbsp; &nbsp; }\n&nbsp; &nbsp; <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Succeeded;\n&nbsp; }\n</pre>\n\n\n<!---"
  },
  {
    "original_filename": "1397_track_changes",
    "header_text": "<a name=\"8\"></a>Caveats",
    "local_header_href": "#a-name8acaveats",
    "chunk_text": "#### <a name=\"8\"></a>Caveats\n\nWhat is the family definition is modified?\n\nNo need to worry, it will change stuff around it.\n\nYou just have to know that it is not going to pick that up.\n-->"
  },
  {
    "original_filename": "1397_track_changes",
    "header_text": "<a name=\"6\"></a>Sample Runs",
    "local_header_href": "#a-name6asample-runs",
    "chunk_text": "#### <a name=\"6\"></a>Sample Runs\n\nLet's run the element modification tracker in a real project, e.g. the Revit sample rac_advanced_sample.rvt:\n\n<center>\n<img src=\"img/track_rac_advanced_sample.png\" alt=\"Revit rac_advanced_sample BIM\" width=\"641\">\n</center>\n\nZoom in to some simple wall that we can modify:\n\n<center>\n<img src=\"img/track_wall_original.png\" alt=\"Original wall\" width=\"615\">\n</center>\n\nMove it a little bit:\n\n<center>\n<img src=\"img/track_wall_original.png\" alt=\"Moved wall\" width=\"624\">\n</center>\n\nThat generates the following report:\n\n<pre>\n5603 elements before, 5603 elements after, 5603 total\n139803 modified Floor Floors &lt;139803 Hollow Core Plank - Concrete Topping&gt;\n139829 modified Floor Floors &lt;139829 Hollow Core Plank - Concrete Topping&gt;\n152882 modified Wall Walls &lt;152882 Interior - 138mm Partition (1-hr)&gt;\n153000 modified Wall Walls &lt;153000 Interior - 138mm Partition (1-hr)&gt;\n153435 modified Wall Walls &lt;153435 Interior - 138mm Partition (1-hr)&gt;\n177329 modified Room Rooms &lt;177329 Corridor 107&gt;\n0 deleted, 0 added, 6 modified, 5597 identical elements\n</pre>\n\nObviously, as always, just moving one single wall a little bit affected a number of related objects, e.g., neighbouring walls, floors, and rooms.\n\nSlightly more interesting test after adding a dialogue box to display the report:\n\nAgain, we'll just move one single wall; this one will affect more elements:\n\n<center>\n<img src=\"img/track_wall2_original.png\" alt=\"Original wall\" width=\"854\">\n</center>\n\nMove this one down a bit:\n\n<center>\n<img src=\"img/track_wall2_moved.png\" alt=\"Moved wall\" width=\"852\">\n</center>\n\nThat generates the following report:\n\n<pre>\n5603 elements before, 5603 elements after, 5603 total\n0 deleted, 0 added, 24 modified, 5579 identical elements:\n139803 modified Floor Floors &lt;139803 Hollow Core Plank - Concrete Topping&gt;\n139829 modified Floor Floors &lt;139829 Hollow Core Plank - Concrete Topping&gt;\n152037 modified Wall Walls &lt;152037 Interior - 138mm Partition (1-hr)&gt;\n152111 modified Wall Walls &lt;152111 Interior - 138mm Partition (1-hr)&gt;\n152271 modified Wall Walls &lt;152271 Interior - 138mm Partition (1-hr)&gt;\n152347 modified Wall Walls &lt;152347 Interior - 138mm Partition (1-hr)&gt;\n152622 modified FamilyInstance Doors M_Single-Flush &lt;152622 0915 x 2134mm&gt;\n152688 modified FamilyInstance Doors M_Single-Flush &lt;152688 0915 x 2134mm&gt;\n152882 modified Wall Walls &lt;152882 Interior - 138mm Partition (1-hr)&gt;\n153000 modified Wall Walls &lt;153000 Interior - 138mm Partition (1-hr)&gt;\n153162 modified Wall Walls &lt;153162 Interior - 138mm Partition (1-hr)&gt;\n153242 modified Wall Walls &lt;153242 Interior - 138mm Partition (1-hr)&gt;\n156935 modified Opening Shaft Openings &lt;156935 Opening Cut&gt;\n168671 modified Ceiling Ceilings &lt;168671 600 x 600mm Grid&gt;\n168679 modified Ceiling Ceilings &lt;168679 600 x 600mm Grid&gt;\n168687 modified Ceiling Ceilings &lt;168687 600 x 600mm Grid&gt;\n168695 modified Ceiling Ceilings &lt;168695 600 x 600mm Grid&gt;\n168894 modified Ceiling Ceilings &lt;168894 600 x 600mm Grid&gt;\n168902 modified Ceiling Ceilings &lt;168902 600 x 600mm Grid&gt;\n177324 modified Room Rooms &lt;177324 Electrical 112&gt;\n177325 modified Room Rooms &lt;177325 Lounge 111&gt;\n177326 modified Room Rooms &lt;177326 Men 110&gt;\n177328 modified Room Rooms &lt;177328 Women 109&gt;\n177329 modified Room Rooms &lt;177329 Corridor 107&gt;\n</pre>\n\nIt is displayed in a task dialogue like this:\n\n<center>\n<img src=\"img/track_wall2_moved_report.png\" alt=\"Tracked element report\" width=\"504\">\n</center>\n\nFor real-world usage, you would obviously implement a more intelligent reporting system, for example a two-tiered one with a top-level summary displayed to the user and a detailed report stored in a log file or somewhere.\n\nOnce again: do not forget that the external command TrackChanges acts as a toggle: every second call creates and stores a snapshot, every second one creates a new snapshot, compares it with the stored one and reports the differences."
  },
  {
    "original_filename": "1397_track_changes",
    "header_text": "<a name=\"7\"></a>Demo Recording",
    "local_header_href": "#a-name7ademo-recording",
    "chunk_text": "#### <a name=\"7\"></a>Demo Recording\n\nHere is a [two-and-a-half minute video recording](https://vimeo.com/152442481) showing it in action:\n\n<center>\n<iframe src=\"https://player.vimeo.com/video/152442481?title=0&byline=0\" width=\"400\" height=\"250\" frameborder=\"0\" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>\n</center>"
  },
  {
    "original_filename": "1397_track_changes",
    "header_text": "<a name=\"8\"></a>Download",
    "local_header_href": "#a-name8adownload",
    "chunk_text": "#### <a name=\"8\"></a>Download\n\nThis project lives in the [TrackChanges GitHub repository](https://github.com/jeremytammik/TrackChanges) and\nthe version discussed above is [release 2016.0.0.1](https://github.com/jeremytammik/TrackChanges/releases/tag/2016.0.0.1)."
  }
]