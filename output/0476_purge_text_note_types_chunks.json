[
  {
    "original_filename": "0476_purge_text_note_types",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<head>\n<link href=\"bc.css\" rel=\"stylesheet\" type=\"text/css\"/>\n</head>"
  },
  {
    "original_filename": "0476_purge_text_note_types",
    "header_text": "Purge Unused Text Note Types",
    "local_header_href": "#purge-unused-text-note-types",
    "chunk_text": "<h3>Purge Unused Text Note Types</h3><p>Chuck Dodson of\n\n<a href=\"http://www.scottgoble.com\">\nScott&amp;Goble Architects</a> and\n\nmy colleague Katsuaki Takamizawa came up with a question on how to purge unused elements from the Revit database, and Harry Mattison from the Revit API development team provides a partial answer:\n\n<p><strong>Question:</strong> I would like to purge unused elements from the Revit project, such as line types, materials, fonts, etc., especially those imported from AutoCAD.\nThe AutoCAD API provides an IsUsed property for layers and other elements.\nI have not found any Revit API method for purging.\n\n<p>Is there any way to determine if an element is not being used by any other elements and can be deleted safely?\n\n<p><strong>Answer:</strong> The Revit API does not provide a generic member such as IsUsed.\nEach type of element will have to be handled individually.\n\n<p>Here is one way to do it for text note types:\n\n<pre class=\"code\">\n  <span class=\"teal\">FilteredElementCollector</span> collector\n    = <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( doc );\n \n  <span class=\"teal\">ICollection</span>&lt;<span class=\"teal\">ElementId</span>&gt; textNoteTypes\n    = collector.OfClass( <span class=\"blue\">typeof</span>( <span class=\"teal\">TextNoteType</span> ) )\n      .ToElementIds()\n      .ToList();\n \n  <span class=\"teal\">FilteredElementCollector</span> collectorUsed\n    = <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( doc );\n \n  <span class=\"teal\">ICollection</span>&lt;<span class=\"teal\">ElementId</span>&gt; textNotes\n    = collectorUsed.OfClass( <span class=\"blue\">typeof</span>( <span class=\"teal\">TextNote</span> ) )\n      .ToElementIds();\n \n  <span class=\"blue\">foreach</span>( <span class=\"teal\">ElementId</span> textNoteid <span class=\"blue\">in</span> textNotes )\n  {\n    <span class=\"teal\">TextNote</span> textNote = doc.get_Element(\n      textNoteid ) <span class=\"blue\">as</span> <span class=\"teal\">TextNote</span>;\n \n    <span class=\"blue\">bool</span> removed = textNoteTypes.Remove(\n      textNote.TextNoteType.Id );\n  }\n \n  doc.Delete( textNoteTypes );\n</pre>\n<p>Here is another approach:\n\n<pre class=\"code\">\n  <span class=\"teal\">ICollection</span>&lt;<span class=\"teal\">ElementId</span>&gt; textNotesTypeIds\n    = <span class=\"blue\">new</span> Collection&lt;<span class=\"teal\">ElementId</span>&gt;();\n \n  <span class=\"teal\">FilteredElementCollector</span> textNoteCollector\n    = <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( doc );\n \n  <span class=\"teal\">ICollection</span>&lt;<span class=\"teal\">ElementId</span>&gt; textNotes\n    = textNoteCollector.OfClass( <span class=\"blue\">typeof</span>( <span class=\"teal\">TextNote</span> ) )\n      .ToElementIds();\n \n  <span class=\"blue\">foreach</span>( <span class=\"teal\">ElementId</span> textNoteid <span class=\"blue\">in</span> textNotes )\n  {\n    <span class=\"teal\">TextNote</span> tn = doc.get_Element(\n      textNoteid ) <span class=\"blue\">as</span> <span class=\"teal\">TextNote</span>;\n \n    textNotesTypeIds.Add( tn.TextNoteType.Id );\n  }\n \n  <span class=\"teal\">FilteredElementCollector</span> unusedTypeCollector\n    = <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( doc );\n \n  <span class=\"teal\">ICollection</span>&lt;<span class=\"teal\">ElementId</span>&gt; unusedTypes\n    = unusedTypeCollector\n      .OfClass( <span class=\"blue\">typeof</span>( <span class=\"teal\">TextNoteType</span> ) )\n      .Excluding( textNotesTypeIds )\n      .ToElementIds();\n \n  doc.Delete( unusedTypes );\n</pre>\n<p>Many thanks to Katsu-san and Harry for this hint!\n\n<p>Note the difference between the two:\n\n<ul>\n<li>In the first approach, a collection A of all text note types is created, then all text notes are collected and iterated, removing each one's text note type from A.\n<li>In the second approach, a collection B is created of the text note types in use. Then the filtered element collector Excluding method is used to retrieve all text note types except those contained in B.\n</li></li></ul>\n<p>In both approaches, some simplification and optimisation of the text note iteration to determine the types in use can be achieved as follows, iterating over the collector directly instead of asking it for its element ids and then opening each text note element from its id:\n\n<pre class=\"code\">\n  <span class=\"teal\">FilteredElementCollector</span> textNotes\n    = <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( doc )\n      .OfClass( <span class=\"blue\">typeof</span>( <span class=\"teal\">TextNote</span> ) );\n \n  <span class=\"blue\">foreach</span>( <span class=\"teal\">TextNote</span> textNote <span class=\"blue\">in</span> textNotes )\n  {\n    <span class=\"blue\">bool</span> removed = textNoteTypes.Remove(\n      textNote.TextNoteType.Id );\n  }\n</pre>\n<p>I was curious whether the two approaches show any discernible performance difference, so I took this code and implemented a new Building Coder sample command CmdPurgeTextNoteTypes to benchmark the two.\n\n<p>Since the deletion operation is identical in both cases, I implemented two methods which just collect the unused text note types, GetUnusedTextNoteTypes and GetUnusedTextNoteTypesExcluding, and then common code can be used to delete them.\n\n<p>GetUnusedTextNoteTypes returns all unused text note types by collecting all existing types in the document and removing the ones in use afterwards:\n\n<pre class=\"code\">\n<span class=\"teal\">ICollection</span>&lt;<span class=\"teal\">ElementId</span>&gt; GetUnusedTextNoteTypes(\n  <span class=\"teal\">Document</span> doc )\n{\n  <span class=\"teal\">FilteredElementCollector</span> collector\n    = <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( doc );\n \n  <span class=\"teal\">ICollection</span>&lt;<span class=\"teal\">ElementId</span>&gt; textNoteTypes\n    = collector.OfClass( <span class=\"blue\">typeof</span>( <span class=\"teal\">TextNoteType</span> ) )\n      .ToElementIds()\n      .ToList();\n \n  <span class=\"teal\">FilteredElementCollector</span> textNotes\n    = <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( doc )\n      .OfClass( <span class=\"blue\">typeof</span>( <span class=\"teal\">TextNote</span> ) );\n \n  <span class=\"blue\">foreach</span>( <span class=\"teal\">TextNote</span> textNote <span class=\"blue\">in</span> textNotes )\n  {\n    <span class=\"blue\">bool</span> removed = textNoteTypes.Remove(\n      textNote.TextNoteType.Id );\n  }\n  <span class=\"blue\">return</span> textNoteTypes;\n}\n</pre>\n<p>GetUnusedTextNoteTypesExcluding return all unused text note types by first determining all text note types in use and then collecting all the others using an exclusion filter:\n\n<pre class=\"code\">\n<span class=\"teal\">ICollection</span>&lt;<span class=\"teal\">ElementId</span>&gt;\n  GetUnusedTextNoteTypesExcluding(\n    <span class=\"teal\">Document</span> doc )\n{\n  <span class=\"teal\">ICollection</span>&lt;<span class=\"teal\">ElementId</span>&gt; usedTextNotesTypeIds\n    = <span class=\"blue\">new</span> <span class=\"teal\">Collection</span>&lt;<span class=\"teal\">ElementId</span>&gt;();\n \n  <span class=\"teal\">FilteredElementCollector</span> textNotes\n    = <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( doc )\n      .OfClass( <span class=\"blue\">typeof</span>( <span class=\"teal\">TextNote</span> ) );\n \n  <span class=\"blue\">foreach</span>( <span class=\"teal\">TextNote</span> textNote <span class=\"blue\">in</span> textNotes )\n  {\n    usedTextNotesTypeIds.Add(\n      textNote.TextNoteType.Id );\n  }\n \n  <span class=\"teal\">FilteredElementCollector</span> unusedTypeCollector\n    = <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( doc )\n      .OfClass( <span class=\"blue\">typeof</span>( <span class=\"teal\">TextNoteType</span> ) );\n \n  <span class=\"blue\">if</span>( 0 &lt; usedTextNotesTypeIds.Count )\n  {\n    unusedTypeCollector.Excluding(\n      usedTextNotesTypeIds );\n  }\n \n  <span class=\"teal\">ICollection</span>&lt;<span class=\"teal\">ElementId</span>&gt; unusedTypes\n    = unusedTypeCollector.ToElementIds();\n \n  <span class=\"blue\">return</span> unusedTypes;\n}\n</pre>\n<p>Note that we have to check whether usedTextNotesTypeIds is empty before calling the Excluding method.\nIf Excluding is called with an empty collection, it throws an exception.\n\n<p>Here is the code of the mainline benchmarking these two methods and deleting the unused text note types, using manual regeneration option and transaction mode:\n\n<pre class=\"code\">\n  <span class=\"teal\">UIApplication</span> app = commandData.Application;\n  <span class=\"teal\">Document</span> doc = app.ActiveUIDocument.Document;\n \n  <span class=\"teal\">ICollection</span>&lt;<span class=\"teal\">ElementId</span>&gt; unusedTextNoteTypes\n    = GetUnusedTextNoteTypes( doc );\n \n  <span class=\"blue\">int</span> n = unusedTextNoteTypes.Count;\n \n  <span class=\"blue\">int</span> nLoop = 100;\n \n  <span class=\"teal\">Stopwatch</span> sw = <span class=\"blue\">new</span> <span class=\"teal\">Stopwatch</span>();\n \n  sw.Reset();\n  sw.Start();\n \n  <span class=\"blue\">for</span>( <span class=\"blue\">int</span> i = 0; i &lt; nLoop; ++ i )\n  {\n    unusedTextNoteTypes\n      = GetUnusedTextNoteTypes( doc );\n \n    <span class=\"teal\">Debug</span>.Assert( unusedTextNoteTypes.Count == n,\n      <span class=\"maroon\">\"expected same number of unused texct note types\"</span> );\n  }\n \n  sw.Stop();\n  <span class=\"blue\">double</span> ms = (<span class=\"blue\">double</span>) sw.ElapsedMilliseconds\n    / (<span class=\"blue\">double</span>) nLoop;\n \n  sw.Reset();\n  sw.Start();\n \n  <span class=\"blue\">for</span>( <span class=\"blue\">int</span> i = 0; i &lt; nLoop; ++ i )\n  {\n    unusedTextNoteTypes\n      = GetUnusedTextNoteTypesExcluding( doc );\n \n    <span class=\"teal\">Debug</span>.Assert( unusedTextNoteTypes.Count == n,\n      <span class=\"maroon\">\"expected same number of unused texct note types\"</span> );\n  }\n \n  sw.Stop();\n  <span class=\"blue\">double</span> msExcluding\n    = (<span class=\"blue\">double</span>) sw.ElapsedMilliseconds\n      / (<span class=\"blue\">double</span>) nLoop;\n \n  <span class=\"teal\">Transaction</span> t = <span class=\"blue\">new</span> <span class=\"teal\">Transaction</span>( doc,\n    <span class=\"maroon\">\"Purging unused text note types\"</span> );\n \n  t.Start();\n \n  sw.Reset();\n  sw.Start();\n \n  doc.Delete( unusedTextNoteTypes );\n \n  sw.Stop();\n  <span class=\"blue\">double</span> msDeleting\n    = (<span class=\"blue\">double</span>) sw.ElapsedMilliseconds\n      / (<span class=\"blue\">double</span>) nLoop;\n \n  t.Commit();\n \n  <span class=\"teal\">Util</span>.InfoMsg( <span class=\"blue\">string</span>.Format(\n    <span class=\"maroon\">\"{0} text note type{1} purged. \"</span>\n    + <span class=\"maroon\">\"{2} ms to collect, {3} ms to collect \"</span>\n    + <span class=\"maroon\">\"excluding, {4} ms to delete.\"</span>,\n    n, <span class=\"teal\">Util</span>.PluralSuffix( n ),\n    ms, msExcluding, msDeleting ) );\n \n  <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Succeeded;\n</pre>\n<p>The assertions ensure that the number of unused text note types is always the same.\nI was worried whether the assertions would affect the benchmarking results, so I ran two sets of tests, one with the assertions commented out, but that makes no difference.\n\n<p>Here are some results in various sample models, with and without assertions, listing the\n\n<ul>\n<li>M – Sample model:\n<ul>\n<li>A – a small model\n<li>B – rac_basic_sample_project.rvt\n<li>C – rac_advanced_sample_project.rvt\n<li>D – a slightly larger model\n</li></li></li></li></ul>\n<li>N – number of unused text note types purged\n<li>C – milliseconds required to collect\n<li>E – milliseconds required to collect excluding\n<li>D – milliseconds required to delete\n</li></li></li></li></li></ul>\n<p>The first row of each pair shows the time with assertions, the second without:</p>\n<center>\n<table>\n<tr><th align=\"right\">M</th><th align=\"right\"> N</th><th align=\"right\">C</th><th align=\"right\">E</th><th align=\"right\">D</th></tr>\n<tr><td align=\"right\">A</td><td align=\"right\">7</td><td align=\"right\">4.97</td><td align=\"right\">4.35</td><td align=\"right\">0.07</td></tr>\n<tr><td align=\"right\">A</td><td align=\"right\">7</td><td align=\"right\">4.43</td><td align=\"right\">4.39</td><td align=\"right\">0.07</td></tr>\n<tr><td align=\"right\">B</td><td align=\"right\">1</td><td align=\"right\">5.8</td><td align=\"right\">5.25</td><td align=\"right\">0.12</td></tr>\n<tr><td align=\"right\">B</td><td align=\"right\">1</td><td align=\"right\">6.4</td><td align=\"right\">5.38</td><td align=\"right\">0.29</td></tr>\n<tr><td align=\"right\">C</td><td align=\"right\">3</td><td align=\"right\">23.45</td><td align=\"right\">29.7</td><td align=\"right\">0.03</td></tr>\n<tr><td align=\"right\">C</td><td align=\"right\">3</td><td align=\"right\">24.29</td><td align=\"right\">28.41</td><td align=\"right\">0.03</td></tr>\n<tr><td align=\"right\">D</td><td align=\"right\">0</td><td align=\"right\">89.91</td><td align=\"right\">107.73</td><td align=\"right\">0.00</td></tr>\n<tr><td align=\"right\">D</td><td align=\"right\">0</td><td align=\"right\"> 89.18</td><td align=\"right\"> 108.94</td><td align=\"right\"> 0.00</td></tr>\n</table>\n</center>\n<p>As you can see, the performance of the two methods is similar, with an advantage for the Excluding method in small models and a disadvantage in larger ones.\nIf you seriously want to optimise a similar algorithm, you will have to decide based on the characteristics of the models you typically work with.\nI am pretty certain that the total number of text notes and used versus unused text note types will play a significant role.</p>\n<p>Here is\n\n<!-- C:\\a\\doc\\revit\\blog\\zip\\bc_11_79.zip -->\n<a href=\"zip/bc_11_79.zip\">\nversion 2011.0.79.0</a>\n\nof The Building Coder samples including the complete source code and Visual Studio solution with the new command.\n</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p>"
  }
]