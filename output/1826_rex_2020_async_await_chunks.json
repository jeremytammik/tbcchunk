[
  {
    "original_filename": "1826_rex_2020_async_await",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n<link rel=\"stylesheet\" type=\"text/css\" href=\"bc.css\">\n<script src=\"https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js\" type=\"text/javascript\"></script>\n<script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n</head>\n\n<!---\n\n- rex sdk\n  /a/doc/revit/tbc/git/a/zip/\n  A REX problem appeared in Revit 2019 and was resolved by sharing a custom version of the REX SDK.\n  Now the same problem occurs again with Revit 2020:\n  https://forums.autodesk.com/t5/revit-api-forum/issue-with-sdk-and-visual-studio/td-p/8052988\n  Resolution for Revit 2019:\n  https://thebuildingcoder.typepad.com/blog/2018/06/rex-sdk-visual-studio-templates-for-revit-structure-2019.html#2\n  REX SDK2020.ZIP\n  Structural Analysis SDK2020.zip\n\n- https://thebuildingcoder.typepad.com/blog/2020/02/external-communication-and-async-await-event-wrapper.html#comment-4813648335\n\n\ntwitter:\n\nTwo important utilities, one eagerly awaited, the other a nice surprise: the updated REX and Structural analysis SDKs and Revit.Async, a powerful async and await wrapper for the Revit API external event in the #RevitAPI #DynamoBim @AutodeskForge @AutodeskRevit #bim #ForgeDevCon http://bit.ly/rex2020asyncawait\n\nHere are two important utilities, one eagerly awaited, the other a nice surprise: the updated REX and Structural analysis SDKs and a powerful <code>async</code> and <code>await</code> wrapper for the Revit API external event\n&ndash; REX SDK and Structural Analysis SDK 2020\n&ndash; Revit.Async\n&ndash; Background\n&ndash; Standard approach\n&ndash; Revit.Async approach...\n\nlinkedin:\n\nTwo important utilities, one eagerly awaited, the other a nice surprise: the updated REX and Structural analysis SDKs and Revit.Async, a powerful async and await wrapper for the Revit API external event in the #RevitAPI \n\nhttp://bit.ly/rex2020asyncawait\n\n- REX SDK and Structural Analysis SDK 2020\n- Revit.Async\n- Background\n- Standard approach\n- Revit.Async approach...\n\n#bim #DynamoBim #ForgeDevCon #Revit #API #IFC #SDK #AI #VisualStudio #Autodesk #AEC #adsk\n\nthe [Revit API discussion forum](http://forums.autodesk.com/t5/revit-api-forum/bd-p/160) thread\n\n<center>\n<img src=\"img/\" alt=\"\" title=\"\" width=\"100\"/>\n<p style=\"font-size: 80%; font-style:italic\"></p>\n</center>\n\n-->"
  },
  {
    "original_filename": "1826_rex_2020_async_await",
    "header_text": "Another Async Await, REX + Structural Analysis SDK",
    "local_header_href": "#another-async-await-rex-structural-analysis-sdk",
    "chunk_text": "### Another Async Await, REX + Structural Analysis SDK\n\nHere are two important utilities, one eagerly awaited, the other a nice surprise: the updated REX and Structural analysis SDKs and a powerful `async` and `await` wrapper for the Revit API external event:\n\n- [REX SDK and Structural Analysis SDK 2020](#2)\n- [Revit.Async](#3)\n    - [Revit.Async background](#3.2)\n    - [Example &ndash; standard approach](#3.3)\n    - [Example &ndash; Revit.Async approach](#3.4)"
  },
  {
    "original_filename": "1826_rex_2020_async_await",
    "header_text": "<a name=\"2\"></a> REX SDK and Structural Analysis SDK 2020",
    "local_header_href": "#a-name2a-rex-sdk-and-structural-analysis-sdk-2020",
    "chunk_text": "#### <a name=\"2\"></a> REX SDK and Structural Analysis SDK 2020\n\nLast year,\nthe [Revit API discussion forum](http://forums.autodesk.com/t5/revit-api-forum/bd-p/160) thread\non an [issue with SDK and Visual Studio](https://forums.autodesk.com/t5/revit-api-forum/issue-with-sdk-and-visual-studio/td-p/8052988)\npointed out that the Visual Studio templates provided with the REX SDK to make use of the Revit Structure Extensions had not yet been updated for Revit 2019.\n\nThat was fixed by the development team and\nan [updated set of REX SDK Visual Studio templates for Revit Structure 2019](https://thebuildingcoder.typepad.com/blog/2018/06/rex-sdk-visual-studio-templates-for-revit-structure-2019.html#2) was\nshared in the forum and here on the blog.\n\nThe same situation arose again with Revit 2020, and here are the updated templates, samples and documentation for Revit 2020:\n\n- [REX_SDK2020.ZIP](zip/REX_SDK2020.ZIP)\n- [Structural_Analysis_SDK2020.zip](Structural_Analysis_SDK2020.zip)\n\n**Response:** The REX SDK installed and is now working!\n\nI read all provided PDF documentation and did the Hello World exercise.\nI have some basic questions on how to get started with my specific projects and will create a separate post for that when I'm ready. \n\nI haven't looked at the Structural Analysis SDK as we are going to link Revit with our own custom proprietary software.\nAfter reading about element mapping between databases and the content generator, I'm relieved to know that the REX SDK will likely reduce a lot of development time since those functionalities already exist. \n\nThank you for providing the updates! I'm glad to have begun my journey down this path."
  },
  {
    "original_filename": "1826_rex_2020_async_await",
    "header_text": "<a name=\"3\"></a> Revit.Async",
    "local_header_href": "#a-name3a-revitasync",
    "chunk_text": "#### <a name=\"3\"></a> Revit.Async\n\nLast month, we briefly looked at a\nsimple [`async` and `await` external event wrapper](https://thebuildingcoder.typepad.com/blog/2020/02/external-communication-and-async-await-event-wrapper.html#2).\n\nKennan Chen kindly reacted to that post in a [comment](https://thebuildingcoder.typepad.com/blog/2020/02/external-communication-and-async-await-event-wrapper.html#comment-4813648335),\nsaying:\n\n> What a coincidence.\nI also implemented my own async/await external event wrapper these days.\nAfter some comparison with the one WhiteSharq provided, I found my implementation contains more useful functionality including wrapping async delegates and exposing core ability to define enhanced external events.\nIt internally adopts an `ExternalEvent` creator, so the developers won't accidentally experience the context problems.\nHope it can be helpful to the community.\n\n> Please look at\nthe [Revit.Async GitHub repository](https://github.com/KennanChan/Revit.Async) showing\nhow to use the task-based asynchronous pattern (TAP) to run Revit API code from any execution context.\nAlso available via nuget.\n\nKennan's implementation does indeed look very complete and impressive with extensive documentation in both English\nand [Chinese](https://github.com/KennanChan/Revit.Async/blob/master/%E8%AF%B4%E6%98%8E.md):"
  },
  {
    "original_filename": "1826_rex_2020_async_await",
    "header_text": "<a name=\"3.2\"></a> Revit.Async Background",
    "local_header_href": "#a-name32a-revitasync-background",
    "chunk_text": "#### <a name=\"3.2\"></a> Revit.Async Background\n\nIf you have ever encountered a Revit API exception saying, \"Cannot execute Revit API outside of Revit API context\",\ntypically when you want to execute Revit API code from a modeless window, you may need this library to save your life.\n\nA common solution for this exception is to wrap the Revit API code using `IExternalEventHandler` and register the handler instance to Revit ahead of time to get a trigger (`ExternalEvent`).\nTo execute the handler, just raise the trigger from anywhere to queue the handler to the Revit command loop.\nBut there comes another problem.\nAfter raising the trigger, within the same context, you have no idea when the handler will be executed and it's not easy to get some result generated from that handler.\nIf you do want to make this happen, you have to manually yield the control back to the calling context.\n\nThis solution looks quite similar to the mechanism of \"Promise\" if you are familiar with JavaScript ES6.\nActually, we can achieve all the above logic by making use of task-based asynchronous pattern (TAP) which is generally known as `Task<T>` in .NET.\nBy adopting Revit.Async, it is possible to run Revit API code from any context, because internally Revit.Async wraps your code automatically with `IExternalEventHandler` and yields the return value to the calling context to make your invocation more natural.\n\nIf you are unfamiliar with the task-based asynchronous pattern (TAP), here is some useful material on it provided by Microsoft:\n\n- [Task-based asynchronous pattern (TAP)\n](https://docs.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap)\n- [Task asynchronous programming model](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/async/task-asynchronous-programming-model)\n\nHere is a [diagram comparing the Revit API external event mechanism with Revit.Async](https://drive.google.com/file/d/1sb6Yrlt6zjkE9XBh4UB5sWV_i8nTpkmG/view?usp=sharing) and\nscreenshots of the two main parts:\n\n<center>\n<img src=\"img/revit_async_external_event.png\" alt=\"Revit API external event\" title=\"Revit API external event\" width=\"800\"/>\n<p style=\"font-size: 80%; font-style:italic\">Revit API external event</p>\n\n<img src=\"img/revit_async_external_event.png\" alt=\"Revit.Async\" title=\"Revit.Async\" width=\"800\"/>\n<p style=\"font-size: 80%; font-style:italic\">Revit.Async</p>\n</center>"
  },
  {
    "original_filename": "1826_rex_2020_async_await",
    "header_text": "<a name=\"3.3\"></a> Example &ndash; Standard Approach",
    "local_header_href": "#a-name33a-example-ndash-standard-approach",
    "chunk_text": "#### <a name=\"3.3\"></a> Example &ndash; Standard Approach\n\n<pre class=\"code\">\n[Transaction(TransactionMode.Manual)]\npublic class MyRevitCommand : IExternalCommand\n{\n  public static ExternalEvent SomeEvent { get; set; }\n  public Result Execute(ExternalCommandData commandData,\n    ref string message, ElementSet elements)\n  {\n    //Register MyExternalEventHandler ahead of time\n    SomeEvent = ExternalEvent.Create(new MyExternalEventHandler());\n    var window = new MyWindow();\n    //Show modeless window\n    window.Show();\n    return Result.Succeeded;\n  }\n}\n\npublic class MyExternalEventHandler : IExternalEventHandler\n{\n  public void Execute(UIApplication app)\n  {\n    //Running some Revit API code here to handle the button click\n    //It's complicated to accept argument from the calling context\n    //and return value to the calling context\n    var families = new FilteredElementCollector(\n      app.ActiveUIDocument.Document)\n        .OfType(typeof(Family))\n        .ToList();\n    //ignore some code\n  }\n}\n\npublic class MyWindow : Window\n{\n  public MyWindow()\n  {\n    InitializeComponents();\n  }\n\n  private void InitializeComponents()\n  {\n    Width = 200;\n    Height = 100;\n    WindowStartupLocation = WindowStartupLocation.CenterScreen;\n    var button = new Button\n    {\n      Content = \"Button\",\n      Command = new ButtonCommand(),\n      VerticalAlignment = VerticalAlignment.Center,\n      HorizontalAlignment = HorizontalAlignment.Center\n    };\n    Content = button;\n  }\n}\n\npublic class ButtonCommand : ICommand\n{  \n  public bool CanExecute(object parameter)\n  {\n    return true;\n  }\n\n  public event EventHandler CanExecuteChanged;\n\n  public void Execute(object parameter)\n  {\n    //Running Revit API code directly here will result in a\n    //\"Running Revit API outside of Revit API context\" exception\n    //Raise a predefined ExternalEvent instead\n    MyRevitCommand.SomeEvent.Raise();\n  }\n}\n</pre>"
  },
  {
    "original_filename": "1826_rex_2020_async_await",
    "header_text": "<a name=\"3.4\"></a> Example &ndash; Revit.Async Approach",
    "local_header_href": "#a-name34a-example-ndash-revitasync-approach",
    "chunk_text": "#### <a name=\"3.4\"></a> Example &ndash; Revit.Async Approach\n\n<pre class=\"code\">\n[Transaction(TransactionMode.Manual)]\npublic class MyRevitCommand : IExternalCommand\n{\n  public Result Execute(ExternalCommandData commandData,\n    ref string message, ElementSet elements)\n  {\n    //Always initialize RevitTask ahead of time within Revit API context\n    RevitTask.Initialze();\n    var window = new MyWindow();\n    //Show modeless window\n    window.Show();\n    return Result.Succeeded;\n  }\n}\n\npublic class MyWindow : Window\n{\n  public MyWindow()\n  {\n    InitializeComponents();\n  }\n\n  private void InitializeComponents()\n  {\n    Width = 200;\n    Height = 100;\n    WindowStartupLocation = WindowStartupLocation.CenterScreen;\n    var button = new Button\n    {\n      Content = \"Button\",\n      Command = new ButtonCommand(),\n      CommandParameter = true,\n      VerticalAlignment = VerticalAlignment.Center,\n      HorizontalAlignment = HorizontalAlignment.Center\n    };\n    Content = button;\n  }\n}\n\npublic class ButtonCommand : ICommand\n{  \n  public bool CanExecute(object parameter)\n  {\n    return true;\n  }\n\n  public event EventHandler CanExecuteChanged;\n\n  public async void Execute(object parameter)\n  {\n    //.NET 4.5 supported keyword, use ContinueWith if using .NET 4.0\n    var families = await RevitTask.RunAsync(\n      app => \n      {\n        //Run Revit API code here\n        \n        //Taking advantage of the closure created by the\n        //lambda expression, we can make use of the argument\n        //passed into the Execute method.\n        //Let's assume it's a boolean indicating whether to\n        // filter families that is editable\n        if(parameter is bool editable)\n        {\n          return new FilteredElementCollector(\n            app.ActiveUIDocument.Document)\n              .OfType(typeof(Family))\n              .Cast<Family>()\n              .Where(family => editable ? family.IsEditable : true)\n              .ToList();\n        }\n        \n        return null;\n      });\n    \n    MessageBox.Show($\"Family count: {families?.Count ?? 0}\");\n  }\n}\n</pre>"
  },
  {
    "original_filename": "1826_rex_2020_async_await",
    "header_text": "Define your own handler",
    "local_header_href": "#define-your-own-handler",
    "chunk_text": "## Define your own handler\n\nFed up with the weak `IExternalEventHandler` interface?\nUse the `IGenericExternalEventHandler<TParameter,TResult>` interface instead.\nIt provides you with the ability to pass argument to a handler and receive result on complete.\n\nIt's always recommended to derive from the predefined abstract classes; they are designed to handle the argument passing and result returning part:\n\n- `AsyncGenericExternalEventHandler<TParameter, TResult>` &rarr; use to execute asynchronous logic\n- `SyncGenericExternalEventHandler<TParameter, TResult>` &rarr; use to execute synchronize logic\n\n<pre class=\"code\">\n[Transaction(TransactionMode.Manual)]\npublic class MyRevitCommand : IExternalCommand\n{\n  public Result Execute(ExternalCommandData commandData,\n    ref string message, ElementSet elements)\n  {\n    RevitTask.Initialize();\n    //Register SaveFamilyToDesktopExternalEventHandler ahead of time\n    RevitTask.RegisterGlobal(\n      new SaveFamilyToDesktopExternalEventHandler());\n    var window = new MyWindow();\n    //Show modeless window\n    window.Show();\n    return Result.Succeeded;\n  }\n}\n\npublic class MyWindow : Window\n{\n  public MyWindow()\n  {\n    InitializeComponents();\n  }\n\n  private void InitializeComponents()\n  {\n    Width = 200;\n    Height = 100;\n    WindowStartupLocation = WindowStartupLocation.CenterScreen;\n    var button = new Button\n    {\n      Content = \"Save Random Family\",\n      Command = new ButtonCommand(),\n      CommandParameter = true,\n      VerticalAlignment = VerticalAlignment.Center,\n      HorizontalAlignment = HorizontalAlignment.Center\n    };\n    Content = button;\n  }\n}\n\npublic class ButtonCommand : ICommand\n{  \n  public bool CanExecute(object parameter)\n  {\n    return true;\n  }\n\n  public event EventHandler CanExecuteChanged;\n\n  public async void Execute(object parameter)\n  {\n    var savePath = await RevitTask.RunAsync(\n      async app =>\n      {\n        try\n        {\n          var document = app.ActiveUIDocument.Document;\n          var randomFamily = await RevitTask.RunAsync(\n            () =>\n            {\n              var families = new FilteredElementCollector(document)\n                .OfClass(typeof(Family))\n                .Cast<Family>()\n                .Where(family => family.IsEditable)\n                .ToArray();\n              var random = new Random(Environment.TickCount);\n              return families[random.Next(0, families.Length)];\n            });\n\n          //Raise your own handler\n          return await RevitTask.RaiseGlobal<\n            SaveFamilyToDesktopExternalEventHandler,\n            Family, string>(randomFamily);\n        }\n        catch (Exception)\n        {\n          return null;\n        }\n      });\n    var saveResult = !string.IsNullOrWhiteSpace(savePath);\n    \n    MessageBox.Show(\n      $\"Family {(saveResult ? \"\" : \"not \")}saved:\\n{savePath}\");\n      \n    if (saveResult)\n    {\n      Process.Start(Path.GetDirectoryName(savePath));\n    }\n  }\n}\n\npublic class SaveFamilyToDesktopExternalEventHandler : \t\t\t\n\tSyncGenericExternalEventHandler<Family, string>\n{\n  public override string GetName()\n  {\n    return \"SaveFamilyToDesktopExternalEventHandler\";\n  }\n\n  protected override string Handle(UIApplication app, Family parameter)\n  {\n    //write sync logic here\n    var document = parameter.Document;\n    var familyDocument = document.EditFamily(parameter);\n    var desktop = Environment.GetFolderPath(Environment.SpecialFolder.DesktopDirectory);\n    var path = Path.Combine(desktop, $\"{parameter.Name}.rfa\");\n    familyDocument.SaveAs(path, new SaveAsOptions {OverwriteExistingFile = true});\n    return path;\n  }\n}\n</pre>\n\nImpressive, isn't it?\n\nVery many thanks to Kennan for this great implementation and explanation!\n\nMore details and full source in\nKennan's [Revit.Async GitHub repository](https://github.com/KennanChan/Revit.Async)."
  }
]