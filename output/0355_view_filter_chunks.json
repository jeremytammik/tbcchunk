[
  {
    "original_filename": "0355_view_filter",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<head>\n<link href=\"bc.css\" rel=\"stylesheet\" type=\"text/css\"/>\n</head>"
  },
  {
    "original_filename": "0355_view_filter",
    "header_text": "Filter for Views and the IsTemplate Predicate",
    "local_header_href": "#filter-for-views-and-the-istemplate-predicate",
    "chunk_text": "<h3>Filter for Views and the IsTemplate Predicate</h3><p>Several people encountered issues when retrieving views in Revit 2011.\nThe reason is that the most direct approach to filtering for view elements using the new \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/04/collector-benchmark.html\">\nelement filtering</a> also \n\nreturns view templates, which were not accessible in the Revit 2010 API.\nHere is the initial issue:\n\n<p><strong>Question:</strong> I tried to extract all PlanView elements from the model and found something weird: besides the expected and obvious plan views such as Level 1, Level 2 and Site, some other unexpected ones also showed up in the collector results, such as Architectural Plan, Structural Framing Plan, Architectural Reflected Ceiling Plan, and Site Plan. I verified that this behaviour is not model specific, and that even an empty project returns all these unexpected plan views.\n\n<p>Why is this happening? What can I do to recognise and eliminate these unexpected and invisible plan views?\n\n<p><strong>Answer:</strong> The unexpected plan view elements that you are seeing are the View Templates.  \nThey used to be excluded from the API iteration, for a reason that is lost to antiquity.  \nThe new iteration didnt know about this.\nIt also turns out that it does not really make sense to exclude them.\n\n<p>We have added a new predicate to the API, the View.IsTemplate property, which allows you to filter them out.\n\n<p>Here is a related question with some sample code:\n\n<p><strong>Question:</strong> I am having difficulties with the new API in relation to retrieving unfiltered elements in a view. \nFrom a preselected list of elements I am trying to find out in which views these elements occur. \n\n<p>In 2010 I used to get the elements in a view by \n\n<pre class=\"code\">\n<span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt; ViewElements\n  = view.Elements.OfType&lt;<span class=\"teal\">Element</span>&gt;().ToList(); \n</pre>\n<p>It could not be simpler than this :-) \n\n<p>However, the Elements collection is no longer available, and the only way to access elements is by creating a FilteredElementCollector. \n\n<p>I apply the WhereElementIsNotElementType filter and then use the following code to get a list of views in which a list of elements are applicable:\n\n<pre class=\"code\">\n<span class=\"blue\">public</span> <span class=\"blue\">static</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">View</span>&gt; GetElementViews( \n  <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt; a, \n  <span class=\"teal\">List</span>&lt;<span class=\"teal\">View</span>&gt; views )\n{\n  <span class=\"teal\">List</span>&lt;<span class=\"teal\">View</span>&gt; returnViews = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">View</span>&gt;();\n  <span class=\"blue\">foreach</span>( <span class=\"teal\">View</span> view <span class=\"blue\">in</span> views )\n  {\n    <span class=\"teal\">FilteredElementCollector</span> coll \n      = <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( \n        view.Document, view.Id );\n \n    coll = coll.WhereElementIsNotElementType();\n \n    <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt; elementList = coll.ToList();\n \n    <span class=\"blue\">foreach</span>( <span class=\"teal\">Element</span> e1 <span class=\"blue\">in</span> a )\n    {\n      <span class=\"teal\">Element</span> e2 = elementList.Where( \n        x =&gt; x.Id == e1.Id )\n        .FirstOrDefault();\n \n      <span class=\"blue\">if</span>( e2 != <span class=\"blue\">null</span> \n        &amp;&amp; <span class=\"blue\">null</span> == returnViews.Where( \n          x =&gt; x.Id == view.Id ).FirstOrDefault() )\n      {\n        returnViews.Add( view );\n      }\n    }\n  }\n  <span class=\"blue\">return</span> returnViews;\n} \n</pre>\n<p>This seems to work for quite a few views, but at a certain moment it causes an exception.\n\n<p><strong>Answer:</strong> The reason is that the following element collection returns some additional view elements than what are not visible in the user interface:\n\n<pre class=\"code\">\n  <span class=\"teal\">FilteredElementCollector</span> coll \n    = <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( doc );\n \n  coll.OfClass( <span class=\"blue\">typeof</span>( <span class=\"teal\">View</span> ) );\n</pre>\n<p>The LINQ query that you apply above fails on these additional views, causing an error message:</p>\n<center>\n<img alt=\"Invalid view id\" src=\"img/invalid_view_id.png\"/>\n</center>\n<p>Some of these additional views are template views.\nIn theory, one way to recognise them would be to check for their crop box property like this:\n\n<pre class=\"code\">\n<span class=\"blue\">public</span> <span class=\"blue\">static</span> <span class=\"blue\">void</span> GetViewsAndDrawingSheets( \n  <span class=\"teal\">Document</span> doc,\n  <span class=\"teal\">List</span>&lt;<span class=\"teal\">View</span>&gt; views, \n  <span class=\"teal\">List</span>&lt;<span class=\"teal\">ViewSheet</span>&gt; viewSheets )\n{\n  <span class=\"teal\">FilteredElementCollector</span> coll\n    = <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( doc );\n \n  coll.OfClass( <span class=\"blue\">typeof</span>( <span class=\"teal\">View</span> ) );\n \n  <span class=\"blue\">foreach</span>( <span class=\"teal\">Element</span> e <span class=\"blue\">in</span> coll )\n  {\n    <span class=\"blue\">if</span>( e <span class=\"blue\">is</span> <span class=\"teal\">View</span> )\n    {\n      <span class=\"teal\">View</span> view = e <span class=\"blue\">as</span> <span class=\"teal\">View</span>;\n      <span class=\"blue\">if</span>( <span class=\"blue\">null</span> != view.CropBox )\n        views.Add( view );\n    }\n    <span class=\"blue\">else</span> <span class=\"blue\">if</span>( e <span class=\"blue\">is</span> <span class=\"teal\">ViewSheet</span> )\n    {\n      viewSheets.Add( e <span class=\"blue\">as</span> <span class=\"teal\">ViewSheet</span> );\n    }\n  }\n}\n</pre>\n<p>However, a more direct and efficient way to filter them out is by using the new Revit 2011 View.IsTemplate predicate that we mentioned above:\n\n<pre class=\"code\">\n  <span class=\"blue\">foreach</span>( <span class=\"teal\">Element</span> e <span class=\"blue\">in</span> coll )\n  {\n    <span class=\"blue\">if</span>( e <span class=\"blue\">is</span> <span class=\"teal\">View</span> )\n    {\n      <span class=\"teal\">View</span> view = e <span class=\"blue\">as</span> <span class=\"teal\">View</span>;\n      <span class=\"blue\">if</span>( !view.IsTemplate )\n        views.Add( view );\n    }\n    <span class=\"blue\">else</span> <span class=\"blue\">if</span>( e <span class=\"blue\">is</span> <span class=\"teal\">ViewSheet</span> )\n    {\n      viewSheets.Add( e <span class=\"blue\">as</span> <span class=\"teal\">ViewSheet</span> );\n    }\n  }\n</pre>\n<p>And now for something slightly off-topic which may be of interest to some of you:\n\n<h4>UK PhD Bursaries</h4>\n<p>Claudio Benghi of the \n\n<a href=\"http://www.northumbria.ac.uk\">\nNorthumbria University</a> in \n\nNewcastle UK sent me a note on two PhD posts for construction-aware coders.\nThey come with paid fees and 13.000 GBP yearly tax-free salaries. \nThe deadline is next Monday, May 3<sup>rd</sup>.\nThe two topics are:\n\n<ul>\n<li>SEEmail: Spatially Enhanced Email for the Construction Industry\n<li>XPIDITE: eXchange Protocols In DesIgn Teams Environments\n</li></li></ul>\n<p>For further information, please contact Claudio or Stephen Lockley, Professor in Building Modelling, at the \nSchool of the Built Environment,\n\n<a href=\"http://www.northumbria.ac.uk\">\nNorthumbria University</a>, \n\ntel. +44 (0)191 227 4819.\n\n</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p>"
  },
  {
    "original_filename": "0355_view_filter",
    "header_text": "UK PhD Bursaries",
    "local_header_href": "#uk-phd-bursaries",
    "chunk_text": "<h4>UK PhD Bursaries</h4><p>Claudio Benghi of the \n\n<a href=\"http://www.northumbria.ac.uk\">\nNorthumbria University</a> in \n\nNewcastle UK sent me a note on two PhD posts for construction-aware coders.\nThey come with paid fees and 13.000 GBP yearly tax-free salaries. \nThe deadline is next Monday, May 3<sup>rd</sup>.\nThe two topics are:\n\n<ul>\n<li>SEEmail: Spatially Enhanced Email for the Construction Industry\n<li>XPIDITE: eXchange Protocols In DesIgn Teams Environments\n</li></li></ul>\n<p>For further information, please contact Claudio or Stephen Lockley, Professor in Building Modelling, at the \nSchool of the Built Environment,\n\n<a href=\"http://www.northumbria.ac.uk\">\nNorthumbria University</a>, \n\ntel. +44 (0)191 227 4819.\n\n</p></p>"
  }
]