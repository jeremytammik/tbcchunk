[
  {
    "original_filename": "0486_ray_trace_place_inst",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<head>\n<link href=\"bc.css\" rel=\"stylesheet\" type=\"text/css\"/>\n</head>"
  },
  {
    "original_filename": "0486_ray_trace_place_inst",
    "header_text": "Ray Tracing to Place Family Instance",
    "local_header_href": "#ray-tracing-to-place-family-instance",
    "chunk_text": "<h3>Ray Tracing to Place Family Instance</h3><p>Jeremiah Farmer of \n\n<a href=\"http://www.landfx.com\">\nLand F/X</a> recently \n\npresented his solution for \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/11/place-detail-instance.html\">\nplacing a site component</a> on \n\na topo surface.\n\n<p>One important issue in addition to the information presented there is that the family instance insertion point needs to be located on the surface.\nOne way to find a suitable point is to use the Revit API method \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/01/findreferencesbydirection.html\">\nFindReferencesByDirection</a> to \n\nshoot a ray through the model to determine a suitable point, i.e. the intersection point between the ray and the surface. \nIf the desired X and Y position is known, one can use a vertical ray, so that its job is just to determine the appropriate Z coordinate.\n\n<p>Here is Jeremiah's short explanation and sample code demonstrating this:\n\n<p>An update on the Import Site Components, it does seem that a ray trace is necessary to get it correctly anchored at the right Z elevation.  So I've added the following:\n\n<pre class=\"code\">\n  <span class=\"blue\">Dim</span> surface <span class=\"blue\">As</span> TopographySurface _\n    = GetSurface(commandData)\n \n  <span class=\"blue\">Dim</span> boundingbox <span class=\"blue\">As</span> BoundingBoxXYZ _\n    = surface.BoundingBox(<span class=\"blue\">Nothing</span>)\n \n  <span class=\"blue\">Dim</span> minZ <span class=\"blue\">As</span> <span class=\"blue\">Double</span> = boundingbox.Min.Z\n \n  <span class=\"blue\">Dim</span> UP <span class=\"blue\">As</span> XYZ = XYZ.BasisZ\n \n  <span class=\"blue\">Dim</span> view <span class=\"blue\">As</span> View = doc.ActiveView\n \n  <span class=\"green\">' for each point to insert component on surface:</span>\n \n  <span class=\"blue\">Dim</span> p0 <span class=\"blue\">As</span> XYZ\n  <span class=\"green\">' p1 is our X and Y for that component</span>\n  p0 = <span class=\"blue\">New</span> XYZ(p1.X, p1.Y, minZ)\n \n  <span class=\"blue\">Dim</span> test <span class=\"blue\">As</span> ReferenceArray _\n    = doc.FindReferencesByDirection(p0, UP, view)\n \n  <span class=\"blue\">If</span> test.Size &gt; 0 <span class=\"blue\">Then</span> <span class=\"green\">' found a surface point</span>\n    <span class=\"green\">' from our desired X,Y, looking Up </span>\n    <span class=\"green\">' from minimum Z to Surface</span>\n    p0 = test.Item(0).GlobalPoint\n  <span class=\"blue\">End</span> <span class=\"blue\">If</span>\n  <span class=\"green\">' note if we don't match a surface point, </span>\n  <span class=\"green\">' the call to loadfamilyinstance will fail</span>\n</pre>\n<p>The GetSurface method is not listed here. \nIt is a basic helper function similar to ones I've seen previous Building Coder blog posts; it creates a filter, loops through the members, calls TryCast to the element type desired, and returns that element. \n\n<p>Also, it might make sense to add some error handling, since the FindReferenceByDirection method requires a 3D view to be active.\nThe routine as it now stands will generate an error if a plan view is active.\n\n<p>Note that if no surface point is matched, the subsequent call to insert the family instance will fail.\n\n<p>Many thanks to Jeremiah for his research and sharing this!\n\n<p>By the way, a similar approach is probably also useful for placing furniture family instances onto a floor in the model.\n</p></p></p></p></p></p></p></p></p>"
  }
]