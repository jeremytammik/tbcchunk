[
  {
    "original_filename": "0053_2d_polygon_area_outer_loop",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<style>\n.blue { color: blue; }\n.teal { color: teal; }\n.maroon { color: maroon; }\n.green { color: green; }\n</style>"
  },
  {
    "original_filename": "0053_2d_polygon_area_outer_loop",
    "header_text": "2D Polygon Areas and Outer Loop",
    "local_header_href": "#2d-polygon-areas-and-outer-loop",
    "chunk_text": "<h3>2D Polygon Areas and Outer Loop</h3><p>When I started writing this post I was sitting in McCallan airport in Las Vegas enjoying a delay due to a faulty part added to the already delayed flight back to Europe. By now we have passed through London, Göteborg and Franfurt on the DevDays tour since then.\nAnyway, I had a chance to explore some more interesting geometrical issues in Revit here.\nWe already discussed determining the profile boundary loop polygons for\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2008/10/slab-boundary.html\">\nfloor slabs</a>\n\nand\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2008/11/wall-elevation-profile.html\">\nwalls</a>.\n\nIn most cases, the outermost boundary loop is listed first in the array of edge loops provided by the face element.\nHowever, my good friend Thomas Fink of\n\n<a href=\"http://www.sofistik.com\">\nSOFiSTiK</a>\n\njust submitted a case in which this is not the case, so we need to determine for ourselves which of the loops is the outer one and which are inner ones associated with holes in the wall or floor.\nAs far as I know, the easiest way to do this is to calculate the area of each polygon.\nThe polygon with the largest area is the outer loop, all others are inner holes.\nAs Thomas pointed out to me, if you know that the shapes of the polygons are very simple and regular, for example rectangular, then you can use the circumference instead of the area to determine which is the largest.</p><p>One approach to calculate their areas is to project them onto a two-dimensional plane.\nAnother approach calculates each polygon's plane data in 3D space, i.e. its normal vector and distance from the origin.\nUsing an algorithm which we plan to discuss later, its area can be obtained as a by-product of these calculations.</p><p>Determining the area of a two-dimensional polygon is easy.\nYou can determine the clockwise or counter-clockwise winding direction and area of a two-dimensional polygon using the following formula:</p><p style=\"text-align: center\">\narea = sign * 0.5 * sum<sub>i</sub>( x<sub>i</sub> * ( y<sub>i+1</sub> - y<sub>i-1</sub> ) )\n</p><p>The indexing needs to loop around the end, so to speak, so that for n polygon vertices numbered from i = 0 to n - 1, you identify p<sub>-1</sub> with p<sub>n-1</sub>.\nHere is some code making use of this algorithm, ported from my custom C++ classes to C# and the Revit API:</p><pre class=\"code\">\n<span class=\"blue\">double</span> GetSignedPolygonArea( <span class=\"teal\">List</span>&lt;<span class=\"teal\">UV</span>&gt; p )\n{\n  <span class=\"blue\">int</span> n = p.Count;\n  <span class=\"blue\">double</span> sum = p[0].U * ( p[1].V - p[n - 1].V );\n  <span class=\"blue\">for</span>( <span class=\"blue\">int</span> i = 1; i &lt; n - 1; ++i )\n  {\n    sum += p[i].U * ( p[i + 1].V - p[i - 1].V );\n  }\n  sum += p[n - 1].U * ( p[0].V - p[n - 2].V );\n  <span class=\"blue\">return</span> 0.5 * sum;\n}\n</pre><p>The lines before and after the loop in the middle handle the boundary cases for looping back to the end from the beginning and looping around to the beginning from the end.</p><p><strong>Addendum:</strong> Here is an incredibly easy and convincing illustrated explanation of how and why this\n\n<a href=\"http://www.mathopenref.com/coordpolygonarea2.html\">\nalgorithm to find the area of a polygon</a> works.</p><p>The polygons we obtain for the floor and wall boundary loops are three dimensional.\nSince we are assuming that the floor is horizontal, it is trivial to project the three-dimensional points into two-dimensional ones in the XY plane by simply dropping the Z coordinate. This is handled by a series of Flatten methods defined like this:</p><pre class=\"code\">\n<span class=\"teal\">UV</span> Flatten( <span class=\"teal\">XYZ</span> point )\n{\n  <span class=\"blue\">return</span> <span class=\"blue\">new</span> <span class=\"teal\">UV</span>( point.X, point.Y );\n}\n \n<span class=\"teal\">List</span>&lt;<span class=\"teal\">UV</span>&gt; Flatten( <span class=\"teal\">List</span>&lt;<span class=\"teal\">XYZ</span>&gt; polygon )\n{\n  <span class=\"blue\">double</span> z = polygon[0].Z;\n  <span class=\"teal\">List</span>&lt;<span class=\"teal\">UV</span>&gt; a = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">UV</span>&gt;( polygon.Count );\n  <span class=\"blue\">foreach</span>( <span class=\"teal\">XYZ</span> p <span class=\"blue\">in</span> polygon )\n  {\n    <span class=\"teal\">Debug</span>.Assert( <span class=\"teal\">Util</span>.IsEqual( p.Z, z ),\n      <span class=\"maroon\">\"expected horizontal polygon\"</span> );\n    a.Add( Flatten( p ) );\n  }\n  <span class=\"blue\">return</span> a;\n}\n \n<span class=\"teal\">List</span>&lt;<span class=\"teal\">List</span>&lt;<span class=\"teal\">UV</span>&gt;&gt; Flatten( <span class=\"teal\">List</span>&lt;<span class=\"teal\">List</span>&lt;<span class=\"teal\">XYZ</span>&gt;&gt; polygons )\n{\n  <span class=\"blue\">double</span> z = polygons[0][0].Z;\n  <span class=\"teal\">List</span>&lt;<span class=\"teal\">List</span>&lt;<span class=\"teal\">UV</span>&gt;&gt; a = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">List</span>&lt;<span class=\"teal\">UV</span>&gt;&gt;( polygons.Count );\n  <span class=\"blue\">foreach</span>( <span class=\"teal\">List</span>&lt;<span class=\"teal\">XYZ</span>&gt; polygon <span class=\"blue\">in</span> polygons )\n  {\n    <span class=\"teal\">Debug</span>.Assert( <span class=\"teal\">Util</span>.IsEqual( polygon[0].Z, z ),\n      <span class=\"maroon\">\"expected horizontal polygons\"</span> );\n    a.Add( Flatten( polygon ) );\n  }\n  <span class=\"blue\">return</span> a;\n}\n</pre><p>There is probably some more elegant generic method for handling this transformation.\nUnfortunately I am still working in Visual Studio 2005, so I do not have the latest version of the .NET generics installed.</p><p>I implemented a new command CmdSlabBoundaryArea for testing this area calculation.\nIt is very similar to the previous\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2008/10/slab-boundary.html\">\nCmdSlabBoundary</a>\n\ncommand, with additional code to calculate the area of each polygonal loop and the maximum area.\nWe repackaged the existing functionality for determining the floor boundary polygons into a separate\nutility method GetFloorBoundaryPolygons() in the CmdSlabBoundary class in order to reuse it in the new command.</p><p>The code assumes that only one floor is picked.\nIf more than one is selected, then the outer loop will only be highlighted for biggest floor slab,\nsince all boundary loops of all floors are collected in one single list before determining the maximum area.\nHere is the enhanced code for the new command:</p><pre class=\"code\">\n<span class=\"teal\">List</span>&lt;<span class=\"teal\">List</span>&lt;<span class=\"teal\">XYZ</span>&gt;&gt; polygons\n  = <span class=\"teal\">CmdSlabBoundary</span>.GetFloorBoundaryPolygons(\n    app, floors );\n \n<span class=\"teal\">List</span>&lt;<span class=\"teal\">List</span>&lt;<span class=\"teal\">UV</span>&gt;&gt; flat_polygons\n  = Flatten( polygons );\n \n<span class=\"blue\">int</span> i = 0, n = flat_polygons.Count;\n<span class=\"blue\">double</span>[] areas = <span class=\"blue\">new</span> <span class=\"blue\">double</span>[n];\n<span class=\"blue\">double</span> a, maxArea = 0.0;\n<span class=\"blue\">foreach</span>( <span class=\"teal\">List</span>&lt;<span class=\"teal\">UV</span>&gt; polygon <span class=\"blue\">in</span> flat_polygons )\n{\n  a = GetSignedPolygonArea( polygon );\n  <span class=\"blue\">if</span>( <span class=\"teal\">Math</span>.Abs( maxArea ) &lt; <span class=\"teal\">Math</span>.Abs( a ) )\n  {\n    maxArea = a;\n  }\n  areas[i++] = a;\n}\n \n<span class=\"teal\">Debug</span>.WriteLine( <span class=\"blue\">string</span>.Format(\n  <span class=\"maroon\">\"{0} boundary loop{1} found.\"</span>,\n  n, <span class=\"teal\">Util</span>.PluralSuffix( n ) ) );\n \n<span class=\"blue\">for</span>( i = 0; i &lt; n; ++i )\n{\n  <span class=\"teal\">Debug</span>.WriteLine( <span class=\"blue\">string</span>.Format(\n    <span class=\"maroon\">\"  Loop {0} area is {1} square feet{2}\"</span>,\n    i,\n    <span class=\"teal\">Util</span>.RealString( areas[i] ),\n    ( areas[i].Equals( maxArea )\n      ? <span class=\"maroon\">\", outer loop of largest floor slab\"</span>\n      : <span class=\"maroon\">\"\"</span> ) ) );\n}\n</pre><p>Here is the same floor that we used at in the previous slab boundary posting, displayed from below after running the slab boundary detection, calculating the loops on the bottom face, and drawing model lines around them, offset downwards by a small amount:</p><img alt=\"Floor slab boundary loops from below\" src=\"img/slab_boundary_below.png\"/><p>This is the output produced in the debug output window by running this command on that floor:</p><pre>\n4 boundary loops found.\n  Loop 0 area is -1651.45 square feet, outer loop of largest floor slab\n  Loop 1 area is 31.37 square feet\n  Loop 2 area is 43.06 square feet\n  Loop 3 area is 66.18 square feet\n</pre><p>Note that this algorithm only calculates polygon areas, i.e. areas of regions with straight edges.\nIf you need the exact areas taking into account the other types of curved boundary edges, you will have to adapt the algorithm accordingly.\nBear in mind that the Revit Face class is also perfectly capable of calculating its area.\nHowever, the Face.Area property also estimates the face area by integrating its tessellated edges and will slightly underestimate when the edges are curved, so it is probably using a method similar to the one presented here.</p><p>Also note that the opposite winding directions for the outer and inner loops are just as expected.\nThe vertices of the outer face loop are oriented counter clockwise when looking at the solid from outside.\nSince the edge loops we are examining stem from the bottom face of the slab, we should actually be looking at them from below to obtain the correct vertex ordering.\nSince our area calculation algorithm is only two-dimensional, it assumes that we are looking down on the XY plane from the positive Z direction, so the winding directions of all loops are reversed.</p>"
  }
]