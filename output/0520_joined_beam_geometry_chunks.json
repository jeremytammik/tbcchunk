[
  {
    "original_filename": "0520_joined_beam_geometry",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<head>\n<link href=\"bc.css\" rel=\"stylesheet\" type=\"text/css\"/>\n</head>"
  },
  {
    "original_filename": "0520_joined_beam_geometry",
    "header_text": "Joined Beam Geometry Access",
    "local_header_href": "#joined-beam-geometry-access",
    "chunk_text": "<h3>Joined Beam Geometry Access</h3><p>We have already discussed situations where an element's geometry needs to be accessed in various ways depending on the circumstances, such as the retrieval of \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/02/unmodified-element-geometry.html\">\nunmodified element geometry</a> or\n\nthe different approaches required to access \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/02/retrieving-column-and-stair-geometry.html\">\ncolumn and stair geometry</a>,\n\ndepending on whether the element has its own solid definition or is reusing the solid defined by the symbol it references.\n\nHere is a similar solution to obtain the geometry of a beam joined with columns from my colleagues Katsuaki Takamizawa and Harry Mattison:\n\n<p><strong>Question:</strong> The NewRebar SDK sample works well with a standalone beam and can access the edges of the beam geometry using the following sequence of calls, illustrated using RevitLookup:</p>\n<center>\n<img alt=\"\" src=\"img/snoop_joined_beam_geom_1.png\"/>\n</center>\n<p>However, it rejects a beam joined with columns because it cannot access its edges.  \nIn this case, the edges can be obtained differently like this:</p>\n<center>\n<img alt=\"\" src=\"img/snoop_joined_beam_geom_2.png\"/>\n</center>\n<p>Should the access to edges (and geometry in general) be implemented differently depending on whether a beam is joined or not?\nWe need to find the beam coordinates to add rebars to it.\n\n<p><strong>Answer:</strong> I am unable to reproduce the problem you describe.\n\n<p>The following code used with a specific file finds the same number of edges for both the joined and non-joined beams.\n\n<pre class=\"code\">\n[<span class=\"teal\">Transaction</span>( <span class=\"teal\">TransactionMode</span>.Automatic )]\n[<span class=\"teal\">Regeneration</span>( <span class=\"teal\">RegenerationOption</span>.Manual )]\n<span class=\"blue\">public</span> <span class=\"blue\">class</span> <span class=\"teal\">CmdGetColumnGeometry</span> : <span class=\"teal\">IExternalCommand</span>\n{\n  <span class=\"blue\">public</span> <span class=\"teal\">Result</span> Execute( \n    <span class=\"teal\">ExternalCommandData</span> commandData, \n    <span class=\"blue\">ref</span> <span class=\"blue\">string</span> message, \n    <span class=\"teal\">ElementSet</span> elements )\n  {\n    <span class=\"teal\">Document</span> doc = commandData.Application\n      .ActiveUIDocument.Document;\n \n    <span class=\"teal\">Options</span> options = <span class=\"blue\">new</span> <span class=\"teal\">Options</span>();\n \n    options.ComputeReferences = <span class=\"blue\">true</span>;\n \n    <span class=\"teal\">GeometryElement</span> geomElement = doc\n      .Selection.PickObject( <span class=\"teal\">ObjectType</span>.Element )\n      .Element.get_Geometry( options );\n \n    <span class=\"blue\">int</span> edgeCount = 0;\n    <span class=\"blue\">foreach</span>( <span class=\"teal\">GeometryObject</span> geomObj \n      <span class=\"blue\">in</span> geomElement.Objects )\n    {\n      <span class=\"blue\">if</span>( geomObj <span class=\"blue\">is</span> <span class=\"teal\">GeometryInstance</span> )\n      {\n        <span class=\"teal\">GeometryInstance</span> inst = geomObj \n          <span class=\"blue\">as</span> <span class=\"teal\">GeometryInstance</span>;\n \n        <span class=\"blue\">if</span>( inst != <span class=\"blue\">null</span> )\n        {\n          <span class=\"teal\">GeometryElement</span> geomElem \n            = inst.GetSymbolGeometry();\n \n          <span class=\"blue\">foreach</span>( <span class=\"teal\">Object</span> o <span class=\"blue\">in</span> geomElem.Objects )\n          {\n            <span class=\"teal\">Solid</span> solid = o <span class=\"blue\">as</span> <span class=\"teal\">Solid</span>;\n            <span class=\"blue\">if</span>( solid != <span class=\"blue\">null</span> )\n            {\n              <span class=\"blue\">foreach</span>( <span class=\"teal\">Face</span> face <span class=\"blue\">in</span> solid.Faces )\n              {\n                <span class=\"blue\">foreach</span>( <span class=\"teal\">EdgeArray</span> edgeArray \n                  <span class=\"blue\">in</span> face.EdgeLoops )\n                {\n                  edgeCount += edgeArray.Size;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    <span class=\"teal\">TaskDialog</span>.Show( <span class=\"maroon\">\"Revit\"</span>, <span class=\"maroon\">\"Edges: \"</span> \n      + edgeCount.ToString() );\n \n    <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Succeeded;\n  }\n}\n</pre>\n<p><strong>Response:</strong> The problem seems to be specific to concrete beams. \nThe code above did not find the geometry objects of a concrete beam joined with columns. \n\n<p><strong>Answer:</strong> You are right in that, depending on the specific element and condition, the GeometryElement may contain the desired geometry as a Solid or GeometryInstance. \nThe following code handles both of these cases, as described in Chapter 20 of the Developer Guide:\n\n<pre class=\"code\">\n  <span class=\"teal\">Document</span> doc = commandData.Application\n    .ActiveUIDocument.Document;\n \n  <span class=\"teal\">Options</span> options = <span class=\"blue\">new</span> <span class=\"teal\">Options</span>();\n  options.ComputeReferences = <span class=\"blue\">true</span>;\n \n  <span class=\"teal\">GeometryElement</span> geomElement = doc.Selection\n    .PickObject( <span class=\"teal\">ObjectType</span>.Element )\n    .Element.get_Geometry( options );\n \n  <span class=\"blue\">int</span> ctr = 0;\n  <span class=\"blue\">foreach</span>( <span class=\"teal\">GeometryObject</span> geomObj \n    <span class=\"blue\">in</span> geomElement.Objects )\n  {\n    <span class=\"blue\">if</span>( geomObj <span class=\"blue\">is</span> <span class=\"teal\">Solid</span> )\n    {\n      <span class=\"teal\">FaceArray</span> faces = ( ( <span class=\"teal\">Solid</span> ) geomObj ).Faces;\n      ctr += faces.Size;\n    }\n \n    <span class=\"blue\">if</span>( geomObj <span class=\"blue\">is</span> <span class=\"teal\">GeometryInstance</span> )\n    {\n      <span class=\"teal\">GeometryInstance</span> inst = geomObj \n        <span class=\"blue\">as</span> <span class=\"teal\">GeometryInstance</span>;\n \n      <span class=\"blue\">if</span>( inst != <span class=\"blue\">null</span> )\n      {\n        <span class=\"teal\">GeometryElement</span> geomElem \n          = inst.GetSymbolGeometry();\n \n        <span class=\"blue\">foreach</span>( <span class=\"teal\">Object</span> o <span class=\"blue\">in</span> geomElem.Objects )\n        {\n          <span class=\"teal\">Solid</span> solid = o <span class=\"blue\">as</span> <span class=\"teal\">Solid</span>;\n          <span class=\"blue\">if</span>( solid != <span class=\"blue\">null</span> )\n          {\n            ctr += solid.Faces.Size;\n          }\n        }\n      }\n    }\n  }\n  <span class=\"teal\">TaskDialog</span>.Show( <span class=\"maroon\">\"Revit\"</span>, <span class=\"maroon\">\"Faces: \"</span> + ctr );\n}\n</pre>\n<p><strong>Response:</strong> Thank you, your code above and also the code in Chapter 20.5 of the developer guide worked for the concrete beam. \n</p></p></p></p></p></p></p>"
  }
]