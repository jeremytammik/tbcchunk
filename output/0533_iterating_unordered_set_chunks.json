[
  {
    "original_filename": "0533_iterating_unordered_set",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<head>\n<link href=\"bc.css\" rel=\"stylesheet\" type=\"text/css\"/>\n</head>"
  },
  {
    "original_filename": "0533_iterating_unordered_set",
    "header_text": "Iterating Over an Unordered Set Property",
    "local_header_href": "#iterating-over-an-unordered-set-property",
    "chunk_text": "<h3>Iterating Over an Unordered Set Property</h3><p>Here is a simple question that recently came up on iterating over the panel cells in a curtain grid:\n\n<p><strong>Question:</strong> I'm noticing some odd behaviour when dealing with CurtainCell.CurveLoops and CurtainCell.PlanarizedCurveLoops taken from CurtainGrid.Cells.  It appears that one of the loops is missing and another one of the loops is duplicated.\n\n<p>I am iterating over the cells using the following code and displaying a message listing the loop edge coordinates:\n\n<pre class=\"code\">\n<span class=\"blue\">Dim</span> cell <span class=\"blue\">As</span> CurtainCell\n \n<span class=\"blue\">For</span> i <span class=\"blue\">As</span> <span class=\"blue\">Integer</span> = 0 <span class=\"blue\">To</span> cg.Cells.Size - 1\n  cell = cg.Cells(i)\n \n  msg += vbCrLf + vbCrLf + <span class=\"maroon\">\"i=\"</span> + i.ToString\n  msg += vbCrLf + <span class=\"maroon\">\"CurveLoops\"</span>\n \n  <span class=\"blue\">Dim</span> iCounter <span class=\"blue\">As</span> <span class=\"blue\">Integer</span> = 0\n \n  <span class=\"blue\">For</span> <span class=\"blue\">Each</span> cArr <span class=\"blue\">As</span> CurveArray <span class=\"blue\">In</span> cell.CurveLoops\n \n    <span class=\"blue\">For</span> <span class=\"blue\">Each</span> c <span class=\"blue\">As</span> Curve <span class=\"blue\">In</span> cArr\n \n      iCounter += 1\n \n      msg += vbCrLf + iCounter.ToString _\n        + <span class=\"maroon\">\". \"</span> + Util.CurveToString(c)\n \n    <span class=\"blue\">Next</span>\n \n  <span class=\"blue\">Next</span>\n \n<span class=\"blue\">Next</span>\n \nMsgBox(msg)\n</pre>\n<p>Here are the cells I am examining:</p>\n<center>\n<img alt=\"Curtain grid cells\" src=\"img/curtain_grid_cells.png\"/>\n</center>\n<p>The resulting dialogue box displays the cell curve loop coordinates like this:</p>\n<center>\n<img alt=\"Cell curve loop coordinates\" src=\"img/CellCurveLoopsJt.png\"/>\n</center>\n<p>As you can see, one loop is missing and the other is duplicated.\n\n<p>Is this normal behaviour?\n\n<p>Also, I noticed that every time I run the query the order in which they are received changes.\n\n<p><strong>Answer:</strong> First, I converted your code to iterate using for each instead:\n\n<pre class=\"code\">\n<span class=\"blue\">Dim</span> cg <span class=\"blue\">As</span> CurtainGrid = w.CurtainGrid\n \n<span class=\"blue\">Dim</span> msg <span class=\"blue\">As</span> <span class=\"blue\">String</span> = <span class=\"maroon\">\"# Cells = \"</span> _\n  + cg.Cells.Size.ToString\n \n<span class=\"blue\">Dim</span> cell <span class=\"blue\">As</span> CurtainCell\n<span class=\"blue\">Dim</span> i <span class=\"blue\">As</span> <span class=\"blue\">Integer</span> = 0\n \n<span class=\"blue\">For</span> <span class=\"blue\">Each</span> cell <span class=\"blue\">In</span> cg.Cells\n \n  msg += vbCrLf + vbCrLf + <span class=\"maroon\">\"i=\"</span> + i.ToString\n  msg += vbCrLf + <span class=\"maroon\">\"CurveLoops\"</span>\n \n  <span class=\"blue\">Dim</span> iCounter <span class=\"blue\">As</span> <span class=\"blue\">Integer</span> = 0\n \n  <span class=\"blue\">For</span> <span class=\"blue\">Each</span> cArr <span class=\"blue\">As</span> CurveArray <span class=\"blue\">In</span> cell.CurveLoops\n \n    <span class=\"blue\">For</span> <span class=\"blue\">Each</span> c <span class=\"blue\">As</span> Curve <span class=\"blue\">In</span> cArr\n \n      iCounter += 1\n \n      msg += vbCrLf + iCounter.ToString _\n        + <span class=\"maroon\">\". \"</span> + Util.CurveToString(c)\n \n    <span class=\"blue\">Next</span>\n \n  <span class=\"blue\">Next</span>\n \n  i += 1\n \n<span class=\"blue\">Next</span>\n \nMsgBox(msg)\n</pre>\n<p>Lo and behold, the problem is resolved, and here are the correct curve loops and their coordinates:</p>\n<center>\n<img alt=\"Cell curve loop coordinates using Foreach\" src=\"img/CellCurveLoopsJtForeach.png\"/>\n</center>\n<p>The problem has nothing to do with whether you use For and indexing or For Each, though.\nFor Each loops operate in the same manner as a For i = loop.\nThe indexing is provided by extension methods from Linq.\n\n<p>The problem is due to the fact that each call to CurtainGrid.Cells returns a new set.\n\n<p>The set returned is unordered, so there is no guarantee that one set will have its elements in the same order as another.\n\n<p>In your original code, you were calling cg.Cells(i) and thus requesting a new differently ordered set to be returned on each iteration step of the loop.\n\n<p>You can get a reliable indexed access if you obtain and store one single reference to the set once, rather than accessing it in each iteration within the loop:\n\n<pre class=\"code\">\n<span class=\"blue\">Dim</span> cgSet <span class=\"blue\">As</span> CurtainCellSet = cg.Cells\n\n<span class=\"blue\">For</span> i <span class=\"blue\">As</span> <span class=\"blue\">Integer</span> = 0 <span class=\"blue\">To</span> cgSet.Size - 1\n  <span class=\"blue\">Dim</span> cell <span class=\"blue\">As</span> CurtainCell = cgSet(i)\n\n  ...\n</pre>\n<p>I have seen several examples in the Revit API where you have to be very aware of the effect of calling a property and storing the result.\n\n<p>In most cases so far, the issue has been calling a property, storing the result in a variable, modifying the value of that variable, and expecting the underlying property to have changed. That is not the case, since the variable just stores a copy of the original value, and the original is not modified by modifying the copy stored in the variable.\n\n<p>In this case, it is the other way round, sort of: each call to the property returns a different result, so we have to store the property value from one single call in a constant variable to ensure that it remains unchanged during the iteration process.\n</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p>"
  }
]