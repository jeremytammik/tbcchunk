[
  {
    "original_filename": "0014_wall_dimensions",
    "header_text": "Wall Dimensions",
    "local_header_href": "#wall-dimensions",
    "chunk_text": "<h3>Wall Dimensions</h3><style type=\"text/css\">\n.blue { color: blue; }\n.green { color: green; }\n.teal { color: teal; }\n.gray { color: gray; }\n.maroon { color: maroon; }\n</style><p>After the diversion exploring the geometry related information and samples provided with the basic Revit SDK, let us finally get into an example of some own geometry related code. We present an algorithm to dimension an arbitrary Revit element containing a solid in its geometry. The implementation is tailored to handle wall elements, but the functionality can be applied to any other element containing geometry as well.</p><p>The idea is pretty simple, and possibly not awfully useful for real life, but geometrically elegant and interesting. We analyse the wall geometry and determine the maximum distance between all planar wall faces with parallel normal vectors. The maximum distance for any given normal vector is assumed to be the wall dimension in that direction. Non-planar faces are ignored. For each planar face, we determine its normal vector and origin. For all faces sharing the same normal vector, we collect all the origin points. After completing this collection process, we determine the maximal distance along the normal vector between all the faces sharing this normal. For a quadrilateral wall, the result will be the three dimensions one expects. For irregular walls with planar faces, additional dimensions will be detected in all directions perpendicular to two or more planar faces.</p><p>Here is the code for the external command and its support routines:</p><pre class=\"code\">\n<span class=\"blue\">#region</span> Header\n<span class=\"green\">//</span>\n<span class=\"green\">// CmdWallDimensions.cs - determine wall dimensions </span>\n<span class=\"green\">// by iterating over wall geometry faces</span>\n<span class=\"green\">//</span>\n<span class=\"green\">// Copyright (C) 2008 by Jeremy Tammik, </span>\n<span class=\"green\">// Autodesk Inc. All rights reserved.</span>\n<span class=\"green\">//</span>\n<span class=\"blue\">#endregion</span> <span class=\"green\">// Header</span>\n \n<span class=\"blue\">#region</span> Namespaces\n<span class=\"blue\">using</span> System;\n<span class=\"blue\">using</span> System.Collections.Generic;\n<span class=\"blue\">using</span> System.Diagnostics;\n<span class=\"blue\">using</span> Autodesk.Revit;\n<span class=\"blue\">using</span> Autodesk.Revit.Elements;\n<span class=\"blue\">using</span> Autodesk.Revit.Geometry;\n<span class=\"blue\">using</span> <span class=\"teal\">CmdResult</span> = Autodesk.Revit.<span class=\"teal\">IExternalCommand</span>.<span class=\"teal\">Result</span>;\n<span class=\"blue\">using</span> <span class=\"teal\">RvtElement</span> = Autodesk.Revit.<span class=\"teal\">Element</span>;\n<span class=\"blue\">using</span> <span class=\"teal\">GeoElement</span> = Autodesk.Revit.Geometry.<span class=\"teal\">Element</span>;\n<span class=\"blue\">using</span> <span class=\"teal\">NormalAndOrigins</span>\n  = System.Collections.Generic.<span class=\"teal\">KeyValuePair</span>\n    &lt; Autodesk.Revit.Geometry.<span class=\"teal\">XYZ</span>\n    , System.Collections.Generic.<span class=\"teal\">List</span>\n      &lt;Autodesk.Revit.Geometry.<span class=\"teal\">XYZ</span>&gt;&gt;;\n<span class=\"blue\">#endregion</span> <span class=\"green\">// Namespaces</span>\n \n<span class=\"blue\">namespace</span> BuildingCoder\n{\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n  <span class=\"gray\">///</span><span class=\"green\"> List dimensions for a quadrilateral wall with </span>\n  <span class=\"gray\">///</span><span class=\"green\"> openings. In this algorithm, we collect all </span>\n  <span class=\"gray\">///</span><span class=\"green\"> the faces with parallel normal vectors and </span>\n  <span class=\"gray\">///</span><span class=\"green\"> calculate the maximal distance between any </span>\n  <span class=\"gray\">///</span><span class=\"green\"> two pairs of them. This is the wall dimension </span>\n  <span class=\"gray\">///</span><span class=\"green\"> in that direction.</span>\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n  <span class=\"blue\">class</span> <span class=\"teal\">CmdWallDimensions</span>\n  {\n<span class=\"blue\">    #region</span> Geometry\n    <span class=\"blue\">const</span> <span class=\"blue\">double</span> _eps = 1.0e-9;\n \n    <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n    <span class=\"gray\">///</span><span class=\"green\"> Check whether two real numbers are equal</span>\n    <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n    <span class=\"blue\">static</span> <span class=\"blue\">bool</span> DoubleEqual( <span class=\"blue\">double</span> a, <span class=\"blue\">double</span> b )\n    {\n      <span class=\"blue\">return</span> <span class=\"teal\">Math</span>.Abs( a - b ) &lt; _eps;\n    }\n \n    <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n    <span class=\"gray\">///</span><span class=\"green\"> Check whether two vectors are parallel</span>\n    <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n    <span class=\"blue\">static</span> <span class=\"blue\">bool</span> XyzParallel( <span class=\"teal\">XYZ</span> a, <span class=\"teal\">XYZ</span> b )\n    {\n      <span class=\"blue\">double</span> angle = a.Angle( b );\n      <span class=\"blue\">return</span> _eps &gt; angle\n        || DoubleEqual( angle, <span class=\"teal\">Math</span>.PI );\n    }\n<span class=\"blue\">    #endregion</span> <span class=\"green\">// Geometry</span>\n \n    <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n    <span class=\"gray\">///</span><span class=\"green\"> Retrieve the planar face normal and origin </span>\n    <span class=\"gray\">///</span><span class=\"green\"> from all of the solid's planar faces and </span>\n    <span class=\"gray\">///</span><span class=\"green\"> insert them into the map mapping face normals</span>\n    <span class=\"gray\">///</span><span class=\"green\"> to a list of all origins of different faces</span>\n    <span class=\"gray\">///</span><span class=\"green\"> sharing this normal.</span>\n    <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n    <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;param name=\"m\"&gt;</span><span class=\"green\">Map mapping each normal vector </span>\n    <span class=\"gray\">///</span><span class=\"green\"> to a list of the origins of all planar faces </span>\n    <span class=\"gray\">///</span><span class=\"green\"> sharing this normal direction</span><span class=\"gray\">&lt;/param&gt;</span>\n    <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;param name=\"solid\"&gt;</span><span class=\"green\">Input solid</span><span class=\"gray\">&lt;/param&gt;</span>\n    <span class=\"blue\">void</span> getFaceData(\n      <span class=\"teal\">Dictionary</span>&lt;<span class=\"teal\">XYZ</span>, <span class=\"teal\">List</span>&lt;<span class=\"teal\">XYZ</span>&gt;&gt; m,\n      <span class=\"teal\">Solid</span> solid )\n    {\n      <span class=\"blue\">int</span> i;\n      <span class=\"teal\">FaceArray</span> faces = solid.Faces;\n      <span class=\"blue\">foreach</span>( <span class=\"teal\">Face</span> face <span class=\"blue\">in</span> solid.Faces )\n      {\n        <span class=\"teal\">PlanarFace</span> planarFace = face <span class=\"blue\">as</span> <span class=\"teal\">PlanarFace</span>;\n        <span class=\"blue\">if</span>( <span class=\"blue\">null</span> != planarFace )\n        {\n          <span class=\"teal\">XYZ</span> normal = planarFace.Normal;\n          <span class=\"teal\">XYZ</span> origin = planarFace.Origin;\n          <span class=\"teal\">List</span>&lt;<span class=\"teal\">XYZ</span>&gt; normals = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">XYZ</span>&gt;( m.Keys );\n          i = normals.FindIndex(\n            <span class=\"blue\">delegate</span>( <span class=\"teal\">XYZ</span> v )\n            {\n              <span class=\"blue\">return</span> XyzParallel( v, normal );\n            } );\n          <span class=\"blue\">if</span>( -1 == i )\n          {\n            <span class=\"teal\">Debug</span>.WriteLine( <span class=\"blue\">string</span>.Format(\n              <span class=\"maroon\">\"Face at {0} has new normal {1}\"</span>,\n              <span class=\"teal\">Util</span>.PointString( origin ),\n              <span class=\"teal\">Util</span>.PointString( normal ) ) );\n            m.Add( normal, <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">XYZ</span>&gt;() );\n            m[normal].Add( origin );\n          }\n          <span class=\"blue\">else</span>\n          {\n            <span class=\"teal\">Debug</span>.WriteLine( <span class=\"blue\">string</span>.Format(\n              <span class=\"maroon\">\"Face at {0} normal {1} matches {2}\"</span>,\n              <span class=\"teal\">Util</span>.PointString( origin ),\n              <span class=\"teal\">Util</span>.PointString( normal ),\n              <span class=\"teal\">Util</span>.PointString( normals[i] ) ) );\n            m[normals[i]].Add( origin );\n          }\n        }\n      }\n    }\n \n    <span class=\"blue\">public</span> <span class=\"teal\">CmdResult</span> Execute(\n      <span class=\"teal\">ExternalCommandData</span> commandData,\n      <span class=\"blue\">ref</span> <span class=\"blue\">string</span> message,\n      <span class=\"teal\">ElementSet</span> elements )\n    {\n      <span class=\"teal\">Application</span> app = commandData.Application;\n      <span class=\"teal\">Document</span> doc = app.ActiveDocument;\n      <span class=\"teal\">Selection</span> sel = doc.Selection;\n      <span class=\"teal\">Options</span> o = app.Create.NewGeometryOptions();\n      <span class=\"green\">// map planar face normals to face origins:</span>\n      <span class=\"teal\">Dictionary</span>&lt;<span class=\"teal\">XYZ</span>, <span class=\"teal\">List</span>&lt;<span class=\"teal\">XYZ</span>&gt;&gt; m\n        = <span class=\"blue\">new</span> <span class=\"teal\">Dictionary</span>&lt;<span class=\"teal\">XYZ</span>, <span class=\"teal\">List</span>&lt;<span class=\"teal\">XYZ</span>&gt;&gt;();\n      <span class=\"blue\">string</span> s, msg = <span class=\"blue\">string</span>.Empty;\n      <span class=\"blue\">int</span> i;\n      <span class=\"blue\">foreach</span>( <span class=\"teal\">RvtElement</span> e <span class=\"blue\">in</span> sel.Elements )\n      {\n        <span class=\"teal\">Wall</span> wall = e <span class=\"blue\">as</span> <span class=\"teal\">Wall</span>;\n        <span class=\"blue\">if</span>( <span class=\"blue\">null</span> != wall )\n        {\n          s = <span class=\"blue\">string</span>.Format( <span class=\"maroon\">\"Wall &lt;{0} {1}&gt;:\"</span>,\n            wall.Name, wall.Id.Value );\n          <span class=\"teal\">Debug</span>.WriteLine( s );\n          <span class=\"blue\">if</span>( 0 &lt; msg.Length ) { msg += <span class=\"maroon\">\"\\n\\n\"</span>; }\n          msg += s;\n          <span class=\"teal\">GeoElement</span> ge = wall.get_Geometry( o );\n          <span class=\"teal\">GeometryObjectArray</span> objs = ge.Objects;\n          <span class=\"blue\">foreach</span>( <span class=\"teal\">GeometryObject</span> obj <span class=\"blue\">in</span> objs )\n          {\n            <span class=\"teal\">Solid</span> solid = obj <span class=\"blue\">as</span> <span class=\"teal\">Solid</span>;\n            <span class=\"blue\">if</span>( <span class=\"blue\">null</span> != solid )\n            {\n              getFaceData( m, solid );\n            }\n          }\n          <span class=\"blue\">int</span> j, n;\n          <span class=\"blue\">double</span> d, dmax;\n          <span class=\"blue\">foreach</span>( <span class=\"teal\">NormalAndOrigins</span> pair <span class=\"blue\">in</span> m )\n          {\n            dmax = 0;\n            <span class=\"teal\">XYZ</span> normal = pair.Key.Normalized;\n            <span class=\"teal\">List</span>&lt;<span class=\"teal\">XYZ</span>&gt; pts = pair.Value;\n            n = pts.Count;\n            <span class=\"blue\">if</span>( 1 == n )\n            {\n              s = <span class=\"blue\">string</span>.Format(\n                <span class=\"maroon\">\"Only one wall face in \"</span>\n                + <span class=\"maroon\">\"direction {0} found.\"</span>,\n                <span class=\"teal\">Util</span>.PointString( normal ) );\n            }\n            <span class=\"blue\">else</span>\n            {\n              <span class=\"blue\">for</span>( i = 0; i &lt; n - 1; ++i )\n              {\n                <span class=\"blue\">for</span>( j = i + 1; j &lt; n; ++j )\n                {\n                  <span class=\"teal\">XYZ</span> v = pts[i].Subtract( pts[j] );\n                  d = v.Dot( normal );\n                  <span class=\"blue\">if</span>( d &gt; dmax )\n                  {\n                    dmax = d;\n                  }\n                }\n              }\n              s = <span class=\"blue\">string</span>.Format(\n                <span class=\"maroon\">\"Max wall dimension in \"</span>\n                + <span class=\"maroon\">\"direction {0} is {1} feet.\"</span>,\n                <span class=\"teal\">Util</span>.PointString( normal ),\n                <span class=\"teal\">Util</span>.RealString( dmax ) );\n            }\n            <span class=\"teal\">Debug</span>.WriteLine( s );\n            msg += <span class=\"maroon\">\"\\n\"</span> + s;\n          }\n          m.Clear();\n        }\n      }\n      <span class=\"blue\">if</span>( 0 == msg.Length )\n      {\n        msg = <span class=\"maroon\">\"Please select some walls.\"</span>;\n      }\n      <span class=\"teal\">Util</span>.InfoMsg( msg );\n      <span class=\"blue\">return</span> <span class=\"teal\">CmdResult</span>.Succeeded;\n    }\n  }\n}\n</pre><p>We use regions to structure the code. It allows us to collapse bits of code that we are currently not interested in to reduce screen clutter and improve the overview. The main geometrical analysis is implemented in getFaceData(). It traverses the solid passed in and collects all the planar face normal vectors and origins, using the normals as dictionary keys, and creating lists of origin points as dictionary values. Once this information has been assembled, we traverse it to format it into a string to be presented in a message box, as well as listing it in the Visual Studio debug output window.</p><p>The namespace is BuildingCoder, and the command name CmdWallDimensions, so the information to add to Revit.ini is something like this:</p><pre>\n[ExternalCommands]\nECCount=1\nECName1=Wall Dimensions\nECDescription1=Extract wall solid and list all its dimensions\nECAssembly1=C:\\bin\\BuildingCoder.dll\nECClassName1=BuildingCoder.CmdWallDimensions\n</pre><p>Here is a sample wall to run it on, created by the external command defined by Lab2_0_CreateLittleHouse in the Revit API introduction labs:</p><img alt=\"Little House Wall Selected\" src=\"img/little_house_3d_wall.png\"/><p>Here is the result of selecting the wall and running the command:</p><img alt=\"Wall Dimensions\" src=\"img/wall_dimensions.png\"/><p>This is the log data printed to the Visual Studio debug output window generated during the process, to help understand how the faces are analysed one by one to determine whether their normal either matches an existing or defines a new  one:</p><pre>\nWall &lt;Generic - 200mm 127248&gt;:\nFace at (0,-0.33,0) has new normal (0,-1,0)\nFace at (12.98,0.33,0) has new normal (-1,0,0)\nFace at (0,-0.33,0) has new normal (0,0,-1)\nFace at (23.29,0,0) normal (1,0,0) matches (-1,0,0)\nFace at (22.97,-0.33,13.12) normal (0,0,1) matches (0,0,-1)\nFace at (-0.33,13.12,0) normal (-1,0,0) matches (-1,0,0)\nFace at (9.98,0.33,7) normal (1,0,0) matches (-1,0,0)\nFace at (12.98,0.33,7) normal (0,0,-1) matches (0,0,-1)\nFace at (5.08,-0.33,3.94) normal (1,0,0) matches (-1,0,0)\nFace at (5.08,-0.33,5.94) normal (0,0,-1) matches (0,0,-1)\nFace at (6.41,-0.33,5.94) normal (-1,0,0) matches (-1,0,0)\nFace at (6.41,-0.33,3.94) normal (0,0,1) matches (0,0,-1)\nFace at (16.56,-0.33,3.94) normal (1,0,0) matches (-1,0,0)\nFace at (16.56,-0.33,5.94) normal (0,0,-1) matches (0,0,-1)\nFace at (17.89,-0.33,5.94) normal (-1,0,0) matches (-1,0,0)\nFace at (17.89,-0.33,3.94) normal (0,0,1) matches (0,0,-1)\nFace at (0,0.33,0) normal (0,1,0) matches (0,-1,0)\nMax wall dimension in direction (0,-1,0) is 0.66 feet.\nMax wall dimension in direction (-1,0,0) is 18.22 feet.\nMax wall dimension in direction (0,0,-1) is 13.12 feet.\nWall &lt;Generic - 200mm 127248&gt;:\nMax wall dimension in direction (0,-1,0) is 0.66 feet.\nMax wall dimension in direction (-1,0,0) is 18.22 feet.\nMax wall dimension in direction (0,0,-1) is 13.12 feet.\n</pre>"
  }
]