[
  {
    "original_filename": "1573_family_inst_lcs_wcs",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n<link rel=\"stylesheet\" type=\"text/css\" href=\"bc.css\">\n<!--\n<script src=\"run_prettify.js\" type=\"text/javascript\"></script>\n<script src=\"https://google-code-prettify.googlecode.com/svn/loader/run_prettify.js\" type=\"text/javascript\"></script>\n-->\n<script src=\"https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js\" type=\"text/javascript\"></script>\n</head>\n\n<!---\n\n- [Incorrect face normal](https://forums.autodesk.com/t5/revit-api-forum/incorrect-face-normal/m-p/7108787)\n  Family instance geometry in LCS or WCS\n  Fair59 presents another brilliant solution, reminding me of the lessons learned \n  using [voodoo magic to retrieve global instance edges](http://thebuildingcoder.typepad.com/blog/2016/08/voodoo-magic-retrieves-global-instance-edges.html),\n  including [snooping the family instance geometry](http://thebuildingcoder.typepad.com/blog/2016/08/voodoo-magic-retrieves-global-instance-edges.html#3) and\n  also demonstrated by the [structural concrete setout point add-in](http://thebuildingcoder.typepad.com/blog/2016/08/voodoo-magic-retrieves-global-instance-edges.html#7).\n\n- Another example describing the symptoms well:\n  13047044 [Arcadis DEVR6076 - Revit API pointOnEdge]\n  https://forums.autodesk.com/t5/revit-api-forum/edge-reference-of-a-family-instance/m-p/7088651\n\n- family instance location on custom exporter and GetTransformed\n  11271005 [Issues with Custom Export]\n\n- 09754737 [Retrieval of Picked geometry faces from instance is untransformed?]\n\nPicked Instance Face Geometry in LCS Versus WCS #RevitAPI @AutodeskRevit #bim #dynamobim @AutodeskForge #ForgeDevCon http://bit.ly/pickfacecs\n\nDepending on circumstances, interactively picked family instance geometry may be returned in the global Revit world coordinate system WCS, or in the family instance definition local coordinate system LCS.\nA family instance may have its own non-empty solid, or use the symbol geometry. The symbol geometry requires keeping track of the instance transform to map it to the actual instance project location\n&ndash; Question on Incorrect Face Normal\n&ndash; Working Plane has no Effect\n&ndash; Non-Picked Face Normals are Correct\n&ndash; Solution &ndash; Detecting When to Use LCS versus WCS\n&ndash; Retrieval of Picked Geometry Face from Instance is Untransformed...\n\n--->"
  },
  {
    "original_filename": "1573_family_inst_lcs_wcs",
    "header_text": "Picked Instance Face Geometry in LCS Versus WCS",
    "local_header_href": "#picked-instance-face-geometry-in-lcs-versus-wcs",
    "chunk_text": "### Picked Instance Face Geometry in LCS Versus WCS\n\nA number of people have run into issues retrieving geometry from interactively picked family instances.\n\nDepending on circumstances, the geometry may be returned in the global Revit world coordinate system WCS, or in the family instance definition local coordinate system LCS.\n\nMy first encounter with that effect was\nwhen [retrieving a solid from an element](http://thebuildingcoder.typepad.com/blog/2012/06/obj-model-exporter-take-one.html#7)\nduring the implementation of the OBJ exporter, then expanding that\nto [handle elements with multiple solids](http://thebuildingcoder.typepad.com/blog/2012/07/obj-model-exporter-with-multiple-solid-support.html#3):\n\n> The `GetSolid` helper method retrieves the first non-empty solid found for a given element. In case it is a family instance, it may have its own non-empty solid, in which case we use that. Otherwise we search the symbol geometry. If we use the symbol geometry, we might have to keep track of the instance transform to map it to the actual instance project location. Instead, we ask for transformed geometry to be returned, so the resulting solid is already in place...\n\nI also used this approach in\nthe [structural concrete setout point add-in](http://thebuildingcoder.typepad.com/blog/2016/08/voodoo-magic-retrieves-global-instance-edges.html#7).\n\nThe issue is even more confusing when combined with interactive picking, and keeps coming up from time to  time, most recently in\nthe [Revit API discussion forum](http://forums.autodesk.com/t5/revit-api-forum/bd-p/160) thread on\nan [incorrect face normal](https://forums.autodesk.com/t5/revit-api-forum/incorrect-face-normal/m-p/7108787).\n\nOnce again, Fair59 presented a brilliant solution and explanation of this issue, making use of some of the lessons learned \nusing [Voodoo magic to retrieve global instance edges](http://thebuildingcoder.typepad.com/blog/2016/08/voodoo-magic-retrieves-global-instance-edges.html)\nand [snooping the family instance geometry](http://thebuildingcoder.typepad.com/blog/2016/08/voodoo-magic-retrieves-global-instance-edges.html#3):\n\n- [Question on Incorrect Face Normal](#2)\n- [Working Plane has no Effect](#3)\n- [Non-Picked Face Normals are Correct](#4)\n- [Solution &ndash; Detecting When to Use LCS versus WCS](#5)\n- [Retrieval of Picked Geometry Face from Instance is Untransformed](#6)"
  },
  {
    "original_filename": "1573_family_inst_lcs_wcs",
    "header_text": "<a name=\"2\"></a>Question on Incorrect Face Normal",
    "local_header_href": "#a-name2aquestion-on-incorrect-face-normal",
    "chunk_text": "#### <a name=\"2\"></a>Question on Incorrect Face Normal\n\n**Question:** I created two beams through different codes. Their FamilySymbols are the same. But their left faces' (marked as red in pic) normal are different!\n\n<center>\n<img src=\"img/incorrect_face_normal_test1.png\" alt=\"Incorrect face normal\" width=\"971\">\n</center>\n\nThe face normal of the left beam is the same as I expected, (-1,0,0). \n\nThe face normal of the right beam is wrong and I don't know why. \n\nAttached is my [project](zip/incorrect_face_normal_project1.rvt) for your reference."
  },
  {
    "original_filename": "1573_family_inst_lcs_wcs",
    "header_text": "<a name=\"3\"></a>Working Plane has no Effect",
    "local_header_href": "#a-name3aworking-plane-has-no-effect",
    "chunk_text": "#### <a name=\"3\"></a>Working Plane has no Effect\n\n**Answer:** It seems that one beam is bound to a working plane, and the other one is unbound. Is this intended? This binding can influence the position of the FamilyInstance in WCS.\n\n**Response:** Bounding to a working plane is not my intention.\nBoth beams are created using this method:\n\n<pre>\n  Instance = Doc.Create.NewFamilyInstance( line,\n    FamilySymbol, Level, StructuralType.Beam)\n</pre>\n\nHow can I avoid bounding to a working plane when creating? Why and how would a working plane influence the `FamilyInstance`? If I can't change the way of creating the right beam, how can I get the correct face normal like the left beam? Thanks!\n\n**Answer:** You can try passing null for `Level`. Unfortunately, it's not explicitly mentioned in the documentation, but the `Level` parameter is optional. The beam, after all, it is a family; like every family, it has a local coordinate system. If you bind it to a plane, then its LCS may no longer be identical to WCS; its local Z axis will correspond to the Z axis of the reference plane. What you are seeing is the beam's face normal in LCS; that's why they differ, even if they point in the same WCS direction.\n\n**Response:** I passed null for Level and the right beam was bound to no working plane this time. But both beams' faces' normal are the same as previous."
  },
  {
    "original_filename": "1573_family_inst_lcs_wcs",
    "header_text": "<a name=\"4\"></a>Non-Picked Face Normals are Correct",
    "local_header_href": "#a-name4anon-picked-face-normals-are-correct",
    "chunk_text": "#### <a name=\"4\"></a>Non-Picked Face Normals are Correct\n\n**Answer:** The Revit API documentation `RevitAPI.chm` says this about the **PlanarFace.FaceNormal property**:\n\nThis property is the \"face normal\" vector, and thus should return a vector consistently pointing out of the solid that this face is a boundary for (if it is a part of a solid).\n \nThere is also another method, `Face.ComputeNormal`: It will always be oriented to point out of a solid that contains the face.\n\nI downloaded your sample file and investigated the face normals. For each of the two Elements, there are six sides having `FaceNormal` values as expected, all pointing outwards. Could it be that you compare the faces by index, meaning the first face in the left element's face list is compared to the first face in the second one's face list? The geometry objects are not returned in order but randomized. As far as I can see, there is no problem at all.\n\n**Response:** I understand your points and thank you. Below is my test code to calculate the face normal and snapshot of the result. I was not using index to get the face.\n\n<pre class=\"code\">\n  <span style=\"color:#2b91af;\">Reference</span>&nbsp;refFace&nbsp;=&nbsp;<span style=\"color:blue;\">null</span>;\n  <span style=\"color:blue;\">while</span>(&nbsp;<span style=\"color:blue;\">true</span>&nbsp;)\n  {\n  &nbsp;&nbsp;<span style=\"color:blue;\">try</span>\n  &nbsp;&nbsp;{\n  &nbsp;&nbsp;&nbsp;&nbsp;refFace&nbsp;=&nbsp;sel.PickObject(&nbsp;<span style=\"color:#2b91af;\">ObjectType</span>.Face,\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:#a31515;\">&quot;select&nbsp;a&nbsp;face&quot;</span>&nbsp;);\n   \n  &nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:#2b91af;\">Element</span>&nbsp;selectedElement&nbsp;=&nbsp;doc.GetElement(\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;refFace&nbsp;);\n   \n  &nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:#2b91af;\">GeometryObject</span>&nbsp;selectedGeoObject&nbsp;=&nbsp;selectedElement\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.GetGeometryObjectFromReference(&nbsp;refFace&nbsp;);\n   \n  &nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:#2b91af;\">Face</span>&nbsp;selectedFace&nbsp;=&nbsp;selectedGeoObject&nbsp;<span style=\"color:blue;\">as</span>&nbsp;<span style=\"color:#2b91af;\">Face</span>;\n  &nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:#2b91af;\">PlanarFace</span>&nbsp;selectedPlanarFace&nbsp;=&nbsp;selectedFace&nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">as</span>&nbsp;<span style=\"color:#2b91af;\">PlanarFace</span>;\n   \n  &nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:#2b91af;\">BoundingBoxUV</span>&nbsp;box&nbsp;=&nbsp;selectedFace.GetBoundingBox();\n  &nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:#2b91af;\">UV</span>&nbsp;faceCenter&nbsp;=&nbsp;(&nbsp;box.Max&nbsp;+&nbsp;box.Min&nbsp;)&nbsp;/&nbsp;2;\n   \n  &nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:#2b91af;\">XYZ</span>&nbsp;computedFaceNormal&nbsp;=&nbsp;selectedFace\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.ComputeNormal(&nbsp;faceCenter&nbsp;).Normalize();\n   \n  &nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:#2b91af;\">XYZ</span>&nbsp;faceNormal&nbsp;=&nbsp;selectedPlanarFace.FaceNormal;\n   \n  &nbsp;&nbsp;&nbsp;&nbsp;MessageBox.Show(&nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:#a31515;\">$&quot;computedFaceNormal:&nbsp;</span>{computedFaceNormal.ToString()}<span style=\"color:#a31515;\">,&nbsp;&quot;</span>\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+&nbsp;<span style=\"color:#a31515;\">&quot;faceNormal:&nbsp;{faceNormal.ToString()}&quot;</span>&nbsp;);\n  &nbsp;&nbsp;}\n  &nbsp;&nbsp;<span style=\"color:blue;\">catch</span>(&nbsp;Autodesk.Revit.Exceptions.<span style=\"color:#2b91af;\">OperationCanceledException</span>&nbsp;e&nbsp;)\n  &nbsp;&nbsp;{\n  &nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">return</span>&nbsp;<span style=\"color:#2b91af;\">Result</span>.Cancelled;\n  &nbsp;&nbsp;}\n  }\n</pre>\n\n<center>\n<img src=\"img/incorrect_face_normal_test2.png\" alt=\"Incorrect face normal\" width=\"721\">\n</center>\n\nWhen you say, \"there are six sides having FaceNormal values as expected\", do you mean the left face's normal of the right beam is (-1,0,0)?\n\n**Answer:** Yes. I just read the solid's faces via RevitLookup. For both of the elements, there were six PlanarFaces, each with perfect `FaceNormal` values. May it be that the selection function itself returns a false face? Seems to be the front face instead of the displayed lateral one.\n\n**Response:** I added this code to display the area:\n\n<pre class=\"code\">\n  MessageBox.Show(\n  &nbsp;&nbsp;<span style=\"color:#a31515;\">$&quot;computedFaceNormal:&nbsp;</span>{computedFaceNormal.ToString()}<span style=\"color:#a31515;\">,&nbsp;&quot;</span>\n  &nbsp;&nbsp;+&nbsp;<span style=\"color:#a31515;\">&quot;faceNormal:&nbsp;{faceNormal.ToString()},&nbsp;&quot;</span>\n  &nbsp;&nbsp;+&nbsp;<span style=\"color:#a31515;\">&quot;&nbsp;Area:&nbsp;{selectedFace.Area.ToString()}&quot;</span>&nbsp;);\n</pre>\n\nI tested it again. The area is correct, but the face normal is not.\n\n<center>\n<img src=\"img/incorrect_face_normal_test3.png\" alt=\"Incorrect face normal\" width=\"721\">\n</center>\n\n**Answer:** When getting the solids and their faces, I draw the normals as ModelLines, starting at the faces' centre points:\n\n<center>\n<img src=\"img/incorrect_face_normal_normals.png\" alt=\"Incorrect face normal\" width=\"400\">\n</center>\n\nEverything looks correct, this way.\n \nWhen I pick a face, I get this result with the left one:\n \n<center>\n<img src=\"img/incorrect_face_normal_normals_picked_left.png\" alt=\"Incorrect face normal\" width=\"400\">\n</center>\n\nBut I get this when picking the right one:\n\n<center>\n<img src=\"img/incorrect_face_normal_normals_picked_right.png\" alt=\"Incorrect face normal\" width=\"500\">\n</center>\n\nWhat does it mean ?\n\nIn fact, the face returned is not transformed to the project context.\n\nThe solid resides around the 0/0/0 project origin.\n\nI've drawn the face boundaries, too:\n\n<center>\n<img src=\"img/incorrect_face_normal_normals_picked_rightallsides.png\" alt=\"Incorrect face normal\" width=\"500\">\n</center>\n \nStrange. No idea.\n\n**Response:** I did further investigation. I found that I've added coping on the left beam before picking it. So, when I add coping on the right one it works right! Why?"
  },
  {
    "original_filename": "1573_family_inst_lcs_wcs",
    "header_text": "<a name=\"5\"></a>Solution &ndash; Detecting When to Use LCS versus WCS",
    "local_header_href": "#a-name5asolution-ndash-detecting-when-to-use-lcs-versus-wcs",
    "chunk_text": "#### <a name=\"5\"></a>Solution &ndash; Detecting When to Use LCS versus WCS\n\n**Answer:** Your comment on coping is the last piece of the puzzle.\n\nWhen a family instance is\n\n- cut,\n- joined,\n- coped\n- and (apparently) has been copied\n\nRevit has to calculate the solids of the instance \"in situ\" as it will be different from the solids from the family definition. So, the normal of the face will be relative to the project.\n \nIn all (??) other cases Revit treats the solids as \"instances\" of the solids from the family definition. And by some Revit-logic, when asked for `Face.ComputeNormal`, it gives the normal relative to the family. Quirkier still, it gives the `Face.Origin` in project coordinates.\n \nSo, with family instances that are not cut, joined or coped, you need to transform the faceNormal to project coordinates.\n\nAs you already have a reference to the face, you can easily test for this condition:\n\n<pre class=\"code\">\n  refFace.ConvertToStableRepresentation(&nbsp;doc&nbsp;)\n  &nbsp;&nbsp;.Contains(&nbsp;<span style=\"color:#a31515;\">&quot;INSTANCE&quot;</span>&nbsp;)\n</pre>\n\nSo, add this to your code:\n\n<pre class=\"code\">\n  <span style=\"color:blue;\">if</span>(&nbsp;refFace.ConvertToStableRepresentation(&nbsp;doc&nbsp;)\n  &nbsp;&nbsp;.Contains(&nbsp;<span style=\"color:#a31515;\">&quot;INSTANCE&quot;</span>&nbsp;)&nbsp;)\n  {\n  &nbsp;&nbsp;<span style=\"color:#2b91af;\">Transform</span>&nbsp;trans&nbsp;=&nbsp;(&nbsp;selectedElement&nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">as</span>&nbsp;<span style=\"color:#2b91af;\">FamilyInstance</span>&nbsp;).GetTransform();\n   \n  &nbsp;&nbsp;computedFaceNormal&nbsp;=&nbsp;trans.OfVector(&nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;computedFaceNormal&nbsp;);\n   \n  &nbsp;&nbsp;faceNormal&nbsp;=&nbsp;trans.OfVector(&nbsp;faceNormal&nbsp;);\n  }\n</pre>\n\n**Response:** Classic! Thank you all so much!\n\nEver so many thanks to Fair59 for coming to the rescue once again!\n\n\n<!---"
  },
  {
    "original_filename": "1573_family_inst_lcs_wcs",
    "header_text": "<a name=\"3\"></a>",
    "local_header_href": "#a-name3a",
    "chunk_text": "#### <a name=\"3\"></a>\n\n... getting an [edge reference of a family instance](https://forums.autodesk.com/t5/revit-api-forum/edge-reference-of-a-family-instance/m-p/7115555)\n\n**Question:** I'm trying to create a tool that will host an adaptive component on an edge in the project environment. The tool should prompt for an adaptive family to host and then for the edge to host it on.\n \nI created the following helper method:\n\n<pre class=\"code\">\n  Function HostOnEdge(\n    document As Document,\n    familyTohost As FamilySymbol,\n    edgeReference As Reference,\n    normalizedParameter As Double) As FamilyInstance\n  \n    'create a family instance and get it's adaptive points\n    Dim familyInstance As FamilyInstance = AdaptiveComponentInstanceUtils.CreateAdaptiveComponentInstance(document, familyTohost)\n    Dim placementPoints As IList(Of ElementId) = AdaptiveComponentInstanceUtils.GetInstancePlacementPointElementRefIds(familyInstance)\n  \n    'create reference point\n    Dim location As New PointLocationOnCurve(PointOnCurveMeasurementType.NormalizedCurveParameter, normalizedParameter, PointOnCurveMeasureFrom.Beginning)\n    Dim pointOnEdge As PointOnEdge = document.Application.Create.NewPointOnEdge(edgeReference, location)\n  \n    'attach first adaptive point to ref point\n    Dim firstPoint As ReferencePoint = TryCast(document.GetElement(placementPoints(0)), ReferencePoint)\n    firstPoint.SetPointElementReference(pointOnEdge)\n  \n    Return familyInstance\n  \n  End Function\n</pre>\n\nI then call it from an external command as follows:\n \n<pre class=\"code\">\n  . . .\n  \n  'select family to host\n  Dim selectedElementId As ElementId = UiDocument.Selection.PickObject(Autodesk.Revit.UI.Selection.ObjectType.Element, \"Select Element To Host:\").ElementId\n  \n  'select edge\n  Dim selectedEdge As Reference = UiDocument.Selection.PickObject(Autodesk.Revit.UI.Selection.ObjectType.Edge)\n  \n  'get the selected elements family symbol\n  Dim familyInstance As FamilyInstance = TryCast(Document.GetElement(selectedElementId), FamilyInstance)\n  Dim familySymbol As FamilySymbol = familyInstance.Symbol\n  \n  'create hosted element\n  HostOnEdge(Document, familySymbol, selectedEdge, 0.5)\n  \n  . . .\n</pre>\n\nIf I select a system family like a floor edge or a wall edge as the host it works as expected. (see attached GIF) If i select an edge of a loaded family such as a beam an internal exception is thrown (snippet attached).\n\nAdditionally, if the I pick a loaded family that has been joined/cut/copped in the project the tool works as expected. \n\nWhat is the correct way to create a pointOnEdge on an edge of a family instance?\n\nAttachment  hostExample.gif ‏622 KB\nAttachment  exception.PNG ‏285 KB\n\n\n**Answer:** The cause of your problem is that Revit has two ways of calculating solids, as explained in my answer to\nthe [incorrect face normal](https://forums.autodesk.com/t5/revit-api-forum/incorrect-face-normal/td-p/7108787).\n \nIn this case, I think it's an error in the Revit-API.  The perfect valid EdgeReference ( of the \"SolidInstance\") apparently can't be used in the  firstPoint.SetPointElementReference() method. I say perfect valid, because you can use the EdgeReference for the creation of a Dimension without a problem.\n \nIf you have a familyInstance that is cut, joined (or Coped) your code will work.\n\n**Response:** Thanks for the tip. As suggested if the \"host\" family is joined/cut/copped by another element it works as expected. If not the exception is thrown.\n--->"
  },
  {
    "original_filename": "1573_family_inst_lcs_wcs",
    "header_text": "<a name=\"6\"></a>Retrieval of Picked Geometry Face from Instance is Untransformed",
    "local_header_href": "#a-name6aretrieval-of-picked-geometry-face-from-instance-is-untransformed",
    "chunk_text": "#### <a name=\"6\"></a>Retrieval of Picked Geometry Face from Instance is Untransformed\n\nThe discussion above also helps understand this old case on how to transform picked element face geometry to WCS:\n\n**Question:** I am currently picking faces from geometry that is likely to be inside of a linked DWG file.\n\nFrom the reference, I access the element geometry like this:\n\n<pre class=\"code\">\n  <span style=\"color:#2b91af;\">Element</span>&nbsp;e&nbsp;=&nbsp;<span style=\"color:#2b91af;\">Document</span>.GetElement(&nbsp;reference&nbsp;);\n   \n  <span style=\"color:#2b91af;\">GeometryObject</span>&nbsp;go&nbsp;\n  &nbsp;&nbsp;=&nbsp;e.GetGeometryObjectFromReference(&nbsp;reference&nbsp;);\n</pre>\n\nMy problem is that the faces that are retrieved in this case are not transformed to the instance location.\n\n**Answer:** I would imagine that if the element `e` is an instance, then:\n\n1. You can query it for its geometry.\n2. The geometry will contain a geometry instance.\n3. The transform is provided by the `GeometryInstance.Transform` property.\n\n**Response:** The problem is that I'm trying to select specific faces from within a DWG instance which has hundreds of faces.\n\nSo, while I can get all of the geometry from the element (transformed), I'm not sure if I can figure out which `Reference` or `GeometryObject` matches the selected face.\n\n**Answer:** You can use the `Instance.GetTransform` method. That is at the element level.\n\n**Response:** Yes, `Instance.GetTransform` would return the transform of the instance, but using that with the untransformed face from the pick would require me to transform everything that comes out of the face, such as normals, curvature, evaluated points, triangulation points, etc.\n\nThat sounds like a lot of work!\n\n**Answer:** Unfortunately, I see other option for this. If you are interested in the edges and edge points, the curves can be transformed. The face itself cannot."
  }
]