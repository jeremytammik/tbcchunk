[
  {
    "original_filename": "0491_point_in_poly",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<head>\n<link href=\"bc.css\" rel=\"stylesheet\" type=\"text/css\"/>\n</head>"
  },
  {
    "original_filename": "0491_point_in_poly",
    "header_text": "Point in Polygon Containment Algorithm",
    "local_header_href": "#point-in-polygon-containment-algorithm",
    "chunk_text": "<h3>Point in Polygon Containment Algorithm</h3><p>I have been travelling for two nights and a day now and arrived in Tel Aviv this morning, via snowy London yesterday, ready to prepare for the next conference.\n\n<p>I just had a wonderful cappuccino with an almond croissant and some chocolate truffles for breakfast, a swim in the Mediterranean, and a run along the beach.\nNow I am ready to post again  :-)\n\n<p>One thing that cropped up repeatedly at Autodesk University was the question of determining point containment and 2D polygon intersections independently of Revit.\nIn fact, the request is not independent of Revit, but...\nSome of the geometrical analysis methods provided by the Revit API are not as generic as they might be.\n\n<ul>\n<li>It provides methods to determine whether a given point is located inside a room or space, but not within an area.\n<li>Many of the interesting geometrical methods like Intersect and FindReferencesByDirection do not work on geometry located in linked files.\n<li>It lacks a generic 2D polygon intersection method.\n</li></li></li></ul>\n<p>Besides, I have this unhealthy tendency to always strive for exaggerated independence. \nIt doesn't always make life easier, but it certainly does make it more interesting at times.\nIt also causes occasional fuss and worry.\n\n<p>Anyway, determining whether a 2D point is located within a given 2D polygon is actually very simple, and this is an important instrument to have available in every CAD programmer's toolbox, so why depend on the Revit API implementation when you can roll it yourself?\nIn conjunction with the Revit independent \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2009/02/boolean-operations-for-2d-polygons.html\">\nBoolean operations on 2D polygons</a>, \n\na lot of powerful analysis can be performed on pure geometry both within Revit and exported into some other external container such as a database.\n\n<p>Actually, one discussion we had dealt with a number of linked files representing the architectural, furniture, MEP, and medical equipment in large hospital projects.\nThe relevant geometrical properties of these elements can be systematically encoded in such a way that they can be used as keys in an external database, e.g. using encodings produced similarly to my\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2009/05/nested-instance-geometry.html\">\nXYZ Compare method</a> and \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2009/05/nested-instance-geometry.html\">\nXyzEqualityComparer class</a>.\n\n<p>This can enable us to manage the equipment and other Revit family instances and maintain their relationship with the appropriate rooms, storing their locations, line segments, and boundary polygons in the database so that they can also be used as keys for identification, searching and sorting.\n\n<p>Here is a typical variant of the point containment question:\n\n<p><strong>Question:</strong> How can I find out whether a particular point lies inside a given area element?\n\n<p>I need to retrieve a list of rooms bounded by an area, and figure that the only way to do so is to see if all the vertices of the room in the plan are inside the shape made by the area element.\n\n<p>You could make this more of a generic mathematical question – in a 2D environment, how do I know when a point in space is inside a given polygon?\n\n<p>I attempted to work this out using FindReferencesByDirection.\nIt allows me to cast a ray out and look at intersections, but it only works in a 3D view. \nAn Area Plan is a 2D view.\n\n<p>How would I cast a ray from a Room origin point and analyze intersections with a containing Area?\n\n<p><strong>Answer:</strong> I am sure that you are aware of the fact that you can query whether a given point lies within a room or space. Here is a snippet of the What's New section in the Revit 2011 API help file covering this:\n\n<span style=\"color:darkblue\">\n<h4>Rooms and Spaces</h4>\n<p>The new method Autodesk.Revit.Elements.Room.IsPointInRoom determines if a 3D point is in the volume of a room. \n\n<p>The new method Autodesk.Revit.Elements.Space.IsPointInSpace determines if a 3D point is in the volume of a space. \n\n<p>The new methods Autodesk.Revit.Document. GetRoomAtPoint and GetSpaceAtPoint find the Room or Space that encloses a given 3D point within the project.\n\n<p>The new property Autodesk.Revit.Elements.FamilyInstance.Space allows an API application to determine what in which Space an air terminal or other family instance exists in Revit MEP.\n\n</p></p></p></p></span>\n<p>However, you wish to determine which area a given room resides in, so this does not address your need.\n\n<p>As you say, for abstract 2D geometry, this is a pretty standard basic question. I did once implement an algorithm for this, years ago, in C++.\nFunnily enough, the algorithm is attributed to Kevin Weiler of Autodesk, although I got it from one of the Graphic Gems books.\nMy implementation looks like this.\nTo see the truncated lines in full, please copy and paste to an editor:\n\n<pre class=\"code\">\n<span class=\"green\">//</span>\n<span class=\"green\">// ptinpoly.cpp - check whether point is inside polygon</span>\n<span class=\"green\">//</span>\n<span class=\"green\">// Copyright (C) 1996 by Jeremy Tammik. All rights reserved.</span>\n<span class=\"green\">//</span>\n<span class=\"green\">// Based on C code from the article</span>\n<span class=\"green\">// \"An Incremental Angle Point in Polygon Test\"</span>\n<span class=\"green\">// by Kevin Weiler, kjw@autodesk.com</span>\n<span class=\"green\">// in \"Graphics Gems IV\", Academic Press, 1994</span>\n<span class=\"green\">//</span>\n<span class=\"green\">// 97-11-28:</span>\n<span class=\"green\">//</span>\n<span class=\"green\">// Added code to handle (hopefully) boundaries including</span>\n<span class=\"green\">// circular arc segments. That is based on code from</span>\n<span class=\"green\">// the article \"Point in polygon strategies\" by Eric Haines</span>\n<span class=\"green\">// also in \"Graphics Gems IV\", Academic Press, 1994.</span>\n<span class=\"green\">//</span>\n \n<span class=\"blue\">typedef</span> <span class=\"blue\">int</span> quadrant_type;\n \n<span class=\"green\">//</span>\n<span class=\"green\">// determine the quadrant of a polygon point relative to the test point:</span>\n<span class=\"green\">//</span>\n<span class=\"blue\">inline</span> quadrant_type quadrant( <span class=\"blue\">const</span> RoPoint2d &amp; vertex, <span class=\"blue\">const</span> RoPoint2d &amp; p )\n{\n  <span class=\"blue\">return</span> (vertex.x &gt; p.x)\n    ? ((vertex.y &gt; p.y) ? 0 : 3)\n    : ( (vertex.y &gt; p.y) ? 1 : 2);\n}\n \n<span class=\"green\">//</span>\n<span class=\"green\">// determine x intercept of a polygon edge</span>\n<span class=\"green\">// with a horizontal line at the y value of the test point:</span>\n<span class=\"green\">//</span>\n<span class=\"blue\">inline</span> <span class=\"blue\">double</span> x_intercept( <span class=\"blue\">const</span> RoPoint2d &amp; pt1, <span class=\"blue\">const</span> RoPoint2d &amp; pt2, <span class=\"blue\">double</span> y )\n{\n  <span class=\"green\">//roassert( 0 != (pt1.y - pt2.y) );</span>\n  <span class=\"blue\">return</span> pt2.x - ( (pt2.y - y) * ((pt1.x - pt2.x) / (pt1.y - pt2.y)) );\n}\n \n<span class=\"blue\">static</span> <span class=\"blue\">void</span> adjust_delta(\n  <span class=\"blue\">int</span> &amp; delta,\n  <span class=\"blue\">const</span> RoPoint2d &amp; vertex,\n  <span class=\"blue\">const</span> RoPoint2d &amp; next_vertex,\n  <span class=\"blue\">const</span> RoPoint2d &amp; p )\n{\n  <span class=\"blue\">switch</span>( delta ) {\n      <span class=\"green\">/* make quadrant deltas wrap around */</span>\n    <span class=\"blue\">case</span>  3:  delta = -1; <span class=\"blue\">break</span>;\n    <span class=\"blue\">case</span> -3:  delta =  1; <span class=\"blue\">break</span>;\n      <span class=\"green\">/* check if went around point cw or ccw */</span>\n    <span class=\"blue\">case</span>  2:\n    <span class=\"blue\">case</span> -2:\n      <span class=\"blue\">if</span> (x_intercept(vertex, next_vertex, p.y) &gt; p.x)\n        delta =  - (delta);\n      <span class=\"blue\">break</span>;\n  }\n}\n \n<span class=\"blue\">bool</span> polygonContains(\n  <span class=\"blue\">int</span> nPoints, \n  <span class=\"blue\">const</span> RoPoint2d * polygon, \n  <span class=\"blue\">const</span> RoPoint2d &amp; p )\n{\n  quadrant_type quad, next_quad, delta, angle;\n \n      <span class=\"green\">/* initialize */</span>\n  <span class=\"blue\">const</span> RoPoint2d &amp; vertex = *polygon;\n  quad = quadrant( *polygon, p );\n  angle = 0;\n      <span class=\"green\">/* loop on all vertices of polygon */</span>\n  <span class=\"blue\">for</span>( <span class=\"blue\">int</span> i = 0; i &lt; nPoints; ++i ) {\n    <span class=\"blue\">const</span> RoPoint2d &amp; vertex = polygon[i];\n    <span class=\"blue\">const</span> RoPoint2d &amp; next_vertex = polygon[ (i+1 &lt; nPoints) ? i+1 : 0];\n    <span class=\"green\">/* calculate quadrant and delta from last quadrant */</span>\n    next_quad = quadrant( next_vertex, p );\n    delta = next_quad - quad;\n    adjust_delta( delta, vertex, next_vertex, p );\n    <span class=\"green\">/* add delta to total angle sum */</span>\n    angle = angle + delta;\n    <span class=\"green\">/* increment for next step */</span>\n    quad = next_quad;\n  }\n      <span class=\"green\">/* complete 360 degrees (angle of + 4 or -4 ) means inside */</span>\n  <span class=\"blue\">return</span> (angle == +4) || (angle == -4);\n      <span class=\"green\">/* odd number of windings rule */</span>\n  <span class=\"green\">/* if (angle &amp; 4) return INSIDE; else return OUTSIDE; */</span>\n      <span class=\"green\">/* non-zero winding rule */</span>\n  <span class=\"green\">/* if (angle != 0) return INSIDE; else return OUTSIDE; */</span>\n}\n</pre>\n<p>This code does not show the definition of the 2D point class, but I think all it needs is a simple container for the X and Y coordinates.\n\n<p>For your convenience and out of personal interest, I ported this code to C#, .NET and the Revit UV class.\nThe result looks like this:\n\n<pre class=\"code\">\n<span class=\"blue\">public</span> <span class=\"blue\">class</span> <span class=\"teal\">PointInPoly</span>\n{\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n  <span class=\"gray\">///</span><span class=\"green\"> Determine the quadrant of a polygon vertex </span>\n  <span class=\"gray\">///</span><span class=\"green\"> relative to the test point.</span>\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n  <span class=\"teal\">Quadrant</span> GetQuadrant( <span class=\"teal\">UV</span> vertex, <span class=\"teal\">UV</span> p )\n  {\n    <span class=\"blue\">return</span> ( vertex.U &gt; p.U )\n      ? ( ( vertex.V &gt; p.V ) ? 0 : 3 )\n      : ( ( vertex.V &gt; p.V ) ? 1 : 2 );\n  }\n \n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n  <span class=\"gray\">///</span><span class=\"green\"> Determine the X intercept of a polygon edge </span>\n  <span class=\"gray\">///</span><span class=\"green\"> with a horizontal line at the Y value of the </span>\n  <span class=\"gray\">///</span><span class=\"green\"> test point.</span>\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n  <span class=\"blue\">double</span> X_intercept( <span class=\"teal\">UV</span> p, <span class=\"teal\">UV</span> q, <span class=\"blue\">double</span> y )\n  {\n    <span class=\"teal\">Debug</span>.Assert( 0 != ( p.V - q.V ),\n      <span class=\"maroon\">\"unexpected horizontal segment\"</span> );\n \n    <span class=\"blue\">return</span> q.U\n      - ( ( q.V - y )\n        * ( ( p.U - q.U ) / ( p.V - q.V ) ) );\n  }\n \n  <span class=\"blue\">void</span> AdjustDelta(\n    <span class=\"blue\">ref</span> <span class=\"blue\">int</span> delta,\n    <span class=\"teal\">UV</span> vertex,\n    <span class=\"teal\">UV</span> next_vertex,\n    <span class=\"teal\">UV</span> p )\n  {\n    <span class=\"blue\">switch</span>( delta )\n    {\n      <span class=\"green\">// make quadrant deltas wrap around:</span>\n      <span class=\"blue\">case</span> 3: delta = -1; <span class=\"blue\">break</span>;\n      <span class=\"blue\">case</span> -3: delta = 1; <span class=\"blue\">break</span>;\n      <span class=\"green\">// check if went around point cw or ccw:</span>\n      <span class=\"blue\">case</span> 2:\n      <span class=\"blue\">case</span> -2:\n        <span class=\"blue\">if</span>( X_intercept( vertex, next_vertex, p.V )\n          &gt; p.U )\n        {\n          delta = -delta;\n        }\n        <span class=\"blue\">break</span>;\n    }\n  }\n \n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n  <span class=\"gray\">///</span><span class=\"green\"> Determine whether given 2D point lies within </span>\n  <span class=\"gray\">///</span><span class=\"green\"> the polygon.</span>\n  <span class=\"gray\">///</span><span class=\"green\"> </span>\n  <span class=\"gray\">///</span><span class=\"green\"> Written by Jeremy Tammik, Autodesk, 2009-09-23, </span>\n  <span class=\"gray\">///</span><span class=\"green\"> based on code that I wrote back in 1996 in C++, </span>\n  <span class=\"gray\">///</span><span class=\"green\"> which in turn was based on C code from the </span>\n  <span class=\"gray\">///</span><span class=\"green\"> article \"An Incremental Angle Point in Polygon </span>\n  <span class=\"gray\">///</span><span class=\"green\"> Test\" by Kevin Weiler, Autodesk, in \"Graphics </span>\n  <span class=\"gray\">///</span><span class=\"green\"> Gems IV\", Academic Press, 1994.</span>\n  <span class=\"gray\">///</span><span class=\"green\"> </span>\n  <span class=\"gray\">///</span><span class=\"green\"> Copyright (C) 2009 by Jeremy Tammik. All </span>\n  <span class=\"gray\">///</span><span class=\"green\"> rights reserved.</span>\n  <span class=\"gray\">///</span><span class=\"green\"> </span>\n  <span class=\"gray\">///</span><span class=\"green\"> This code may be freely used. Please preserve </span>\n  <span class=\"gray\">///</span><span class=\"green\"> this comment.</span>\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n  <span class=\"blue\">bool</span> PolygonContains(\n    <span class=\"teal\">UVArray</span> polygon,\n    <span class=\"teal\">UV</span> point )\n  {\n    <span class=\"green\">// initialize</span>\n    <span class=\"teal\">Quadrant</span> quad = GetQuadrant(\n      polygon.get_Item( 0 ), point );\n \n    <span class=\"teal\">Quadrant</span> angle = 0;\n \n    <span class=\"green\">// loop on all vertices of polygon</span>\n    <span class=\"teal\">Quadrant</span> next_quad, delta;\n    <span class=\"blue\">int</span> n = polygon.Size;\n    <span class=\"blue\">for</span>( <span class=\"blue\">int</span> i = 0; i &lt; n; ++i )\n    {\n      <span class=\"teal\">UV</span> vertex = polygon.get_Item( i );\n \n      <span class=\"teal\">UV</span> next_vertex = polygon.get_Item(\n        ( i + 1 &lt; n ) ? i + 1 : 0 );\n \n      <span class=\"green\">// calculate quadrant and delta from last quadrant</span>\n \n      next_quad = GetQuadrant( next_vertex, point );\n      delta = next_quad - quad;\n \n      AdjustDelta(\n        <span class=\"blue\">ref</span> delta, vertex, next_vertex, point );\n \n      <span class=\"green\">// add delta to total angle sum</span>\n      angle = angle + delta;\n \n      <span class=\"green\">// increment for next step</span>\n      quad = next_quad;\n    }\n \n    <span class=\"green\">// complete 360 degrees (angle of + 4 or -4 ) </span>\n    <span class=\"green\">// means inside</span>\n \n    <span class=\"blue\">return</span> ( angle == +4 ) || ( angle == -4 );\n \n    <span class=\"green\">// odd number of windings rule:</span>\n    <span class=\"green\">// if (angle &amp; 4) return INSIDE; else return OUTSIDE;</span>\n    <span class=\"green\">// non-zero winding rule:</span>\n    <span class=\"green\">// if (angle != 0) return INSIDE; else return OUTSIDE;</span>\n  }\n}\n</pre>\n<p>This compiles all right, but I have not tested it yet. I would appreciate if you would set up a sample project, test it, and let me know whether it satisfies your needs. You will need to implement code to extract the boundary polygon of an area, convert it to an abstract geometrical 2D polygon represented by an UVArray, and call PolygonContains with that and a point to test for containment inside the room. I already discussed the \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2008/12/polygon-transformation.html\">\ntransformation of arrays of points between 2D and 3D</a>.\n\n<p>A nice little exercise based on this would be to implement a Revit command that retrieves room, space or area boundaries, feeds them into this algorithm, and verifies that it really does correctly determine the containment of a number of given points in the resulting boundary polygon, as a sort of simplistic\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/11/unit-testing-in-revit.html\">\nunit test</a>.\n\nI would love to implement this myself.\nIf anybody else if faster, please be my guest.\n\n<p>Here is \n\n<a href=\"zip/PointInPoly.zip\">\nPointInPoly.zip</a>\n\ncontaining the entire Visual Studio project implementing the methods listed above.\n</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p>"
  },
  {
    "original_filename": "0491_point_in_poly",
    "header_text": "Rooms and Spaces",
    "local_header_href": "#rooms-and-spaces",
    "chunk_text": "<h4>Rooms and Spaces</h4><p>The new method Autodesk.Revit.Elements.Room.IsPointInRoom determines if a 3D point is in the volume of a room. \n\n<p>The new method Autodesk.Revit.Elements.Space.IsPointInSpace determines if a 3D point is in the volume of a space. \n\n<p>The new methods Autodesk.Revit.Document. GetRoomAtPoint and GetSpaceAtPoint find the Room or Space that encloses a given 3D point within the project.\n\n<p>The new property Autodesk.Revit.Elements.FamilyInstance.Space allows an API application to determine what in which Space an air terminal or other family instance exists in Revit MEP.\n\n</p></p></p></p>"
  }
]