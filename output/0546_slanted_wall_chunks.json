[
  {
    "original_filename": "0546_slanted_wall",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<head>\n<link href=\"bc.css\" rel=\"stylesheet\" type=\"text/css\"/>\n</head>"
  },
  {
    "original_filename": "0546_slanted_wall",
    "header_text": "The FaceWall Class and Slanted Walls",
    "local_header_href": "#the-facewall-class-and-slanted-walls",
    "chunk_text": "<h3>The FaceWall Class and Slanted Walls</h3><p>We have never previously taken looked at the FaceWall class.\nHere is a question on this handled by Joe Ye, which also addresses an old \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2009/02/creating-a-wall-with-a-sloped-profile.html?cid=6a00e553e168978833011571944bd1970b#comment-6a00e553e168978833011571944bd1970b\">\ncomment</a> by \n\nDeric Wallace on \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2009/02/creating-a-wall-with-a-sloped-profile.html\">\ncreating a wall with a sloped profile</a>.\n\nDeric wishes to create a wall like this programmatically:</p><center>\n<img alt=\"Slanted wall\" src=\"img/slanted_wall.png\"/>\n</center><p>This was not easily achievable in Revit 2010.\nThe access to slanted walls is improved in Revit 2011, as we can see from Joe's answer below:\n\n\n<p><strong>Question:</strong> How can I use the API to distinguish a slanted wall from a normal one?\n\n<p>Once I have a slanted wall, how can I determine its angle?</p>\n<center>\n<img alt=\"Slanted wall angle\" src=\"img/slanted_wall2.png\"/>\n</center>\n<p><strong>Answer:</strong> Slanted walls are represented by the FaceWall class, whereas normal walls use the Wall class. \nYou can thus take advantage of the Revit element's .NET class to distinguish between slanted and non-slanted walls.\n\n<p>With regard to getting the angle of a slanted wall, you can determine one of its side faces, calculate the side face's normal vector, and then determine the angle between that and the vertical vector or Z axis (0,0,1):\n\n<center>\n<img alt=\"Slanted wall angle calculation\" src=\"img/slanted_wall3.png\"/>\n</center>\n<p>Now the question remains how to obtain the slanted wall's upside face. \nTo do so, first retrieve the slanted wall solid using its Geometry property. \nThen go through each face of the solid.\nIf the face area times the wall thickness equals the wall volume, and the face normal vector's Z coordinate is positive, then this face is the upside face we are looking for. \n\n<p>As said, we can then calculate the angle between vertical vector (0,0,1) and the upside face's normal to determine the slanted wall angle.\n\n<p>Here is the code to achieve all of this:\n\n<pre class=\"code\">\n<span class=\"blue\">using</span> System;\n<span class=\"blue\">using</span> System.Collections.Generic;\n<span class=\"blue\">using</span> Autodesk.Revit.ApplicationServices;\n<span class=\"blue\">using</span> Autodesk.Revit.Attributes;\n<span class=\"blue\">using</span> Autodesk.Revit.DB;\n<span class=\"blue\">using</span> Autodesk.Revit.UI;\n \n[<span class=\"teal\">TransactionAttribute</span>( <span class=\"teal\">TransactionMode</span>.ReadOnly )]\n[<span class=\"teal\">RegenerationAttribute</span>( <span class=\"teal\">RegenerationOption</span>.Manual )]\n<span class=\"blue\">public</span> <span class=\"blue\">class</span> <span class=\"teal\">GetSlantedWallAndAngle</span> : <span class=\"teal\">IExternalCommand</span>\n{\n  <span class=\"blue\">public</span> <span class=\"teal\">Result</span> Execute( \n    <span class=\"teal\">ExternalCommandData</span> commandData, \n    <span class=\"blue\">ref</span> <span class=\"blue\">string</span> messages, \n    <span class=\"teal\">ElementSet</span> elements )\n  {\n    <span class=\"teal\">UIApplication</span> app = commandData.Application;\n    <span class=\"teal\">Document</span> doc = app.ActiveUIDocument.Document;\n \n    <span class=\"teal\">FilteredElementCollector</span> collector \n      = <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( doc )\n        .OfCategory( <span class=\"teal\">BuiltInCategory</span>.OST_Walls );\n \n    <span class=\"teal\">FaceWall</span> slantedWall = <span class=\"blue\">null</span>;\n \n    <span class=\"blue\">foreach</span>( <span class=\"teal\">Element</span> elem <span class=\"blue\">in</span> collector )\n    {\n      <span class=\"green\">// use the class to identify slanted wall</span>\n \n      <span class=\"blue\">if</span>( elem <span class=\"blue\">is</span> <span class=\"teal\">FaceWall</span> ) \n      {\n        slantedWall = elem <span class=\"blue\">as</span> <span class=\"teal\">FaceWall</span>;\n        <span class=\"blue\">break</span>;\n      }\n    }\n \n    <span class=\"blue\">if</span>( slantedWall == <span class=\"blue\">null</span> )\n    {\n      messages = <span class=\"maroon\">\"There is no slanted wall in this model\"</span>;\n      <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n    }\n \n    <span class=\"green\">// retrieve geometry</span>\n \n    <span class=\"teal\">Options</span> options = app.Application.Create\n      .NewGeometryOptions();\n \n    <span class=\"teal\">GeometryElement</span> geoElement \n      = slantedWall.get_Geometry( options );\n \n    <span class=\"green\">// get the only solid</span>\n \n    <span class=\"teal\">Solid</span> wallSolid = <span class=\"blue\">null</span>;\n \n    <span class=\"blue\">foreach</span>( <span class=\"teal\">GeometryObject</span> geoObject \n      <span class=\"blue\">in</span> geoElement.Objects )\n    {\n      <span class=\"blue\">if</span>( geoObject <span class=\"blue\">is</span> <span class=\"teal\">Solid</span> )\n      {\n        wallSolid = geoObject <span class=\"blue\">as</span> <span class=\"teal\">Solid</span>;\n        <span class=\"blue\">break</span>;\n      }\n    }\n \n    <span class=\"green\">// get the wall width</span>\n \n    <span class=\"teal\">ElementId</span> typeId = slantedWall.GetTypeId();\n \n    <span class=\"teal\">WallType</span> type = doc.get_Element( typeId ) \n      <span class=\"blue\">as</span> <span class=\"teal\">WallType</span>;\n \n    <span class=\"blue\">double</span> dWidth = type.Width;\n \n    <span class=\"blue\">double</span> dTolerance = 0.01;\n    <span class=\"blue\">double</span> dAngle = 0.0;\n    <span class=\"blue\">foreach</span>( <span class=\"teal\">PlanarFace</span> face <span class=\"blue\">in</span> wallSolid.Faces )\n    {\n      <span class=\"blue\">if</span>( dTolerance &gt; <span class=\"teal\">Math</span>.Abs( \n        face.Area * dWidth - wallSolid.Volume ) )\n      {\n        <span class=\"blue\">if</span>( face.Normal.Z &gt; dTolerance )\n        {\n          <span class=\"green\">// calculate the angle</span>\n \n          <span class=\"teal\">XYZ</span> verticalVector = <span class=\"teal\">XYZ</span>.BasisZ;\n \n          dAngle = verticalVector.AngleTo( \n            face.Normal ) * 180 / 3.1415926;\n \n          <span class=\"teal\">TaskDialog</span>.Show( \n            <span class=\"maroon\">\"Slanted wall angle to XOY plane\"</span>, \n            dAngle.ToString() );\n \n          <span class=\"blue\">break</span>;\n        }\n      }\n    }\n    <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Succeeded;\n  }\n}\n</pre>\n<p>Here is the complete Visual Studio code project \n\n<a href=\"zip/slanted_wall.zip\">\nslanted_wall.zip</a>. \n\n<p>Many thanks to Joe for this answer and sample code!\n\n<p>One last-minute idea for a possible enhancement of the filtering code that came to me while editing this post is that since we are searching for walls whose .NET class is FaceWall, the filtering could probably be further optimised by using \n\n<pre class=\"code\">\n  <span class=\"teal\">FilteredElementCollector</span> collector \n    = <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( doc )\n      .OfClass( <span class=\"blue\">typeof</span>( <span class=\"teal\">FaceWall</span> ) )\n      .OfCategory( <span class=\"teal\">BuiltInCategory</span>.OST_Walls );\n</pre>\n<p>Then the explicit iteration after setting up the filter could be avoided.\nMaybe we could even skip the check for the category, since FaceWall instances presumably always will have the OST_Walls built-in category.\nEliminating the category check would probably have an absolutely negligible effect, though.\n</p></p></p></p></p></p></p></p></p></p></p>"
  }
]