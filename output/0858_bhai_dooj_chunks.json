[
  {
    "original_filename": "0858_bhai_dooj",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<head>\n<link href=\"bc.css\" rel=\"stylesheet\" type=\"text/css\"/>\n</head>"
  },
  {
    "original_filename": "0858_bhai_dooj",
    "header_text": "Happy Bhai Dooj!",
    "local_header_href": "#happy-bhai-dooj",
    "chunk_text": "<h3>Happy Bhai Dooj!</h3><p>Happy\n\n<a href=\"http://en.wikipedia.org/wiki/Bhau-beej\">\nBhai Dooj</a> to you!</p><center>\n<img alt=\"Happy Bhai Dooj!\" src=\"img/happy-bhai-dooj.jpg\"/>\n</center><p>This greeting comes from my colleague Sandeep Kumar in\n\n<a href=\"http://en.wikipedia.org/wiki/Bangalore\">Bangalore</a>, who explains:\n\n<p>Bhai Dooj is a festival of prayers from sister to brother, brother's protection for her sister.\nMay we all celebrate this Bhai Dooj with even more love and protection for our sisters and brothers.\nBest wishes on this Bhai Dooj.\n\n<p>Thus fortified, let us turn to a Revit API issue, based on this excerpt from a useful little chat I had yesterday that might be of general use:</p>\n<a name=\"2\"></a>\n<h4>Implementing a Single Command for Multiple Buttons</h4>\n<p><strong>Question:</strong> My external application displays a large number of all kinds of ribbon items.\nNow I thought I might implement one single handler class for all of the external commands these items can trigger, instead of creating a separate one for each.\nI would like to create only one CommandHandler class  derived from IExternalCommand, and decide which function is required in its Execute method.\nThe problem I have is that the ExternalCommandData instance passed in does not provide any information about the source of the event, so there is no way of knowing which RibbonItem was clicked.\nIs there a way to get that information, e.g. retrieve the name of the button clicked or something?\n\n\n<p><strong>Answer:</strong> A good idea. It makes perfect sense. Unfortunately, no, this is not possible.\n\n<p>At least, the Revit API does not give you this access.\nYou might possibly have more luck using .NET\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/automation\">UI Automation</a>.\n\nIt probably provides\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2011/01/subscribing-to-ui-automation-events.html\">UI Automation events</a> that\n\ncan let you find out what button was clicked.</p>\n<p>Using the standard Revit API functionality, you really do have to implement a separate command for each button.\nYou can easily funnel them all into the same handler yourself afterwards, if you like.\nThat would achieve almost what you want.\nImplement a separate command for each button, determine which button was clicked, and then funnel all calls into the same command handler method.\nThe handler method can check the source of the event and branch out again appropriately.\n\n<p><strong>Addendum:</strong> In his comment below, Rudolf Honke points to the very interesting discussion thread on\n\n<a href=\"http://forums.autodesk.com/t5/Autodesk-Revit-API/Which-pushbutton-caused-the-ExternalCommand/td-p/3698908\">\nwhich pushbutton caused the ExternalCommand</a> where\n\n<a href=\"http://forums.autodesk.com/t5/user/viewprofilepage/user-id/1103138\">Revitalizer</a> and\n\n<a href=\"http://forums.autodesk.com/t5/user/viewprofilepage/user-id/774564\">ollikat</a> expound\n\non various alternative solutions, e.g. subscribing to the UIElementActivated event, creating commands at runtime and implementing one single base class inheriting IExternalCommand and other command classes derived from it.\n</p></p></p></p></p></p>"
  },
  {
    "original_filename": "0858_bhai_dooj",
    "header_text": "Implementing a Single Command for Multiple Buttons",
    "local_header_href": "#implementing-a-single-command-for-multiple-buttons",
    "chunk_text": "<h4>Implementing a Single Command for Multiple Buttons</h4><p><strong>Question:</strong> My external application displays a large number of all kinds of ribbon items.\nNow I thought I might implement one single handler class for all of the external commands these items can trigger, instead of creating a separate one for each.\nI would like to create only one CommandHandler class  derived from IExternalCommand, and decide which function is required in its Execute method.\nThe problem I have is that the ExternalCommandData instance passed in does not provide any information about the source of the event, so there is no way of knowing which RibbonItem was clicked.\nIs there a way to get that information, e.g. retrieve the name of the button clicked or something?\n\n\n<p><strong>Answer:</strong> A good idea. It makes perfect sense. Unfortunately, no, this is not possible.\n\n<p>At least, the Revit API does not give you this access.\nYou might possibly have more luck using .NET\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/automation\">UI Automation</a>.\n\nIt probably provides\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2011/01/subscribing-to-ui-automation-events.html\">UI Automation events</a> that\n\ncan let you find out what button was clicked.</p>\n<p>Using the standard Revit API functionality, you really do have to implement a separate command for each button.\nYou can easily funnel them all into the same handler yourself afterwards, if you like.\nThat would achieve almost what you want.\nImplement a separate command for each button, determine which button was clicked, and then funnel all calls into the same command handler method.\nThe handler method can check the source of the event and branch out again appropriately.\n\n<p><strong>Addendum:</strong> In his comment below, Rudolf Honke points to the very interesting discussion thread on\n\n<a href=\"http://forums.autodesk.com/t5/Autodesk-Revit-API/Which-pushbutton-caused-the-ExternalCommand/td-p/3698908\">\nwhich pushbutton caused the ExternalCommand</a> where\n\n<a href=\"http://forums.autodesk.com/t5/user/viewprofilepage/user-id/1103138\">Revitalizer</a> and\n\n<a href=\"http://forums.autodesk.com/t5/user/viewprofilepage/user-id/774564\">ollikat</a> expound\n\non various alternative solutions, e.g. subscribing to the UIElementActivated event, creating commands at runtime and implementing one single base class inheriting IExternalCommand and other command classes derived from it.\n</p></p></p></p>"
  }
]