[
  {
    "original_filename": "0738_melbourne_devlab",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<head>\n<link href=\"bc.css\" rel=\"stylesheet\" type=\"text/css\"/>\n</head>"
  },
  {
    "original_filename": "0738_melbourne_devlab",
    "header_text": "Melbourne DevLab",
    "local_header_href": "#melbourne-devlab",
    "chunk_text": "<h3>Melbourne DevLab</h3><p>The last few days I started walking on foot from Flinder Station to Queen's Road.\nI can enjoy lush green grass, beautiful huge trees and strange birdsong in morning sunlight all the way past the Shrine of Remembrance.\nIt takes just ten minutes longer than waiting for the overfilled noisy slow tram, in which I am forced to stand and therefore can't look out through the windows due to my height.\n\n<p>The Melbourne Revit API training \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2012/03/melbourne-day-one.html\">\nday one</a> and \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2012/03/melbourne-day-two.html\">\nday two</a> were \n\nfollowed by a DevLab.\n\n<p>A DevLab is an open event where developers roll up bringing their current work and issues and continue developing side by side with one or more ADN DevTech engineers, in this case poor old me.\n\n<p>We had three days to play with and achieved some quite exciting and impressive results.\nHere are some of them:\n\n<ul>\n<li>Delete all 3D views.\n<li><a href=\"#1\">Retrieve specific views</a>: GetNicksViews.\n<li>Find unnamed reference planes using a parameter filter.\n<li><a href=\"#2\">Delete reference planes not hosting any elements</a>: DeleteUnnamedNonHostingReferencePlanes.\n<li>Find elements which have had certain information added, so they can be deleted and updated.\n<li><a href=\"#3\">Automatically create setout points</a> for on-site location and construction of structural elements.\n</li></li></li></li></li></li></ul>\n<p>The first couple of items were things I worked on with Nicholas Broadbent of \n\n<a href=\"http://www.coxarchitecture.com.au\">\nCOX Architecture</a>, \n\nwho is also involved in a whole bunch of other exciting projects, such as:\n\n<ul>\n<li>A Navisworks clash detection data importer for Revit.\n<ul>\n<li>Save Navisworks clash detection data into the clashing elements in Revit.\n</li></ul>\n<li>A link between Rhino (using the Grasshopper plug-in) and Revit.\n<ul>\n<li>Draw Revit straight and arced beams from points exported from Rhino.\n<li>Place family instances and adaptive components using the same exported data.\n<li>Avoid using SAT files. A known issue is that they can crash Revit.\n</li></li></li></ul>\n<li>Exporting a Revit model to the Unity Gaming engine.\n<ul>\n<li>Looking up Revit data in an Access database based on a Revit element id.\n<li>Display Revit data in the Unity gaming engine when you click on an element.\n</li></li></ul>\n<li>FBX C++ API\n<ul>\n<li>Modify an FBX file, renaming and merging nodes.\n</li></ul>\n</li></li></li></li></ul>\n<p>The second and third days I spent most of the time together with Paul Hellawell of \n\n<a href=\"http://www.ghd.com\">\nGHD</a> working\n\non a full-blown end-user-capable little application for the automatic creation of setout points for on-site location and construction of structural elements.\nI'll say a little bit about it \n\n<a href=\"#3\">\nbelow</a> and\n\nwe plan to post the full description, add-in and support files sometime soon.\n\n<p>After DevLab, we went off on a visit to a pub or two which is right now starting to turn into a crawl.\nHere are The DevLab Boys at the \n\n<a href=\"http://www.looponline.com.au\">\nLoop</a>:</p>\n<center>\n<img alt=\"The DevLab boys in the Loop\" src=\"file:////j/photo/jeremy/2012/2012-03-23_pub_melbourne/loop_the_devlab_boys.jpg\" width=\"400\"/>\n</center>\n<p>This place calls itself an architectural and experimental space and used to be the venue of \n\n<a href=\"http://www.revic.org.au\">\nRevic</a>, \n\nthe Revit Users Group of Victoria.\n\n<p>From there we moved on to \n\n<a href=\"http://www.theage.com.au/news/bar-reviews/siglo-bar/2008/05/12/1210444319156.html\">\nSiglo</a>, \n\nin the same house as the \n\n<a href=\"http://www.theage.com.au/news/bar-reviews/the-melbourne-supper-club/2006/04/03/1143916451849.html\">\nSupper Club</a> that \n\nI visited \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2012/03/melbourne-day-two.html\">\njust a few days ago</a>:</p>\n<center>\n<img alt=\"Siglo\" src=\"file:////j/photo/jeremy/2012/2012-03-23_pub_melbourne/siglo.jpg\" width=\"400\"/>\n</center>\n<a name=\"1\"></a>\n<h4>Retrieving Specific Views</h4>\n<p>Actually, we have had a couple of beers by now, and both Nick and Paul are enjoying 40 dollar cigars (credit: Nick bought), so I will simply post this with no further comment:\n\n<pre class=\"code\">\n[<span class=\"teal\">Transaction</span>( <span class=\"teal\">TransactionMode</span>.Manual )]\n<span class=\"blue\">public</span> <span class=\"blue\">class</span> <span class=\"teal\">Command</span> : <span class=\"teal\">IExternalCommand</span>\n{\n  <span class=\"blue\">public</span> <span class=\"teal\">Result</span> Execute(\n    <span class=\"teal\">ExternalCommandData</span> commandData,\n    <span class=\"blue\">ref</span> <span class=\"blue\">string</span> message,\n    <span class=\"teal\">ElementSet</span> elements )\n  {\n    <span class=\"teal\">UIApplication</span> uiapp = commandData.Application;\n    <span class=\"teal\">UIDocument</span> uidoc = uiapp.ActiveUIDocument;\n    <span class=\"teal\">Application</span> app = uiapp.Application;\n    <span class=\"teal\">Document</span> doc = uidoc.Document;\n \n    <span class=\"teal\">List</span>&lt;<span class=\"teal\">ElementFilter</span>&gt; a\n      = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">ElementFilter</span>&gt;( 4 );\n \n    a.Add( <span class=\"blue\">new</span> <span class=\"teal\">ElementClassFilter</span>( <span class=\"blue\">typeof</span>( <span class=\"teal\">View3D</span> ) ) );\n    a.Add( <span class=\"blue\">new</span> <span class=\"teal\">ElementClassFilter</span>( <span class=\"blue\">typeof</span>( <span class=\"teal\">ViewDrafting</span> ) ) );\n    a.Add( <span class=\"blue\">new</span> <span class=\"teal\">ElementClassFilter</span>( <span class=\"blue\">typeof</span>( <span class=\"teal\">ViewPlan</span> ) ) );\n    a.Add( <span class=\"blue\">new</span> <span class=\"teal\">ElementClassFilter</span>( <span class=\"blue\">typeof</span>( <span class=\"teal\">ViewSection</span> ) ) );\n \n    <span class=\"teal\">LogicalOrFilter</span> f = <span class=\"blue\">new</span> <span class=\"teal\">LogicalOrFilter</span>( a );\n \n    <span class=\"teal\">FilteredElementCollector</span> col \n      = <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( doc )\n        .WhereElementIsNotElementType()\n        .WherePasses( f );\n \n    <span class=\"blue\">foreach</span>( <span class=\"teal\">View</span> view <span class=\"blue\">in</span> col )\n    {\n      <span class=\"green\">//Debug.WriteLine( view.IsTemplate.ToString() </span>\n      <span class=\"green\">// + \":\" + view.ViewType.ToString() + \":\" </span>\n      <span class=\"green\">// + view.ViewName.ToString() + \":\" </span>\n      <span class=\"green\">// + view.Id.ToString() );</span>\n \n      <span class=\"teal\">Debug</span>.Print( \n        <span class=\"maroon\">\"{0} : {1} : {2} : {3}\"</span>,\n        view.IsTemplate, view.ViewType, \n        view.ViewName, view.Id );\n \n      <span class=\"blue\">if</span>( !view.IsTemplate ) \n      {\n        <span class=\"green\">// . . .</span>\n      }\n    }\n \n    <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Succeeded;\n  }\n}\n</pre>\n<a name=\"2\"></a>\n<h4>Delete Reference Planes Not Hosting Any Elements</h4>\n<p>A complex model can contain a pretty huge number of useless reference planes.\n\n<p>Nick proposed deleting all reference planes that \n\n<ol type=\"a\">\n<li>Have not been assigned a name, and\n<li>Do not host any elements.\n</li></li></ol>\n<p>To maximise performance, we use a parameter filter to check that the reference plane name is non-empty.\nThat is about twice as efficient as just filtering for all reference planes and then using LINQ or an explicit loop in .NET to check for a non-empty name.\n\n<p>Once we have found all the reference planes with a non-empty name, we need to check for each whether it hosts any elements.\nThis topic has been covered several times in the past, e.g. looking for \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/03/object-relationships.html\">\ngeneric object relationships</a> (also\n\navailable for \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/03/object-relationships-in-vb.html\">\nVB</a>).\n\n<p>The simplest approach that I am aware of is to delete it and check the number of element returned by the Delete method.\nThis list should include at least the element id of the reference plane itself, if the deletion succeeded.\nIf its length is larger than one, other elements were affected, which in this case probably means that they were hosted by the plane.\n\n<p>So, if the number of deleted elements equals one, we are happy and have deleted a reference plane hosting no other elements.\nIf the number is larger than one, it probably hosts something.\nIn that case, we can simply abort the transaction to undo the deletion attempt.\n\n<p>The deletion including the commit or rollback is achieved by the DeleteIfNotHosting method:\n\n<pre class=\"code\">\n<span class=\"blue\">bool</span> DeleteIfNotHosting( <span class=\"teal\">ReferencePlane</span> rp )\n{\n  <span class=\"blue\">bool</span> rc = <span class=\"blue\">false</span>;\n \n  <span class=\"teal\">Document</span> doc = rp.Document;\n \n  <span class=\"teal\">Transaction</span> tx = <span class=\"blue\">new</span> <span class=\"teal\">Transaction</span>( doc );\n \n  tx.Start( <span class=\"maroon\">\"Delete ReferencePlane \"</span> \n    + (++_i).ToString() );\n \n  <span class=\"green\">// Deletion simply fails if the reference plane </span>\n  <span class=\"green\">// hosts anything. If so, the return value ids </span>\n  <span class=\"green\">// is null:</span>\n \n  <span class=\"teal\">ICollection</span>&lt;<span class=\"teal\">ElementId</span>&gt; ids = doc.Delete( rp );\n \n  <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == ids || 1 &lt; ids.Count )\n  {\n    tx.RollBack();\n  }\n  <span class=\"blue\">else</span>\n  {\n    tx.Commit();\n    rc = <span class=\"blue\">true</span>;\n  }\n  <span class=\"blue\">return</span> rc;\n}\n</pre>\n<p>If you look carefully, you'll notice that we number the transactions that we generate so that they can be differentiated in the user interface undo list.\n\n<p>Actually, during debugging, I noticed that the deletion simply fails if the reference plane is hosting any elements, so the approach that I originally envisaged is not working.\nHowever, the failed deletion attempt returns a null collection of element ids instead of one containing more than one element.\nI added the null check and roll back the transaction in that case also, and all is fine.\n\n<p>Since the deletion fails anyway for a reference plane hosting anything, we could just as well commit the transaction, I suppose, but I prefer to roll it back.\nGiven more time to play, I could check which is faster or uses less resources, rolling back or committing.\nIn AutoCAD ObjectARX, rolling back is significantly more expensive than committing, but I assume that is a special case.\n\n<p>This method is driven by the mainline Execute method which implements the parameter filtering for non-empty reference plane names:\n\n<pre class=\"code\">\n  <span class=\"blue\">public</span> <span class=\"teal\">Result</span> Execute(\n    <span class=\"teal\">ExternalCommandData</span> commandData,\n    <span class=\"blue\">ref</span> <span class=\"blue\">string</span> message,\n    <span class=\"teal\">ElementSet</span> elements )\n  {\n    <span class=\"teal\">UIApplication</span> uiapp = commandData.Application;\n    <span class=\"teal\">UIDocument</span> uidoc = uiapp.ActiveUIDocument;\n    <span class=\"teal\">Application</span> app = uiapp.Application;\n    <span class=\"teal\">Document</span> doc = uidoc.Document;\n \n    <span class=\"green\">// Construct a parameter filter to get only </span>\n    <span class=\"green\">// unnamed reference planes, i.e. reference </span>\n    <span class=\"green\">// planes whose name equals the empty string:</span>\n \n    <span class=\"teal\">BuiltInParameter</span> bip\n      = <span class=\"teal\">BuiltInParameter</span>.DATUM_TEXT;\n \n    <span class=\"teal\">ParameterValueProvider</span> provider\n      = <span class=\"blue\">new</span> <span class=\"teal\">ParameterValueProvider</span>(\n        <span class=\"blue\">new</span> <span class=\"teal\">ElementId</span>( bip ) );\n \n    <span class=\"teal\">FilterStringRuleEvaluator</span> evaluator \n      = <span class=\"blue\">new</span> <span class=\"teal\">FilterStringEquals</span>();\n \n    <span class=\"teal\">FilterStringRule</span> rule = <span class=\"blue\">new</span> <span class=\"teal\">FilterStringRule</span>(\n      provider, evaluator, <span class=\"maroon\">\"\"</span>, <span class=\"blue\">false</span> );\n \n    <span class=\"teal\">ElementParameterFilter</span> filter\n      = <span class=\"blue\">new</span> <span class=\"teal\">ElementParameterFilter</span>( rule );\n \n    <span class=\"teal\">FilteredElementCollector</span> col \n      = <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( doc )\n        .OfClass( <span class=\"blue\">typeof</span>( <span class=\"teal\">ReferencePlane</span> ) )\n        .WherePasses( filter );\n \n    <span class=\"blue\">int</span> n = 0;\n    <span class=\"blue\">int</span> nDeleted = 0;\n \n    <span class=\"green\">// No need to cast ... this is pretty nifty,</span>\n    <span class=\"green\">// I find ... grab the elements as ReferencePlane</span>\n    <span class=\"green\">// instances, since the filter guarantees that </span>\n    <span class=\"green\">// only ReferencePlane instances are selected.</span>\n \n    <span class=\"blue\">foreach</span>( <span class=\"teal\">ReferencePlane</span> rp <span class=\"blue\">in</span> col )\n    {\n      ++n;\n      nDeleted += DeleteIfNotHosting( rp ) ? 1 : 0;\n    }\n \n    <span class=\"teal\">Debug</span>.Print( \n      <span class=\"maroon\">\"{0} unnamed reference plane{1} examined, {2} of them were deleted.\"</span>,\n      n, (1==n?<span class=\"maroon\">\"\"</span>:<span class=\"maroon\">\"s\"</span>), nDeleted );\n \n    <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Succeeded;\n  }\n}\n</pre>\n<p>Here is \n\n<a <=\"\" a=\"\" href=\"zip/DeleteUnnamedNonHostingReferencePlanes.zip\"> containing\n\nthe source code, manifest file, and Visual Studio solution.\n\n\n<a name=\"3\"></a>\n<h4>Automatic Setout Points</h4>\n<p>Why are we doing this?\n\n<p>It has been known to mankind for the following kind of situation to occur:\n\n<p>A large complex structure is constructed off-site.\nWhen assembled on site, it does not fit.\nThe workers continue nonetheless and force it into place.\nThe error is discovered later and corrected using brute force and post adaption.\nOverall cost of exercise: several days of delay and tens of thousands in cost overruns.\n\n<p>Here is Paul's description of this:\n\n<p><strong>The Challenge:</strong> Provide a way to find the real world coordinates, for the corners of potential elements we want to set out in the field, automatically from the model. \nIn this example, concrete structural elements. \nIdeally display these points in a Revit schedule, so that they can be formatted and placed on a drawing sheet. \nThen define which of the points could be used as set out points list them in a schedule, preferably numbered sequentially for readability.\n\n<p><strong>In Practice:</strong> Initially we could get the points listing, all from the API, but transferring this information into a schedule proved to be not possible. \nInstead we created a family that contained shared parameters to hold the data we required for scheduling. \nThen we place the created family at the points we have extracted from the geometry. \nThrough the API it is then possible to populate the parameters with the X, Y, Z coordinates we have extracted from the geometry, and then add these values to the extracted project location, to convert the values to real world coordinates.\n\n<p>Initially one type was used in the set out point family. \nHowever this did not enable the ability to select which points we want as scheduled set out points. \nFor this two types were created within the family, SetoutPoint_Major and SetoutPoint_Minor. \nThis allowed two separate schedules to be created, one capturing all the points, another to capture points defined as major points for use on a drawing sheet for set out. \nThe 'all points' schedule is useful for export to a CSV file for import into a surveying device such as a \n\n<a href=\"http://www.trimble.com\">\nTrimble</a>\n\nallowing site set-out directly from the model.\n\n<p>To be continued...\n\n<!--\n\n<h5>Nitty-Gritty</h5>\n\n<p>The setout point add-in performs the following steps:\n\n<ul>\n<li>Select all structural elements of interest in the model.\n<li>Extract and analyse their geometry.\n<li>Automatically define setout points based on the geometry analysis and place family instances to mark all of them.\n<li>Support manual marking of key setout points, to differentiate the (few) important major ones from the (many) less important minor ones.\n<li>Implement the setout point family definition.\n<li>Create Revit schedules listing all minor and key setout points for export to CSV, automatic trimble point population, on-site viewing.\n\n<li>apply project location transform as described in \n\nhttp://thebuildingcoder.typepad.com/blog/2010/01/project-location.html\n\n</ul>\n\n<p>It populates the following shared parameters which are used to create the schedules:\n\n<ul>\n<li>Key_Setout_Point\n<li>Host_Type\n<li>Host_Id \n<li>Point_Number\n<li>X\n<li>Y\n<li>Z\n</ul>\n\n<p>We classify the possible setup point host geometry types that we support.\nThe host types are one of the following:\n\n<pre class=\"code\">\n&nbsp; <span class=\"blue\">enum</span> <span class=\"teal\">HostType</span>\n&nbsp; {\n&nbsp; &nbsp; Floors,\n&nbsp; &nbsp; Ramps,\n&nbsp; &nbsp; StructuralColumns,\n&nbsp; &nbsp; StructuralFraming,\n&nbsp; &nbsp; StructuralFoundations,\n&nbsp; &nbsp; Walls\n&nbsp; }\n</pre>\n\n<p>This is what the schedule ends up looking like this, ready to be sent and used on-site:</p>\n\n<center>\n<img src=\"img/\" alt=\"\"/>\n</center>\n\n\n<ul>\n<li><a href=\"zip/shared_parameters.txt\">shared_parameters.txt</a>, the shared parameter definition file.\n<li><a href=\"zip/SetoutPoint2012.rfa\">SetoutPoint2012.rfa</a>, the setout point family file including the relevant shared parameter definitions.\n<li><a href=\"\"></a> \n<li><a href=\"\"></a> \n</ul>\n\n\nwe calculate all setout points on structural concrete geometry\n\nwe thought to schedule these points directly, but cannot add more than one X, Y, Z shared param per element\n\nsolution: create setout point family instances for each individual setout point and use those for scheduling\n\nyou could actually use DMU to regen the points automatically every time the geometry changes, but easier might be to regenerate the whole thing each time you need it and delete them immediately afterwards\n\nC:\\tmp\\Revit\\SetoutPoints\\test\\rst_basic_sample_project_with_location.rvt\n\nSchedule setout points.\n\nWe calculate all setout points on structural concrete geometry.\n\nWe thought to schedule these points directly, but cannot add more than one X, Y, Z shared parameter per element.\n\nSolution: create setout point family instances for each individual setout point and use those for scheduling.\n\nYou could actually use DMU to regenerate the points automatically every time the geometry changes, but easier might be to regenerate the whole thing each time you need it and delete them immediately afterwards\n\n    /// <summary>\n    /// Classify the possible setup point \n    /// host geometry types that support.\n    /// </summary>\n    enum HostType\n    {\n      Floors,\n      Ramps,\n      StructuralColumns,\n      StructuralFraming,\n      StructuralFoundations,\n      Walls\n    }\n\nReturn all the \"corner\" vertices of a given solid. Note that a circle in Revit consists of two arcs and will return a \"corner\" at each of the two arc end points.\n\nRetrieve all structural elements that we are interested in using to define setout points. We are looking at concrete for the moment. This includes: columns, framing, floors, foundations, ramps, walls. \n\nShared parameter GUIDs retrieved from the shared parameter file.\n\nObserve the project location transform.\n\nTwo symbols, major (key) and minor. Expecting major (key) setout point first, minor setout point second.\n\nRetrieve the first non-empty solid found for the given element. In case the element is a family instance, it may have its own non-empty solid, in which case we use that. Otherwise we search the symbol geometry. If we use the symbol geometry, we have to keep track of the instance transform to map it to the actual instance project location.\n\nSome columns have no solids, and we have to retrieve the geometry from the symbol; others do have solids on the instance itself and no contents in he instance geometry (e.g. in rst_basic_sample_project.rvt).\n\nRenumber key setout points. We remove the \"SOP\" prefix and restart numbering from one.\n\nFilter for key setout points. They are family instances with the generic model category whose Key_Setout_Point shared parameter is set to true. \n\nTo get the key points only, we initially set up a parameter filter. For that, we need a parameter definition to set up the parameter filter.\n\nLater, we decided to switch type when we promote a setout point to a major or key point, so there is no need to filter for a parameter value at all; we can just filter for the major setout point type instead.\n\n\n\n<ul>\n<li>\n</ul>\n\n\n<a href=\"\">\n</a> \n\n\n<center>\n<img src=\"img/\" alt=\"\"/>\n</center>\n\n<hr>\n\n<pre class=\"code\">\n</pre>\n\n<a name=\"\"></a>\n\n<h4></h4>\n\n<a href=\"\">\n</a> \n\n<a name=\"3\"></a>\n\n<h4>Determine Revit Demo Mode</h4>\n\n<p>Rudolf Honke \n\n<a href=\"\">\ncommented</a> on \n\nthe approach I suggested to \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2012/03/determine-revit-demo-mode.html\">\ndetermine-revit-demo-mode</a> and\n\nproposed using the OptionalFunctionalityUtils IsDWGExportAvailable method instead of using my much more complex try-catch method.\n\n<p>This method is documented to check whether the DWG export functionality is available in the installed version of Revit. \nThe DWG export requires presence of certain modules that are optional and may not be part of the installed Revit. \n-->\n</p></p></p></p></p></p></p></p></a></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p>"
  },
  {
    "original_filename": "0738_melbourne_devlab",
    "header_text": "Retrieving Specific Views",
    "local_header_href": "#retrieving-specific-views",
    "chunk_text": "<h4>Retrieving Specific Views</h4><p>Actually, we have had a couple of beers by now, and both Nick and Paul are enjoying 40 dollar cigars (credit: Nick bought), so I will simply post this with no further comment:\n\n<pre class=\"code\">\n[<span class=\"teal\">Transaction</span>( <span class=\"teal\">TransactionMode</span>.Manual )]\n<span class=\"blue\">public</span> <span class=\"blue\">class</span> <span class=\"teal\">Command</span> : <span class=\"teal\">IExternalCommand</span>\n{\n  <span class=\"blue\">public</span> <span class=\"teal\">Result</span> Execute(\n    <span class=\"teal\">ExternalCommandData</span> commandData,\n    <span class=\"blue\">ref</span> <span class=\"blue\">string</span> message,\n    <span class=\"teal\">ElementSet</span> elements )\n  {\n    <span class=\"teal\">UIApplication</span> uiapp = commandData.Application;\n    <span class=\"teal\">UIDocument</span> uidoc = uiapp.ActiveUIDocument;\n    <span class=\"teal\">Application</span> app = uiapp.Application;\n    <span class=\"teal\">Document</span> doc = uidoc.Document;\n \n    <span class=\"teal\">List</span>&lt;<span class=\"teal\">ElementFilter</span>&gt; a\n      = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">ElementFilter</span>&gt;( 4 );\n \n    a.Add( <span class=\"blue\">new</span> <span class=\"teal\">ElementClassFilter</span>( <span class=\"blue\">typeof</span>( <span class=\"teal\">View3D</span> ) ) );\n    a.Add( <span class=\"blue\">new</span> <span class=\"teal\">ElementClassFilter</span>( <span class=\"blue\">typeof</span>( <span class=\"teal\">ViewDrafting</span> ) ) );\n    a.Add( <span class=\"blue\">new</span> <span class=\"teal\">ElementClassFilter</span>( <span class=\"blue\">typeof</span>( <span class=\"teal\">ViewPlan</span> ) ) );\n    a.Add( <span class=\"blue\">new</span> <span class=\"teal\">ElementClassFilter</span>( <span class=\"blue\">typeof</span>( <span class=\"teal\">ViewSection</span> ) ) );\n \n    <span class=\"teal\">LogicalOrFilter</span> f = <span class=\"blue\">new</span> <span class=\"teal\">LogicalOrFilter</span>( a );\n \n    <span class=\"teal\">FilteredElementCollector</span> col \n      = <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( doc )\n        .WhereElementIsNotElementType()\n        .WherePasses( f );\n \n    <span class=\"blue\">foreach</span>( <span class=\"teal\">View</span> view <span class=\"blue\">in</span> col )\n    {\n      <span class=\"green\">//Debug.WriteLine( view.IsTemplate.ToString() </span>\n      <span class=\"green\">// + \":\" + view.ViewType.ToString() + \":\" </span>\n      <span class=\"green\">// + view.ViewName.ToString() + \":\" </span>\n      <span class=\"green\">// + view.Id.ToString() );</span>\n \n      <span class=\"teal\">Debug</span>.Print( \n        <span class=\"maroon\">\"{0} : {1} : {2} : {3}\"</span>,\n        view.IsTemplate, view.ViewType, \n        view.ViewName, view.Id );\n \n      <span class=\"blue\">if</span>( !view.IsTemplate ) \n      {\n        <span class=\"green\">// . . .</span>\n      }\n    }\n \n    <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Succeeded;\n  }\n}\n</pre>\n<a name=\"2\"></a>\n<h4>Delete Reference Planes Not Hosting Any Elements</h4>\n<p>A complex model can contain a pretty huge number of useless reference planes.\n\n<p>Nick proposed deleting all reference planes that \n\n<ol type=\"a\">\n<li>Have not been assigned a name, and\n<li>Do not host any elements.\n</li></li></ol>\n<p>To maximise performance, we use a parameter filter to check that the reference plane name is non-empty.\nThat is about twice as efficient as just filtering for all reference planes and then using LINQ or an explicit loop in .NET to check for a non-empty name.\n\n<p>Once we have found all the reference planes with a non-empty name, we need to check for each whether it hosts any elements.\nThis topic has been covered several times in the past, e.g. looking for \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/03/object-relationships.html\">\ngeneric object relationships</a> (also\n\navailable for \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/03/object-relationships-in-vb.html\">\nVB</a>).\n\n<p>The simplest approach that I am aware of is to delete it and check the number of element returned by the Delete method.\nThis list should include at least the element id of the reference plane itself, if the deletion succeeded.\nIf its length is larger than one, other elements were affected, which in this case probably means that they were hosted by the plane.\n\n<p>So, if the number of deleted elements equals one, we are happy and have deleted a reference plane hosting no other elements.\nIf the number is larger than one, it probably hosts something.\nIn that case, we can simply abort the transaction to undo the deletion attempt.\n\n<p>The deletion including the commit or rollback is achieved by the DeleteIfNotHosting method:\n\n<pre class=\"code\">\n<span class=\"blue\">bool</span> DeleteIfNotHosting( <span class=\"teal\">ReferencePlane</span> rp )\n{\n  <span class=\"blue\">bool</span> rc = <span class=\"blue\">false</span>;\n \n  <span class=\"teal\">Document</span> doc = rp.Document;\n \n  <span class=\"teal\">Transaction</span> tx = <span class=\"blue\">new</span> <span class=\"teal\">Transaction</span>( doc );\n \n  tx.Start( <span class=\"maroon\">\"Delete ReferencePlane \"</span> \n    + (++_i).ToString() );\n \n  <span class=\"green\">// Deletion simply fails if the reference plane </span>\n  <span class=\"green\">// hosts anything. If so, the return value ids </span>\n  <span class=\"green\">// is null:</span>\n \n  <span class=\"teal\">ICollection</span>&lt;<span class=\"teal\">ElementId</span>&gt; ids = doc.Delete( rp );\n \n  <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == ids || 1 &lt; ids.Count )\n  {\n    tx.RollBack();\n  }\n  <span class=\"blue\">else</span>\n  {\n    tx.Commit();\n    rc = <span class=\"blue\">true</span>;\n  }\n  <span class=\"blue\">return</span> rc;\n}\n</pre>\n<p>If you look carefully, you'll notice that we number the transactions that we generate so that they can be differentiated in the user interface undo list.\n\n<p>Actually, during debugging, I noticed that the deletion simply fails if the reference plane is hosting any elements, so the approach that I originally envisaged is not working.\nHowever, the failed deletion attempt returns a null collection of element ids instead of one containing more than one element.\nI added the null check and roll back the transaction in that case also, and all is fine.\n\n<p>Since the deletion fails anyway for a reference plane hosting anything, we could just as well commit the transaction, I suppose, but I prefer to roll it back.\nGiven more time to play, I could check which is faster or uses less resources, rolling back or committing.\nIn AutoCAD ObjectARX, rolling back is significantly more expensive than committing, but I assume that is a special case.\n\n<p>This method is driven by the mainline Execute method which implements the parameter filtering for non-empty reference plane names:\n\n<pre class=\"code\">\n  <span class=\"blue\">public</span> <span class=\"teal\">Result</span> Execute(\n    <span class=\"teal\">ExternalCommandData</span> commandData,\n    <span class=\"blue\">ref</span> <span class=\"blue\">string</span> message,\n    <span class=\"teal\">ElementSet</span> elements )\n  {\n    <span class=\"teal\">UIApplication</span> uiapp = commandData.Application;\n    <span class=\"teal\">UIDocument</span> uidoc = uiapp.ActiveUIDocument;\n    <span class=\"teal\">Application</span> app = uiapp.Application;\n    <span class=\"teal\">Document</span> doc = uidoc.Document;\n \n    <span class=\"green\">// Construct a parameter filter to get only </span>\n    <span class=\"green\">// unnamed reference planes, i.e. reference </span>\n    <span class=\"green\">// planes whose name equals the empty string:</span>\n \n    <span class=\"teal\">BuiltInParameter</span> bip\n      = <span class=\"teal\">BuiltInParameter</span>.DATUM_TEXT;\n \n    <span class=\"teal\">ParameterValueProvider</span> provider\n      = <span class=\"blue\">new</span> <span class=\"teal\">ParameterValueProvider</span>(\n        <span class=\"blue\">new</span> <span class=\"teal\">ElementId</span>( bip ) );\n \n    <span class=\"teal\">FilterStringRuleEvaluator</span> evaluator \n      = <span class=\"blue\">new</span> <span class=\"teal\">FilterStringEquals</span>();\n \n    <span class=\"teal\">FilterStringRule</span> rule = <span class=\"blue\">new</span> <span class=\"teal\">FilterStringRule</span>(\n      provider, evaluator, <span class=\"maroon\">\"\"</span>, <span class=\"blue\">false</span> );\n \n    <span class=\"teal\">ElementParameterFilter</span> filter\n      = <span class=\"blue\">new</span> <span class=\"teal\">ElementParameterFilter</span>( rule );\n \n    <span class=\"teal\">FilteredElementCollector</span> col \n      = <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( doc )\n        .OfClass( <span class=\"blue\">typeof</span>( <span class=\"teal\">ReferencePlane</span> ) )\n        .WherePasses( filter );\n \n    <span class=\"blue\">int</span> n = 0;\n    <span class=\"blue\">int</span> nDeleted = 0;\n \n    <span class=\"green\">// No need to cast ... this is pretty nifty,</span>\n    <span class=\"green\">// I find ... grab the elements as ReferencePlane</span>\n    <span class=\"green\">// instances, since the filter guarantees that </span>\n    <span class=\"green\">// only ReferencePlane instances are selected.</span>\n \n    <span class=\"blue\">foreach</span>( <span class=\"teal\">ReferencePlane</span> rp <span class=\"blue\">in</span> col )\n    {\n      ++n;\n      nDeleted += DeleteIfNotHosting( rp ) ? 1 : 0;\n    }\n \n    <span class=\"teal\">Debug</span>.Print( \n      <span class=\"maroon\">\"{0} unnamed reference plane{1} examined, {2} of them were deleted.\"</span>,\n      n, (1==n?<span class=\"maroon\">\"\"</span>:<span class=\"maroon\">\"s\"</span>), nDeleted );\n \n    <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Succeeded;\n  }\n}\n</pre>\n<p>Here is \n\n<a <=\"\" a=\"\" href=\"zip/DeleteUnnamedNonHostingReferencePlanes.zip\"> containing\n\nthe source code, manifest file, and Visual Studio solution.\n\n\n<a name=\"3\"></a>\n<h4>Automatic Setout Points</h4>\n<p>Why are we doing this?\n\n<p>It has been known to mankind for the following kind of situation to occur:\n\n<p>A large complex structure is constructed off-site.\nWhen assembled on site, it does not fit.\nThe workers continue nonetheless and force it into place.\nThe error is discovered later and corrected using brute force and post adaption.\nOverall cost of exercise: several days of delay and tens of thousands in cost overruns.\n\n<p>Here is Paul's description of this:\n\n<p><strong>The Challenge:</strong> Provide a way to find the real world coordinates, for the corners of potential elements we want to set out in the field, automatically from the model. \nIn this example, concrete structural elements. \nIdeally display these points in a Revit schedule, so that they can be formatted and placed on a drawing sheet. \nThen define which of the points could be used as set out points list them in a schedule, preferably numbered sequentially for readability.\n\n<p><strong>In Practice:</strong> Initially we could get the points listing, all from the API, but transferring this information into a schedule proved to be not possible. \nInstead we created a family that contained shared parameters to hold the data we required for scheduling. \nThen we place the created family at the points we have extracted from the geometry. \nThrough the API it is then possible to populate the parameters with the X, Y, Z coordinates we have extracted from the geometry, and then add these values to the extracted project location, to convert the values to real world coordinates.\n\n<p>Initially one type was used in the set out point family. \nHowever this did not enable the ability to select which points we want as scheduled set out points. \nFor this two types were created within the family, SetoutPoint_Major and SetoutPoint_Minor. \nThis allowed two separate schedules to be created, one capturing all the points, another to capture points defined as major points for use on a drawing sheet for set out. \nThe 'all points' schedule is useful for export to a CSV file for import into a surveying device such as a \n\n<a href=\"http://www.trimble.com\">\nTrimble</a>\n\nallowing site set-out directly from the model.\n\n<p>To be continued...\n\n<!--\n\n<h5>Nitty-Gritty</h5>\n\n<p>The setout point add-in performs the following steps:\n\n<ul>\n<li>Select all structural elements of interest in the model.\n<li>Extract and analyse their geometry.\n<li>Automatically define setout points based on the geometry analysis and place family instances to mark all of them.\n<li>Support manual marking of key setout points, to differentiate the (few) important major ones from the (many) less important minor ones.\n<li>Implement the setout point family definition.\n<li>Create Revit schedules listing all minor and key setout points for export to CSV, automatic trimble point population, on-site viewing.\n\n<li>apply project location transform as described in \n\nhttp://thebuildingcoder.typepad.com/blog/2010/01/project-location.html\n\n</ul>\n\n<p>It populates the following shared parameters which are used to create the schedules:\n\n<ul>\n<li>Key_Setout_Point\n<li>Host_Type\n<li>Host_Id \n<li>Point_Number\n<li>X\n<li>Y\n<li>Z\n</ul>\n\n<p>We classify the possible setup point host geometry types that we support.\nThe host types are one of the following:\n\n<pre class=\"code\">\n&nbsp; <span class=\"blue\">enum</span> <span class=\"teal\">HostType</span>\n&nbsp; {\n&nbsp; &nbsp; Floors,\n&nbsp; &nbsp; Ramps,\n&nbsp; &nbsp; StructuralColumns,\n&nbsp; &nbsp; StructuralFraming,\n&nbsp; &nbsp; StructuralFoundations,\n&nbsp; &nbsp; Walls\n&nbsp; }\n</pre>\n\n<p>This is what the schedule ends up looking like this, ready to be sent and used on-site:</p>\n\n<center>\n<img src=\"img/\" alt=\"\"/>\n</center>\n\n\n<ul>\n<li><a href=\"zip/shared_parameters.txt\">shared_parameters.txt</a>, the shared parameter definition file.\n<li><a href=\"zip/SetoutPoint2012.rfa\">SetoutPoint2012.rfa</a>, the setout point family file including the relevant shared parameter definitions.\n<li><a href=\"\"></a> \n<li><a href=\"\"></a> \n</ul>\n\n\nwe calculate all setout points on structural concrete geometry\n\nwe thought to schedule these points directly, but cannot add more than one X, Y, Z shared param per element\n\nsolution: create setout point family instances for each individual setout point and use those for scheduling\n\nyou could actually use DMU to regen the points automatically every time the geometry changes, but easier might be to regenerate the whole thing each time you need it and delete them immediately afterwards\n\nC:\\tmp\\Revit\\SetoutPoints\\test\\rst_basic_sample_project_with_location.rvt\n\nSchedule setout points.\n\nWe calculate all setout points on structural concrete geometry.\n\nWe thought to schedule these points directly, but cannot add more than one X, Y, Z shared parameter per element.\n\nSolution: create setout point family instances for each individual setout point and use those for scheduling.\n\nYou could actually use DMU to regenerate the points automatically every time the geometry changes, but easier might be to regenerate the whole thing each time you need it and delete them immediately afterwards\n\n    /// <summary>\n    /// Classify the possible setup point \n    /// host geometry types that support.\n    /// </summary>\n    enum HostType\n    {\n      Floors,\n      Ramps,\n      StructuralColumns,\n      StructuralFraming,\n      StructuralFoundations,\n      Walls\n    }\n\nReturn all the \"corner\" vertices of a given solid. Note that a circle in Revit consists of two arcs and will return a \"corner\" at each of the two arc end points.\n\nRetrieve all structural elements that we are interested in using to define setout points. We are looking at concrete for the moment. This includes: columns, framing, floors, foundations, ramps, walls. \n\nShared parameter GUIDs retrieved from the shared parameter file.\n\nObserve the project location transform.\n\nTwo symbols, major (key) and minor. Expecting major (key) setout point first, minor setout point second.\n\nRetrieve the first non-empty solid found for the given element. In case the element is a family instance, it may have its own non-empty solid, in which case we use that. Otherwise we search the symbol geometry. If we use the symbol geometry, we have to keep track of the instance transform to map it to the actual instance project location.\n\nSome columns have no solids, and we have to retrieve the geometry from the symbol; others do have solids on the instance itself and no contents in he instance geometry (e.g. in rst_basic_sample_project.rvt).\n\nRenumber key setout points. We remove the \"SOP\" prefix and restart numbering from one.\n\nFilter for key setout points. They are family instances with the generic model category whose Key_Setout_Point shared parameter is set to true. \n\nTo get the key points only, we initially set up a parameter filter. For that, we need a parameter definition to set up the parameter filter.\n\nLater, we decided to switch type when we promote a setout point to a major or key point, so there is no need to filter for a parameter value at all; we can just filter for the major setout point type instead.\n\n\n\n<ul>\n<li>\n</ul>\n\n\n<a href=\"\">\n</a> \n\n\n<center>\n<img src=\"img/\" alt=\"\"/>\n</center>\n\n<hr>\n\n<pre class=\"code\">\n</pre>\n\n<a name=\"\"></a>\n\n<h4></h4>\n\n<a href=\"\">\n</a> \n\n<a name=\"3\"></a>\n\n<h4>Determine Revit Demo Mode</h4>\n\n<p>Rudolf Honke \n\n<a href=\"\">\ncommented</a> on \n\nthe approach I suggested to \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2012/03/determine-revit-demo-mode.html\">\ndetermine-revit-demo-mode</a> and\n\nproposed using the OptionalFunctionalityUtils IsDWGExportAvailable method instead of using my much more complex try-catch method.\n\n<p>This method is documented to check whether the DWG export functionality is available in the installed version of Revit. \nThe DWG export requires presence of certain modules that are optional and may not be part of the installed Revit. \n-->\n</p></p></p></p></p></p></p></p></a></p></p></p></p></p></p></p></p></p></p></p></p></p>"
  },
  {
    "original_filename": "0738_melbourne_devlab",
    "header_text": "Delete Reference Planes Not Hosting Any Elements",
    "local_header_href": "#delete-reference-planes-not-hosting-any-elements",
    "chunk_text": "<h4>Delete Reference Planes Not Hosting Any Elements</h4><p>A complex model can contain a pretty huge number of useless reference planes.\n\n<p>Nick proposed deleting all reference planes that \n\n<ol type=\"a\">\n<li>Have not been assigned a name, and\n<li>Do not host any elements.\n</li></li></ol>\n<p>To maximise performance, we use a parameter filter to check that the reference plane name is non-empty.\nThat is about twice as efficient as just filtering for all reference planes and then using LINQ or an explicit loop in .NET to check for a non-empty name.\n\n<p>Once we have found all the reference planes with a non-empty name, we need to check for each whether it hosts any elements.\nThis topic has been covered several times in the past, e.g. looking for \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/03/object-relationships.html\">\ngeneric object relationships</a> (also\n\navailable for \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/03/object-relationships-in-vb.html\">\nVB</a>).\n\n<p>The simplest approach that I am aware of is to delete it and check the number of element returned by the Delete method.\nThis list should include at least the element id of the reference plane itself, if the deletion succeeded.\nIf its length is larger than one, other elements were affected, which in this case probably means that they were hosted by the plane.\n\n<p>So, if the number of deleted elements equals one, we are happy and have deleted a reference plane hosting no other elements.\nIf the number is larger than one, it probably hosts something.\nIn that case, we can simply abort the transaction to undo the deletion attempt.\n\n<p>The deletion including the commit or rollback is achieved by the DeleteIfNotHosting method:\n\n<pre class=\"code\">\n<span class=\"blue\">bool</span> DeleteIfNotHosting( <span class=\"teal\">ReferencePlane</span> rp )\n{\n  <span class=\"blue\">bool</span> rc = <span class=\"blue\">false</span>;\n \n  <span class=\"teal\">Document</span> doc = rp.Document;\n \n  <span class=\"teal\">Transaction</span> tx = <span class=\"blue\">new</span> <span class=\"teal\">Transaction</span>( doc );\n \n  tx.Start( <span class=\"maroon\">\"Delete ReferencePlane \"</span> \n    + (++_i).ToString() );\n \n  <span class=\"green\">// Deletion simply fails if the reference plane </span>\n  <span class=\"green\">// hosts anything. If so, the return value ids </span>\n  <span class=\"green\">// is null:</span>\n \n  <span class=\"teal\">ICollection</span>&lt;<span class=\"teal\">ElementId</span>&gt; ids = doc.Delete( rp );\n \n  <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == ids || 1 &lt; ids.Count )\n  {\n    tx.RollBack();\n  }\n  <span class=\"blue\">else</span>\n  {\n    tx.Commit();\n    rc = <span class=\"blue\">true</span>;\n  }\n  <span class=\"blue\">return</span> rc;\n}\n</pre>\n<p>If you look carefully, you'll notice that we number the transactions that we generate so that they can be differentiated in the user interface undo list.\n\n<p>Actually, during debugging, I noticed that the deletion simply fails if the reference plane is hosting any elements, so the approach that I originally envisaged is not working.\nHowever, the failed deletion attempt returns a null collection of element ids instead of one containing more than one element.\nI added the null check and roll back the transaction in that case also, and all is fine.\n\n<p>Since the deletion fails anyway for a reference plane hosting anything, we could just as well commit the transaction, I suppose, but I prefer to roll it back.\nGiven more time to play, I could check which is faster or uses less resources, rolling back or committing.\nIn AutoCAD ObjectARX, rolling back is significantly more expensive than committing, but I assume that is a special case.\n\n<p>This method is driven by the mainline Execute method which implements the parameter filtering for non-empty reference plane names:\n\n<pre class=\"code\">\n  <span class=\"blue\">public</span> <span class=\"teal\">Result</span> Execute(\n    <span class=\"teal\">ExternalCommandData</span> commandData,\n    <span class=\"blue\">ref</span> <span class=\"blue\">string</span> message,\n    <span class=\"teal\">ElementSet</span> elements )\n  {\n    <span class=\"teal\">UIApplication</span> uiapp = commandData.Application;\n    <span class=\"teal\">UIDocument</span> uidoc = uiapp.ActiveUIDocument;\n    <span class=\"teal\">Application</span> app = uiapp.Application;\n    <span class=\"teal\">Document</span> doc = uidoc.Document;\n \n    <span class=\"green\">// Construct a parameter filter to get only </span>\n    <span class=\"green\">// unnamed reference planes, i.e. reference </span>\n    <span class=\"green\">// planes whose name equals the empty string:</span>\n \n    <span class=\"teal\">BuiltInParameter</span> bip\n      = <span class=\"teal\">BuiltInParameter</span>.DATUM_TEXT;\n \n    <span class=\"teal\">ParameterValueProvider</span> provider\n      = <span class=\"blue\">new</span> <span class=\"teal\">ParameterValueProvider</span>(\n        <span class=\"blue\">new</span> <span class=\"teal\">ElementId</span>( bip ) );\n \n    <span class=\"teal\">FilterStringRuleEvaluator</span> evaluator \n      = <span class=\"blue\">new</span> <span class=\"teal\">FilterStringEquals</span>();\n \n    <span class=\"teal\">FilterStringRule</span> rule = <span class=\"blue\">new</span> <span class=\"teal\">FilterStringRule</span>(\n      provider, evaluator, <span class=\"maroon\">\"\"</span>, <span class=\"blue\">false</span> );\n \n    <span class=\"teal\">ElementParameterFilter</span> filter\n      = <span class=\"blue\">new</span> <span class=\"teal\">ElementParameterFilter</span>( rule );\n \n    <span class=\"teal\">FilteredElementCollector</span> col \n      = <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( doc )\n        .OfClass( <span class=\"blue\">typeof</span>( <span class=\"teal\">ReferencePlane</span> ) )\n        .WherePasses( filter );\n \n    <span class=\"blue\">int</span> n = 0;\n    <span class=\"blue\">int</span> nDeleted = 0;\n \n    <span class=\"green\">// No need to cast ... this is pretty nifty,</span>\n    <span class=\"green\">// I find ... grab the elements as ReferencePlane</span>\n    <span class=\"green\">// instances, since the filter guarantees that </span>\n    <span class=\"green\">// only ReferencePlane instances are selected.</span>\n \n    <span class=\"blue\">foreach</span>( <span class=\"teal\">ReferencePlane</span> rp <span class=\"blue\">in</span> col )\n    {\n      ++n;\n      nDeleted += DeleteIfNotHosting( rp ) ? 1 : 0;\n    }\n \n    <span class=\"teal\">Debug</span>.Print( \n      <span class=\"maroon\">\"{0} unnamed reference plane{1} examined, {2} of them were deleted.\"</span>,\n      n, (1==n?<span class=\"maroon\">\"\"</span>:<span class=\"maroon\">\"s\"</span>), nDeleted );\n \n    <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Succeeded;\n  }\n}\n</pre>\n<p>Here is \n\n<a <=\"\" a=\"\" href=\"zip/DeleteUnnamedNonHostingReferencePlanes.zip\"> containing\n\nthe source code, manifest file, and Visual Studio solution.\n\n\n<a name=\"3\"></a>\n<h4>Automatic Setout Points</h4>\n<p>Why are we doing this?\n\n<p>It has been known to mankind for the following kind of situation to occur:\n\n<p>A large complex structure is constructed off-site.\nWhen assembled on site, it does not fit.\nThe workers continue nonetheless and force it into place.\nThe error is discovered later and corrected using brute force and post adaption.\nOverall cost of exercise: several days of delay and tens of thousands in cost overruns.\n\n<p>Here is Paul's description of this:\n\n<p><strong>The Challenge:</strong> Provide a way to find the real world coordinates, for the corners of potential elements we want to set out in the field, automatically from the model. \nIn this example, concrete structural elements. \nIdeally display these points in a Revit schedule, so that they can be formatted and placed on a drawing sheet. \nThen define which of the points could be used as set out points list them in a schedule, preferably numbered sequentially for readability.\n\n<p><strong>In Practice:</strong> Initially we could get the points listing, all from the API, but transferring this information into a schedule proved to be not possible. \nInstead we created a family that contained shared parameters to hold the data we required for scheduling. \nThen we place the created family at the points we have extracted from the geometry. \nThrough the API it is then possible to populate the parameters with the X, Y, Z coordinates we have extracted from the geometry, and then add these values to the extracted project location, to convert the values to real world coordinates.\n\n<p>Initially one type was used in the set out point family. \nHowever this did not enable the ability to select which points we want as scheduled set out points. \nFor this two types were created within the family, SetoutPoint_Major and SetoutPoint_Minor. \nThis allowed two separate schedules to be created, one capturing all the points, another to capture points defined as major points for use on a drawing sheet for set out. \nThe 'all points' schedule is useful for export to a CSV file for import into a surveying device such as a \n\n<a href=\"http://www.trimble.com\">\nTrimble</a>\n\nallowing site set-out directly from the model.\n\n<p>To be continued...\n\n<!--\n\n<h5>Nitty-Gritty</h5>\n\n<p>The setout point add-in performs the following steps:\n\n<ul>\n<li>Select all structural elements of interest in the model.\n<li>Extract and analyse their geometry.\n<li>Automatically define setout points based on the geometry analysis and place family instances to mark all of them.\n<li>Support manual marking of key setout points, to differentiate the (few) important major ones from the (many) less important minor ones.\n<li>Implement the setout point family definition.\n<li>Create Revit schedules listing all minor and key setout points for export to CSV, automatic trimble point population, on-site viewing.\n\n<li>apply project location transform as described in \n\nhttp://thebuildingcoder.typepad.com/blog/2010/01/project-location.html\n\n</ul>\n\n<p>It populates the following shared parameters which are used to create the schedules:\n\n<ul>\n<li>Key_Setout_Point\n<li>Host_Type\n<li>Host_Id \n<li>Point_Number\n<li>X\n<li>Y\n<li>Z\n</ul>\n\n<p>We classify the possible setup point host geometry types that we support.\nThe host types are one of the following:\n\n<pre class=\"code\">\n&nbsp; <span class=\"blue\">enum</span> <span class=\"teal\">HostType</span>\n&nbsp; {\n&nbsp; &nbsp; Floors,\n&nbsp; &nbsp; Ramps,\n&nbsp; &nbsp; StructuralColumns,\n&nbsp; &nbsp; StructuralFraming,\n&nbsp; &nbsp; StructuralFoundations,\n&nbsp; &nbsp; Walls\n&nbsp; }\n</pre>\n\n<p>This is what the schedule ends up looking like this, ready to be sent and used on-site:</p>\n\n<center>\n<img src=\"img/\" alt=\"\"/>\n</center>\n\n\n<ul>\n<li><a href=\"zip/shared_parameters.txt\">shared_parameters.txt</a>, the shared parameter definition file.\n<li><a href=\"zip/SetoutPoint2012.rfa\">SetoutPoint2012.rfa</a>, the setout point family file including the relevant shared parameter definitions.\n<li><a href=\"\"></a> \n<li><a href=\"\"></a> \n</ul>\n\n\nwe calculate all setout points on structural concrete geometry\n\nwe thought to schedule these points directly, but cannot add more than one X, Y, Z shared param per element\n\nsolution: create setout point family instances for each individual setout point and use those for scheduling\n\nyou could actually use DMU to regen the points automatically every time the geometry changes, but easier might be to regenerate the whole thing each time you need it and delete them immediately afterwards\n\nC:\\tmp\\Revit\\SetoutPoints\\test\\rst_basic_sample_project_with_location.rvt\n\nSchedule setout points.\n\nWe calculate all setout points on structural concrete geometry.\n\nWe thought to schedule these points directly, but cannot add more than one X, Y, Z shared parameter per element.\n\nSolution: create setout point family instances for each individual setout point and use those for scheduling.\n\nYou could actually use DMU to regenerate the points automatically every time the geometry changes, but easier might be to regenerate the whole thing each time you need it and delete them immediately afterwards\n\n    /// <summary>\n    /// Classify the possible setup point \n    /// host geometry types that support.\n    /// </summary>\n    enum HostType\n    {\n      Floors,\n      Ramps,\n      StructuralColumns,\n      StructuralFraming,\n      StructuralFoundations,\n      Walls\n    }\n\nReturn all the \"corner\" vertices of a given solid. Note that a circle in Revit consists of two arcs and will return a \"corner\" at each of the two arc end points.\n\nRetrieve all structural elements that we are interested in using to define setout points. We are looking at concrete for the moment. This includes: columns, framing, floors, foundations, ramps, walls. \n\nShared parameter GUIDs retrieved from the shared parameter file.\n\nObserve the project location transform.\n\nTwo symbols, major (key) and minor. Expecting major (key) setout point first, minor setout point second.\n\nRetrieve the first non-empty solid found for the given element. In case the element is a family instance, it may have its own non-empty solid, in which case we use that. Otherwise we search the symbol geometry. If we use the symbol geometry, we have to keep track of the instance transform to map it to the actual instance project location.\n\nSome columns have no solids, and we have to retrieve the geometry from the symbol; others do have solids on the instance itself and no contents in he instance geometry (e.g. in rst_basic_sample_project.rvt).\n\nRenumber key setout points. We remove the \"SOP\" prefix and restart numbering from one.\n\nFilter for key setout points. They are family instances with the generic model category whose Key_Setout_Point shared parameter is set to true. \n\nTo get the key points only, we initially set up a parameter filter. For that, we need a parameter definition to set up the parameter filter.\n\nLater, we decided to switch type when we promote a setout point to a major or key point, so there is no need to filter for a parameter value at all; we can just filter for the major setout point type instead.\n\n\n\n<ul>\n<li>\n</ul>\n\n\n<a href=\"\">\n</a> \n\n\n<center>\n<img src=\"img/\" alt=\"\"/>\n</center>\n\n<hr>\n\n<pre class=\"code\">\n</pre>\n\n<a name=\"\"></a>\n\n<h4></h4>\n\n<a href=\"\">\n</a> \n\n<a name=\"3\"></a>\n\n<h4>Determine Revit Demo Mode</h4>\n\n<p>Rudolf Honke \n\n<a href=\"\">\ncommented</a> on \n\nthe approach I suggested to \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2012/03/determine-revit-demo-mode.html\">\ndetermine-revit-demo-mode</a> and\n\nproposed using the OptionalFunctionalityUtils IsDWGExportAvailable method instead of using my much more complex try-catch method.\n\n<p>This method is documented to check whether the DWG export functionality is available in the installed version of Revit. \nThe DWG export requires presence of certain modules that are optional and may not be part of the installed Revit. \n-->\n</p></p></p></p></p></p></p></p></a></p></p></p></p></p></p></p></p></p></p></p></p>"
  },
  {
    "original_filename": "0738_melbourne_devlab",
    "header_text": "Automatic Setout Points",
    "local_header_href": "#automatic-setout-points",
    "chunk_text": "<h4>Automatic Setout Points</h4><p>Why are we doing this?\n\n<p>It has been known to mankind for the following kind of situation to occur:\n\n<p>A large complex structure is constructed off-site.\nWhen assembled on site, it does not fit.\nThe workers continue nonetheless and force it into place.\nThe error is discovered later and corrected using brute force and post adaption.\nOverall cost of exercise: several days of delay and tens of thousands in cost overruns.\n\n<p>Here is Paul's description of this:\n\n<p><strong>The Challenge:</strong> Provide a way to find the real world coordinates, for the corners of potential elements we want to set out in the field, automatically from the model. \nIn this example, concrete structural elements. \nIdeally display these points in a Revit schedule, so that they can be formatted and placed on a drawing sheet. \nThen define which of the points could be used as set out points list them in a schedule, preferably numbered sequentially for readability.\n\n<p><strong>In Practice:</strong> Initially we could get the points listing, all from the API, but transferring this information into a schedule proved to be not possible. \nInstead we created a family that contained shared parameters to hold the data we required for scheduling. \nThen we place the created family at the points we have extracted from the geometry. \nThrough the API it is then possible to populate the parameters with the X, Y, Z coordinates we have extracted from the geometry, and then add these values to the extracted project location, to convert the values to real world coordinates.\n\n<p>Initially one type was used in the set out point family. \nHowever this did not enable the ability to select which points we want as scheduled set out points. \nFor this two types were created within the family, SetoutPoint_Major and SetoutPoint_Minor. \nThis allowed two separate schedules to be created, one capturing all the points, another to capture points defined as major points for use on a drawing sheet for set out. \nThe 'all points' schedule is useful for export to a CSV file for import into a surveying device such as a \n\n<a href=\"http://www.trimble.com\">\nTrimble</a>\n\nallowing site set-out directly from the model.\n\n<p>To be continued...\n\n<!--\n\n<h5>Nitty-Gritty</h5>\n\n<p>The setout point add-in performs the following steps:\n\n<ul>\n<li>Select all structural elements of interest in the model.\n<li>Extract and analyse their geometry.\n<li>Automatically define setout points based on the geometry analysis and place family instances to mark all of them.\n<li>Support manual marking of key setout points, to differentiate the (few) important major ones from the (many) less important minor ones.\n<li>Implement the setout point family definition.\n<li>Create Revit schedules listing all minor and key setout points for export to CSV, automatic trimble point population, on-site viewing.\n\n<li>apply project location transform as described in \n\nhttp://thebuildingcoder.typepad.com/blog/2010/01/project-location.html\n\n</ul>\n\n<p>It populates the following shared parameters which are used to create the schedules:\n\n<ul>\n<li>Key_Setout_Point\n<li>Host_Type\n<li>Host_Id \n<li>Point_Number\n<li>X\n<li>Y\n<li>Z\n</ul>\n\n<p>We classify the possible setup point host geometry types that we support.\nThe host types are one of the following:\n\n<pre class=\"code\">\n&nbsp; <span class=\"blue\">enum</span> <span class=\"teal\">HostType</span>\n&nbsp; {\n&nbsp; &nbsp; Floors,\n&nbsp; &nbsp; Ramps,\n&nbsp; &nbsp; StructuralColumns,\n&nbsp; &nbsp; StructuralFraming,\n&nbsp; &nbsp; StructuralFoundations,\n&nbsp; &nbsp; Walls\n&nbsp; }\n</pre>\n\n<p>This is what the schedule ends up looking like this, ready to be sent and used on-site:</p>\n\n<center>\n<img src=\"img/\" alt=\"\"/>\n</center>\n\n\n<ul>\n<li><a href=\"zip/shared_parameters.txt\">shared_parameters.txt</a>, the shared parameter definition file.\n<li><a href=\"zip/SetoutPoint2012.rfa\">SetoutPoint2012.rfa</a>, the setout point family file including the relevant shared parameter definitions.\n<li><a href=\"\"></a> \n<li><a href=\"\"></a> \n</ul>\n\n\nwe calculate all setout points on structural concrete geometry\n\nwe thought to schedule these points directly, but cannot add more than one X, Y, Z shared param per element\n\nsolution: create setout point family instances for each individual setout point and use those for scheduling\n\nyou could actually use DMU to regen the points automatically every time the geometry changes, but easier might be to regenerate the whole thing each time you need it and delete them immediately afterwards\n\nC:\\tmp\\Revit\\SetoutPoints\\test\\rst_basic_sample_project_with_location.rvt\n\nSchedule setout points.\n\nWe calculate all setout points on structural concrete geometry.\n\nWe thought to schedule these points directly, but cannot add more than one X, Y, Z shared parameter per element.\n\nSolution: create setout point family instances for each individual setout point and use those for scheduling.\n\nYou could actually use DMU to regenerate the points automatically every time the geometry changes, but easier might be to regenerate the whole thing each time you need it and delete them immediately afterwards\n\n    /// <summary>\n    /// Classify the possible setup point \n    /// host geometry types that support.\n    /// </summary>\n    enum HostType\n    {\n      Floors,\n      Ramps,\n      StructuralColumns,\n      StructuralFraming,\n      StructuralFoundations,\n      Walls\n    }\n\nReturn all the \"corner\" vertices of a given solid. Note that a circle in Revit consists of two arcs and will return a \"corner\" at each of the two arc end points.\n\nRetrieve all structural elements that we are interested in using to define setout points. We are looking at concrete for the moment. This includes: columns, framing, floors, foundations, ramps, walls. \n\nShared parameter GUIDs retrieved from the shared parameter file.\n\nObserve the project location transform.\n\nTwo symbols, major (key) and minor. Expecting major (key) setout point first, minor setout point second.\n\nRetrieve the first non-empty solid found for the given element. In case the element is a family instance, it may have its own non-empty solid, in which case we use that. Otherwise we search the symbol geometry. If we use the symbol geometry, we have to keep track of the instance transform to map it to the actual instance project location.\n\nSome columns have no solids, and we have to retrieve the geometry from the symbol; others do have solids on the instance itself and no contents in he instance geometry (e.g. in rst_basic_sample_project.rvt).\n\nRenumber key setout points. We remove the \"SOP\" prefix and restart numbering from one.\n\nFilter for key setout points. They are family instances with the generic model category whose Key_Setout_Point shared parameter is set to true. \n\nTo get the key points only, we initially set up a parameter filter. For that, we need a parameter definition to set up the parameter filter.\n\nLater, we decided to switch type when we promote a setout point to a major or key point, so there is no need to filter for a parameter value at all; we can just filter for the major setout point type instead.\n\n\n\n<ul>\n<li>\n</ul>\n\n\n<a href=\"\">\n</a> \n\n\n<center>\n<img src=\"img/\" alt=\"\"/>\n</center>\n\n<hr>\n\n<pre class=\"code\">\n</pre>\n\n<a name=\"\"></a>\n\n<h4></h4>\n\n<a href=\"\">\n</a> \n\n<a name=\"3\"></a>\n\n<h4>Determine Revit Demo Mode</h4>\n\n<p>Rudolf Honke \n\n<a href=\"\">\ncommented</a> on \n\nthe approach I suggested to \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2012/03/determine-revit-demo-mode.html\">\ndetermine-revit-demo-mode</a> and\n\nproposed using the OptionalFunctionalityUtils IsDWGExportAvailable method instead of using my much more complex try-catch method.\n\n<p>This method is documented to check whether the DWG export functionality is available in the installed version of Revit. \nThe DWG export requires presence of certain modules that are optional and may not be part of the installed Revit. \n-->\n</p></p></p></p></p></p></p></p>"
  }
]