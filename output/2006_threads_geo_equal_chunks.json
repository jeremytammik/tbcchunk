[
  {
    "original_filename": "2006_threads_geo_equal",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n<link rel=\"stylesheet\" type=\"text/css\" href=\"bc.css\">\n<script src=\"https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js\" type=\"text/javascript\"></script>\n</head>\n\n<!---\n\n- Equality methods of GeometryObject\n  https://forums.autodesk.com/t5/revit-api-forum/equality-methods-of-geometryobject/m-p/12155610\n\n- on single threaded API versus multi-threaded Revit\n  Is my plugin restricted by the computing resources of Revit?\n  https://forums.autodesk.com/t5/revit-api-forum/is-my-plugin-restricted-by-the-computing-resources-of-revit/m-p/12155865#M73273\n\ntwitter:\n\nDeep Revit API questions requiring clarification on add-in threads, GeometryObject comparison methods and accessing MS Access in the @AutodeskRevit #RevitAPI #BIM @DynamoBIM @AutodeskAPS https://autode.sk/objequals\n\nDeep Revit API questions requiring clarification and a simple database connection issue resolved\n&ndash; Add-in threads\n&ndash; <code>GeometryObject</code> comparison methods\n&ndash; Accessing Access\n&ndash; The INTERCAL programming language...\n\nlinkedin:\n\nDeep Revit API questions requiring clarification on add-in threads, GeometryObject comparison methods and accessing MS Access in the #RevitAPI\n\nhttps://autode.sk/objequals\n\n- Add-in threads\n- GeometryObject comparison methods\n- Accessing Access\n- The INTERCAL programming language...\n\n#BIM #DynamoBIM #AutodeskAPS #Revit #API #IFC #SDK #Autodesk #AEC #adsk\n\nthe [Revit API discussion forum](http://forums.autodesk.com/t5/revit-api-forum/bd-p/160) thread\n\n<center>\n<img src=\"img/\" alt=\"\" title=\"\" width=\"600\"/>\n<p style=\"font-size: 80%; font-style:italic\"></p>\n</center>\n\n-->"
  },
  {
    "original_filename": "2006_threads_geo_equal",
    "header_text": "Add-In Threads and Geometry Comparison",
    "local_header_href": "#add-in-threads-and-geometry-comparison",
    "chunk_text": "### Add-In Threads and Geometry Comparison\n\nA couple of rather deep Revit API questions can use some clarification, plus a simple database connection issue is resolved:\n\n- [Add-in threads](#2)\n- [`GeometryObject` comparison methods](#3)\n- [Accessing Access](#4)\n- [The INTERCAL programming language](#5)"
  },
  {
    "original_filename": "2006_threads_geo_equal",
    "header_text": "Add-In Threads",
    "local_header_href": "#2",
    "chunk_text": "####<a name=\"2\"></a> Add-In Threads\n\nSome aspects of the single-threaded Revit API versus multi-threaded Revit.exe and add-ins were highlighted in\nthe [Revit API discussion forum](http://forums.autodesk.com/t5/revit-api-forum/bd-p/160) thread\nasking [Is my plugin restricted by the computing resources of Revit?](https://forums.autodesk.com/t5/revit-api-forum/is-my-plugin-restricted-by-the-computing-resources-of-revit/m-p/12155865):\n\n**Question:** The Revit API is a single-threaded (therefore single-core) process.\nI was wondering if a Revit plugin would then have to live with the same restriction or whether a plugin could theoretically run multi-threaded/multi-processed?\nAnd what about GPU access?\nI know that some commercial plugin providers have developed standalone software with bidirectional connections to and from Revit, and I was wondering whether the hardware restrictions of Revit were the reason behind that.\n\n**Answer:** The limitation of running tasks on a single thread in the Revit API is not due to hardware restrictions but rather a deliberate design choice aimed at ensuring data consistency.\n\nTo clarify, the term \"single-threaded\" does not necessarily mean it all operates on a single core; it depends on the nature of the data your application handles during different phases.\n\nWhen we refer to \"single-threaded,\" we are likely talking about the \"event loop\" utilized by Revit to manage model modifications. The event loop is a common design pattern used in UI applications. However, internally, Revit can utilize multi-core or GPU cores to parallelize rendering processes and generate model data into images.\n\nIn the majority of cases, achieving parallel execution of tasks requires a careful design to split jobs into multiple individual sub-jobs. This can be quite challenging for most real-world scenarios.\n\nFor many UI applications, opting for a single-threaded approach offers greater stability and simplicity in maintaining data consistency. This holds particularly true for Revit, which is a software equipped with a third-party plugin system. In Revit, all operations related to reading and updating the model are queued and executed sequentially on the main thread, a decision rooted in Revit's specific business domain.\n\nWhile it is possible to design Revit to support multi-threading, similar to a database software, doing so would entail sacrificing simplicity and introduce complexities related to handling thread-safety during modifications.\n\nMoreover, it's important to note that even for writing data in parallel, a database relies on locking mechanisms to ensure data consistency, effectively making it single-threaded at its core. This approach is based on the widely accepted understanding that modifying related data must be regulated to guarantee data consistency.\n\nYour add-in is not restricted in any way.\nThe only restriction imposed by Revit is the single-threaded implementation of the Revit API and access to Revit functionality.\nAll other operations performed by your add-in are not restricted, limited or influenced by Revit in any way whatsoever.\nThe next limiting factor might be the .NET environment in which your add-in lives, and the `AppDomain` that Revit provides for it.\nPlease examine the official .NET documentation for that.\n\nHowever, you also can always implement whatever functionality you like outside of your Revit add-in and communicate between that and the add-in in a number of ways.\n\nMany thanks to Kennan Chen for this clarification!"
  },
  {
    "original_filename": "2006_threads_geo_equal",
    "header_text": "GeometryObject Comparison Methods",
    "local_header_href": "#3",
    "chunk_text": "####<a name=\"3\"></a> GeometryObject Comparison Methods\n\nA pertinent question from\nRichard [RPThomas108](https://forums.autodesk.com/t5/user/viewprofilepage/user-id/1035859) Thomas\non [equality methods of `GeometryObject`](https://forums.autodesk.com/t5/revit-api-forum/equality-methods-of-geometryobject/td-p/12149045):\nwas clarified by the development team:\n\n**Question:** Can someone confirm what the equality methods of `GeometryObject` are based upon, i.e.:\n\n- Memory reference\n- Geometric configuration and/or properties of the class\n- Id assigned to the class alone (GeometryObject.Id)\n- Something else?\n\nI'm specifically interested in the equality/inequality operators and the overridden `Object.Equals`:\n\n<center>\n<img src=\"img/geo_obj_comparison.png\" alt=\"Object.Equals et al\" title=\"Object.Equals et al\" width=\"800\"/> <!-- Pixel Height: 353 Pixel Width: 974 -->\n</center>\n\nI guess the simple yes / no answer (if it exists) would be: are the equality methods noted above based on memory reference alone?\nHowever, isn't `Object.Equals` based on memory reference to begin with?\nIf it is overridden, then how is it overridden?\nI tend to create a lot of class objects whose purpose is to wrap an API object and attach an id due to uncertainty about the equality of the API objects.\nSome clarification here or in the documentation would probably be quite helpful in reducing this aspect.\nI see the following in the RevitAPI.chm under GeometryObject.Equals in the Remarks section:\n\n> This compares the internal identifiers of the geometry, and doesn't compare them geometrically\n\nNow that we've ruled out the geometric configuration, we just need to know what the 'internal identifiers' are exactly.\nIs it the `GeometryObject.Id` or something else?\nWhat kind of operations affect these identifiers?\nDo they exist for every API object created or just the items coming directly from element geometry?\n\nI've now also reviewed the below from RevitAPI.chm on `GeometryObject.Id`:\n\n> This id can be stored and used for future referencing.\nThe reference should be stable between minor geometric changes and modifications, but may not remain valid if there are major changes to the element or its surroundings.\nNote that the id may be negative (and thus invalid for referencing) if obtained from view-specific geometry, or if obtained from most GeometryObjects created in memory by the API.\nNegative ids cannot be used for referencing.\nThese integer ids should not be used for comparison purposes (other than to check if they are equivalent or not).\nNothing should be assumed about rules about how an element populates the sequence of different numeric values as this may change based on the element's definition.\n\nI've noticed previously that geometry from two different elements could have the same id (the id values are low so that is reasonable).\nThat being the case, I'm also looking to confirm that the equality methods noted above are not equating two geometry objects with the same id from two different elements as being the same (internal identifier <> GeometryObject.Id).\n\nI think knowing more about this could be quite helpful either way.\nWe could test and find answers, but it would then remain an unknown aspect to new people encountering the API.\n\nPersonally, I always look at the equals functions in the documentation to see if it has been overridden for a class or not.\nThat then informs me if I can use Linq extensions such as `distinct` and `union` with it (so we need to know how it is overridden also).\n\nFor classes such as `ElementId`, it is inherently obvious, but some objects are less so and need more description.\nIf it is just using GeometryObject.Id, then I can live with the limitations of that; I just need to know that is what it is doing.\n\n**Answer:** Good question, might be something worth documenting:\n\n- GeometryObject.Equals &ndash; This compares the memory references of the compared objects.\n- GeometryObject.operator == &ndash; This compares the pointers of the Revit-internal geometry objects.\n- GeometryObject.GetHashCode &ndash; This is a hash of the pointer to the Revit-internal geometry object.\n\nIn principle, there could be two different Revit.DB.GeometryObject objects that are both handles to the same Revit-internal geometry object; for example, if you retrieve the GeometryObject from the same `Reference` twice in succession, you will end up with two different GeometryObjects that both are handles to the same Revit-internal object.\nIn this case, GeometryObject.Equals would return false, but GeometryObject.operator == would return true.\nBoth GeometryObjects would have the same hash code.\n\nIf either comparison method returns true, then that guarantees that they both have the same GeometryObject.Id, which is an attribute of the underlying Revit object.\nHowever, two totally unrelated GeometryObjects may have the same Id, since this is not intended to be a globally unique identifier.\n\nFor completeness, the inequality operator is simply the negation of the equality operator.\nTwo GeometryObjects that internally hold null pointers to Revit-internal objects are considered equal when compared with operator ==.\n\nI think this behaviour could be considered reasonable, if we update the documentation to reflect the actual behaviour.\n\nAlso, as noted, it may not make sense to override Object.Equals at all.\n\n**Response:** I think I'm largely happy with the status quo; as stated, it is probably more important that how it works is better described in the documentation; we then can make the right allowances based on that.\n\nSeems like there is no real logic in two managed objects that point to the same unmanaged object not returning true for Equals.\nI can't think of a reason off of the top of my head as to why the Equals function doesn't work exactly the same way as the == operator.\nHowever, the Linq extensions will only be using 'Equals', not ==, so it might be useful therefore to make Equals the same as ==.\nSecondly, `GetHashCode` will be called by Linq extensions prior to `Equals`, so therefore it should be overridden to return 0 to force the comparison by `Equals` or be overridden to perhaps provide a better hashing function related to the unmanaged memory reference (not the managed counterpart.\n\nI have a feeling that the default algorithm that Object.GetHashCode uses in .NET is fast rather than perfect in terms of comparing two objects as being the same.\nSince the hash code is based on the reference (64 bit on 64-bit system) but the hash code itself is only 32 bits.\nSo, in theory there can be clashes that then need further resolution via `Equals`.\nIn contrast, if you are comparing the value of 64-bit memory pointers directly on the unmanaged side, then there can be no doubt it is the same object.\n\nAll I'm aiming for in the end is that when I extract objects from Revit I can then pass those objects through my functions which could perhaps sort them or group them, but in the end I can compare what comes out against the original set.\nI also need to remove items from a List (List&lt;T&gt;.Remove) which is sometimes hard if `Equals` and `GetHashCode` have not been overridden, since that method will use the default equality comparer.\n\nTo deal with these kinds of things I recently wrote the following generic classes where comparisons are conducted during the context of the external command.\nI think a lot of it comes down to trust in `GetHashCode`.\nObviously, the below is for all kinds of things, not just geometry objects.\nThe pain of this kind of approach is that you have to create a new list of items of the below classes from the existing list of API objects rather than just knowing you can use the API objects directly.\n\n<pre class=\"prettyprint\">\n  Public Class RT_GeometryObjWithId(Of T As GeometryObject)\n    Inherits RT_ApiObjectWithId(Of T)\n\n    Public ReadOnly Property GeometryId As Integer\n    Public Sub New(Obj As T)\n      MyBase.New(Obj)\n      GeometryId = Obj.Id\n    End Sub\n  End Class\n\n  Public Class RT_ApiObjectWithId(Of T As APIObject)\n    Implements IDisposable\n\n    Public ReadOnly Property UID As Guid = Guid.NewGuid\n    Private disposedValue As Boolean\n    Private IntAPIObj As T\n    Public Property APIObject As T\n      Get\n        Return IntAPIObj\n      End Get\n      Set(value As T)\n        IntAPIObj = value\n      End Set\n    End Property\n    Public Sub New(Obj As T)\n      IntAPIObj = Obj\n    End Sub\n\n    Public Overrides Function GetHashCode() As Integer\n      'Force consideration of Equals\n      'Likely I could leave this alone and rely on the default implementation\n      'However I have more trust in comparing two guids than GetHashCode\n      Return 0\n    End Function\n    Public Overrides Function Equals(obj As Object) As Boolean\n      Dim Other As RT_ApiObjectWithId(Of T) = _\n        TryCast(obj, RT_ApiObjectWithId(Of T))\n      If Other Is Nothing Then Return False else\n      Return Me.UID = Other.UID\n    End Function\n\n    Public Shared Operator =(A As RT_ApiObjectWithId(Of T), _\n      B As RT_ApiObjectWithId(Of T)) As Boolean\n      Return A.Equals(B)\n    End Operator\n    Public Shared Operator &lt;&gt;(A As RT_ApiObjectWithId(Of T), _\n      B As RT_ApiObjectWithId(Of T)) As Boolean\n      Return Not A.Equals(B)\n    End Operator\n\n    Protected Overridable Sub Dispose(disposing As Boolean)\n      If Not disposedValue Then\n        If disposing Then\n          ' TODO: dispose managed state (managed objects)\n          If APIObject IsNot Nothing Then\n            APIObject.Dispose()\n          End If\n        End If\n\n        ' TODO: free unmanaged resources (unmanaged objects) and override finalizer\n        ' TODO: set large fields to null\n        disposedValue = True\n      End If\n    End Sub\n\n    ' ' TODO: override finalizer only if 'Dispose(disposing As Boolean)' has code to free unmanaged resources\n    ' Protected Overrides Sub Finalize()\n    '   ' Do not change this code. Put cleanup code in 'Dispose(disposing As Boolean)' method\n    '   Dispose(disposing:=False)\n    '   MyBase.Finalize()\n    ' End Sub\n\n    Public Sub Dispose() Implements IDisposable.Dispose\n      ' Do not change this code. Put cleanup code in 'Dispose(disposing As Boolean)' method\n      Dispose(disposing:=True)\n      GC.SuppressFinalize(Me)\n    End Sub\n  End Class\n</pre>\n\nMany thanks to Richard for raising this important question and sharing his viable and well-considered solution."
  },
  {
    "original_filename": "2006_threads_geo_equal",
    "header_text": "Accessing Access",
    "local_header_href": "#4",
    "chunk_text": "####<a name=\"4\"></a> Accessing Access\n\nA repeating question\non [connecting with a MS Access database](https://forums.autodesk.com/t5/revit-api-forum/connecting-to-ms-access/m-p/12208698) came\nup once again, and the answer is known, so worthwhile to point out here as well.\n\nOleg 'OR_AND_NO' Rodygin of [RZD Project](https://en.wikipedia.org/wiki/Russian_Railways) very kindly pointed out that the answer is provided in a previous post:\n[Can't make connection to Access database](https://forums.autodesk.com/t5/revit-api-forum/cant-make-connection-to-acces-database/m-p/10879626):\n\n> You need to install the [Microsoft Access 2013 Runtime](https://www.microsoft.com/en-us/download/details.aspx?id=39358)\n\nThank you, Oleg."
  },
  {
    "original_filename": "2006_threads_geo_equal",
    "header_text": "The INTERCAL Programming Language",
    "local_header_href": "#5",
    "chunk_text": "####<a name=\"5\"></a> The INTERCAL Programming Language\n\nFor some slightly less useful information,\nin case you are interested in weird programming languages,\n[INTERCAL](https://en.wikipedia.org/wiki/INTERCAL) may rank pretty high.\nReading the Wikipedia entry made me laugh out loud."
  }
]