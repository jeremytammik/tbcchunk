[
  {
    "original_filename": "1096_futureproof",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<head>\n<link href=\"bc.css\" rel=\"stylesheet\" type=\"text/css\"/>\n<meta content=\"text/html; charset=utf-8\" http-equiv=\"Content-Type\"/>\n</head>"
  },
  {
    "original_filename": "1096_futureproof",
    "header_text": "Future Proofing The Building Coder Samples",
    "local_header_href": "#future-proofing-the-building-coder-samples",
    "chunk_text": "<h3>Future Proofing The Building Coder Samples</h3><p>We've reached the add-in future-proofing season again, the time of year to eliminate compiler warnings and deprecated calls for easier migration to an updated API, just like last year in\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2012/01/eliminating-compiler-warnings-and-deprecated-calls.html\">January</a> and\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2013/02/eliminating-compiler-warnings-and-deprecated-calls.html\">February</a>.</p><p>It is very easy this time around, since we only have\n\n<a href=\"zip/bc_migr_2014_j.txt\">\ntwo warnings</a> left,\n\nabout use of the obsolete TitleBlocks property and FindReferencesWithContextByDirection method:</p><ul>\n<li>CmdSheetSize.cs: 'Autodesk.Revit.DB.Document.TitleBlocks' is obsolete: 'This method is obsolete in Revit 2014. Use FilteredElementCollector with a FamilySymbol class filter and an appropriate category filter instead.'</li>\n<li>CmdDimensionWallsFindRefs.cs: 'Autodesk.Revit.DB.Document.FindReferencesWithContextByDirection(Autodesk.Revit.DB.XYZ, Autodesk.Revit.DB.XYZ, Autodesk.Revit.DB.View3D)' is obsolete: 'This method is deprecated in Revit 2014.  Use the ReferenceIntersector class instead.'</li>\n</ul><p>The former warning is caused by code explicitly left in for comparison with the new suggested workaround listed in the warning message, so we can leave it there as long as it still compiles, until the very last minute.</p><p>I fixed the latter by updating the CmdDimensionWallsFindRefs external command implementation, simply following the suggestion to replace the obsolete FindReferencesWithContextByDirection by the simplified interface provided by the ReferenceIntersector wrapper class.</p><p>The original CmdDimensionWallsFindRefs implementation showed how to\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2011/02/dimension-walls-using-findreferencesbydirection.html\">\ndimension walls using FindReferencesByDirection</a>.</p><p>I later updated it, replacing the FindReferencesByDirection method by FindReferencesWithContextByDirection when\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2011/04/migrating-the-building-coder-samples-to-revit-2012.html\">\nmigrating to the Revit 2012 API</a>.</p><p>This newest update makes it much shorter and simpler, since the ReferenceIntersector.FindNearest method enables us to eliminate all the code previously needed to determine the closest reference ourselves.</p><p>Here is the new code:</p><pre class=\"code\">\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n<span class=\"gray\">///</span><span class=\"green\"> Dimension two opposing parallel walls.</span>\n<span class=\"gray\">///</span><span class=\"green\"> Prompt user to select the first wall, and</span>\n<span class=\"gray\">///</span><span class=\"green\"> the second at the point at which to create</span>\n<span class=\"gray\">///</span><span class=\"green\"> the dimensioning. Use FindReferencesByDirection</span>\n<span class=\"gray\">///</span><span class=\"green\"> to determine the wall face references.</span>\n<span class=\"gray\">///</span>\n<span class=\"gray\">///</span><span class=\"green\"> Second sample solution for case 1263303 [Case</span>\n<span class=\"gray\">///</span><span class=\"green\"> Number 1263071 [Revit 2011 Dimension Wall]].</span>\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n[<span class=\"teal\">Transaction</span>( <span class=\"teal\">TransactionMode</span>.Manual )]\n<span class=\"blue\">class</span> <span class=\"teal\">CmdDimensionWallsFindRefs</span> : <span class=\"teal\">IExternalCommand</span>\n{\n  <span class=\"blue\">const</span> <span class=\"blue\">string</span> _prompt\n    = <span class=\"maroon\">\"Please select two parallel straight walls\"</span>\n      + <span class=\"maroon\">\" with a partial projected overlap.\"</span>;\n \n<span class=\"blue\">  #region</span> WallSelectionFilter\n  <span class=\"blue\">class</span> <span class=\"teal\">WallSelectionFilter</span> : <span class=\"teal\">ISelectionFilter</span>\n  {\n    <span class=\"blue\">public</span> <span class=\"blue\">bool</span> AllowElement( <span class=\"teal\">Element</span> e )\n    {\n      <span class=\"blue\">return</span> e <span class=\"blue\">is</span> <span class=\"teal\">Wall</span>;\n    }\n \n    <span class=\"blue\">public</span> <span class=\"blue\">bool</span> AllowReference( <span class=\"teal\">Reference</span> r, <span class=\"teal\">XYZ</span> p )\n    {\n      <span class=\"blue\">return</span> <span class=\"blue\">true</span>;\n    }\n  }\n<span class=\"blue\">  #endregion</span> <span class=\"green\">// WallSelectionFilter</span>\n \n<span class=\"blue\">  #region</span> Get3DView\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n  <span class=\"gray\">///</span><span class=\"green\"> Return a 3D view from the given document.</span>\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n  <span class=\"blue\">private</span> <span class=\"teal\">View3D</span> Get3DView( <span class=\"teal\">Document</span> doc )\n  {\n    <span class=\"teal\">FilteredElementCollector</span> collector\n      = <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( doc );\n \n    collector.OfClass( <span class=\"blue\">typeof</span>( <span class=\"teal\">View3D</span> ) );\n \n    <span class=\"blue\">foreach</span>( <span class=\"teal\">View3D</span> v <span class=\"blue\">in</span> collector )\n    {\n      <span class=\"green\">// skip view templates here because they</span>\n      <span class=\"green\">// are invisible in project browsers:</span>\n \n      <span class=\"blue\">if</span>( v != <span class=\"blue\">null</span> &amp;&amp; !v.IsTemplate &amp;&amp; v.Name == <span class=\"maroon\">\"{3D}\"</span> )\n      {\n        <span class=\"blue\">return</span> v;\n      }\n    }\n    <span class=\"blue\">return</span> <span class=\"blue\">null</span>;\n  }\n<span class=\"blue\">  #endregion</span> <span class=\"green\">// Get3DView</span>\n \n  <span class=\"blue\">public</span> <span class=\"teal\">Result</span> Execute(\n    <span class=\"teal\">ExternalCommandData</span> commandData,\n    <span class=\"blue\">ref</span> <span class=\"blue\">string</span> message,\n    <span class=\"teal\">ElementSet</span> elements )\n  {\n    <span class=\"teal\">UIApplication</span> uiapp = commandData.Application;\n    <span class=\"teal\">UIDocument</span> uidoc = uiapp.ActiveUIDocument;\n    <span class=\"teal\">Application</span> app = uiapp.Application;\n    <span class=\"teal\">Document</span> doc = uidoc.Document;\n \n    <span class=\"green\">// Select two walls and the dimension line point:</span>\n \n    <span class=\"teal\">Selection</span> sel = uidoc.Selection;\n    <span class=\"teal\">ReferenceArray</span> refs = <span class=\"blue\">new</span> <span class=\"teal\">ReferenceArray</span>();\n \n    <span class=\"blue\">try</span>\n    {\n      <span class=\"teal\">WallSelectionFilter</span> f\n        = <span class=\"blue\">new</span> <span class=\"teal\">WallSelectionFilter</span>();\n \n      refs.Append( sel.PickObject(\n        <span class=\"teal\">ObjectType</span>.Element, f,\n        <span class=\"maroon\">\"Please select first wall\"</span> ) );\n \n      refs.Append( sel.PickObject(\n        <span class=\"teal\">ObjectType</span>.Element, f,\n        <span class=\"maroon\">\"Please pick dimension line \"</span>\n        + <span class=\"maroon\">\"point on second wall\"</span> ) );\n    }\n    <span class=\"blue\">catch</span>( <span class=\"teal\">OperationCanceledException</span> )\n    {\n      message = <span class=\"maroon\">\"No two walls selected\"</span>;\n      <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n    }\n \n    <span class=\"green\">// Ensure the two selected walls are straight and</span>\n    <span class=\"green\">// parallel; determine their mutual normal vector</span>\n    <span class=\"green\">// and a point on each wall for distance</span>\n    <span class=\"green\">// calculations:</span>\n \n    <span class=\"teal\">Wall</span>[] walls = <span class=\"blue\">new</span> <span class=\"teal\">Wall</span>[2];\n    <span class=\"teal\">List</span>&lt;<span class=\"blue\">int</span>&gt; ids = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"blue\">int</span>&gt;( 2 );\n    <span class=\"teal\">XYZ</span>[] pts = <span class=\"blue\">new</span> <span class=\"teal\">XYZ</span>[2];\n    <span class=\"teal\">Line</span>[] lines = <span class=\"blue\">new</span> <span class=\"teal\">Line</span>[2];\n    <span class=\"teal\">IntersectionResult</span> ir;\n    <span class=\"teal\">XYZ</span> normal = <span class=\"blue\">null</span>;\n    <span class=\"blue\">int</span> i = 0;\n \n    <span class=\"blue\">foreach</span>( <span class=\"teal\">Reference</span> r <span class=\"blue\">in</span> refs )\n    {\n      <span class=\"green\">// 'Autodesk.Revit.DB.Reference.Element' is</span>\n      <span class=\"green\">// obsolete: Property will be removed. Use</span>\n      <span class=\"green\">// Document.GetElement(Reference) instead.</span>\n      <span class=\"green\">//Wall wall = r.Element as Wall; // 2011</span>\n \n      <span class=\"teal\">Wall</span> wall = doc.GetElement( r ) <span class=\"blue\">as</span> <span class=\"teal\">Wall</span>; <span class=\"green\">// 2012</span>\n \n      walls[i] = wall;\n      ids.Add( wall.Id.IntegerValue );\n \n      <span class=\"green\">// Obtain location curve and</span>\n      <span class=\"green\">// check that it is straight:</span>\n \n      <span class=\"teal\">LocationCurve</span> lc = wall.Location\n        <span class=\"blue\">as</span> <span class=\"teal\">LocationCurve</span>;\n \n      <span class=\"teal\">Curve</span> curve = lc.Curve;\n      lines[i] = curve <span class=\"blue\">as</span> <span class=\"teal\">Line</span>;\n \n      <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == lines[i] )\n      {\n        message = _prompt;\n        <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n      }\n \n      <span class=\"green\">// Obtain normal vectors</span>\n      <span class=\"green\">// and ensure that they are equal,</span>\n      <span class=\"green\">// i.e. walls are parallel:</span>\n \n      <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == normal )\n      {\n        normal = <span class=\"teal\">Util</span>.Normal( lines[i] );\n      }\n      <span class=\"blue\">else</span>\n      {\n        <span class=\"blue\">if</span>( !<span class=\"teal\">Util</span>.IsParallel( normal,\n          <span class=\"teal\">Util</span>.Normal( lines[i] ) ) )\n        {\n          message = _prompt;\n          <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n        }\n      }\n \n      <span class=\"green\">// Obtain pick points and project</span>\n      <span class=\"green\">// onto wall location lines:</span>\n \n      <span class=\"teal\">XYZ</span> p = r.GlobalPoint;\n      ir = lines[i].Project( p );\n \n      <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == ir )\n      {\n        message = <span class=\"blue\">string</span>.Format(\n          <span class=\"maroon\">\"Unable to project pick point {0} \"</span>\n          + <span class=\"maroon\">\"onto wall location line.\"</span>,\n          i );\n \n        <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n      }\n \n      pts[i] = ir.XYZPoint;\n \n      <span class=\"teal\">Debug</span>.Print(\n        <span class=\"maroon\">\"Wall {0} id {1} at {2}, {3} --&gt; point {4}\"</span>,\n        i, wall.Id.IntegerValue,\n        <span class=\"teal\">Util</span>.PointString( lines[i].GetEndPoint( 0 ) ),\n        <span class=\"teal\">Util</span>.PointString( lines[i].GetEndPoint( 1 ) ),\n        <span class=\"teal\">Util</span>.PointString( pts[i] ) );\n \n      <span class=\"blue\">if</span>( 0 &lt; i )\n      {\n        <span class=\"green\">// Project dimension point selected on second wall</span>\n        <span class=\"green\">// back onto first wall, and ensure that normal</span>\n        <span class=\"green\">// points from second wall to first:</span>\n \n        ir = lines[0].Project( pts[1] );\n        <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == ir )\n        {\n          message = <span class=\"blue\">string</span>.Format(\n            <span class=\"maroon\">\"Unable to project selected dimension \"</span>\n            + <span class=\"maroon\">\"line point {0} on second wall onto \"</span>\n            + <span class=\"maroon\">\"first wall's location line.\"</span>,\n            <span class=\"teal\">Util</span>.PointString( pts[1] ) );\n \n          <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n        }\n        pts[0] = ir.XYZPoint;\n      }\n \n      ++i;\n    }\n \n    <span class=\"teal\">XYZ</span> v = pts[0] - pts[1];\n    <span class=\"blue\">if</span>( 0 &gt; v.DotProduct( normal ) )\n    {\n      normal = -normal;\n    }\n \n    <span class=\"green\">// Shoot a ray back from the second </span>\n    <span class=\"green\">// picked wall towards first:</span>\n \n    <span class=\"teal\">Debug</span>.Print(\n      <span class=\"maroon\">\"Shooting ray from {0} in direction {1}\"</span>,\n      <span class=\"teal\">Util</span>.PointString( pts[1] ),\n      <span class=\"teal\">Util</span>.PointString( normal ) );\n \n    <span class=\"teal\">View3D</span> view = Get3DView( doc );\n \n    <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == view )\n    {\n      message = <span class=\"maroon\">\"No 3D view named '{3D}' found; \"</span>\n        + <span class=\"maroon\">\"run the View &gt; 3D View command once \"</span>\n        + <span class=\"maroon\">\"to generate it.\"</span>;\n \n      <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n    }\n \n    <span class=\"green\">//refs = doc.FindReferencesByDirection(</span>\n    <span class=\"green\">//  pts[1], normal, view ); // 2011</span>\n \n    <span class=\"green\">//IList&lt;ReferenceWithContext&gt; refs2</span>\n    <span class=\"green\">//  = doc.FindReferencesWithContextByDirection(</span>\n    <span class=\"green\">//    pts[1], normal, view ); // 2012</span>\n \n    <span class=\"green\">// In the Revit 2014 API, the call to</span>\n    <span class=\"green\">// FindReferencesWithContextByDirection causes a </span>\n    <span class=\"green\">// warning saying:</span>\n    <span class=\"green\">// \"FindReferencesWithContextByDirection is obsolete:</span>\n    <span class=\"green\">// This method is deprecated in Revit 2014.  </span>\n    <span class=\"green\">// Use the ReferenceIntersector class instead.\"</span>\n \n    <span class=\"teal\">ReferenceIntersector</span> ri\n      = <span class=\"blue\">new</span> <span class=\"teal\">ReferenceIntersector</span>(\n        walls[0].Id, <span class=\"teal\">FindReferenceTarget</span>.Element, view );\n \n    <span class=\"teal\">ReferenceWithContext</span> ref2\n      = ri.FindNearest( pts[1], normal );\n \n    <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == ref2 )\n    {\n      message = <span class=\"maroon\">\"ReferenceIntersector.FindNearest\"</span>\n        + <span class=\"maroon\">\" returned null!\"</span>;\n \n      <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n    }\n \n    <span class=\"teal\">CmdDimensionWallsIterateFaces</span>\n      .CreateDimensionElement( doc.ActiveView,\n      pts[0], ref2.GetReference(), pts[1], refs.get_Item( 1 ) );\n \n    <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Succeeded;\n  }\n}\n</pre><p>I committed those changes to The Building Coder samples\n\n<a href=\"https://github.com/jeremytammik/the_building_coder_samples/releases/tag/2014.0.106.7\">release 2014.0.106.7</a>.</p><p>In a second step, I also incremented the copyright year from 2013 to 2014, affecting all the modules, and saved that as\n\n<a href=\"https://github.com/jeremytammik/the_building_coder_samples/releases/tag/2014.0.106.8\">release 2014.0.106.8</a>.</p><p>Normally, you would simply grab\n\n<a href=\"https://github.com/jeremytammik/the_building_coder_samples\">\nThe Building Coder samples</a> current\n\nmaster branch, of course.</p>"
  }
]