[
  {
    "original_filename": "0405_data_grid_view",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<head>\n<link href=\"bc.css\" rel=\"stylesheet\" type=\"text/css\"/>\n</head>"
  },
  {
    "original_filename": "0405_data_grid_view",
    "header_text": "Populating a Data Grid View",
    "local_header_href": "#populating-a-data-grid-view",
    "chunk_text": "<h3>Populating a Data Grid View</h3><p>By the time you read this, I will be gone on the first of a series of holidays this summer.\nBy the way, for that reason, don't expect any answers to comments for a while.\nI left the computer at home this time!\nI posted this in advance to ensure you have something worthwhile to chew on during my absence.\n\n<p>This is another stepping stone towards implementing Martin Schmid's proposal to display and navigate through all unconnected MEP connectors in the model that I mentioned in the discussion on\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/06/retrieve-mep-elements-and-connectors.html\">\nretrieving MEP elements and connectors</a>.\n\n<p>Another one of the steps is\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/06/revit-parent-window.html\">\ndetermining the Revit parent window</a> and\n\nattaching a form to it.\nThe latter enables us to set Revit as the parent window of the modeless form, ensuring that it stays on top of Revit when Revit is visible, and also that it is minimised when the user minimises Revit.\n\n<p>After we have determined the unconnected connectors, we populate a modeless form with their pertinent information, display it, and enable the user to double click on an element to zoom to it in Revit.\nThe double click handling and zooming interaction still needs to be documented.\nFor the moment, we will focus on implementing, populating and displaying the modeless form.\n\n<h4>Modeless Form with Data Grid View</h4>\n<p>I implemented a modeless form named LooseConnectorNavigator.\nIt is derived from a Form base class from the System.Windows.Forms namespace.\nIt has one single DataGridView control added to it which is anchored to all four sides.\nHere is what it looks like with its properties in the Visual Studio form designer:</p>\n<center>\n<img alt=\"Modeless loose connector navigator form\" src=\"img/modeless_loose_connector_navigator_form.png\"/>\n</center>\n<p>A data grid view is extremely easy to populate with an absolute minimum of coding, as we have already seen in Joel Karr's sample showing how to\n\n<!-- 106 -->\n<a href=\"http://thebuildingcoder.typepad.com/blog/2009/02/list-linked-elements.html\">\nlist linked elements</a>.\n\nIf you set up an appropriate data container whose elements expose certain public member properties, all you need to do is to specify the container as the data source of the data grid view, and it will not only automatically populate the rows of data, but even create the columns according to the available properties!</p>\n<p>What's more, by using\n\n<!-- 164 -->\n<a href=\"http://thebuildingcoder.typepad.com/blog/2009/07/three-coding-and-performance-hints.html\">\nauto-implemented properties</a>,\n\nthe definition of the properties on the data item classes is reduced to just specifying their name and type and almost nothing else.</p>\n<h4>Data Container Classes</h4>\n<p>In this case, we wish to display the unconnected connectors.\nEach connector belongs to a specific Revit element, and in some circumstances we wish to present the element data independently of its connectors, so I implemented two separate data containers for each, a base ElementData class and a derived ConnectorData one.\nBoth of them have a list of public properties whose main purpose is to define exactly what ultimately gets displayed in the data grid view.\nThey also each have a constructor which populates their public properties, and a ToString method to stream them to a text file for logging purposes:</p>\n<pre class=\"code\">\n<span class=\"blue\">public</span> <span class=\"blue\">class</span> <span class=\"teal\">ElementData</span>\n{\n  <span class=\"blue\">public</span> <span class=\"blue\">string</span> Class { <span class=\"blue\">get</span>; <span class=\"blue\">set</span>; }\n  <span class=\"blue\">public</span> <span class=\"blue\">string</span> Category { <span class=\"blue\">get</span>; <span class=\"blue\">set</span>; }\n  <span class=\"blue\">public</span> <span class=\"blue\">string</span> Family { <span class=\"blue\">get</span>; <span class=\"blue\">set</span>; }\n  <span class=\"blue\">public</span> <span class=\"blue\">string</span> Symbol { <span class=\"blue\">get</span>; <span class=\"blue\">set</span>; }\n  <span class=\"blue\">public</span> <span class=\"blue\">string</span> Name { <span class=\"blue\">get</span>; <span class=\"blue\">set</span>; }\n  <span class=\"blue\">public</span> <span class=\"blue\">int</span> Id { <span class=\"blue\">get</span>; <span class=\"blue\">set</span>; }\n \n  <span class=\"blue\">public</span> ElementData(\n    <span class=\"teal\">Element</span> e,\n    <span class=\"teal\">Document</span> doc )\n  {\n    Class = e.GetType().Name;\n \n    Category = ( <span class=\"blue\">null</span> == e.Category )\n      ? <span class=\"blue\">string</span>.Empty\n      : e.Category.Name;\n \n    <span class=\"teal\">ElementId</span> typeId = e.GetTypeId();\n \n    <span class=\"teal\">ElementType</span> elementType = ( <span class=\"blue\">null</span> == typeId )\n      ? <span class=\"blue\">null</span>\n      : doc.get_Element( typeId ) <span class=\"blue\">as</span> <span class=\"teal\">ElementType</span>;\n \n    <span class=\"teal\">FamilyInstance</span> fi = e <span class=\"blue\">as</span> <span class=\"teal\">FamilyInstance</span>;\n    <span class=\"teal\">Duct</span> duct = e <span class=\"blue\">as</span> <span class=\"teal\">Duct</span>;\n    <span class=\"blue\">if</span>( <span class=\"blue\">null</span> != duct )\n    {\n      <span class=\"blue\">string</span> s = duct.DuctType.Name;\n    }\n \n    Family = ( <span class=\"blue\">null</span> != fi )\n      ? fi.Symbol.Family.Name\n      : <span class=\"blue\">string</span>.Empty;\n \n    Symbol = ( <span class=\"blue\">null</span> != fi ) ? fi.Symbol.Name\n      : ( ( <span class=\"blue\">null</span> != elementType ) ? elementType.Name\n      : <span class=\"blue\">string</span>.Empty );\n \n    Name = e.Name;\n \n    Id = e.Id.IntegerValue;\n  }\n \n  <span class=\"blue\">public</span> <span class=\"blue\">override</span> <span class=\"blue\">string</span> ToString()\n  {\n    <span class=\"blue\">string</span> c = (0 == Category.Length)\n      ? Class\n      : Category;\n \n    <span class=\"blue\">string</span> fam = (0 == Family.Length)\n      ? <span class=\"blue\">string</span>.Empty\n      : <span class=\"maroon\">\"'\"</span> + Family + <span class=\"maroon\">\"' \"</span>;\n \n    <span class=\"blue\">return</span> <span class=\"blue\">string</span>.Format(\n      <span class=\"maroon\">\"{0} {1}&lt;{2} '{3}'&gt;\"</span>,\n      c, fam, Id, Name );\n  }\n}\n \n<span class=\"blue\">public</span> <span class=\"blue\">class</span> <span class=\"teal\">ConnectorData</span> : <span class=\"teal\">ElementData</span>\n{\n  <span class=\"teal\">XYZ</span> _p;\n \n  <span class=\"blue\">public</span> <span class=\"blue\">string</span> ConnectorType { <span class=\"blue\">get</span>; <span class=\"blue\">set</span>; }\n  <span class=\"blue\">public</span> <span class=\"blue\">string</span> X { <span class=\"blue\">get</span>; <span class=\"blue\">set</span>; }\n  <span class=\"blue\">public</span> <span class=\"blue\">string</span> Y { <span class=\"blue\">get</span>; <span class=\"blue\">set</span>; }\n  <span class=\"blue\">public</span> <span class=\"blue\">string</span> Z { <span class=\"blue\">get</span>; <span class=\"blue\">set</span>; }\n \n  <span class=\"blue\">public</span> ConnectorData(\n    <span class=\"teal\">Element</span> e,\n    <span class=\"teal\">Document</span> doc,\n    <span class=\"teal\">ConnectorType</span> ct,\n    <span class=\"teal\">XYZ</span> p )\n    : <span class=\"blue\">base</span>( e, doc )\n  {\n    ConnectorType = ct.ToString();\n    _p = p;\n    X = <span class=\"teal\">Util</span>.RealString( p.X );\n    Y = <span class=\"teal\">Util</span>.RealString( p.Y );\n    Z = <span class=\"teal\">Util</span>.RealString( p.Z );\n  }\n \n  <span class=\"blue\">public</span> <span class=\"blue\">override</span> <span class=\"blue\">string</span> ToString()\n  {\n    <span class=\"blue\">return</span> <span class=\"blue\">string</span>.Format(\n      <span class=\"maroon\">\"{0} connector at ({1},{2},{3}) on {4}\"</span>,\n      ConnectorType, X, Y, Z, <span class=\"blue\">base</span>.ToString() );\n  }\n}\n</pre>\n<p>There are a few details here worth mentioning.\nFor instance, I split the connector point into separate X, Y and Z coordinate values, because then I can later sort them based on these values, which gives me more sorting options and flexibility than if they were all lumped together into one single point data item.\nFurthermore, I save the coordinates as string values instead of double numbers, because later on I do not want to see reams of useless, confusing and unintelligible post-comma digits in my user interface.</p>\n<p>Talking about sorting, by the way:</p>\n<h4>Sortable Binding List</h4>\n<p>In the\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2009/02/list-linked-elements.html\">\nlinked elements</a> example\n\nmentioned above, we simply used a generic .NET List&lt;&gt; as a data container.\nThat works fine, but does not automatically provide support for one additional neat feature available from the data grid view, which is the ability to sort the columns.</p>\n<p>If we use a\n\n<a href=\"http://www.timvw.be/presenting-the-sortablebindinglistt-take-two\">\nsortable binding list</a> instead,\n\nall of our columns will automatically be sortable.\nSo we do just that.</p>\n<h4>Log File</h4>\n<p>Since most MEP models will initially contain a large number of parts, and many of them may have unconnected connectors, it makes sense to log the data to a text file in addition to presenting it in the modeless dialogue box.\nThe text file is easier than a form to manually search or automatically post-process for specific purposes.\nHere is my log file implementation:</p>\n<pre class=\"code\">\n<span class=\"blue\">class</span> <span class=\"teal\">JtLogFile</span> : <span class=\"teal\">IDisposable</span>\n{\n  <span class=\"blue\">string</span> _path;\n  <span class=\"teal\">StreamWriter</span> _sw;\n \n  <span class=\"blue\">public</span> JtLogFile( <span class=\"blue\">string</span> basename )\n  {\n    _path = System.IO.<span class=\"teal\">Path</span>.Combine(\n      System.IO.<span class=\"teal\">Path</span>.GetTempPath(),\n      basename + <span class=\"maroon\">\".log\"</span> );\n \n    _sw = <span class=\"blue\">new</span> <span class=\"teal\">StreamWriter</span>( _path, <span class=\"blue\">true</span> );\n \n    _sw.WriteLine( <span class=\"maroon\">\"\\n\\rStart analysis {0}\\n\\r\"</span>,\n      <span class=\"teal\">DateTime</span>.Now.ToString( <span class=\"maroon\">\"u\"</span> ) );\n  }\n \n  <span class=\"blue\">public</span> <span class=\"blue\">void</span> Dispose()\n  {\n    _sw.Close();\n    _sw.Dispose();\n  }\n \n  <span class=\"blue\">public</span> <span class=\"blue\">void</span> Log( <span class=\"blue\">string</span> s )\n  {\n    _sw.WriteLine( s );\n    <span class=\"teal\">Debug</span>.WriteLine( s );\n  }\n \n  <span class=\"blue\">public</span> <span class=\"blue\">string</span> Path\n  {\n    <span class=\"blue\">get</span>\n    {\n      <span class=\"blue\">return</span> _path;\n    }\n  }\n}\n</pre>\n<h4>Collecting and Displaying Information</h4>\n<p>We now have all the components ready to collect and display the unconnected connector information, both in the log file and the modeless form.\nEnter the external command mainline Execute method, which performs the following steps:\n\n<ul>\n<li>Determine Revit application window handle.\n<li>Retrieve all MEP elements that have connectors.\n<li>Loop over all elements and retrieve loose connectors.\n<li>List these in a log file and a data container.\n<li>Display the log file.\n<li>Start a modeless dialogue with entries for all loose connectors and set up the appropriate interaction with Revit.\nI'll postpone the discussion of this last step to a later post, so that we can give it the full attention that it deserves.\n</li></li></li></li></li></li></ul>\n<p>There is whole bunch of additional category tracking going on for logging and validation purposes.\nAt the end of the log file, we display information on the number of elements and connectors processed and what categories they belong to.\nDon't let that confuse or distract you from the main points.</p>\n<pre class=\"code\">\n<span class=\"blue\">public</span> <span class=\"teal\">Result</span> Execute(\n  <span class=\"teal\">ExternalCommandData</span> commandData,\n  <span class=\"blue\">ref</span> <span class=\"teal\">String</span> message,\n  <span class=\"teal\">ElementSet</span> elements )\n{\n  <span class=\"green\">// set up IWin32Window instance encapsulating </span>\n  <span class=\"green\">// main Revit application window handle:</span>\n \n  <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == _hWndRevit )\n  {\n    <span class=\"teal\">Process</span> process = <span class=\"teal\">Process</span>.GetCurrentProcess();\n \n    <span class=\"teal\">IntPtr</span> h = process.MainWindowHandle;\n \n    _hWndRevit = <span class=\"blue\">new</span> <span class=\"teal\">JtWindowHandle</span>( h );\n  }\n \n  <span class=\"teal\">UIApplication</span> app = commandData.Application;\n  <span class=\"teal\">Document</span> doc = app.ActiveUIDocument.Document;\n  <span class=\"blue\">bool</span> include_wires = <span class=\"blue\">false</span>;\n \n  <span class=\"teal\">SortableBindingList</span>&lt;<span class=\"teal\">ConnectorData</span>&gt; data\n    = <span class=\"blue\">new</span> <span class=\"teal\">SortableBindingList</span>&lt;<span class=\"teal\">ConnectorData</span>&gt;();\n \n  <span class=\"blue\">string</span> path;\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtLogFile</span> log\n    = <span class=\"blue\">new</span> <span class=\"teal\">JtLogFile</span>( <span class=\"maroon\">\"LooseConnectors\"</span> ) )\n  {\n    <span class=\"teal\">FilteredElementCollector</span> collector\n      = GetConnectorElements( doc, include_wires );\n \n    <span class=\"teal\">ConnectorSet</span> connectors = <span class=\"blue\">null</span>;\n \n    <span class=\"teal\">Dictionary</span>&lt;<span class=\"blue\">string</span>, <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt;&gt; categories\n      = <span class=\"blue\">new</span> <span class=\"teal\">Dictionary</span>&lt;<span class=\"blue\">string</span>, <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt;&gt;();\n \n    <span class=\"blue\">int</span> nErrors = 0;\n    <span class=\"blue\">int</span> nUnconnected = 0;\n \n    <span class=\"blue\">foreach</span>( <span class=\"teal\">Element</span> e <span class=\"blue\">in</span> collector )\n    {\n      <span class=\"teal\">Category</span> cat = e.Category;\n \n      <span class=\"teal\">Debug</span>.Assert( <span class=\"blue\">null</span> != cat,\n        <span class=\"maroon\">\"expected a valid category on all elements\"</span> );\n \n      <span class=\"blue\">string</span> key = cat.Name;\n \n      <span class=\"blue\">if</span>( !categories.ContainsKey( key ) )\n      {\n        categories[key] = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt;();\n      }\n      categories[key].Add( e );\n \n      connectors = <span class=\"blue\">null</span>;\n \n      <span class=\"blue\">try</span>\n      {\n        connectors = GetConnectors( e );\n      }\n      <span class=\"blue\">catch</span>( <span class=\"teal\">Exception</span> ex )\n      {\n        ++nErrors;\n \n        log.Log( <span class=\"blue\">string</span>.Format(\n          <span class=\"maroon\">\"Error {0} retrieving connectors \"</span>\n          + <span class=\"maroon\">\"from {1}: {2} '{3}'\"</span>,\n          nErrors,\n          <span class=\"blue\">new</span> <span class=\"teal\">ElementData</span>( e, doc ),\n          ex.GetType().Name,\n          ex.Message ) );\n      }\n \n      <span class=\"blue\">if</span>( <span class=\"blue\">null</span> != connectors )\n      {\n        <span class=\"blue\">foreach</span>( <span class=\"teal\">Connector</span> c <span class=\"blue\">in</span> connectors )\n        {\n          <span class=\"blue\">if</span>(\n \n            <span class=\"green\">// this is too restrictive:</span>\n \n            <span class=\"green\">// ConnectorType.PhysicalConn </span>\n            <span class=\"green\">//   == c.ConnectorType </span>\n \n            <span class=\"green\">// i had to add some strange checks to avoid </span>\n            <span class=\"green\">// IsConnected throwing an exception:</span>\n \n            <span class=\"teal\">ConnectorType</span>.LogicalConn != c.ConnectorType\n            &amp;&amp; 32 != ((<span class=\"blue\">int</span>)c.ConnectorType)\n            &amp;&amp; !c.IsConnected )\n          {\n            ++nUnconnected;\n \n            <span class=\"teal\">ConnectorData</span> cd = <span class=\"blue\">new</span> <span class=\"teal\">ConnectorData</span>(\n              e, doc, c.ConnectorType, c.Origin );\n \n            log.Log( <span class=\"blue\">string</span>.Format(\n              <span class=\"maroon\">\"Unconnected {0}: {1}\"</span>,\n              nUnconnected, cd ) );\n \n            data.Add( cd );\n          }\n        }\n      }\n    }\n \n    <span class=\"blue\">int</span> total = categories.Values\n        .Aggregate&lt;<span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt;, <span class=\"blue\">int</span>&gt;(\n          0, ( n, a ) =&gt; n + a.Count );\n \n    log.Log( <span class=\"blue\">string</span>.Format(\n      <span class=\"maroon\">\"Examined {0} elements of {1} categories:\"</span>,\n      total, categories.Count ) );\n \n    <span class=\"teal\">List</span>&lt;<span class=\"blue\">string</span>&gt; keys = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"blue\">string</span>&gt;(\n      categories.Keys );\n \n    keys.Sort();\n \n    <span class=\"blue\">foreach</span>( <span class=\"blue\">string</span> key <span class=\"blue\">in</span> keys )\n    {\n      <span class=\"teal\">Element</span> e = categories[key][0];\n \n      <span class=\"teal\">BuiltInCategory</span> bic = ( <span class=\"teal\">BuiltInCategory</span> )\n        e.Category.Id.IntegerValue;\n \n      log.Log( <span class=\"blue\">string</span>.Format(\n        <span class=\"maroon\">\"{0,8} '{1}' {2}\"</span>,\n        categories[key].Count,\n        key,\n        bic ) );\n    }\n \n    log.Log( <span class=\"blue\">string</span>.Format(\n      <span class=\"maroon\">\"Error retrieving connectors on {0} elements,\"</span>\n      + <span class=\"maroon\">\" {1} unconnected connectors found.\"</span>,\n      nErrors, nUnconnected ) );\n \n    path = log.Path;\n  }\n \n  <span class=\"green\">// display log file:</span>\n \n  <span class=\"teal\">Process</span>.Start( path );\n \n  <span class=\"green\">// display data in modeless form and ensure</span>\n  <span class=\"green\">// that the form remains on tp of Revit:</span>\n \n  <span class=\"teal\">LooseConnectorNavigator</span> navigator\n    = <span class=\"blue\">new</span> <span class=\"teal\">LooseConnectorNavigator</span>(\n      data,\n      <span class=\"blue\">new</span> <span class=\"teal\">SetElementId</span>( SetPendingElementId )  );\n \n  navigator.Show( _hWndRevit );\n \n  <span class=\"green\">// subscribe to Idling event:</span>\n \n  app.Idling += <span class=\"blue\">new</span> <span class=\"teal\">EventHandler</span>&lt;<span class=\"teal\">IdlingEventArgs</span>&gt;(\n    OnIdling );\n \n  <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Succeeded;\n}\n</pre>\n<p>Notes:</p>\n<ul>\n<li>I had to add some checks to work around an exception being thrown by the IsConnected predicate.</li>\n<li>I can use Process.Start to display the log file.</li>\n</ul>\n<p>Here are a couple of sample lines from the generated log file listing the unconnected connector information in the rme_basic_sample_project.rvt included in the Revit MEP distribution:</p>\n<pre class=\"code\">\nUnconnected 48: EndConn connector at (77.22,-12.31,10.38)\n  on Ducts &lt;411599 'Mitered Elbows / Taps'&gt;\n\nUnconnected 49: EndConn connector at (106.09,-12.31,10.38)\n  on Ducts &lt;411618 'Mitered Elbows / Taps'&gt;\n\nUnconnected 50: EndConn connector at (136.28,-9.69,10.38)\n  on Ducts &lt;411724 'Mitered Elbows / Taps'&gt;\n</pre>\n<p>This is the summary information listed at the end of the log file: </p>\n<pre class=\"code\">\nExamined 3927 elements of 15 categories:\n 309 'Air Terminals' OST_DuctTerminal\n  14 'Conduit Fittings' OST_ConduitFitting\n  20 'Conduits' OST_Conduit\n 933 'Duct Fittings' OST_DuctFitting\n 727 'Ducts' OST_DuctCurves\n  29 'Electrical Equipment' OST_ElectricalEquipment\n 424 'Electrical Fixtures' OST_ElectricalFixtures\n  63 'Lighting Devices' OST_LightingDevices\n 410 'Lighting Fixtures' OST_LightingFixtures\n  47 'Mechanical Equipment' OST_MechanicalEquipment\n 464 'Pipe Fittings' OST_PipeFitting\n 467 'Pipes' OST_PipeCurves\n  11 'Plumbing Fixtures' OST_PlumbingFixtures\n   3 'Specialty Equipment' OST_SpecialityEquipment\n   6 'Sprinklers' OST_Sprinklers\nError retrieving connectors on 3 elements,\n381 unconnected connectors found.\n</pre>\n<p>The modeless form populated and displayed by the command looks like this:</p>\n<center>\n<img alt=\"Modeless loose connector form\" src=\"img/modeless_loose_connector_form.png\"/>\n</center>\n<h4>Next</h4>\n<p>The next and final instalment of this discussion will present the details of the interaction of the modeless dialogue box with Revit.\nThe modeless form does not have access to the Revit API, since it is\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/04/asynchronous-api-calls-and-idling.html\">\nnot asynchronously accessible</a>.\n\nHappily, we can use the\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/04/idling-event.html\">\nIdling event</a>\n\nto create a reliable and seamless solution for that.</p>\n<p>In spite of not having completed the entire discussion yet, there is nothing to stop me from sharing the Visual Studio solution and source code with you already now, so here it is in\n\n<!-- C:\\a\\doc\\revit\\blog\\zip\\loose_connectors_5.zip -->\n<a href=\"zip/loose_connectors_5.zip\">\nloose_connectors_5.zip</a>.\n\nThis is actually almost the same sample that I already shared in the discussion of hooking up a modeless dialogue with the\n\n<a href=\"zip/http://thebuildingcoder.typepad.com/blog/2010/06/revit-parent-window.html\">\nRevit parent window</a>.\n\n<p>Enjoy, and I look forward to hearing back from you after my holidays!</p>\n</p></p></p></p></p></p>"
  },
  {
    "original_filename": "0405_data_grid_view",
    "header_text": "Modeless Form with Data Grid View",
    "local_header_href": "#modeless-form-with-data-grid-view",
    "chunk_text": "<h4>Modeless Form with Data Grid View</h4><p>I implemented a modeless form named LooseConnectorNavigator.\nIt is derived from a Form base class from the System.Windows.Forms namespace.\nIt has one single DataGridView control added to it which is anchored to all four sides.\nHere is what it looks like with its properties in the Visual Studio form designer:</p><center>\n<img alt=\"Modeless loose connector navigator form\" src=\"img/modeless_loose_connector_navigator_form.png\"/>\n</center><p>A data grid view is extremely easy to populate with an absolute minimum of coding, as we have already seen in Joel Karr's sample showing how to\n\n<!-- 106 -->\n<a href=\"http://thebuildingcoder.typepad.com/blog/2009/02/list-linked-elements.html\">\nlist linked elements</a>.\n\nIf you set up an appropriate data container whose elements expose certain public member properties, all you need to do is to specify the container as the data source of the data grid view, and it will not only automatically populate the rows of data, but even create the columns according to the available properties!</p><p>What's more, by using\n\n<!-- 164 -->\n<a href=\"http://thebuildingcoder.typepad.com/blog/2009/07/three-coding-and-performance-hints.html\">\nauto-implemented properties</a>,\n\nthe definition of the properties on the data item classes is reduced to just specifying their name and type and almost nothing else.</p>"
  },
  {
    "original_filename": "0405_data_grid_view",
    "header_text": "Data Container Classes",
    "local_header_href": "#data-container-classes",
    "chunk_text": "<h4>Data Container Classes</h4><p>In this case, we wish to display the unconnected connectors.\nEach connector belongs to a specific Revit element, and in some circumstances we wish to present the element data independently of its connectors, so I implemented two separate data containers for each, a base ElementData class and a derived ConnectorData one.\nBoth of them have a list of public properties whose main purpose is to define exactly what ultimately gets displayed in the data grid view.\nThey also each have a constructor which populates their public properties, and a ToString method to stream them to a text file for logging purposes:</p><pre class=\"code\">\n<span class=\"blue\">public</span> <span class=\"blue\">class</span> <span class=\"teal\">ElementData</span>\n{\n  <span class=\"blue\">public</span> <span class=\"blue\">string</span> Class { <span class=\"blue\">get</span>; <span class=\"blue\">set</span>; }\n  <span class=\"blue\">public</span> <span class=\"blue\">string</span> Category { <span class=\"blue\">get</span>; <span class=\"blue\">set</span>; }\n  <span class=\"blue\">public</span> <span class=\"blue\">string</span> Family { <span class=\"blue\">get</span>; <span class=\"blue\">set</span>; }\n  <span class=\"blue\">public</span> <span class=\"blue\">string</span> Symbol { <span class=\"blue\">get</span>; <span class=\"blue\">set</span>; }\n  <span class=\"blue\">public</span> <span class=\"blue\">string</span> Name { <span class=\"blue\">get</span>; <span class=\"blue\">set</span>; }\n  <span class=\"blue\">public</span> <span class=\"blue\">int</span> Id { <span class=\"blue\">get</span>; <span class=\"blue\">set</span>; }\n \n  <span class=\"blue\">public</span> ElementData(\n    <span class=\"teal\">Element</span> e,\n    <span class=\"teal\">Document</span> doc )\n  {\n    Class = e.GetType().Name;\n \n    Category = ( <span class=\"blue\">null</span> == e.Category )\n      ? <span class=\"blue\">string</span>.Empty\n      : e.Category.Name;\n \n    <span class=\"teal\">ElementId</span> typeId = e.GetTypeId();\n \n    <span class=\"teal\">ElementType</span> elementType = ( <span class=\"blue\">null</span> == typeId )\n      ? <span class=\"blue\">null</span>\n      : doc.get_Element( typeId ) <span class=\"blue\">as</span> <span class=\"teal\">ElementType</span>;\n \n    <span class=\"teal\">FamilyInstance</span> fi = e <span class=\"blue\">as</span> <span class=\"teal\">FamilyInstance</span>;\n    <span class=\"teal\">Duct</span> duct = e <span class=\"blue\">as</span> <span class=\"teal\">Duct</span>;\n    <span class=\"blue\">if</span>( <span class=\"blue\">null</span> != duct )\n    {\n      <span class=\"blue\">string</span> s = duct.DuctType.Name;\n    }\n \n    Family = ( <span class=\"blue\">null</span> != fi )\n      ? fi.Symbol.Family.Name\n      : <span class=\"blue\">string</span>.Empty;\n \n    Symbol = ( <span class=\"blue\">null</span> != fi ) ? fi.Symbol.Name\n      : ( ( <span class=\"blue\">null</span> != elementType ) ? elementType.Name\n      : <span class=\"blue\">string</span>.Empty );\n \n    Name = e.Name;\n \n    Id = e.Id.IntegerValue;\n  }\n \n  <span class=\"blue\">public</span> <span class=\"blue\">override</span> <span class=\"blue\">string</span> ToString()\n  {\n    <span class=\"blue\">string</span> c = (0 == Category.Length)\n      ? Class\n      : Category;\n \n    <span class=\"blue\">string</span> fam = (0 == Family.Length)\n      ? <span class=\"blue\">string</span>.Empty\n      : <span class=\"maroon\">\"'\"</span> + Family + <span class=\"maroon\">\"' \"</span>;\n \n    <span class=\"blue\">return</span> <span class=\"blue\">string</span>.Format(\n      <span class=\"maroon\">\"{0} {1}&lt;{2} '{3}'&gt;\"</span>,\n      c, fam, Id, Name );\n  }\n}\n \n<span class=\"blue\">public</span> <span class=\"blue\">class</span> <span class=\"teal\">ConnectorData</span> : <span class=\"teal\">ElementData</span>\n{\n  <span class=\"teal\">XYZ</span> _p;\n \n  <span class=\"blue\">public</span> <span class=\"blue\">string</span> ConnectorType { <span class=\"blue\">get</span>; <span class=\"blue\">set</span>; }\n  <span class=\"blue\">public</span> <span class=\"blue\">string</span> X { <span class=\"blue\">get</span>; <span class=\"blue\">set</span>; }\n  <span class=\"blue\">public</span> <span class=\"blue\">string</span> Y { <span class=\"blue\">get</span>; <span class=\"blue\">set</span>; }\n  <span class=\"blue\">public</span> <span class=\"blue\">string</span> Z { <span class=\"blue\">get</span>; <span class=\"blue\">set</span>; }\n \n  <span class=\"blue\">public</span> ConnectorData(\n    <span class=\"teal\">Element</span> e,\n    <span class=\"teal\">Document</span> doc,\n    <span class=\"teal\">ConnectorType</span> ct,\n    <span class=\"teal\">XYZ</span> p )\n    : <span class=\"blue\">base</span>( e, doc )\n  {\n    ConnectorType = ct.ToString();\n    _p = p;\n    X = <span class=\"teal\">Util</span>.RealString( p.X );\n    Y = <span class=\"teal\">Util</span>.RealString( p.Y );\n    Z = <span class=\"teal\">Util</span>.RealString( p.Z );\n  }\n \n  <span class=\"blue\">public</span> <span class=\"blue\">override</span> <span class=\"blue\">string</span> ToString()\n  {\n    <span class=\"blue\">return</span> <span class=\"blue\">string</span>.Format(\n      <span class=\"maroon\">\"{0} connector at ({1},{2},{3}) on {4}\"</span>,\n      ConnectorType, X, Y, Z, <span class=\"blue\">base</span>.ToString() );\n  }\n}\n</pre><p>There are a few details here worth mentioning.\nFor instance, I split the connector point into separate X, Y and Z coordinate values, because then I can later sort them based on these values, which gives me more sorting options and flexibility than if they were all lumped together into one single point data item.\nFurthermore, I save the coordinates as string values instead of double numbers, because later on I do not want to see reams of useless, confusing and unintelligible post-comma digits in my user interface.</p><p>Talking about sorting, by the way:</p>"
  },
  {
    "original_filename": "0405_data_grid_view",
    "header_text": "Sortable Binding List",
    "local_header_href": "#sortable-binding-list",
    "chunk_text": "<h4>Sortable Binding List</h4><p>In the\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2009/02/list-linked-elements.html\">\nlinked elements</a> example\n\nmentioned above, we simply used a generic .NET List&lt;&gt; as a data container.\nThat works fine, but does not automatically provide support for one additional neat feature available from the data grid view, which is the ability to sort the columns.</p><p>If we use a\n\n<a href=\"http://www.timvw.be/presenting-the-sortablebindinglistt-take-two\">\nsortable binding list</a> instead,\n\nall of our columns will automatically be sortable.\nSo we do just that.</p>"
  },
  {
    "original_filename": "0405_data_grid_view",
    "header_text": "Log File",
    "local_header_href": "#log-file",
    "chunk_text": "<h4>Log File</h4><p>Since most MEP models will initially contain a large number of parts, and many of them may have unconnected connectors, it makes sense to log the data to a text file in addition to presenting it in the modeless dialogue box.\nThe text file is easier than a form to manually search or automatically post-process for specific purposes.\nHere is my log file implementation:</p><pre class=\"code\">\n<span class=\"blue\">class</span> <span class=\"teal\">JtLogFile</span> : <span class=\"teal\">IDisposable</span>\n{\n  <span class=\"blue\">string</span> _path;\n  <span class=\"teal\">StreamWriter</span> _sw;\n \n  <span class=\"blue\">public</span> JtLogFile( <span class=\"blue\">string</span> basename )\n  {\n    _path = System.IO.<span class=\"teal\">Path</span>.Combine(\n      System.IO.<span class=\"teal\">Path</span>.GetTempPath(),\n      basename + <span class=\"maroon\">\".log\"</span> );\n \n    _sw = <span class=\"blue\">new</span> <span class=\"teal\">StreamWriter</span>( _path, <span class=\"blue\">true</span> );\n \n    _sw.WriteLine( <span class=\"maroon\">\"\\n\\rStart analysis {0}\\n\\r\"</span>,\n      <span class=\"teal\">DateTime</span>.Now.ToString( <span class=\"maroon\">\"u\"</span> ) );\n  }\n \n  <span class=\"blue\">public</span> <span class=\"blue\">void</span> Dispose()\n  {\n    _sw.Close();\n    _sw.Dispose();\n  }\n \n  <span class=\"blue\">public</span> <span class=\"blue\">void</span> Log( <span class=\"blue\">string</span> s )\n  {\n    _sw.WriteLine( s );\n    <span class=\"teal\">Debug</span>.WriteLine( s );\n  }\n \n  <span class=\"blue\">public</span> <span class=\"blue\">string</span> Path\n  {\n    <span class=\"blue\">get</span>\n    {\n      <span class=\"blue\">return</span> _path;\n    }\n  }\n}\n</pre>"
  },
  {
    "original_filename": "0405_data_grid_view",
    "header_text": "Collecting and Displaying Information",
    "local_header_href": "#collecting-and-displaying-information",
    "chunk_text": "<h4>Collecting and Displaying Information</h4><p>We now have all the components ready to collect and display the unconnected connector information, both in the log file and the modeless form.\nEnter the external command mainline Execute method, which performs the following steps:\n\n<ul>\n<li>Determine Revit application window handle.\n<li>Retrieve all MEP elements that have connectors.\n<li>Loop over all elements and retrieve loose connectors.\n<li>List these in a log file and a data container.\n<li>Display the log file.\n<li>Start a modeless dialogue with entries for all loose connectors and set up the appropriate interaction with Revit.\nI'll postpone the discussion of this last step to a later post, so that we can give it the full attention that it deserves.\n</li></li></li></li></li></li></ul>\n<p>There is whole bunch of additional category tracking going on for logging and validation purposes.\nAt the end of the log file, we display information on the number of elements and connectors processed and what categories they belong to.\nDon't let that confuse or distract you from the main points.</p>\n<pre class=\"code\">\n<span class=\"blue\">public</span> <span class=\"teal\">Result</span> Execute(\n  <span class=\"teal\">ExternalCommandData</span> commandData,\n  <span class=\"blue\">ref</span> <span class=\"teal\">String</span> message,\n  <span class=\"teal\">ElementSet</span> elements )\n{\n  <span class=\"green\">// set up IWin32Window instance encapsulating </span>\n  <span class=\"green\">// main Revit application window handle:</span>\n \n  <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == _hWndRevit )\n  {\n    <span class=\"teal\">Process</span> process = <span class=\"teal\">Process</span>.GetCurrentProcess();\n \n    <span class=\"teal\">IntPtr</span> h = process.MainWindowHandle;\n \n    _hWndRevit = <span class=\"blue\">new</span> <span class=\"teal\">JtWindowHandle</span>( h );\n  }\n \n  <span class=\"teal\">UIApplication</span> app = commandData.Application;\n  <span class=\"teal\">Document</span> doc = app.ActiveUIDocument.Document;\n  <span class=\"blue\">bool</span> include_wires = <span class=\"blue\">false</span>;\n \n  <span class=\"teal\">SortableBindingList</span>&lt;<span class=\"teal\">ConnectorData</span>&gt; data\n    = <span class=\"blue\">new</span> <span class=\"teal\">SortableBindingList</span>&lt;<span class=\"teal\">ConnectorData</span>&gt;();\n \n  <span class=\"blue\">string</span> path;\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtLogFile</span> log\n    = <span class=\"blue\">new</span> <span class=\"teal\">JtLogFile</span>( <span class=\"maroon\">\"LooseConnectors\"</span> ) )\n  {\n    <span class=\"teal\">FilteredElementCollector</span> collector\n      = GetConnectorElements( doc, include_wires );\n \n    <span class=\"teal\">ConnectorSet</span> connectors = <span class=\"blue\">null</span>;\n \n    <span class=\"teal\">Dictionary</span>&lt;<span class=\"blue\">string</span>, <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt;&gt; categories\n      = <span class=\"blue\">new</span> <span class=\"teal\">Dictionary</span>&lt;<span class=\"blue\">string</span>, <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt;&gt;();\n \n    <span class=\"blue\">int</span> nErrors = 0;\n    <span class=\"blue\">int</span> nUnconnected = 0;\n \n    <span class=\"blue\">foreach</span>( <span class=\"teal\">Element</span> e <span class=\"blue\">in</span> collector )\n    {\n      <span class=\"teal\">Category</span> cat = e.Category;\n \n      <span class=\"teal\">Debug</span>.Assert( <span class=\"blue\">null</span> != cat,\n        <span class=\"maroon\">\"expected a valid category on all elements\"</span> );\n \n      <span class=\"blue\">string</span> key = cat.Name;\n \n      <span class=\"blue\">if</span>( !categories.ContainsKey( key ) )\n      {\n        categories[key] = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt;();\n      }\n      categories[key].Add( e );\n \n      connectors = <span class=\"blue\">null</span>;\n \n      <span class=\"blue\">try</span>\n      {\n        connectors = GetConnectors( e );\n      }\n      <span class=\"blue\">catch</span>( <span class=\"teal\">Exception</span> ex )\n      {\n        ++nErrors;\n \n        log.Log( <span class=\"blue\">string</span>.Format(\n          <span class=\"maroon\">\"Error {0} retrieving connectors \"</span>\n          + <span class=\"maroon\">\"from {1}: {2} '{3}'\"</span>,\n          nErrors,\n          <span class=\"blue\">new</span> <span class=\"teal\">ElementData</span>( e, doc ),\n          ex.GetType().Name,\n          ex.Message ) );\n      }\n \n      <span class=\"blue\">if</span>( <span class=\"blue\">null</span> != connectors )\n      {\n        <span class=\"blue\">foreach</span>( <span class=\"teal\">Connector</span> c <span class=\"blue\">in</span> connectors )\n        {\n          <span class=\"blue\">if</span>(\n \n            <span class=\"green\">// this is too restrictive:</span>\n \n            <span class=\"green\">// ConnectorType.PhysicalConn </span>\n            <span class=\"green\">//   == c.ConnectorType </span>\n \n            <span class=\"green\">// i had to add some strange checks to avoid </span>\n            <span class=\"green\">// IsConnected throwing an exception:</span>\n \n            <span class=\"teal\">ConnectorType</span>.LogicalConn != c.ConnectorType\n            &amp;&amp; 32 != ((<span class=\"blue\">int</span>)c.ConnectorType)\n            &amp;&amp; !c.IsConnected )\n          {\n            ++nUnconnected;\n \n            <span class=\"teal\">ConnectorData</span> cd = <span class=\"blue\">new</span> <span class=\"teal\">ConnectorData</span>(\n              e, doc, c.ConnectorType, c.Origin );\n \n            log.Log( <span class=\"blue\">string</span>.Format(\n              <span class=\"maroon\">\"Unconnected {0}: {1}\"</span>,\n              nUnconnected, cd ) );\n \n            data.Add( cd );\n          }\n        }\n      }\n    }\n \n    <span class=\"blue\">int</span> total = categories.Values\n        .Aggregate&lt;<span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt;, <span class=\"blue\">int</span>&gt;(\n          0, ( n, a ) =&gt; n + a.Count );\n \n    log.Log( <span class=\"blue\">string</span>.Format(\n      <span class=\"maroon\">\"Examined {0} elements of {1} categories:\"</span>,\n      total, categories.Count ) );\n \n    <span class=\"teal\">List</span>&lt;<span class=\"blue\">string</span>&gt; keys = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"blue\">string</span>&gt;(\n      categories.Keys );\n \n    keys.Sort();\n \n    <span class=\"blue\">foreach</span>( <span class=\"blue\">string</span> key <span class=\"blue\">in</span> keys )\n    {\n      <span class=\"teal\">Element</span> e = categories[key][0];\n \n      <span class=\"teal\">BuiltInCategory</span> bic = ( <span class=\"teal\">BuiltInCategory</span> )\n        e.Category.Id.IntegerValue;\n \n      log.Log( <span class=\"blue\">string</span>.Format(\n        <span class=\"maroon\">\"{0,8} '{1}' {2}\"</span>,\n        categories[key].Count,\n        key,\n        bic ) );\n    }\n \n    log.Log( <span class=\"blue\">string</span>.Format(\n      <span class=\"maroon\">\"Error retrieving connectors on {0} elements,\"</span>\n      + <span class=\"maroon\">\" {1} unconnected connectors found.\"</span>,\n      nErrors, nUnconnected ) );\n \n    path = log.Path;\n  }\n \n  <span class=\"green\">// display log file:</span>\n \n  <span class=\"teal\">Process</span>.Start( path );\n \n  <span class=\"green\">// display data in modeless form and ensure</span>\n  <span class=\"green\">// that the form remains on tp of Revit:</span>\n \n  <span class=\"teal\">LooseConnectorNavigator</span> navigator\n    = <span class=\"blue\">new</span> <span class=\"teal\">LooseConnectorNavigator</span>(\n      data,\n      <span class=\"blue\">new</span> <span class=\"teal\">SetElementId</span>( SetPendingElementId )  );\n \n  navigator.Show( _hWndRevit );\n \n  <span class=\"green\">// subscribe to Idling event:</span>\n \n  app.Idling += <span class=\"blue\">new</span> <span class=\"teal\">EventHandler</span>&lt;<span class=\"teal\">IdlingEventArgs</span>&gt;(\n    OnIdling );\n \n  <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Succeeded;\n}\n</pre>\n<p>Notes:</p>\n<ul>\n<li>I had to add some checks to work around an exception being thrown by the IsConnected predicate.</li>\n<li>I can use Process.Start to display the log file.</li>\n</ul>\n<p>Here are a couple of sample lines from the generated log file listing the unconnected connector information in the rme_basic_sample_project.rvt included in the Revit MEP distribution:</p>\n<pre class=\"code\">\nUnconnected 48: EndConn connector at (77.22,-12.31,10.38)\n  on Ducts &lt;411599 'Mitered Elbows / Taps'&gt;\n\nUnconnected 49: EndConn connector at (106.09,-12.31,10.38)\n  on Ducts &lt;411618 'Mitered Elbows / Taps'&gt;\n\nUnconnected 50: EndConn connector at (136.28,-9.69,10.38)\n  on Ducts &lt;411724 'Mitered Elbows / Taps'&gt;\n</pre>\n<p>This is the summary information listed at the end of the log file: </p>\n<pre class=\"code\">\nExamined 3927 elements of 15 categories:\n 309 'Air Terminals' OST_DuctTerminal\n  14 'Conduit Fittings' OST_ConduitFitting\n  20 'Conduits' OST_Conduit\n 933 'Duct Fittings' OST_DuctFitting\n 727 'Ducts' OST_DuctCurves\n  29 'Electrical Equipment' OST_ElectricalEquipment\n 424 'Electrical Fixtures' OST_ElectricalFixtures\n  63 'Lighting Devices' OST_LightingDevices\n 410 'Lighting Fixtures' OST_LightingFixtures\n  47 'Mechanical Equipment' OST_MechanicalEquipment\n 464 'Pipe Fittings' OST_PipeFitting\n 467 'Pipes' OST_PipeCurves\n  11 'Plumbing Fixtures' OST_PlumbingFixtures\n   3 'Specialty Equipment' OST_SpecialityEquipment\n   6 'Sprinklers' OST_Sprinklers\nError retrieving connectors on 3 elements,\n381 unconnected connectors found.\n</pre>\n<p>The modeless form populated and displayed by the command looks like this:</p>\n<center>\n<img alt=\"Modeless loose connector form\" src=\"img/modeless_loose_connector_form.png\"/>\n</center>\n<h4>Next</h4>\n<p>The next and final instalment of this discussion will present the details of the interaction of the modeless dialogue box with Revit.\nThe modeless form does not have access to the Revit API, since it is\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/04/asynchronous-api-calls-and-idling.html\">\nnot asynchronously accessible</a>.\n\nHappily, we can use the\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/04/idling-event.html\">\nIdling event</a>\n\nto create a reliable and seamless solution for that.</p>\n<p>In spite of not having completed the entire discussion yet, there is nothing to stop me from sharing the Visual Studio solution and source code with you already now, so here it is in\n\n<!-- C:\\a\\doc\\revit\\blog\\zip\\loose_connectors_5.zip -->\n<a href=\"zip/loose_connectors_5.zip\">\nloose_connectors_5.zip</a>.\n\nThis is actually almost the same sample that I already shared in the discussion of hooking up a modeless dialogue with the\n\n<a href=\"zip/http://thebuildingcoder.typepad.com/blog/2010/06/revit-parent-window.html\">\nRevit parent window</a>.\n\n<p>Enjoy, and I look forward to hearing back from you after my holidays!</p>\n</p></p>"
  },
  {
    "original_filename": "0405_data_grid_view",
    "header_text": "Next",
    "local_header_href": "#next",
    "chunk_text": "<h4>Next</h4><p>The next and final instalment of this discussion will present the details of the interaction of the modeless dialogue box with Revit.\nThe modeless form does not have access to the Revit API, since it is\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/04/asynchronous-api-calls-and-idling.html\">\nnot asynchronously accessible</a>.\n\nHappily, we can use the\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/04/idling-event.html\">\nIdling event</a>\n\nto create a reliable and seamless solution for that.</p><p>In spite of not having completed the entire discussion yet, there is nothing to stop me from sharing the Visual Studio solution and source code with you already now, so here it is in\n\n<!-- C:\\a\\doc\\revit\\blog\\zip\\loose_connectors_5.zip -->\n<a href=\"zip/loose_connectors_5.zip\">\nloose_connectors_5.zip</a>.\n\nThis is actually almost the same sample that I already shared in the discussion of hooking up a modeless dialogue with the\n\n<a href=\"zip/http://thebuildingcoder.typepad.com/blog/2010/06/revit-parent-window.html\">\nRevit parent window</a>.\n\n<p>Enjoy, and I look forward to hearing back from you after my holidays!</p>\n</p>"
  }
]