[
  {
    "original_filename": "0344_mirror_new_elements",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<head>\n<link href=\"bc.css\" rel=\"stylesheet\" type=\"text/css\"/>\n</head>"
  },
  {
    "original_filename": "0344_mirror_new_elements",
    "header_text": "Retrieving Newly Created Elements in Revit 2011",
    "local_header_href": "#retrieving-newly-created-elements-in-revit-2011",
    "chunk_text": "<h3>Retrieving Newly Created Elements in Revit 2011</h3><p>Here is a largish post which will hopefully keep you happily occupied over the weekend.\nWe looked at the topic of\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2009/07/retrieving-newly-created-elements.html\">\nretrieving newly created elements</a> in\n\nRevit 2010 last year.\nSince the method presented there is based on simply retrieving sequential entries from the Revit element collection, and that collection is no longer directly accessible in Revit 2011, I was curious to see whether the approach presented there would still work.\nTo my surprise, with some adaptation, it really does.\n\n<p>I also discovered a new approach which I believe to be significantly more reliable.\nIt is based on the element ids, and the assumption that they will be monotonously increasing, instead of simply using the sequential order of retrieval of the elements themselves.\nThis new algorithm makes use of the Revit 2011 API filtered element collector mechanism and a parameter filter.\n\nSince my recent\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/04/collector-benchmark.html\">\ncollector benchmarking</a> seems\n\nto indicate that any kind of parameter filter will be significantly faster than post-processing the collector results, I would assume that this new approach is faster as well.\n\n<p>Please note that this technique is completely unnecessary for actually detecting newly added elements in real life, since the new Revit 2011 \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/04/element-level-events.html#1\">\nDocumentChanged element level event</a> provides \n\nthe application subscribing to it a set of all newly added elements each time a transaction is closed.\nSo be aware that the following exercise is mainly academic in nature.\nThank you very much, Guy, for noticing and pointing that out below.\n\n<p>Before looking at how to retrieve the newly created elements, we implemented a minimal command demonstrating the\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2009/07/mirror-an-element.html\">\nuse of the Document.Mirror method</a> in\n\nRevit 2010 and used the result of that method to test the retrieval algorithm.\nI updated that command for Revit 2011 as well, and think it is worthwhile taking a quick look at the differences.\n\n<p>So here are the topics I will be discussing here:\n\n<ul>\n<li><a href=\"#1\">Element mirroring and code changes</a>.\n<li><a href=\"#2\">Revit element access</a>.\n<li>Newly created element retrieval based on <a href=\"#3\">sequential element order</a>.\n<li>Newly created element retrieval based on <a href=\"#4\">monotonously increasing element id values</a>.\n<li><a href=\"#5\">Enhanced parameter filter</a> for greater element id values.\n<li><a href=\"#6\">Download</a>\n</li></li></li></li></li></li></ul>\n<a name=\"#1\"></a>\n<h4>Element Mirroring</h4>\n<p>Let us first have a look at the differences between the 2010 and 2011 versions of the very simple CmdMirror command.\nAll it does is apply the Document.Mirror method on the set of currently selected elements.\nHere is the code for Revit 2010:\n\n<pre class=\"code\">\n<span class=\"blue\">class</span> <span class=\"teal\">CmdMirror</span> : <span class=\"teal\">IExternalCommand</span>\n{\n  <span class=\"blue\">public</span> <span class=\"teal\">CmdResult</span> Execute(\n    <span class=\"teal\">ExternalCommandData</span> commandData,\n    <span class=\"blue\">ref</span> <span class=\"blue\">string</span> message,\n    <span class=\"teal\">ElementSet</span> elements )\n  {\n    <span class=\"teal\">Application</span> app = commandData.Application;\n    <span class=\"teal\">Document</span> doc = app.ActiveDocument;\n \n    <span class=\"teal\">ElementSet</span> els = doc.Selection.Elements;\n \n    <span class=\"teal\">Line</span> line = app.Create.NewLine(\n      <span class=\"teal\">XYZ</span>.Zero, <span class=\"teal\">XYZ</span>.BasisX, <span class=\"blue\">true</span> );\n \n    doc.Mirror( els, line );\n \n    <span class=\"blue\">return</span> <span class=\"teal\">CmdResult</span>.Succeeded;\n  }\n}\n</pre>\n<p>The equivalent code for Revit 2011 looks like this:\n\n<pre class=\"code\">\n[<span class=\"teal\">Transaction</span>( <span class=\"teal\">TransactionMode</span>.Automatic )]\n[<span class=\"teal\">Regeneration</span>( <span class=\"teal\">RegenerationOption</span>.Manual )]\n<span class=\"blue\">class</span> <span class=\"teal\">CmdMirror</span> : <span class=\"teal\">IExternalCommand</span>\n{\n  <span class=\"blue\">public</span> <span class=\"teal\">Result</span> Execute(\n    <span class=\"teal\">ExternalCommandData</span> commandData,\n    <span class=\"blue\">ref</span> <span class=\"blue\">string</span> message,\n    <span class=\"teal\">ElementSet</span> elements )\n  {\n    <span class=\"teal\">UIApplication</span> uiapp = commandData.Application;\n    <span class=\"teal\">UIDocument</span> uidoc = uiapp.ActiveUIDocument;\n \n    <span class=\"teal\">Application</span> app = uiapp.Application;\n    <span class=\"teal\">Document</span> doc = uidoc.Document;\n \n    <span class=\"teal\">ElementSet</span> els = uidoc.Selection.Elements;\n \n    <span class=\"teal\">Line</span> line = app.Create.NewLine(\n      <span class=\"teal\">XYZ</span>.Zero, <span class=\"teal\">XYZ</span>.BasisX, <span class=\"blue\">true</span> );\n \n    doc.Mirror( els, line );\n \n    <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Succeeded;\n  }\n}\n</pre>\n<p>Note the following differences:\n\n<ul>\n<li>The class now requires the transaction mode and regeneration options.\n<li>The CmdResult enumeration has been renamed.\n<li>There are separate classes for the user interface and database versions of the application and document classes.\n</li></li></li></ul>\n<p>In addition to the code itself, the Revit namespaces have changed completely, and we also have to reference two Revit API assemblies instead of just one now after the\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/03/revit-2011-is-coming.html\">\nDLL split</a> and\n\n<a href=\"http://redbolts.com/blog/post/2010/03/27/Revit2011-API-e28093-Whate28099s-in-a-name.aspx\">\nnamespace refactoring</a>.\nHere are the namespaces and classes that we reference in the Revit 2010 version of the code:\n\n<pre class=\"code\">\n<span class=\"blue\">using</span> System;\n<span class=\"blue\">using</span> System.Collections.Generic;\n<span class=\"blue\">using</span> Autodesk.Revit;\n<span class=\"blue\">using</span> <span class=\"teal\">Line</span> = Autodesk.Revit.Geometry.<span class=\"teal\">Line</span>;\n<span class=\"blue\">using</span> <span class=\"teal\">XYZ</span> = Autodesk.Revit.Geometry.<span class=\"teal\">XYZ</span>;\n<span class=\"blue\">using</span> <span class=\"teal\">CmdResult</span> = Autodesk.Revit.<span class=\"teal\">IExternalCommand</span>.<span class=\"teal\">Result</span>;\n</pre>\n<p>In the Revit 2011 API, we make use of the following namespaces instead:\n\n<pre class=\"code\">\n<span class=\"blue\">using</span> System;\n<span class=\"blue\">using</span> System.Collections.Generic;\n<span class=\"blue\">using</span> System.Diagnostics;\n<span class=\"blue\">using</span> System.Linq;\n<span class=\"blue\">using</span> Autodesk.Revit.ApplicationServices;\n<span class=\"blue\">using</span> Autodesk.Revit.Attributes;\n<span class=\"blue\">using</span> Autodesk.Revit.DB;\n<span class=\"blue\">using</span> Autodesk.Revit.UI;\n</pre>\n<p>Other than that, nothing has changed.\nIn this super-simple seven-line command, though, that does mean that five of the original lines of code have been modified, four more added, and every single Revit namespace reference replaced.\n\n<p>All of the changes we encountered in this case, however, only have to do with the add-in packaging and connection to Revit.\nNone of them have anything to do with its actual functionality, and the two lines of code which really do any work, the calls to NewLine and Mirror, have in fact not changed at all.\nTherefore, in a larger application, you would expect a much smaller percentage of the code to be affected.\n\n<p>Now that we have the mirroring operation sorted out for Revit 2011, let's have a look at the newly created element retrieval algorithm.\nBut first, a couple of words on Revit element access in general.\n\n\n<a name=\"#2\"></a>\n<h4>Revit Element Access</h4>\n<p>In Revit 2010 and previous versions, the Revit API provided direct access to the Revit element collection.\nIn the Revit 2011 API, this collection is no longer directly accessible at all, since the API designers have decided that no normal application ever has any legitimate need to iterate over all elements in the database in one go, but should always be interested in only a subset.\nTo retrieve such subsets, the API provides highly optimised filtered element collectors, as we saw in the recent discussions on\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/03/performance-profiling.html\">\nperformance profiling</a> and\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/04/collector-benchmark.html\">\ncollector benchmarking</a>.\n\n<p>In Revit 2010, we implemented a system to retrieve newly added elements, for instance those generated by executing the mirror command, simply by making a note of the total number of elements before executing the command, executing the mirroring operation, and then retrieving all the ones returned after that number when sequentially iterating over the elements collection.\nSince the elements collection is no longer accessible in the Revit 2011 API, I was pretty sure that this would no longer work.\nSurprisingly, though, it still does.\n\n<p>Since there is no access to the full elements collection, I applied the filter WhereElementIsNotElementType to the document's FilteredElementCollector.\nElementType is 2011-speak for Symbol, i.e. the Revit 2010 class Symbol has been renamed to ElementType in the Revit 2011 API, so this filter returns all elements which are not element types.\nI would assume that to include all elements which may result from a mirroring operation.\nPlease correct me if I am mistaken.\n\n<p>Here is the very simple method making use of this filter, which we will later use for both the sequential element and the monotonously increasing element id retrieval methods:\n\n<pre class=\"code\">\n<span class=\"teal\">FilteredElementCollector</span> GetElements( <span class=\"teal\">Document</span> doc )\n{\n  <span class=\"teal\">FilteredElementCollector</span> collector\n    = <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( doc );\n  <span class=\"blue\">return</span> collector.WhereElementIsNotElementType();\n}\n</pre>\n<a name=\"#3\"></a>\n<h4>Newly Created Element Retrieval Based on Sequential Element Order</h4>\n<p>To retrieve all elements returned after a given sequence number, similar to the original 2010 algorithm, we implemented the following methods:\n\n<pre class=\"code\">\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n<span class=\"gray\">///</span><span class=\"green\"> Return the current number of non-ElementType elements.</span>\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n<span class=\"blue\">int</span> GetElementCount( <span class=\"teal\">Document</span> doc )\n{\n  <span class=\"blue\">return</span> GetElements( doc ).ToElements().Count;\n}\n \n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n<span class=\"gray\">///</span><span class=\"green\"> Return all database elements after the given number n.</span>\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n<span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt; GetElementsAfter( <span class=\"blue\">int</span> n, <span class=\"teal\">Document</span> doc )\n{\n  <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt; a = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt;();\n  <span class=\"teal\">FilteredElementCollector</span> c = GetElements( doc );\n  <span class=\"blue\">int</span> i = 0;\n \n  <span class=\"blue\">foreach</span>( <span class=\"teal\">Element</span> e <span class=\"blue\">in</span> c )\n  {\n    ++i;\n \n    <span class=\"blue\">if</span>( n &lt; i )\n    {\n      a.Add( e );\n    }\n  }\n  <span class=\"blue\">return</span> a;\n}\n</pre>\n<p>They are called like this to determine the number of non-ElementType elements before the mirroring operation, execute the mirroring command, and retrieve the newly added elements afterwards:\n\n<pre class=\"code\">\n<span class=\"blue\">using</span>( <span class=\"teal\">SubTransaction</span> t = <span class=\"blue\">new</span> <span class=\"teal\">SubTransaction</span>( doc ) )\n{\n  t.Start();\n \n  <span class=\"blue\">int</span> n = GetElementCount( doc );\n \n  doc.Mirror( els, line );\n \n  <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt; a = GetElementsAfter( n, doc );\n \n  <span class=\"blue\">string</span> s = _msg;\n \n  <span class=\"blue\">foreach</span>( <span class=\"teal\">Element</span> e <span class=\"blue\">in</span> a )\n  {\n    s += <span class=\"blue\">string</span>.Format( <span class=\"maroon\">\"\\r\\n  {0}\"</span>,\n      <span class=\"teal\">Util</span>.ElementDescription( e ) );\n  }\n  <span class=\"teal\">Util</span>.InfoMsg( s );\n \n  t.RollBack();\n}\n</pre>\n<p>The entire operation is encapsulated in a sub-transaction which is subsequently rolled back, so that we can immediately continue to test the alternative and more reliable new retrieval method based on element ids instead of the sequence of the elements themselves.\n\n\n<a name=\"#4\"></a>\n<h4>Newly Created Element Retrieval Based on Monotonously Increasing Element Id Values</h4>\n<p>Instead of simply using the sequential ordering of elements as they happen to be returned by the filtered element collector, a much more reliable assumption is that element ids are allocated monotonously increasing values.\nTherefore, instead of simply counting the number of elements returned by the GetElements method, as we did above in GetElementCount, a more reliable approach might be to determine the maximal element id value before the mirroring operation, and then retrieve all elements with a higher element id afterwards.\n\n<p>Since the element id is available through a parameter, we can make use of a parameter filter to retrieve these elements.\nTo make use of a parameter filter, you have to define the following components:\n\n<ul>\n<li>The provider, e.g. the parameter you are interested in.\n<li>The evaluator, e.g. how to compare it with the target value.\n<li>The rule, which specifies how the provider and the comparison work together.\n</li></li></li></ul>\n<p>We demonstrated one implementation of using a parameter filter in the \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/04/collector-benchmark.html\">\ncollector benchmark</a> command\n\nCmdCollectorPerformance, in the method GetFirstNamedElementOfTypeUsingParameterFilter, where we used it to find an element with a specific name by checking the built-in parameter ELEM_NAME_PARAM for equality with the given target string.\n\n<p>In this case, we set up a parameter filter to retrieve elements whose element id is greater than a given value.\nWe can achieve this by specifying that the value of the built-in parameter ID_PARAM must exceed the target element id, like this:\n\n<pre class=\"code\">\n<span class=\"teal\">FilteredElementCollector</span> GetElementsAfter(\n  <span class=\"teal\">Document</span> doc,\n  <span class=\"teal\">ElementId</span> lastId )\n{\n  <span class=\"teal\">BuiltInParameter</span> bip = <span class=\"teal\">BuiltInParameter</span>.ID_PARAM;\n \n  <span class=\"teal\">ParameterValueProvider</span> provider\n    = <span class=\"blue\">new</span> <span class=\"teal\">ParameterValueProvider</span>( \n      <span class=\"blue\">new</span> <span class=\"teal\">ElementId</span>( bip ) );\n \n  <span class=\"teal\">FilterNumericRuleEvaluator</span> evaluator\n    = <span class=\"blue\">new</span> <span class=\"teal\">FilterNumericGreater</span>();\n \n  <span class=\"teal\">FilterRule</span> rule = <span class=\"blue\">new</span> <span class=\"teal\">FilterElementIdRule</span>(\n    provider, evaluator, lastId );\n \n  <span class=\"teal\">ElementParameterFilter</span> filter\n    = <span class=\"blue\">new</span> <span class=\"teal\">ElementParameterFilter</span>( rule );\n \n  <span class=\"teal\">FilteredElementCollector</span> collector\n    = <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( doc );\n \n  <span class=\"blue\">return</span> collector.WherePasses( filter );\n}\n</pre>\n<p>This method returns all elements in the entire document whose element id is greater than 'lastId'.\n\n<p>Here is the code making use of this method, analogously to the snippet above, i.e. determine the maximal element id before the mirroring operation, execute the mirroring command, and retrieve the newly added elements afterwards:\n\n<pre class=\"code\">\n<span class=\"blue\">using</span>( <span class=\"teal\">SubTransaction</span> t = <span class=\"blue\">new</span> <span class=\"teal\">SubTransaction</span>( doc ) )\n{\n  t.Start();\n \n  <span class=\"teal\">FilteredElementCollector</span> a = GetElements( doc );\n  <span class=\"blue\">int</span> i = a.Max&lt;<span class=\"teal\">Element</span>&gt;( e =&gt; e.Id.IntegerValue );\n  <span class=\"teal\">ElementId</span> maxId = <span class=\"blue\">new</span> <span class=\"teal\">ElementId</span>( i );\n \n  doc.Mirror( els, line );\n \n  <span class=\"green\">// get all elements in document with an</span>\n  <span class=\"green\">// element id greater than maxId:</span>\n \n  a = GetElementsAfter( doc, maxId );\n \n  <span class=\"blue\">string</span> s = _msg;\n \n  <span class=\"blue\">foreach</span>( <span class=\"teal\">Element</span> e <span class=\"blue\">in</span> a )\n  {\n    s += <span class=\"blue\">string</span>.Format( <span class=\"maroon\">\"\\r\\n  {0}\"</span>,\n      <span class=\"teal\">Util</span>.ElementDescription( e ) );\n  }\n  <span class=\"teal\">Util</span>.InfoMsg( s );\n \n  t.RollBack();\n}\n</pre>\n<a name=\"#5\"></a>\n<h4>Enhanced Parameter Filter for Greater Element Id Values</h4>\n<p>While writing this, I just noticed some potential for more improvement here.\nThe parameter filter is a slow filter, so it is important to eliminate as many elements as possible using other quick filters before applying it.\nOne filter that we did apply in all the previous element retrieval was the non-ElementType one, so why not use it here as well?\n\n<p>A filtered element collector need not necessarily be based on a document, but can also be used to apply further filtering to the results of a previous filter.\nMaking use of this functionality, we can rewrite our parameter filter method as follows to use a collection of already filtered elements instead of the contents of the entire document:\n\n<pre class=\"code\">\n<span class=\"teal\">FilteredElementCollector</span> GetElementsAfter(\n  <span class=\"teal\">FilteredElementCollector</span> input,\n  <span class=\"teal\">ElementId</span> lastId )\n{\n  <span class=\"teal\">BuiltInParameter</span> bip = <span class=\"teal\">BuiltInParameter</span>.ID_PARAM;\n \n  <span class=\"teal\">ParameterValueProvider</span> provider \n    = <span class=\"blue\">new</span> <span class=\"teal\">ParameterValueProvider</span>( \n      <span class=\"blue\">new</span> <span class=\"teal\">ElementId</span>( bip ) );\n \n  <span class=\"teal\">FilterNumericRuleEvaluator</span> evaluator \n    = <span class=\"blue\">new</span> <span class=\"teal\">FilterNumericGreater</span>();\n \n  <span class=\"teal\">FilterRule</span> rule = <span class=\"blue\">new</span> <span class=\"teal\">FilterElementIdRule</span>( \n    provider, evaluator, lastId );\n \n  <span class=\"teal\">ElementParameterFilter</span> filter \n    = <span class=\"blue\">new</span> <span class=\"teal\">ElementParameterFilter</span>( rule );\n \n  <span class=\"blue\">return</span> input.WherePasses( filter );\n}\n</pre>\n<p>Then we can reuse the GetElements that we used above once again for the parameter filter retrieval as well like this:\n\n<pre class=\"code\">\n<span class=\"blue\">using</span>( <span class=\"teal\">SubTransaction</span> t = <span class=\"blue\">new</span> <span class=\"teal\">SubTransaction</span>( doc ) )\n{\n  t.Start();\n \n  <span class=\"teal\">FilteredElementCollector</span> a = GetElements( doc );\n  <span class=\"blue\">int</span> i = a.Max&lt;<span class=\"teal\">Element</span>&gt;( e =&gt; e.Id.IntegerValue );\n  <span class=\"teal\">ElementId</span> maxId = <span class=\"blue\">new</span> <span class=\"teal\">ElementId</span>( i );\n \n  doc.Mirror( els, line );\n \n  <span class=\"green\">// only look at non-ElementType elements</span>\n  <span class=\"green\">// instead of all document elements:</span>\n \n  a = GetElements( doc );\n  a = GetElementsAfter( a, maxId );\n \n  <span class=\"blue\">string</span> s = _msg;\n \n  <span class=\"blue\">foreach</span>( <span class=\"teal\">Element</span> e <span class=\"blue\">in</span> a )\n  {\n    s += <span class=\"blue\">string</span>.Format( <span class=\"maroon\">\"\\r\\n  {0}\"</span>,\n      <span class=\"teal\">Util</span>.ElementDescription( e ) );\n  }\n  <span class=\"teal\">Util</span>.InfoMsg( s );\n \n  t.RollBack();\n}\n</pre>\n<p>In a real-world application, there will probably be numerous other quick filters that can be applied additionally before resorting to slow ones to eliminate even more uninteresting elements and further improve performance.\nIt would also be interesting to add some benchmarking code to the three cases presented above and run a test in a reasonably sized model to see whether the performance differences that I am postulating above really exist.\nI will leave that as an exercise to the interested reader, for the moment, leaving this post at is, for now, and hope that this exploration proves useful to you.\n\n\n<a name=\"#6\"></a>\n<h4>Download</h4>\n<p>Here is \n\n<a href=\"zip/bc_11_64.zip\">\nversion 2011.0.0.64</a>\n\nof the complete Visual Studio solution including the updated mirroring and newly created element retrieval commands CmdMirror and CmdMirrorListAdded.</p>\n</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p>"
  },
  {
    "original_filename": "0344_mirror_new_elements",
    "header_text": "Element Mirroring",
    "local_header_href": "#element-mirroring",
    "chunk_text": "<h4>Element Mirroring</h4><p>Let us first have a look at the differences between the 2010 and 2011 versions of the very simple CmdMirror command.\nAll it does is apply the Document.Mirror method on the set of currently selected elements.\nHere is the code for Revit 2010:\n\n<pre class=\"code\">\n<span class=\"blue\">class</span> <span class=\"teal\">CmdMirror</span> : <span class=\"teal\">IExternalCommand</span>\n{\n  <span class=\"blue\">public</span> <span class=\"teal\">CmdResult</span> Execute(\n    <span class=\"teal\">ExternalCommandData</span> commandData,\n    <span class=\"blue\">ref</span> <span class=\"blue\">string</span> message,\n    <span class=\"teal\">ElementSet</span> elements )\n  {\n    <span class=\"teal\">Application</span> app = commandData.Application;\n    <span class=\"teal\">Document</span> doc = app.ActiveDocument;\n \n    <span class=\"teal\">ElementSet</span> els = doc.Selection.Elements;\n \n    <span class=\"teal\">Line</span> line = app.Create.NewLine(\n      <span class=\"teal\">XYZ</span>.Zero, <span class=\"teal\">XYZ</span>.BasisX, <span class=\"blue\">true</span> );\n \n    doc.Mirror( els, line );\n \n    <span class=\"blue\">return</span> <span class=\"teal\">CmdResult</span>.Succeeded;\n  }\n}\n</pre>\n<p>The equivalent code for Revit 2011 looks like this:\n\n<pre class=\"code\">\n[<span class=\"teal\">Transaction</span>( <span class=\"teal\">TransactionMode</span>.Automatic )]\n[<span class=\"teal\">Regeneration</span>( <span class=\"teal\">RegenerationOption</span>.Manual )]\n<span class=\"blue\">class</span> <span class=\"teal\">CmdMirror</span> : <span class=\"teal\">IExternalCommand</span>\n{\n  <span class=\"blue\">public</span> <span class=\"teal\">Result</span> Execute(\n    <span class=\"teal\">ExternalCommandData</span> commandData,\n    <span class=\"blue\">ref</span> <span class=\"blue\">string</span> message,\n    <span class=\"teal\">ElementSet</span> elements )\n  {\n    <span class=\"teal\">UIApplication</span> uiapp = commandData.Application;\n    <span class=\"teal\">UIDocument</span> uidoc = uiapp.ActiveUIDocument;\n \n    <span class=\"teal\">Application</span> app = uiapp.Application;\n    <span class=\"teal\">Document</span> doc = uidoc.Document;\n \n    <span class=\"teal\">ElementSet</span> els = uidoc.Selection.Elements;\n \n    <span class=\"teal\">Line</span> line = app.Create.NewLine(\n      <span class=\"teal\">XYZ</span>.Zero, <span class=\"teal\">XYZ</span>.BasisX, <span class=\"blue\">true</span> );\n \n    doc.Mirror( els, line );\n \n    <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Succeeded;\n  }\n}\n</pre>\n<p>Note the following differences:\n\n<ul>\n<li>The class now requires the transaction mode and regeneration options.\n<li>The CmdResult enumeration has been renamed.\n<li>There are separate classes for the user interface and database versions of the application and document classes.\n</li></li></li></ul>\n<p>In addition to the code itself, the Revit namespaces have changed completely, and we also have to reference two Revit API assemblies instead of just one now after the\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/03/revit-2011-is-coming.html\">\nDLL split</a> and\n\n<a href=\"http://redbolts.com/blog/post/2010/03/27/Revit2011-API-e28093-Whate28099s-in-a-name.aspx\">\nnamespace refactoring</a>.\nHere are the namespaces and classes that we reference in the Revit 2010 version of the code:\n\n<pre class=\"code\">\n<span class=\"blue\">using</span> System;\n<span class=\"blue\">using</span> System.Collections.Generic;\n<span class=\"blue\">using</span> Autodesk.Revit;\n<span class=\"blue\">using</span> <span class=\"teal\">Line</span> = Autodesk.Revit.Geometry.<span class=\"teal\">Line</span>;\n<span class=\"blue\">using</span> <span class=\"teal\">XYZ</span> = Autodesk.Revit.Geometry.<span class=\"teal\">XYZ</span>;\n<span class=\"blue\">using</span> <span class=\"teal\">CmdResult</span> = Autodesk.Revit.<span class=\"teal\">IExternalCommand</span>.<span class=\"teal\">Result</span>;\n</pre>\n<p>In the Revit 2011 API, we make use of the following namespaces instead:\n\n<pre class=\"code\">\n<span class=\"blue\">using</span> System;\n<span class=\"blue\">using</span> System.Collections.Generic;\n<span class=\"blue\">using</span> System.Diagnostics;\n<span class=\"blue\">using</span> System.Linq;\n<span class=\"blue\">using</span> Autodesk.Revit.ApplicationServices;\n<span class=\"blue\">using</span> Autodesk.Revit.Attributes;\n<span class=\"blue\">using</span> Autodesk.Revit.DB;\n<span class=\"blue\">using</span> Autodesk.Revit.UI;\n</pre>\n<p>Other than that, nothing has changed.\nIn this super-simple seven-line command, though, that does mean that five of the original lines of code have been modified, four more added, and every single Revit namespace reference replaced.\n\n<p>All of the changes we encountered in this case, however, only have to do with the add-in packaging and connection to Revit.\nNone of them have anything to do with its actual functionality, and the two lines of code which really do any work, the calls to NewLine and Mirror, have in fact not changed at all.\nTherefore, in a larger application, you would expect a much smaller percentage of the code to be affected.\n\n<p>Now that we have the mirroring operation sorted out for Revit 2011, let's have a look at the newly created element retrieval algorithm.\nBut first, a couple of words on Revit element access in general.\n\n\n<a name=\"#2\"></a>\n<h4>Revit Element Access</h4>\n<p>In Revit 2010 and previous versions, the Revit API provided direct access to the Revit element collection.\nIn the Revit 2011 API, this collection is no longer directly accessible at all, since the API designers have decided that no normal application ever has any legitimate need to iterate over all elements in the database in one go, but should always be interested in only a subset.\nTo retrieve such subsets, the API provides highly optimised filtered element collectors, as we saw in the recent discussions on\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/03/performance-profiling.html\">\nperformance profiling</a> and\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/04/collector-benchmark.html\">\ncollector benchmarking</a>.\n\n<p>In Revit 2010, we implemented a system to retrieve newly added elements, for instance those generated by executing the mirror command, simply by making a note of the total number of elements before executing the command, executing the mirroring operation, and then retrieving all the ones returned after that number when sequentially iterating over the elements collection.\nSince the elements collection is no longer accessible in the Revit 2011 API, I was pretty sure that this would no longer work.\nSurprisingly, though, it still does.\n\n<p>Since there is no access to the full elements collection, I applied the filter WhereElementIsNotElementType to the document's FilteredElementCollector.\nElementType is 2011-speak for Symbol, i.e. the Revit 2010 class Symbol has been renamed to ElementType in the Revit 2011 API, so this filter returns all elements which are not element types.\nI would assume that to include all elements which may result from a mirroring operation.\nPlease correct me if I am mistaken.\n\n<p>Here is the very simple method making use of this filter, which we will later use for both the sequential element and the monotonously increasing element id retrieval methods:\n\n<pre class=\"code\">\n<span class=\"teal\">FilteredElementCollector</span> GetElements( <span class=\"teal\">Document</span> doc )\n{\n  <span class=\"teal\">FilteredElementCollector</span> collector\n    = <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( doc );\n  <span class=\"blue\">return</span> collector.WhereElementIsNotElementType();\n}\n</pre>\n<a name=\"#3\"></a>\n<h4>Newly Created Element Retrieval Based on Sequential Element Order</h4>\n<p>To retrieve all elements returned after a given sequence number, similar to the original 2010 algorithm, we implemented the following methods:\n\n<pre class=\"code\">\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n<span class=\"gray\">///</span><span class=\"green\"> Return the current number of non-ElementType elements.</span>\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n<span class=\"blue\">int</span> GetElementCount( <span class=\"teal\">Document</span> doc )\n{\n  <span class=\"blue\">return</span> GetElements( doc ).ToElements().Count;\n}\n \n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n<span class=\"gray\">///</span><span class=\"green\"> Return all database elements after the given number n.</span>\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n<span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt; GetElementsAfter( <span class=\"blue\">int</span> n, <span class=\"teal\">Document</span> doc )\n{\n  <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt; a = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt;();\n  <span class=\"teal\">FilteredElementCollector</span> c = GetElements( doc );\n  <span class=\"blue\">int</span> i = 0;\n \n  <span class=\"blue\">foreach</span>( <span class=\"teal\">Element</span> e <span class=\"blue\">in</span> c )\n  {\n    ++i;\n \n    <span class=\"blue\">if</span>( n &lt; i )\n    {\n      a.Add( e );\n    }\n  }\n  <span class=\"blue\">return</span> a;\n}\n</pre>\n<p>They are called like this to determine the number of non-ElementType elements before the mirroring operation, execute the mirroring command, and retrieve the newly added elements afterwards:\n\n<pre class=\"code\">\n<span class=\"blue\">using</span>( <span class=\"teal\">SubTransaction</span> t = <span class=\"blue\">new</span> <span class=\"teal\">SubTransaction</span>( doc ) )\n{\n  t.Start();\n \n  <span class=\"blue\">int</span> n = GetElementCount( doc );\n \n  doc.Mirror( els, line );\n \n  <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt; a = GetElementsAfter( n, doc );\n \n  <span class=\"blue\">string</span> s = _msg;\n \n  <span class=\"blue\">foreach</span>( <span class=\"teal\">Element</span> e <span class=\"blue\">in</span> a )\n  {\n    s += <span class=\"blue\">string</span>.Format( <span class=\"maroon\">\"\\r\\n  {0}\"</span>,\n      <span class=\"teal\">Util</span>.ElementDescription( e ) );\n  }\n  <span class=\"teal\">Util</span>.InfoMsg( s );\n \n  t.RollBack();\n}\n</pre>\n<p>The entire operation is encapsulated in a sub-transaction which is subsequently rolled back, so that we can immediately continue to test the alternative and more reliable new retrieval method based on element ids instead of the sequence of the elements themselves.\n\n\n<a name=\"#4\"></a>\n<h4>Newly Created Element Retrieval Based on Monotonously Increasing Element Id Values</h4>\n<p>Instead of simply using the sequential ordering of elements as they happen to be returned by the filtered element collector, a much more reliable assumption is that element ids are allocated monotonously increasing values.\nTherefore, instead of simply counting the number of elements returned by the GetElements method, as we did above in GetElementCount, a more reliable approach might be to determine the maximal element id value before the mirroring operation, and then retrieve all elements with a higher element id afterwards.\n\n<p>Since the element id is available through a parameter, we can make use of a parameter filter to retrieve these elements.\nTo make use of a parameter filter, you have to define the following components:\n\n<ul>\n<li>The provider, e.g. the parameter you are interested in.\n<li>The evaluator, e.g. how to compare it with the target value.\n<li>The rule, which specifies how the provider and the comparison work together.\n</li></li></li></ul>\n<p>We demonstrated one implementation of using a parameter filter in the \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/04/collector-benchmark.html\">\ncollector benchmark</a> command\n\nCmdCollectorPerformance, in the method GetFirstNamedElementOfTypeUsingParameterFilter, where we used it to find an element with a specific name by checking the built-in parameter ELEM_NAME_PARAM for equality with the given target string.\n\n<p>In this case, we set up a parameter filter to retrieve elements whose element id is greater than a given value.\nWe can achieve this by specifying that the value of the built-in parameter ID_PARAM must exceed the target element id, like this:\n\n<pre class=\"code\">\n<span class=\"teal\">FilteredElementCollector</span> GetElementsAfter(\n  <span class=\"teal\">Document</span> doc,\n  <span class=\"teal\">ElementId</span> lastId )\n{\n  <span class=\"teal\">BuiltInParameter</span> bip = <span class=\"teal\">BuiltInParameter</span>.ID_PARAM;\n \n  <span class=\"teal\">ParameterValueProvider</span> provider\n    = <span class=\"blue\">new</span> <span class=\"teal\">ParameterValueProvider</span>( \n      <span class=\"blue\">new</span> <span class=\"teal\">ElementId</span>( bip ) );\n \n  <span class=\"teal\">FilterNumericRuleEvaluator</span> evaluator\n    = <span class=\"blue\">new</span> <span class=\"teal\">FilterNumericGreater</span>();\n \n  <span class=\"teal\">FilterRule</span> rule = <span class=\"blue\">new</span> <span class=\"teal\">FilterElementIdRule</span>(\n    provider, evaluator, lastId );\n \n  <span class=\"teal\">ElementParameterFilter</span> filter\n    = <span class=\"blue\">new</span> <span class=\"teal\">ElementParameterFilter</span>( rule );\n \n  <span class=\"teal\">FilteredElementCollector</span> collector\n    = <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( doc );\n \n  <span class=\"blue\">return</span> collector.WherePasses( filter );\n}\n</pre>\n<p>This method returns all elements in the entire document whose element id is greater than 'lastId'.\n\n<p>Here is the code making use of this method, analogously to the snippet above, i.e. determine the maximal element id before the mirroring operation, execute the mirroring command, and retrieve the newly added elements afterwards:\n\n<pre class=\"code\">\n<span class=\"blue\">using</span>( <span class=\"teal\">SubTransaction</span> t = <span class=\"blue\">new</span> <span class=\"teal\">SubTransaction</span>( doc ) )\n{\n  t.Start();\n \n  <span class=\"teal\">FilteredElementCollector</span> a = GetElements( doc );\n  <span class=\"blue\">int</span> i = a.Max&lt;<span class=\"teal\">Element</span>&gt;( e =&gt; e.Id.IntegerValue );\n  <span class=\"teal\">ElementId</span> maxId = <span class=\"blue\">new</span> <span class=\"teal\">ElementId</span>( i );\n \n  doc.Mirror( els, line );\n \n  <span class=\"green\">// get all elements in document with an</span>\n  <span class=\"green\">// element id greater than maxId:</span>\n \n  a = GetElementsAfter( doc, maxId );\n \n  <span class=\"blue\">string</span> s = _msg;\n \n  <span class=\"blue\">foreach</span>( <span class=\"teal\">Element</span> e <span class=\"blue\">in</span> a )\n  {\n    s += <span class=\"blue\">string</span>.Format( <span class=\"maroon\">\"\\r\\n  {0}\"</span>,\n      <span class=\"teal\">Util</span>.ElementDescription( e ) );\n  }\n  <span class=\"teal\">Util</span>.InfoMsg( s );\n \n  t.RollBack();\n}\n</pre>\n<a name=\"#5\"></a>\n<h4>Enhanced Parameter Filter for Greater Element Id Values</h4>\n<p>While writing this, I just noticed some potential for more improvement here.\nThe parameter filter is a slow filter, so it is important to eliminate as many elements as possible using other quick filters before applying it.\nOne filter that we did apply in all the previous element retrieval was the non-ElementType one, so why not use it here as well?\n\n<p>A filtered element collector need not necessarily be based on a document, but can also be used to apply further filtering to the results of a previous filter.\nMaking use of this functionality, we can rewrite our parameter filter method as follows to use a collection of already filtered elements instead of the contents of the entire document:\n\n<pre class=\"code\">\n<span class=\"teal\">FilteredElementCollector</span> GetElementsAfter(\n  <span class=\"teal\">FilteredElementCollector</span> input,\n  <span class=\"teal\">ElementId</span> lastId )\n{\n  <span class=\"teal\">BuiltInParameter</span> bip = <span class=\"teal\">BuiltInParameter</span>.ID_PARAM;\n \n  <span class=\"teal\">ParameterValueProvider</span> provider \n    = <span class=\"blue\">new</span> <span class=\"teal\">ParameterValueProvider</span>( \n      <span class=\"blue\">new</span> <span class=\"teal\">ElementId</span>( bip ) );\n \n  <span class=\"teal\">FilterNumericRuleEvaluator</span> evaluator \n    = <span class=\"blue\">new</span> <span class=\"teal\">FilterNumericGreater</span>();\n \n  <span class=\"teal\">FilterRule</span> rule = <span class=\"blue\">new</span> <span class=\"teal\">FilterElementIdRule</span>( \n    provider, evaluator, lastId );\n \n  <span class=\"teal\">ElementParameterFilter</span> filter \n    = <span class=\"blue\">new</span> <span class=\"teal\">ElementParameterFilter</span>( rule );\n \n  <span class=\"blue\">return</span> input.WherePasses( filter );\n}\n</pre>\n<p>Then we can reuse the GetElements that we used above once again for the parameter filter retrieval as well like this:\n\n<pre class=\"code\">\n<span class=\"blue\">using</span>( <span class=\"teal\">SubTransaction</span> t = <span class=\"blue\">new</span> <span class=\"teal\">SubTransaction</span>( doc ) )\n{\n  t.Start();\n \n  <span class=\"teal\">FilteredElementCollector</span> a = GetElements( doc );\n  <span class=\"blue\">int</span> i = a.Max&lt;<span class=\"teal\">Element</span>&gt;( e =&gt; e.Id.IntegerValue );\n  <span class=\"teal\">ElementId</span> maxId = <span class=\"blue\">new</span> <span class=\"teal\">ElementId</span>( i );\n \n  doc.Mirror( els, line );\n \n  <span class=\"green\">// only look at non-ElementType elements</span>\n  <span class=\"green\">// instead of all document elements:</span>\n \n  a = GetElements( doc );\n  a = GetElementsAfter( a, maxId );\n \n  <span class=\"blue\">string</span> s = _msg;\n \n  <span class=\"blue\">foreach</span>( <span class=\"teal\">Element</span> e <span class=\"blue\">in</span> a )\n  {\n    s += <span class=\"blue\">string</span>.Format( <span class=\"maroon\">\"\\r\\n  {0}\"</span>,\n      <span class=\"teal\">Util</span>.ElementDescription( e ) );\n  }\n  <span class=\"teal\">Util</span>.InfoMsg( s );\n \n  t.RollBack();\n}\n</pre>\n<p>In a real-world application, there will probably be numerous other quick filters that can be applied additionally before resorting to slow ones to eliminate even more uninteresting elements and further improve performance.\nIt would also be interesting to add some benchmarking code to the three cases presented above and run a test in a reasonably sized model to see whether the performance differences that I am postulating above really exist.\nI will leave that as an exercise to the interested reader, for the moment, leaving this post at is, for now, and hope that this exploration proves useful to you.\n\n\n<a name=\"#6\"></a>\n<h4>Download</h4>\n<p>Here is \n\n<a href=\"zip/bc_11_64.zip\">\nversion 2011.0.0.64</a>\n\nof the complete Visual Studio solution including the updated mirroring and newly created element retrieval commands CmdMirror and CmdMirrorListAdded.</p>\n</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p>"
  },
  {
    "original_filename": "0344_mirror_new_elements",
    "header_text": "Revit Element Access",
    "local_header_href": "#revit-element-access",
    "chunk_text": "<h4>Revit Element Access</h4><p>In Revit 2010 and previous versions, the Revit API provided direct access to the Revit element collection.\nIn the Revit 2011 API, this collection is no longer directly accessible at all, since the API designers have decided that no normal application ever has any legitimate need to iterate over all elements in the database in one go, but should always be interested in only a subset.\nTo retrieve such subsets, the API provides highly optimised filtered element collectors, as we saw in the recent discussions on\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/03/performance-profiling.html\">\nperformance profiling</a> and\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/04/collector-benchmark.html\">\ncollector benchmarking</a>.\n\n<p>In Revit 2010, we implemented a system to retrieve newly added elements, for instance those generated by executing the mirror command, simply by making a note of the total number of elements before executing the command, executing the mirroring operation, and then retrieving all the ones returned after that number when sequentially iterating over the elements collection.\nSince the elements collection is no longer accessible in the Revit 2011 API, I was pretty sure that this would no longer work.\nSurprisingly, though, it still does.\n\n<p>Since there is no access to the full elements collection, I applied the filter WhereElementIsNotElementType to the document's FilteredElementCollector.\nElementType is 2011-speak for Symbol, i.e. the Revit 2010 class Symbol has been renamed to ElementType in the Revit 2011 API, so this filter returns all elements which are not element types.\nI would assume that to include all elements which may result from a mirroring operation.\nPlease correct me if I am mistaken.\n\n<p>Here is the very simple method making use of this filter, which we will later use for both the sequential element and the monotonously increasing element id retrieval methods:\n\n<pre class=\"code\">\n<span class=\"teal\">FilteredElementCollector</span> GetElements( <span class=\"teal\">Document</span> doc )\n{\n  <span class=\"teal\">FilteredElementCollector</span> collector\n    = <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( doc );\n  <span class=\"blue\">return</span> collector.WhereElementIsNotElementType();\n}\n</pre>\n<a name=\"#3\"></a>\n<h4>Newly Created Element Retrieval Based on Sequential Element Order</h4>\n<p>To retrieve all elements returned after a given sequence number, similar to the original 2010 algorithm, we implemented the following methods:\n\n<pre class=\"code\">\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n<span class=\"gray\">///</span><span class=\"green\"> Return the current number of non-ElementType elements.</span>\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n<span class=\"blue\">int</span> GetElementCount( <span class=\"teal\">Document</span> doc )\n{\n  <span class=\"blue\">return</span> GetElements( doc ).ToElements().Count;\n}\n \n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n<span class=\"gray\">///</span><span class=\"green\"> Return all database elements after the given number n.</span>\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n<span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt; GetElementsAfter( <span class=\"blue\">int</span> n, <span class=\"teal\">Document</span> doc )\n{\n  <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt; a = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt;();\n  <span class=\"teal\">FilteredElementCollector</span> c = GetElements( doc );\n  <span class=\"blue\">int</span> i = 0;\n \n  <span class=\"blue\">foreach</span>( <span class=\"teal\">Element</span> e <span class=\"blue\">in</span> c )\n  {\n    ++i;\n \n    <span class=\"blue\">if</span>( n &lt; i )\n    {\n      a.Add( e );\n    }\n  }\n  <span class=\"blue\">return</span> a;\n}\n</pre>\n<p>They are called like this to determine the number of non-ElementType elements before the mirroring operation, execute the mirroring command, and retrieve the newly added elements afterwards:\n\n<pre class=\"code\">\n<span class=\"blue\">using</span>( <span class=\"teal\">SubTransaction</span> t = <span class=\"blue\">new</span> <span class=\"teal\">SubTransaction</span>( doc ) )\n{\n  t.Start();\n \n  <span class=\"blue\">int</span> n = GetElementCount( doc );\n \n  doc.Mirror( els, line );\n \n  <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt; a = GetElementsAfter( n, doc );\n \n  <span class=\"blue\">string</span> s = _msg;\n \n  <span class=\"blue\">foreach</span>( <span class=\"teal\">Element</span> e <span class=\"blue\">in</span> a )\n  {\n    s += <span class=\"blue\">string</span>.Format( <span class=\"maroon\">\"\\r\\n  {0}\"</span>,\n      <span class=\"teal\">Util</span>.ElementDescription( e ) );\n  }\n  <span class=\"teal\">Util</span>.InfoMsg( s );\n \n  t.RollBack();\n}\n</pre>\n<p>The entire operation is encapsulated in a sub-transaction which is subsequently rolled back, so that we can immediately continue to test the alternative and more reliable new retrieval method based on element ids instead of the sequence of the elements themselves.\n\n\n<a name=\"#4\"></a>\n<h4>Newly Created Element Retrieval Based on Monotonously Increasing Element Id Values</h4>\n<p>Instead of simply using the sequential ordering of elements as they happen to be returned by the filtered element collector, a much more reliable assumption is that element ids are allocated monotonously increasing values.\nTherefore, instead of simply counting the number of elements returned by the GetElements method, as we did above in GetElementCount, a more reliable approach might be to determine the maximal element id value before the mirroring operation, and then retrieve all elements with a higher element id afterwards.\n\n<p>Since the element id is available through a parameter, we can make use of a parameter filter to retrieve these elements.\nTo make use of a parameter filter, you have to define the following components:\n\n<ul>\n<li>The provider, e.g. the parameter you are interested in.\n<li>The evaluator, e.g. how to compare it with the target value.\n<li>The rule, which specifies how the provider and the comparison work together.\n</li></li></li></ul>\n<p>We demonstrated one implementation of using a parameter filter in the \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/04/collector-benchmark.html\">\ncollector benchmark</a> command\n\nCmdCollectorPerformance, in the method GetFirstNamedElementOfTypeUsingParameterFilter, where we used it to find an element with a specific name by checking the built-in parameter ELEM_NAME_PARAM for equality with the given target string.\n\n<p>In this case, we set up a parameter filter to retrieve elements whose element id is greater than a given value.\nWe can achieve this by specifying that the value of the built-in parameter ID_PARAM must exceed the target element id, like this:\n\n<pre class=\"code\">\n<span class=\"teal\">FilteredElementCollector</span> GetElementsAfter(\n  <span class=\"teal\">Document</span> doc,\n  <span class=\"teal\">ElementId</span> lastId )\n{\n  <span class=\"teal\">BuiltInParameter</span> bip = <span class=\"teal\">BuiltInParameter</span>.ID_PARAM;\n \n  <span class=\"teal\">ParameterValueProvider</span> provider\n    = <span class=\"blue\">new</span> <span class=\"teal\">ParameterValueProvider</span>( \n      <span class=\"blue\">new</span> <span class=\"teal\">ElementId</span>( bip ) );\n \n  <span class=\"teal\">FilterNumericRuleEvaluator</span> evaluator\n    = <span class=\"blue\">new</span> <span class=\"teal\">FilterNumericGreater</span>();\n \n  <span class=\"teal\">FilterRule</span> rule = <span class=\"blue\">new</span> <span class=\"teal\">FilterElementIdRule</span>(\n    provider, evaluator, lastId );\n \n  <span class=\"teal\">ElementParameterFilter</span> filter\n    = <span class=\"blue\">new</span> <span class=\"teal\">ElementParameterFilter</span>( rule );\n \n  <span class=\"teal\">FilteredElementCollector</span> collector\n    = <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( doc );\n \n  <span class=\"blue\">return</span> collector.WherePasses( filter );\n}\n</pre>\n<p>This method returns all elements in the entire document whose element id is greater than 'lastId'.\n\n<p>Here is the code making use of this method, analogously to the snippet above, i.e. determine the maximal element id before the mirroring operation, execute the mirroring command, and retrieve the newly added elements afterwards:\n\n<pre class=\"code\">\n<span class=\"blue\">using</span>( <span class=\"teal\">SubTransaction</span> t = <span class=\"blue\">new</span> <span class=\"teal\">SubTransaction</span>( doc ) )\n{\n  t.Start();\n \n  <span class=\"teal\">FilteredElementCollector</span> a = GetElements( doc );\n  <span class=\"blue\">int</span> i = a.Max&lt;<span class=\"teal\">Element</span>&gt;( e =&gt; e.Id.IntegerValue );\n  <span class=\"teal\">ElementId</span> maxId = <span class=\"blue\">new</span> <span class=\"teal\">ElementId</span>( i );\n \n  doc.Mirror( els, line );\n \n  <span class=\"green\">// get all elements in document with an</span>\n  <span class=\"green\">// element id greater than maxId:</span>\n \n  a = GetElementsAfter( doc, maxId );\n \n  <span class=\"blue\">string</span> s = _msg;\n \n  <span class=\"blue\">foreach</span>( <span class=\"teal\">Element</span> e <span class=\"blue\">in</span> a )\n  {\n    s += <span class=\"blue\">string</span>.Format( <span class=\"maroon\">\"\\r\\n  {0}\"</span>,\n      <span class=\"teal\">Util</span>.ElementDescription( e ) );\n  }\n  <span class=\"teal\">Util</span>.InfoMsg( s );\n \n  t.RollBack();\n}\n</pre>\n<a name=\"#5\"></a>\n<h4>Enhanced Parameter Filter for Greater Element Id Values</h4>\n<p>While writing this, I just noticed some potential for more improvement here.\nThe parameter filter is a slow filter, so it is important to eliminate as many elements as possible using other quick filters before applying it.\nOne filter that we did apply in all the previous element retrieval was the non-ElementType one, so why not use it here as well?\n\n<p>A filtered element collector need not necessarily be based on a document, but can also be used to apply further filtering to the results of a previous filter.\nMaking use of this functionality, we can rewrite our parameter filter method as follows to use a collection of already filtered elements instead of the contents of the entire document:\n\n<pre class=\"code\">\n<span class=\"teal\">FilteredElementCollector</span> GetElementsAfter(\n  <span class=\"teal\">FilteredElementCollector</span> input,\n  <span class=\"teal\">ElementId</span> lastId )\n{\n  <span class=\"teal\">BuiltInParameter</span> bip = <span class=\"teal\">BuiltInParameter</span>.ID_PARAM;\n \n  <span class=\"teal\">ParameterValueProvider</span> provider \n    = <span class=\"blue\">new</span> <span class=\"teal\">ParameterValueProvider</span>( \n      <span class=\"blue\">new</span> <span class=\"teal\">ElementId</span>( bip ) );\n \n  <span class=\"teal\">FilterNumericRuleEvaluator</span> evaluator \n    = <span class=\"blue\">new</span> <span class=\"teal\">FilterNumericGreater</span>();\n \n  <span class=\"teal\">FilterRule</span> rule = <span class=\"blue\">new</span> <span class=\"teal\">FilterElementIdRule</span>( \n    provider, evaluator, lastId );\n \n  <span class=\"teal\">ElementParameterFilter</span> filter \n    = <span class=\"blue\">new</span> <span class=\"teal\">ElementParameterFilter</span>( rule );\n \n  <span class=\"blue\">return</span> input.WherePasses( filter );\n}\n</pre>\n<p>Then we can reuse the GetElements that we used above once again for the parameter filter retrieval as well like this:\n\n<pre class=\"code\">\n<span class=\"blue\">using</span>( <span class=\"teal\">SubTransaction</span> t = <span class=\"blue\">new</span> <span class=\"teal\">SubTransaction</span>( doc ) )\n{\n  t.Start();\n \n  <span class=\"teal\">FilteredElementCollector</span> a = GetElements( doc );\n  <span class=\"blue\">int</span> i = a.Max&lt;<span class=\"teal\">Element</span>&gt;( e =&gt; e.Id.IntegerValue );\n  <span class=\"teal\">ElementId</span> maxId = <span class=\"blue\">new</span> <span class=\"teal\">ElementId</span>( i );\n \n  doc.Mirror( els, line );\n \n  <span class=\"green\">// only look at non-ElementType elements</span>\n  <span class=\"green\">// instead of all document elements:</span>\n \n  a = GetElements( doc );\n  a = GetElementsAfter( a, maxId );\n \n  <span class=\"blue\">string</span> s = _msg;\n \n  <span class=\"blue\">foreach</span>( <span class=\"teal\">Element</span> e <span class=\"blue\">in</span> a )\n  {\n    s += <span class=\"blue\">string</span>.Format( <span class=\"maroon\">\"\\r\\n  {0}\"</span>,\n      <span class=\"teal\">Util</span>.ElementDescription( e ) );\n  }\n  <span class=\"teal\">Util</span>.InfoMsg( s );\n \n  t.RollBack();\n}\n</pre>\n<p>In a real-world application, there will probably be numerous other quick filters that can be applied additionally before resorting to slow ones to eliminate even more uninteresting elements and further improve performance.\nIt would also be interesting to add some benchmarking code to the three cases presented above and run a test in a reasonably sized model to see whether the performance differences that I am postulating above really exist.\nI will leave that as an exercise to the interested reader, for the moment, leaving this post at is, for now, and hope that this exploration proves useful to you.\n\n\n<a name=\"#6\"></a>\n<h4>Download</h4>\n<p>Here is \n\n<a href=\"zip/bc_11_64.zip\">\nversion 2011.0.0.64</a>\n\nof the complete Visual Studio solution including the updated mirroring and newly created element retrieval commands CmdMirror and CmdMirrorListAdded.</p>\n</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p>"
  },
  {
    "original_filename": "0344_mirror_new_elements",
    "header_text": "Newly Created Element Retrieval Based on Sequential Element Order",
    "local_header_href": "#newly-created-element-retrieval-based-on-sequential-element-order",
    "chunk_text": "<h4>Newly Created Element Retrieval Based on Sequential Element Order</h4><p>To retrieve all elements returned after a given sequence number, similar to the original 2010 algorithm, we implemented the following methods:\n\n<pre class=\"code\">\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n<span class=\"gray\">///</span><span class=\"green\"> Return the current number of non-ElementType elements.</span>\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n<span class=\"blue\">int</span> GetElementCount( <span class=\"teal\">Document</span> doc )\n{\n  <span class=\"blue\">return</span> GetElements( doc ).ToElements().Count;\n}\n \n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n<span class=\"gray\">///</span><span class=\"green\"> Return all database elements after the given number n.</span>\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n<span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt; GetElementsAfter( <span class=\"blue\">int</span> n, <span class=\"teal\">Document</span> doc )\n{\n  <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt; a = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt;();\n  <span class=\"teal\">FilteredElementCollector</span> c = GetElements( doc );\n  <span class=\"blue\">int</span> i = 0;\n \n  <span class=\"blue\">foreach</span>( <span class=\"teal\">Element</span> e <span class=\"blue\">in</span> c )\n  {\n    ++i;\n \n    <span class=\"blue\">if</span>( n &lt; i )\n    {\n      a.Add( e );\n    }\n  }\n  <span class=\"blue\">return</span> a;\n}\n</pre>\n<p>They are called like this to determine the number of non-ElementType elements before the mirroring operation, execute the mirroring command, and retrieve the newly added elements afterwards:\n\n<pre class=\"code\">\n<span class=\"blue\">using</span>( <span class=\"teal\">SubTransaction</span> t = <span class=\"blue\">new</span> <span class=\"teal\">SubTransaction</span>( doc ) )\n{\n  t.Start();\n \n  <span class=\"blue\">int</span> n = GetElementCount( doc );\n \n  doc.Mirror( els, line );\n \n  <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt; a = GetElementsAfter( n, doc );\n \n  <span class=\"blue\">string</span> s = _msg;\n \n  <span class=\"blue\">foreach</span>( <span class=\"teal\">Element</span> e <span class=\"blue\">in</span> a )\n  {\n    s += <span class=\"blue\">string</span>.Format( <span class=\"maroon\">\"\\r\\n  {0}\"</span>,\n      <span class=\"teal\">Util</span>.ElementDescription( e ) );\n  }\n  <span class=\"teal\">Util</span>.InfoMsg( s );\n \n  t.RollBack();\n}\n</pre>\n<p>The entire operation is encapsulated in a sub-transaction which is subsequently rolled back, so that we can immediately continue to test the alternative and more reliable new retrieval method based on element ids instead of the sequence of the elements themselves.\n\n\n<a name=\"#4\"></a>\n<h4>Newly Created Element Retrieval Based on Monotonously Increasing Element Id Values</h4>\n<p>Instead of simply using the sequential ordering of elements as they happen to be returned by the filtered element collector, a much more reliable assumption is that element ids are allocated monotonously increasing values.\nTherefore, instead of simply counting the number of elements returned by the GetElements method, as we did above in GetElementCount, a more reliable approach might be to determine the maximal element id value before the mirroring operation, and then retrieve all elements with a higher element id afterwards.\n\n<p>Since the element id is available through a parameter, we can make use of a parameter filter to retrieve these elements.\nTo make use of a parameter filter, you have to define the following components:\n\n<ul>\n<li>The provider, e.g. the parameter you are interested in.\n<li>The evaluator, e.g. how to compare it with the target value.\n<li>The rule, which specifies how the provider and the comparison work together.\n</li></li></li></ul>\n<p>We demonstrated one implementation of using a parameter filter in the \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/04/collector-benchmark.html\">\ncollector benchmark</a> command\n\nCmdCollectorPerformance, in the method GetFirstNamedElementOfTypeUsingParameterFilter, where we used it to find an element with a specific name by checking the built-in parameter ELEM_NAME_PARAM for equality with the given target string.\n\n<p>In this case, we set up a parameter filter to retrieve elements whose element id is greater than a given value.\nWe can achieve this by specifying that the value of the built-in parameter ID_PARAM must exceed the target element id, like this:\n\n<pre class=\"code\">\n<span class=\"teal\">FilteredElementCollector</span> GetElementsAfter(\n  <span class=\"teal\">Document</span> doc,\n  <span class=\"teal\">ElementId</span> lastId )\n{\n  <span class=\"teal\">BuiltInParameter</span> bip = <span class=\"teal\">BuiltInParameter</span>.ID_PARAM;\n \n  <span class=\"teal\">ParameterValueProvider</span> provider\n    = <span class=\"blue\">new</span> <span class=\"teal\">ParameterValueProvider</span>( \n      <span class=\"blue\">new</span> <span class=\"teal\">ElementId</span>( bip ) );\n \n  <span class=\"teal\">FilterNumericRuleEvaluator</span> evaluator\n    = <span class=\"blue\">new</span> <span class=\"teal\">FilterNumericGreater</span>();\n \n  <span class=\"teal\">FilterRule</span> rule = <span class=\"blue\">new</span> <span class=\"teal\">FilterElementIdRule</span>(\n    provider, evaluator, lastId );\n \n  <span class=\"teal\">ElementParameterFilter</span> filter\n    = <span class=\"blue\">new</span> <span class=\"teal\">ElementParameterFilter</span>( rule );\n \n  <span class=\"teal\">FilteredElementCollector</span> collector\n    = <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( doc );\n \n  <span class=\"blue\">return</span> collector.WherePasses( filter );\n}\n</pre>\n<p>This method returns all elements in the entire document whose element id is greater than 'lastId'.\n\n<p>Here is the code making use of this method, analogously to the snippet above, i.e. determine the maximal element id before the mirroring operation, execute the mirroring command, and retrieve the newly added elements afterwards:\n\n<pre class=\"code\">\n<span class=\"blue\">using</span>( <span class=\"teal\">SubTransaction</span> t = <span class=\"blue\">new</span> <span class=\"teal\">SubTransaction</span>( doc ) )\n{\n  t.Start();\n \n  <span class=\"teal\">FilteredElementCollector</span> a = GetElements( doc );\n  <span class=\"blue\">int</span> i = a.Max&lt;<span class=\"teal\">Element</span>&gt;( e =&gt; e.Id.IntegerValue );\n  <span class=\"teal\">ElementId</span> maxId = <span class=\"blue\">new</span> <span class=\"teal\">ElementId</span>( i );\n \n  doc.Mirror( els, line );\n \n  <span class=\"green\">// get all elements in document with an</span>\n  <span class=\"green\">// element id greater than maxId:</span>\n \n  a = GetElementsAfter( doc, maxId );\n \n  <span class=\"blue\">string</span> s = _msg;\n \n  <span class=\"blue\">foreach</span>( <span class=\"teal\">Element</span> e <span class=\"blue\">in</span> a )\n  {\n    s += <span class=\"blue\">string</span>.Format( <span class=\"maroon\">\"\\r\\n  {0}\"</span>,\n      <span class=\"teal\">Util</span>.ElementDescription( e ) );\n  }\n  <span class=\"teal\">Util</span>.InfoMsg( s );\n \n  t.RollBack();\n}\n</pre>\n<a name=\"#5\"></a>\n<h4>Enhanced Parameter Filter for Greater Element Id Values</h4>\n<p>While writing this, I just noticed some potential for more improvement here.\nThe parameter filter is a slow filter, so it is important to eliminate as many elements as possible using other quick filters before applying it.\nOne filter that we did apply in all the previous element retrieval was the non-ElementType one, so why not use it here as well?\n\n<p>A filtered element collector need not necessarily be based on a document, but can also be used to apply further filtering to the results of a previous filter.\nMaking use of this functionality, we can rewrite our parameter filter method as follows to use a collection of already filtered elements instead of the contents of the entire document:\n\n<pre class=\"code\">\n<span class=\"teal\">FilteredElementCollector</span> GetElementsAfter(\n  <span class=\"teal\">FilteredElementCollector</span> input,\n  <span class=\"teal\">ElementId</span> lastId )\n{\n  <span class=\"teal\">BuiltInParameter</span> bip = <span class=\"teal\">BuiltInParameter</span>.ID_PARAM;\n \n  <span class=\"teal\">ParameterValueProvider</span> provider \n    = <span class=\"blue\">new</span> <span class=\"teal\">ParameterValueProvider</span>( \n      <span class=\"blue\">new</span> <span class=\"teal\">ElementId</span>( bip ) );\n \n  <span class=\"teal\">FilterNumericRuleEvaluator</span> evaluator \n    = <span class=\"blue\">new</span> <span class=\"teal\">FilterNumericGreater</span>();\n \n  <span class=\"teal\">FilterRule</span> rule = <span class=\"blue\">new</span> <span class=\"teal\">FilterElementIdRule</span>( \n    provider, evaluator, lastId );\n \n  <span class=\"teal\">ElementParameterFilter</span> filter \n    = <span class=\"blue\">new</span> <span class=\"teal\">ElementParameterFilter</span>( rule );\n \n  <span class=\"blue\">return</span> input.WherePasses( filter );\n}\n</pre>\n<p>Then we can reuse the GetElements that we used above once again for the parameter filter retrieval as well like this:\n\n<pre class=\"code\">\n<span class=\"blue\">using</span>( <span class=\"teal\">SubTransaction</span> t = <span class=\"blue\">new</span> <span class=\"teal\">SubTransaction</span>( doc ) )\n{\n  t.Start();\n \n  <span class=\"teal\">FilteredElementCollector</span> a = GetElements( doc );\n  <span class=\"blue\">int</span> i = a.Max&lt;<span class=\"teal\">Element</span>&gt;( e =&gt; e.Id.IntegerValue );\n  <span class=\"teal\">ElementId</span> maxId = <span class=\"blue\">new</span> <span class=\"teal\">ElementId</span>( i );\n \n  doc.Mirror( els, line );\n \n  <span class=\"green\">// only look at non-ElementType elements</span>\n  <span class=\"green\">// instead of all document elements:</span>\n \n  a = GetElements( doc );\n  a = GetElementsAfter( a, maxId );\n \n  <span class=\"blue\">string</span> s = _msg;\n \n  <span class=\"blue\">foreach</span>( <span class=\"teal\">Element</span> e <span class=\"blue\">in</span> a )\n  {\n    s += <span class=\"blue\">string</span>.Format( <span class=\"maroon\">\"\\r\\n  {0}\"</span>,\n      <span class=\"teal\">Util</span>.ElementDescription( e ) );\n  }\n  <span class=\"teal\">Util</span>.InfoMsg( s );\n \n  t.RollBack();\n}\n</pre>\n<p>In a real-world application, there will probably be numerous other quick filters that can be applied additionally before resorting to slow ones to eliminate even more uninteresting elements and further improve performance.\nIt would also be interesting to add some benchmarking code to the three cases presented above and run a test in a reasonably sized model to see whether the performance differences that I am postulating above really exist.\nI will leave that as an exercise to the interested reader, for the moment, leaving this post at is, for now, and hope that this exploration proves useful to you.\n\n\n<a name=\"#6\"></a>\n<h4>Download</h4>\n<p>Here is \n\n<a href=\"zip/bc_11_64.zip\">\nversion 2011.0.0.64</a>\n\nof the complete Visual Studio solution including the updated mirroring and newly created element retrieval commands CmdMirror and CmdMirrorListAdded.</p>\n</p></p></p></p></p></p></p></p></p></p></p></p></p>"
  },
  {
    "original_filename": "0344_mirror_new_elements",
    "header_text": "Newly Created Element Retrieval Based on Monotonously Increasing Element Id Values",
    "local_header_href": "#newly-created-element-retrieval-based-on-monotonously-increasing-element-id-values",
    "chunk_text": "<h4>Newly Created Element Retrieval Based on Monotonously Increasing Element Id Values</h4><p>Instead of simply using the sequential ordering of elements as they happen to be returned by the filtered element collector, a much more reliable assumption is that element ids are allocated monotonously increasing values.\nTherefore, instead of simply counting the number of elements returned by the GetElements method, as we did above in GetElementCount, a more reliable approach might be to determine the maximal element id value before the mirroring operation, and then retrieve all elements with a higher element id afterwards.\n\n<p>Since the element id is available through a parameter, we can make use of a parameter filter to retrieve these elements.\nTo make use of a parameter filter, you have to define the following components:\n\n<ul>\n<li>The provider, e.g. the parameter you are interested in.\n<li>The evaluator, e.g. how to compare it with the target value.\n<li>The rule, which specifies how the provider and the comparison work together.\n</li></li></li></ul>\n<p>We demonstrated one implementation of using a parameter filter in the \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/04/collector-benchmark.html\">\ncollector benchmark</a> command\n\nCmdCollectorPerformance, in the method GetFirstNamedElementOfTypeUsingParameterFilter, where we used it to find an element with a specific name by checking the built-in parameter ELEM_NAME_PARAM for equality with the given target string.\n\n<p>In this case, we set up a parameter filter to retrieve elements whose element id is greater than a given value.\nWe can achieve this by specifying that the value of the built-in parameter ID_PARAM must exceed the target element id, like this:\n\n<pre class=\"code\">\n<span class=\"teal\">FilteredElementCollector</span> GetElementsAfter(\n  <span class=\"teal\">Document</span> doc,\n  <span class=\"teal\">ElementId</span> lastId )\n{\n  <span class=\"teal\">BuiltInParameter</span> bip = <span class=\"teal\">BuiltInParameter</span>.ID_PARAM;\n \n  <span class=\"teal\">ParameterValueProvider</span> provider\n    = <span class=\"blue\">new</span> <span class=\"teal\">ParameterValueProvider</span>( \n      <span class=\"blue\">new</span> <span class=\"teal\">ElementId</span>( bip ) );\n \n  <span class=\"teal\">FilterNumericRuleEvaluator</span> evaluator\n    = <span class=\"blue\">new</span> <span class=\"teal\">FilterNumericGreater</span>();\n \n  <span class=\"teal\">FilterRule</span> rule = <span class=\"blue\">new</span> <span class=\"teal\">FilterElementIdRule</span>(\n    provider, evaluator, lastId );\n \n  <span class=\"teal\">ElementParameterFilter</span> filter\n    = <span class=\"blue\">new</span> <span class=\"teal\">ElementParameterFilter</span>( rule );\n \n  <span class=\"teal\">FilteredElementCollector</span> collector\n    = <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( doc );\n \n  <span class=\"blue\">return</span> collector.WherePasses( filter );\n}\n</pre>\n<p>This method returns all elements in the entire document whose element id is greater than 'lastId'.\n\n<p>Here is the code making use of this method, analogously to the snippet above, i.e. determine the maximal element id before the mirroring operation, execute the mirroring command, and retrieve the newly added elements afterwards:\n\n<pre class=\"code\">\n<span class=\"blue\">using</span>( <span class=\"teal\">SubTransaction</span> t = <span class=\"blue\">new</span> <span class=\"teal\">SubTransaction</span>( doc ) )\n{\n  t.Start();\n \n  <span class=\"teal\">FilteredElementCollector</span> a = GetElements( doc );\n  <span class=\"blue\">int</span> i = a.Max&lt;<span class=\"teal\">Element</span>&gt;( e =&gt; e.Id.IntegerValue );\n  <span class=\"teal\">ElementId</span> maxId = <span class=\"blue\">new</span> <span class=\"teal\">ElementId</span>( i );\n \n  doc.Mirror( els, line );\n \n  <span class=\"green\">// get all elements in document with an</span>\n  <span class=\"green\">// element id greater than maxId:</span>\n \n  a = GetElementsAfter( doc, maxId );\n \n  <span class=\"blue\">string</span> s = _msg;\n \n  <span class=\"blue\">foreach</span>( <span class=\"teal\">Element</span> e <span class=\"blue\">in</span> a )\n  {\n    s += <span class=\"blue\">string</span>.Format( <span class=\"maroon\">\"\\r\\n  {0}\"</span>,\n      <span class=\"teal\">Util</span>.ElementDescription( e ) );\n  }\n  <span class=\"teal\">Util</span>.InfoMsg( s );\n \n  t.RollBack();\n}\n</pre>\n<a name=\"#5\"></a>\n<h4>Enhanced Parameter Filter for Greater Element Id Values</h4>\n<p>While writing this, I just noticed some potential for more improvement here.\nThe parameter filter is a slow filter, so it is important to eliminate as many elements as possible using other quick filters before applying it.\nOne filter that we did apply in all the previous element retrieval was the non-ElementType one, so why not use it here as well?\n\n<p>A filtered element collector need not necessarily be based on a document, but can also be used to apply further filtering to the results of a previous filter.\nMaking use of this functionality, we can rewrite our parameter filter method as follows to use a collection of already filtered elements instead of the contents of the entire document:\n\n<pre class=\"code\">\n<span class=\"teal\">FilteredElementCollector</span> GetElementsAfter(\n  <span class=\"teal\">FilteredElementCollector</span> input,\n  <span class=\"teal\">ElementId</span> lastId )\n{\n  <span class=\"teal\">BuiltInParameter</span> bip = <span class=\"teal\">BuiltInParameter</span>.ID_PARAM;\n \n  <span class=\"teal\">ParameterValueProvider</span> provider \n    = <span class=\"blue\">new</span> <span class=\"teal\">ParameterValueProvider</span>( \n      <span class=\"blue\">new</span> <span class=\"teal\">ElementId</span>( bip ) );\n \n  <span class=\"teal\">FilterNumericRuleEvaluator</span> evaluator \n    = <span class=\"blue\">new</span> <span class=\"teal\">FilterNumericGreater</span>();\n \n  <span class=\"teal\">FilterRule</span> rule = <span class=\"blue\">new</span> <span class=\"teal\">FilterElementIdRule</span>( \n    provider, evaluator, lastId );\n \n  <span class=\"teal\">ElementParameterFilter</span> filter \n    = <span class=\"blue\">new</span> <span class=\"teal\">ElementParameterFilter</span>( rule );\n \n  <span class=\"blue\">return</span> input.WherePasses( filter );\n}\n</pre>\n<p>Then we can reuse the GetElements that we used above once again for the parameter filter retrieval as well like this:\n\n<pre class=\"code\">\n<span class=\"blue\">using</span>( <span class=\"teal\">SubTransaction</span> t = <span class=\"blue\">new</span> <span class=\"teal\">SubTransaction</span>( doc ) )\n{\n  t.Start();\n \n  <span class=\"teal\">FilteredElementCollector</span> a = GetElements( doc );\n  <span class=\"blue\">int</span> i = a.Max&lt;<span class=\"teal\">Element</span>&gt;( e =&gt; e.Id.IntegerValue );\n  <span class=\"teal\">ElementId</span> maxId = <span class=\"blue\">new</span> <span class=\"teal\">ElementId</span>( i );\n \n  doc.Mirror( els, line );\n \n  <span class=\"green\">// only look at non-ElementType elements</span>\n  <span class=\"green\">// instead of all document elements:</span>\n \n  a = GetElements( doc );\n  a = GetElementsAfter( a, maxId );\n \n  <span class=\"blue\">string</span> s = _msg;\n \n  <span class=\"blue\">foreach</span>( <span class=\"teal\">Element</span> e <span class=\"blue\">in</span> a )\n  {\n    s += <span class=\"blue\">string</span>.Format( <span class=\"maroon\">\"\\r\\n  {0}\"</span>,\n      <span class=\"teal\">Util</span>.ElementDescription( e ) );\n  }\n  <span class=\"teal\">Util</span>.InfoMsg( s );\n \n  t.RollBack();\n}\n</pre>\n<p>In a real-world application, there will probably be numerous other quick filters that can be applied additionally before resorting to slow ones to eliminate even more uninteresting elements and further improve performance.\nIt would also be interesting to add some benchmarking code to the three cases presented above and run a test in a reasonably sized model to see whether the performance differences that I am postulating above really exist.\nI will leave that as an exercise to the interested reader, for the moment, leaving this post at is, for now, and hope that this exploration proves useful to you.\n\n\n<a name=\"#6\"></a>\n<h4>Download</h4>\n<p>Here is \n\n<a href=\"zip/bc_11_64.zip\">\nversion 2011.0.0.64</a>\n\nof the complete Visual Studio solution including the updated mirroring and newly created element retrieval commands CmdMirror and CmdMirrorListAdded.</p>\n</p></p></p></p></p></p></p></p></p></p>"
  },
  {
    "original_filename": "0344_mirror_new_elements",
    "header_text": "Enhanced Parameter Filter for Greater Element Id Values",
    "local_header_href": "#enhanced-parameter-filter-for-greater-element-id-values",
    "chunk_text": "<h4>Enhanced Parameter Filter for Greater Element Id Values</h4><p>While writing this, I just noticed some potential for more improvement here.\nThe parameter filter is a slow filter, so it is important to eliminate as many elements as possible using other quick filters before applying it.\nOne filter that we did apply in all the previous element retrieval was the non-ElementType one, so why not use it here as well?\n\n<p>A filtered element collector need not necessarily be based on a document, but can also be used to apply further filtering to the results of a previous filter.\nMaking use of this functionality, we can rewrite our parameter filter method as follows to use a collection of already filtered elements instead of the contents of the entire document:\n\n<pre class=\"code\">\n<span class=\"teal\">FilteredElementCollector</span> GetElementsAfter(\n  <span class=\"teal\">FilteredElementCollector</span> input,\n  <span class=\"teal\">ElementId</span> lastId )\n{\n  <span class=\"teal\">BuiltInParameter</span> bip = <span class=\"teal\">BuiltInParameter</span>.ID_PARAM;\n \n  <span class=\"teal\">ParameterValueProvider</span> provider \n    = <span class=\"blue\">new</span> <span class=\"teal\">ParameterValueProvider</span>( \n      <span class=\"blue\">new</span> <span class=\"teal\">ElementId</span>( bip ) );\n \n  <span class=\"teal\">FilterNumericRuleEvaluator</span> evaluator \n    = <span class=\"blue\">new</span> <span class=\"teal\">FilterNumericGreater</span>();\n \n  <span class=\"teal\">FilterRule</span> rule = <span class=\"blue\">new</span> <span class=\"teal\">FilterElementIdRule</span>( \n    provider, evaluator, lastId );\n \n  <span class=\"teal\">ElementParameterFilter</span> filter \n    = <span class=\"blue\">new</span> <span class=\"teal\">ElementParameterFilter</span>( rule );\n \n  <span class=\"blue\">return</span> input.WherePasses( filter );\n}\n</pre>\n<p>Then we can reuse the GetElements that we used above once again for the parameter filter retrieval as well like this:\n\n<pre class=\"code\">\n<span class=\"blue\">using</span>( <span class=\"teal\">SubTransaction</span> t = <span class=\"blue\">new</span> <span class=\"teal\">SubTransaction</span>( doc ) )\n{\n  t.Start();\n \n  <span class=\"teal\">FilteredElementCollector</span> a = GetElements( doc );\n  <span class=\"blue\">int</span> i = a.Max&lt;<span class=\"teal\">Element</span>&gt;( e =&gt; e.Id.IntegerValue );\n  <span class=\"teal\">ElementId</span> maxId = <span class=\"blue\">new</span> <span class=\"teal\">ElementId</span>( i );\n \n  doc.Mirror( els, line );\n \n  <span class=\"green\">// only look at non-ElementType elements</span>\n  <span class=\"green\">// instead of all document elements:</span>\n \n  a = GetElements( doc );\n  a = GetElementsAfter( a, maxId );\n \n  <span class=\"blue\">string</span> s = _msg;\n \n  <span class=\"blue\">foreach</span>( <span class=\"teal\">Element</span> e <span class=\"blue\">in</span> a )\n  {\n    s += <span class=\"blue\">string</span>.Format( <span class=\"maroon\">\"\\r\\n  {0}\"</span>,\n      <span class=\"teal\">Util</span>.ElementDescription( e ) );\n  }\n  <span class=\"teal\">Util</span>.InfoMsg( s );\n \n  t.RollBack();\n}\n</pre>\n<p>In a real-world application, there will probably be numerous other quick filters that can be applied additionally before resorting to slow ones to eliminate even more uninteresting elements and further improve performance.\nIt would also be interesting to add some benchmarking code to the three cases presented above and run a test in a reasonably sized model to see whether the performance differences that I am postulating above really exist.\nI will leave that as an exercise to the interested reader, for the moment, leaving this post at is, for now, and hope that this exploration proves useful to you.\n\n\n<a name=\"#6\"></a>\n<h4>Download</h4>\n<p>Here is \n\n<a href=\"zip/bc_11_64.zip\">\nversion 2011.0.0.64</a>\n\nof the complete Visual Studio solution including the updated mirroring and newly created element retrieval commands CmdMirror and CmdMirrorListAdded.</p>\n</p></p></p></p>"
  },
  {
    "original_filename": "0344_mirror_new_elements",
    "header_text": "Download",
    "local_header_href": "#download",
    "chunk_text": "<h4>Download</h4><p>Here is \n\n<a href=\"zip/bc_11_64.zip\">\nversion 2011.0.0.64</a>\n\nof the complete Visual Studio solution including the updated mirroring and newly created element retrieval commands CmdMirror and CmdMirrorListAdded.</p>"
  }
]