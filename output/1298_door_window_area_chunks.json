[
  {
    "original_filename": "1298_door_window_area",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<head>\n<meta content=\"text/html; charset=utf-8\" http-equiv=\"Content-Type\"/>\n<link href=\"bc.css\" rel=\"stylesheet\" type=\"text/css\"/>\n</head>"
  },
  {
    "original_filename": "1298_door_window_area",
    "header_text": "IFCExportUtils Methods Determine Door and Window Area",
    "local_header_href": "#ifcexportutils-methods-determine-door-and-window-area",
    "chunk_text": "<h3>IFCExportUtils Methods Determine Door and Window Area</h3><p>Last week we discussed the\n\n<a href=\"https://github.com/jeremytammik/SpatialElementGeometryCalculator\">\nSpatialElementGeometryCalculator sample</a> for\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2015/03/calculating-gross-and-net-wall-areas.html\">\ncalculating gross and net wall areas</a> that\n\nin turn led to the discovery of the\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2015/03/findinserts-retrieves-all-openings-in-all-wall-types.html\">\nFindInserts method to retrieve all openings in a wall</a>.</p><p>Both of these were prompted by the\n\n<a href=\"http://forums.autodesk.com/t5/revit-api/bd-p/160\">Revit API discussion forum</a> thread on\n\n<a href=\"http://forums.autodesk.com/t5/revit-api/door-window-areas/td-p/5535565\">door/window areas</a> raised\n\nby Phillip Miller of <a href=\"\">Kiwi Codes Solutions Ltd</a>.</p><p>Another question that arose in that thread regards the meaning of the built-in parameter HOST_AREA_COMPUTED and how to best calculate the area of a door or window family instance.</p><p>By the way, here are some previous discussions on HOST_AREA_COMPUTED regarding walls:</p><ul>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2008/09/selecting-all-w.html\">Selecting all Walls</a></li>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2009/01/room-and-wall-adjacency.html\">Room and Wall Adjacency</a></li>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2009/02/compound-wall-layer-volumes.html\">Compound Wall Layer Volumes</a></li>\n</ul><p>In the thread on\n\n<a href=\"http://forums.autodesk.com/t5/revit-api/door-window-areas/td-p/5535565\">door/window areas</a>,\n\nPhillip wonders about its meaning applied to family instances:</p><p><strong>Question:</strong> I need to determine the cut areas of windows and doors in a wall. I thought this would be a simple matter of grabbing the BIP HOST_AREA_COMPUTED as with my testing that was returning the correct area.  It turns out that this is not the case from further testing.</p><p>Please refer to the attached RVT file with two doors inserted into a wall.  They look similar but one is reporting through RevitLookup 4m2 and the other 2m2.</p><p>Why is this?  What actually is HOST_AREA_COMPUTED reporting?\nWhat is the most reliable way of getting the cut area of windows and doors?</p><p><strong>Answer:</strong> We initially avoided looking at the family instance areas directly – by analysing the wall with and without its openings instead – leaving two other interesting topics open for further exploration:</p><ul>\n<li>The meaning of the HOST_AREA_COMPUTED parameter value.</li>\n<li>The use of the ExporterIFCUtils GetInstanceCutoutFromWall and ComputeAreaOfCurveLoops methods.</li>\n</ul><p>Peter\n\n(<a href=\"http://forums.autodesk.com/t5/user/viewprofilepage/user-id/2663907\">pjohan13</a>)\n\njumped in and answered:</p><p>Even though you solved the problem (congratulations on that by the way) I might be able to provide some additional info on the subject.</p><p>During the last couple of months I've been working with something related. In my case the specific surface area of each window/door is the main interest and I have thus been digging into this topic quite a bit.</p><p>My findings suggest that the value of HOST_AREA_COMPUTED in regards to family instances is, what I can best explain as a sum of the geometric objects 'overlapping' the wall geometry in all 3 axes.</p><p>Terrible as that explanation might be, consider the following:</p><p>A simple 1000 x 1000 mm window family containing only a sheet of glass with a thickness of 100 mm will report an area of 1.2 square meters, equivalent to what could be measured in 2D plan, section and elevation views. If the geometry is copied in the family so that it contains two sweets of glass, HOST_AREA_COMPUTED will report the area of both, adding up to 2.4 square meters. This assumption can be supported by snooping a window hosted by a curtain wall. As the curtain wall has no actual depth/thickness, only one overlapping area exist, e.g. as defined by points the X and Z axes.</p><p>Whether I'm right or not doesn't really affect anything, but I thought it was worth sharing anyway   :-)</p><p>An easy approach to access the actual surface/opening area that I've found extremely useful resides in the Autodesk.Revit.DB.IFC namespace, more specifically in the ExporterIFCUtils class that has provided other interesting features in the past. The methods GetInstanceCutoutFromWall and ComputeAreaOfCurveLoops are able to handle every oddly shaped window I have ever fed them. And especially the latter is handy in a very wide context   :-)</p><p>Unfortunately I have no sample code related to HOST_AREA_COMPUTED analysis. My findings on the parameter value are based on manual analysis including family editing, measuring, snooping and comparing through a series of small steps. When I eventually stumbled upon the IFCExportUtils methods, that settled my quest for clarity.</p><p>The way I have used them, generally, is pretty straightforward. I attached a very simple sample implementing both methods to display the surface areas of selected windows/doors/curtain panels. I've also attached a sample project containing the earlier mentioned 1000 x 1000 mm single sheet window and a 'zig-zag'-shaped window intended to challenge the method a bit – which it doesn't    :-)</p><ul>\n<li><a href=\"zip/pj_SampleExpIfcUtilsWinArea.zip\">SampleExpIfcUtilsWinArea.zip</a></li>\n<li><a href=\"zip/pj_WallAndWindow.rvt\">WallAndWindow.rvt</a></li>\n</ul><p>One beauty of the GetInstanceCutoutFromWall method is that it returns the opening boundary as a curve loop and thus provides additional possibilities related to windows/door. For instance, the perimeter is available through curve lengths or sealant area can be calculated by adding a CurveLoop.CreateViaOffset to the list fed into ComputeAreaOfCurveLoops, etc.</p><p>I've tested the methods on windows intersecting the vertical join between two different wall types and windows intersecting the horizontal join in stacked walls, in each case with consistent outcome.</p><p>Ideally the GetAreaCutoutFromWall would instead be named *FromHost to cover skylights as well. But with solid performance like this I can't really ask for more, except maybe the values exposed directly by the FamilyInstance class or curtain wall's orientation vector updating accordingly when flipped   a different discussion, maybe   :-)</p><p>I hope that the sample can be of use and look forward to seeing more on this matter on The Building Coder.</p><p>Please note that this sample is a bit lazy. Normally I would not recommend unit conversion until 'the last moment', e.g. before printing values in the task dialog. Approaches like the one illustrated in the sample could obviously lead to some unintentional 'ft * m' scenarios causing unexpected outcome.</p><p>Many thanks to Peter for his research and sample material!</p><a name=\"2\"></a>"
  },
  {
    "original_filename": "1298_door_window_area",
    "header_text": "Implementation",
    "local_header_href": "#implementation",
    "chunk_text": "<h4>Implementation</h4><p>I cleaned up his sample code for publication in the\n\n<a href=\"https://github.com/jeremytammik/ExporterIfcUtilsWinArea\">ExporterIfcUtilsWinArea GitHub repository</a>.</p><p>As always, the Revit database length unit is imperial feet, and we are interested in seeing the resulting area in square metres, so an approximate conversion factor will come in handy:</p><pre class=\"code\">\n  <span class=\"blue\">const</span> <span class=\"blue\">double</span> _square_feet_to_square_metres\n    = 0.09290304;\n</pre><p>The algorithm implemented by Peter in the GetInstanceSurfaceAreaMetric method goes like this:</p><ul>\n<li>For a family instance hosted by a normal wall, we can make use of the ExporterIFCUtils GetInstanceCutoutFromWall and ComputeAreaOfCurveLoops methods to determine its area quite accurately.</li>\n<li>For a curtain wall, we can use the value provided by the HOST_AREA_COMPUTED built-in parameter instead.</li>\n<li>Finally, for an unhosted family instance, we use the product of its family symbol width and height parameters.</li>\n</ul><p>Here is the implementation of that:</p><pre class=\"code\">\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n  <span class=\"gray\">///</span><span class=\"green\"> Return surface area of given family instance</span>\n  <span class=\"gray\">///</span><span class=\"green\"> in square metres.</span>\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n  <span class=\"blue\">static</span> <span class=\"blue\">double</span> GetInstanceSurfaceAreaMetric(\n    <span class=\"teal\">FamilyInstance</span> familyInstance )\n  {\n    <span class=\"blue\">double</span> area_sq_ft = 0;\n \n    <span class=\"teal\">Wall</span> wall = familyInstance.Host <span class=\"blue\">as</span> <span class=\"teal\">Wall</span>;\n \n    <span class=\"blue\">if</span>( <span class=\"blue\">null</span> != wall )\n    {\n      <span class=\"blue\">if</span>( wall.WallType.Kind == <span class=\"teal\">WallKind</span>.Curtain )\n      {\n        area_sq_ft = familyInstance.get_Parameter(\n          <span class=\"teal\">BuiltInParameter</span>.HOST_AREA_COMPUTED )\n            .AsDouble();\n      }\n      <span class=\"blue\">else</span>\n      {\n        <span class=\"teal\">Document</span> doc = familyInstance.Document;\n        <span class=\"teal\">XYZ</span> basisY = <span class=\"teal\">XYZ</span>.BasisY;\n \n        <span class=\"green\">// using I = Autodesk.Revit.DB.IFC;</span>\n \n        <span class=\"teal\">CurveLoop</span> curveLoop = I.<span class=\"teal\">ExporterIFCUtils</span>\n          .GetInstanceCutoutFromWall( doc, wall,\n            familyInstance, <span class=\"blue\">out</span> basisY );\n \n        <span class=\"teal\">IList</span>&lt;<span class=\"teal\">CurveLoop</span>&gt; loops\n          = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">CurveLoop</span>&gt;( 1 );\n \n        loops.Add( curveLoop );\n \n        area_sq_ft = I.<span class=\"teal\">ExporterIFCUtils</span>\n          .ComputeAreaOfCurveLoops( loops );\n      }\n    }\n    <span class=\"blue\">else</span>\n    {\n      <span class=\"blue\">double</span> width\n        = familyInstance.Symbol.get_Parameter(\n          <span class=\"teal\">BuiltInParameter</span>.FAMILY_WIDTH_PARAM )\n            .AsDouble();\n \n      <span class=\"blue\">double</span> height\n        = familyInstance.Symbol.get_Parameter(\n          <span class=\"teal\">BuiltInParameter</span>.FAMILY_HEIGHT_PARAM )\n            .AsDouble();\n \n      area_sq_ft = width * height;\n    }\n    <span class=\"blue\">return</span> _square_feet_to_square_metres * area_sq_ft;\n  }\n</pre><p>The element selection and result reporting is handled like this by the external command mainline Execute method:</p><pre class=\"code\">\n  <span class=\"blue\">public</span> <span class=\"teal\">Result</span> Execute(\n    <span class=\"teal\">ExternalCommandData</span> commandData,\n    <span class=\"blue\">ref</span> <span class=\"blue\">string</span> message,\n    <span class=\"teal\">ElementSet</span> elements )\n  {\n    <span class=\"teal\">UIApplication</span> uiapp = commandData.Application;\n    <span class=\"teal\">UIDocument</span> uidoc = uiapp.ActiveUIDocument;\n    <span class=\"teal\">Application</span> app = uiapp.Application;\n    <span class=\"teal\">Document</span> doc = uidoc.Document;\n \n    <span class=\"teal\">Selection</span> sel = uidoc.Selection;\n \n    <span class=\"teal\">StringBuilder</span> sb = <span class=\"blue\">new</span> <span class=\"teal\">StringBuilder</span>();\n    <span class=\"blue\">double</span> areaTotal = 0;\n \n    <span class=\"teal\">IEnumerable</span>&lt;<span class=\"teal\">ElementId</span>&gt; elementIds = sel.GetElementIds();\n \n    <span class=\"blue\">foreach</span>( <span class=\"teal\">ElementId</span> elementId <span class=\"blue\">in</span> elementIds )\n    {\n      <span class=\"teal\">FamilyInstance</span> fi = doc.GetElement( elementId )\n        <span class=\"blue\">as</span> <span class=\"teal\">FamilyInstance</span>;\n \n      <span class=\"blue\">if</span>( <span class=\"blue\">null</span> != fi )\n      {\n        <span class=\"blue\">double</span> areaMetric =\n            GetInstanceSurfaceAreaMetric( fi );\n        areaTotal += areaMetric;\n \n        <span class=\"blue\">double</span> areaRound = <span class=\"teal\">Math</span>.Round( areaMetric, 2 );\n \n        sb.AppendLine();\n        sb.Append( <span class=\"maroon\">\"ElementId: \"</span> + fi.Id.IntegerValue );\n        sb.Append( <span class=\"maroon\">\"  Name: \"</span> + fi.Name );\n        sb.AppendLine( <span class=\"maroon\">\"  Area: \"</span> + areaRound + <span class=\"maroon\">\" m2\"</span> );\n      }\n    }\n    <span class=\"blue\">int</span> count = elementIds.Count&lt;<span class=\"teal\">ElementId</span>&gt;();\n \n    <span class=\"blue\">double</span> areaPrintFriendly = <span class=\"teal\">Math</span>.Round( areaTotal, 2 );\n \n    sb.AppendLine( <span class=\"maroon\">\"\\nTotal area: \"</span>\n      + areaPrintFriendly + <span class=\"maroon\">\" m2\"</span> );\n \n    <span class=\"teal\">TaskDialog</span> taskDialog = <span class=\"blue\">new</span> <span class=\"teal\">TaskDialog</span>(\n      <span class=\"maroon\">\"Selection Area\"</span> );\n \n    taskDialog.MainInstruction = <span class=\"maroon\">\"Elements selected: \"</span>\n      + count;\n \n    taskDialog.MainContent = sb.ToString();\n \n    taskDialog.Show();\n \n    <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Succeeded;\n  }\n</pre><a name=\"3\"></a>"
  },
  {
    "original_filename": "1298_door_window_area",
    "header_text": "Sample Model",
    "local_header_href": "#sample-model",
    "chunk_text": "<h4>Sample Model</h4><p>Peter's sample model contains three different kinds of windows:</p><center>\n<img alt=\"ExporterIFCUtils sample model\" src=\"img/ExporterIfcUtilsWinArea_model.png\" width=\"316\"/>\n</center><p>The sample code calculates the following resulting areas for it:</p><center>\n<img alt=\"ExporterIFCUtils sample result\" src=\"img/ExporterIfcUtilsWinArea_result.png\" width=\"369\"/>\n</center><a name=\"4\"></a>"
  },
  {
    "original_filename": "1298_door_window_area",
    "header_text": "Download",
    "local_header_href": "#download",
    "chunk_text": "<h4>Download</h4><p>The entire source code, Visual Studio solution and add-in manifest is provided in the\n\n<a href=\"https://github.com/jeremytammik/ExporterIfcUtilsWinArea\">ExporterIfcUtilsWinArea GitHub repository</a>,\n\nand the version discussed above is\n\n<a href=\"https://github.com/jeremytammik/ExporterIfcUtilsWinArea/releases/tag/2015.0.0.1\">release 2015.0.0.1</a>.\n</p>"
  }
]