[
  {
    "original_filename": "0872_toelementids_perf",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<head>\n<link href=\"bc.css\" rel=\"stylesheet\" type=\"text/css\"/>\n</head>"
  },
  {
    "original_filename": "0872_toelementids_perf",
    "header_text": "ToElementIds Performance",
    "local_header_href": "#toelementids-performance",
    "chunk_text": "<h3>ToElementIds Performance</h3><p>Conversion of a filtered element collector to an explicit .NET collection of elements or element ids is always costly and mostly avoidable and unnecessary.</p><p>Before getting to the details of that issue, here is another quick snapshot from our travels to the West European developer conferences.\nAs you either know or might guess, one of the main topics of these is cloud and mobile development, e.g. looking at topics such as the\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2012/12/the-bim-360-glue-viewer-and-rest-api.html\">\nBIM 360 Glue REST API and SDK</a> and\n\nmy hands-on exploration of how to\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2012/12/bim-360-glue-rest-api-authentication-using-python.html\">\naccess and use it via Python</a>.\n\n<p>Funnily enough, the lighting in the Paris Charles de Gaulle airport is designed along a cloud scheme, so here is very low quality picture of us almost touching the clouds at the airport gate preparing to board the flight to Milano:</p>\n<center>\n<img alt=\"Jeremy in the clouds in Charles de Gaulle in Paris\" src=\"file:///j/photo/jeremy/2012/2012-12-12_devdays_paris/jeremy_under_cloud_charles_de_gaulle_paris.jpeg\" width=\"400\"/>\n</center>\n<p>Ora siamo arrivati in Milano per un'altra conferenza di sviluppatori.</p>\n<p>Returning to the Revit API, I recently mentioned a couple of\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2012/09/findelement-and-collector-optimisation.html\">\nFindElement and collector optimisations</a>.\n\n<p>One of them is the fact that the conversion from a filtered element collector to a .NET collection is costly and should be avoided if possible.</p>\n<p>Here is another observation related to that, brought up by <a href=\"http://redbolts.com\">Guy Robinson</a> and answered by Scott Conover of the Revit API development team:</p>\n<p><strong>Question:</strong> I sometimes use the ToElementIds method, e.g. like this:</p>\n<pre class=\"code&gt;\">\n  <span class=\"blue\">var</span> fc = <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( doc )\n    .OfSomething()\n    .ToElementIds();\n \n  <span class=\"blue\">foreach</span>( <span class=\"blue\">var</span> elemId <span class=\"blue\">in</span> fc )\n  {\n    <span class=\"blue\">var</span> element = doc.GetElement( elemId );\n  }\n</pre>\n<p>I noticed that this is about 25% slower than accessing the elements directly as follows:</p>\n<pre class=\"code&gt;\">\n  <span class=\"blue\">var</span> fc = <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( doc )\n    .OfSomething();\n \n  <span class=\"blue\">foreach</span> (<span class=\"blue\">var</span> elem <span class=\"blue\">in</span> fc)\n  {\n      <span class=\"blue\">var</span> element = elem;\n  }\n</pre>\n<p>I am wondering why the ToElementIds approach is so much slower?\n\n<p>Shouldn't the two approaches be equivalent?</p>\n<p>Is there any good reason to use ToElementIds at all?</p>\n<p>Not surprisingly, this ~25% slower figure has been the same on my tests ever since I started comparing in Revit 2012.</p>\n<p><strong>Answer:</strong> This is not unexpected.\n\n<p>ToElementIds and ToElements allocate a new concrete .NET collection containing the elements passing the filter.\nThen it returns this allocated collection to you, which involves a conversion from a native level collection to a managed object.\nThis will take extra time as compared to a direct iteration.</p>\n<p>Why might you use the ToElementIds variants?\nWell, you might need a concrete collection to store in memory.\nOr you might need a collection to pass as input to an API method like Delete – which you should definitely not call from the middle of a foreach iteration unless you like unexpected behaviour.\nThis provides a shortcut to building this allocation.</p>\n<p>For any sort of operation of the type \"I want to read properties of each passing element\" you can skip ToElements and the extra collection allocation.</p>\n<p>Thank you Scott for these insights!</p>\n<p>For one example of how this can be achieved, look at the aforementioned\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2012/09/findelement-and-collector-optimisation.html\">\nFindElement and collector optimisations</a>.\n\nThere are lots of other examples in many of The Building Coder discussions, since I consciously and consistently avoid this conversion whenever possible, i.e. almost always.</p>\n</p></p></p></p>"
  }
]