[
  {
    "original_filename": "0647_filledregion_coords",
    "header_text": "FilledRegion Coordinates",
    "local_header_href": "#filledregion-coordinates",
    "chunk_text": "<h3>FilledRegion Coordinates</h3><p>Here is a \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/11/access-to-sketch-and-sketch-plane.html?cid=6a00e553e1689788330153915d8721970b#comment-6a00e553e1689788330153915d8721970b\">\nquestion</a>\n\nraised by Trang on how to access the coordinates of a filled region.\n\n<p>It demonstrates that you can make (completely unsupported and at your own risk) use of the sequential nature of the element id allocation to determine relationships between Revit database elements and their data that is not otherwise accessible through the Revit API.\n\n<p><strong>Question:</strong> I try to get coordinates of corners of a FilledRegion but I couldn't. \nCould you show me how I can get the boundary of a FilledRegion?\n\n<p><strong>Answer:</strong> The current Revit API does not provide any direct access to this data. \n\n<p>Meanwhile, however, just creating a filled region on the fly and using RevitLookup to analyse the results, I see that a FilledRegion element was created with the element id 161178. \nImmediately before, a sketch with id 161176 was created. Its profile defines a curve array, and the lines are accessible. \nMaybe this kind of approach can help you retrieve the data you are looking for?\n\n<p><strong>Response:</strong> What I want is coordinates of a FilledRegion, so here is my code.\n\n<pre class=\"code\">\n<span class=\"blue\">public</span> List getBoundaryCorner( \n  <span class=\"teal\">FilledRegion</span> region, \n  <span class=\"teal\">Document</span> doc )\n{\n  List result = <span class=\"blue\">new</span> List();\n \n  <span class=\"teal\">ElementId</span> id = <span class=\"blue\">new</span> <span class=\"teal\">ElementId</span>( \n    region.Id.IntegerValue - 1 );\n \n  <span class=\"teal\">Sketch</span> boundary = doc.get_Element( id ) <span class=\"blue\">as</span> <span class=\"teal\">Sketch</span>;\n \n  <span class=\"blue\">if</span>( <span class=\"blue\">null</span> != boundary )\n  {\n    <span class=\"teal\">CurveArray</span> curBoundary \n      = boundary.Profile.get_Item( 0 );\n \n    <span class=\"blue\">if</span>( <span class=\"blue\">null</span> != curBoundary )\n    {\n      <span class=\"blue\">foreach</span>( <span class=\"teal\">Curve</span> cur <span class=\"blue\">in</span> curBoundary )\n      {\n        <span class=\"teal\">XYZ</span> corner = cur.get_EndPoint( 0 );\n        result.Add( corner );\n      }\n    }\n  }\n  <span class=\"blue\">return</span> result;\n}\n</pre>\n<p><strong>Answer:</strong> Congratulations on getting it working!\n\n<p>I created a new external command CmdFilledRegionCoords from your solution for The Building Coder samples.\nFor that, I updated your getBoundaryCorner implementation very slightly like this:\n\n<pre class=\"code\">\n<span class=\"teal\">List</span>&lt;<span class=\"teal\">XYZ</span>&gt; GetBoundaryCorners( <span class=\"teal\">FilledRegion</span> region )\n{\n  <span class=\"teal\">List</span>&lt;<span class=\"teal\">XYZ</span>&gt; result = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">XYZ</span>&gt;();\n \n  <span class=\"teal\">ElementId</span> id = <span class=\"blue\">new</span> <span class=\"teal\">ElementId</span>( \n    region.Id.IntegerValue - 1 );\n \n  <span class=\"teal\">Sketch</span> sketch = region.Document.get_Element( \n    id ) <span class=\"blue\">as</span> <span class=\"teal\">Sketch</span>;\n \n  <span class=\"blue\">if</span>( <span class=\"blue\">null</span> != sketch )\n  {\n    <span class=\"teal\">CurveArray</span> curves = sketch.Profile.get_Item( 0 );\n \n    <span class=\"blue\">if</span>( <span class=\"blue\">null</span> != curves )\n    {\n      <span class=\"blue\">foreach</span>( <span class=\"teal\">Curve</span> cur <span class=\"blue\">in</span> curves )\n      {\n        <span class=\"teal\">XYZ</span> corner = cur.get_EndPoint( 0 );\n        result.Add( corner );\n      }\n    }\n  }\n  <span class=\"blue\">return</span> result;\n}\n</pre>\n<p>This helper method is driven by the following mainline in the Execute method implementation:\n\n<pre class=\"code\">\n<span class=\"blue\">public</span> <span class=\"teal\">Result</span> Execute(\n  <span class=\"teal\">ExternalCommandData</span> commandData,\n  <span class=\"blue\">ref</span> <span class=\"blue\">string</span> message,\n  <span class=\"teal\">ElementSet</span> elements )\n{\n  <span class=\"teal\">UIApplication</span> uiapp = commandData.Application;\n  <span class=\"teal\">UIDocument</span> uidoc = uiapp.ActiveUIDocument;\n  <span class=\"teal\">Application</span> app = uiapp.Application;\n  <span class=\"teal\">Document</span> doc = uidoc.Document;\n \n  <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt; filledRegions \n    = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt;();\n \n  <span class=\"blue\">if</span>( <span class=\"teal\">Util</span>.GetSelectedElementsOrAll( \n    filledRegions, uidoc, <span class=\"blue\">typeof</span>( <span class=\"teal\">FilledRegion</span> ) ) )\n  {\n    <span class=\"blue\">int</span> n = filledRegions.Count;\n \n    <span class=\"blue\">string</span>[] results = <span class=\"blue\">new</span> <span class=\"blue\">string</span> [n];\n \n    <span class=\"blue\">int</span> i = 0;\n \n    <span class=\"blue\">foreach</span>( <span class=\"teal\">FilledRegion</span> region <span class=\"blue\">in</span> \n      filledRegions.Cast&lt;<span class=\"teal\">FilledRegion</span>&gt;() )\n    {\n      <span class=\"blue\">string</span> desc = <span class=\"teal\">Util</span>.ElementDescription( region );\n \n      <span class=\"teal\">List</span>&lt;<span class=\"teal\">XYZ</span>&gt; corners = GetBoundaryCorners( \n        region );\n \n      <span class=\"blue\">string</span> result = ( <span class=\"blue\">null</span> == corners ) ? <span class=\"maroon\">\"failed\"</span>\n        : <span class=\"blue\">string</span>.Join( <span class=\"maroon\">\", \"</span>, \n          corners.ConvertAll&lt;<span class=\"blue\">string</span>&gt;( \n            p =&gt; <span class=\"teal\">Util</span>.PointString( p ) )\n              .ToArray() );\n \n      results[i++] = <span class=\"blue\">string</span>.Format( <span class=\"maroon\">\"{0}: {1}\"</span>, \n        desc, result );\n    }\n    <span class=\"blue\">string</span> s = <span class=\"blue\">string</span>.Format( \n      <span class=\"maroon\">\"Retrieving corners for {0} filled region{1}{2}\"</span>, \n      n, <span class=\"teal\">Util</span>.PluralSuffix( n ), <span class=\"teal\">Util</span>.DotOrColon( n ) );\n \n    <span class=\"blue\">string</span> t = <span class=\"blue\">string</span>.Join( <span class=\"maroon\">\"\\r\\n\"</span>, results );\n \n    <span class=\"teal\">Util</span>.InfoMsg( s, t );\n  }\n  <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Succeeded;\n}\n</pre>\n<p>Here is a sample filled region to test this code on:\n\n<center>\n<img alt=\"FilledRegion\" src=\"img/filledregion.png\"/>\n</center>\n<p>Here are the resulting coordinates as displayed by the new overload of the InfoMsg method using a task dialogue:\n\n<center>\n<img alt=\"FilledRegion coordinates\" src=\"img/filledregion_coords.png\"/>\n</center>\n<p>For completeness' sake, here they are in text format as well:\n\n<pre>\nRetrieving corners for 1 filled region:\n\nDetail Items &lt;161178 Detail Filled Region&gt;: \n  (-19.01,40.84,0), \n  (1.64,11.35,0), \n  (-35.7,17.93,0), \n  (-38.81,21.04,0)\n</pre>\n<p>Thanks to Trang for raising this topic and testing out the idea.\n\n<p>Here is\n\n<a href=\"zip/bc_12_92.zip\">\nversion 2012.0.92.0</a> of\n\nThe Building Coder samples including the new command CmdFilledRegionCoords.\n\n<p>Some additional notes: the element ids I originally saw in RevitLookup were not consecutive, but two apart. \nTrang used consecutive ones, I am assuming after a more detailed analysis than my quick glance.\n\n<p>Obviously, the method described here is completely unsupported and will almost certainly fail in some future version.\nYou use it completely at your own risk.\n\n<p>Probably, at some point in the future, the Revit API will provide official access to the filled region coordinates, and this workaround will no longer be needed.\n\n<p>Still, it was pretty satisfying and good fun to make use of this undocumented feature, and also hear from Rudolf in his comment below that he is aware of it as well, for a similar use with revision clouds.\n</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p>"
  }
]