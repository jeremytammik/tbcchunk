[
  {
    "original_filename": "1868_outline_performance",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n<link rel=\"stylesheet\" type=\"text/css\" href=\"bc.css\">\n<script src=\"https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js\" type=\"text/javascript\"></script>\n</head>\n\n<!---\n\n- high-performance optimisation using Revit API for outline for many elements (>100'000 items)\n  e.g., for 54000 walls (after filtering) and 18000 pipes, leading to 972'000'000 operation.\n  How can I get bounding box for several elements?\n  https://stackoverflow.com/questions/63083938/revit-api-how-can-i-get-bounding-box-for-several-elements\n  how to get element nearby specific element using bounding box if it is just outside(some distance apart) bounding box?\n  https://forums.autodesk.com/t5/revit-api-forum/how-to-get-element-nearby-specific-element-using-bounding-box-if/m-p/9741883\n\n- set the clipped/unclipped state of the base and survey points in 2021.1\n  https://autodesk.slack.com/archives/C0SR6NAP8/p1600379512087800\n  Jacob Small:mega-thinking: 17 Sep at 23:51\n  Can anyone in Dev confirm this statement is still true?\n  The clipped/unclipped state of the base and survey points cannot be set via the API. You can pin them using the Element.Pinned property.\n  https://thebuildingcoder.typepad.com/blog/2012/11/survey-and-project-base-point.html\n  Jennifer (Xue) Li  5 days ago\n  We exposed a new property Clipped for Base Point in R2021.1. So starting from this version, you will have the ability to get/set clipped state for Survey Point. And for Project Base Point, the property is readonly and will always return false because we’ve removed the clipped state fro PBP.\n  :celebrate:\n  Jacob Small:mega-thinking:  5 days ago\n  Yay!!!!! Huge help thanks!\n\n- BIM360 apps from German university startups now live\n  [15 New Integrations with Autodesk Construction Cloud ](https://constructionblog.autodesk.com/15-integrations-autodesk-construction)\n  two Startups from the Forge developer Universities:\n  Gamma AR &ndash; RWTH Aachen \n  4d planner &ndash; TU Berlin \n  https://twitter.com/ADSK_Construct/status/1311699100312666113\n\n- [Inventing Virtual Meetings of Tomorrow with NVIDIA AI Research](https://youtu.be/NqmMnjJ6GEg)\n  [Nvidia Maxine Cloud-AI Video-Streaming Platform](https://developer.nvidia.com/maxine)\n  New AI breakthroughs in NVIDIA Maxine, cloud-native video streaming AI SDK, slash bandwidth use while make it possible to re-animate faces, correct gaze and animate characters for immersive and engaging meetings. Learn more: https://nvda.ws/3l9foIn\n  AI-based face recognition and reconstruction is used, enabling bandwidth reduction by transmitting only animated face keypoint data instead of the entire video keyframe information.\n\ntwitter:\n\nAI-based face keypoint streaming hits mainstream, German university BIM360 construction cloud startups, clipped and unclipped base and survey points, line-plane intersection and high-performance outline calculation and optimisation for a huge model with the #RevitAPI @AutodeskForge @AutodeskRevit #bim #DynamoBim #ForgeDevCon http://bit.ly/highperfoutline\n\nToday let's talk mainly about geometric analysis and performance\n&ndash; High-performance outline optimisation\n&ndash; Simple line-plane intersection\n&ndash; Set base and survey clipped and unclipped\n&ndash; Two German uni BIM360 construction cloud startups\n&ndash; AI-based face streaming hits mainstream...\n\nlinkedin:\n\nAI-based face keypoint streaming hits mainstream, German university BIM360 construction cloud startups, clipped and unclipped base and survey points, line-plane intersection and high-performance outline calculation and optimisation for a huge model with the #RevitAPI\n\nhttp://bit.ly/highperfoutline\n\nToday let's talk mainly about geometric analysis and performance:\n\n- High-performance outline optimisation\n- Simple line-plane intersection\n- Set base and survey clipped and unclipped\n- Two German uni BIM360 construction cloud startups\n- AI-based face streaming hits mainstream...\n\n#bim #DynamoBim #ForgeDevCon #Revit #API #IFC #SDK #AI #VisualStudio #Autodesk #AEC #adsk\n\nthe [Revit API discussion forum](http://forums.autodesk.com/t5/revit-api-forum/bd-p/160) thread\n\n<center>\n<img src=\"img/\" alt=\"\" title=\"\" width=\"600\"/>\n<p style=\"font-size: 80%; font-style:italic\"></p>\n</center>\n\n-->"
  },
  {
    "original_filename": "1868_outline_performance",
    "header_text": "High Performance Outline, Line-Plane Intersection",
    "local_header_href": "#high-performance-outline-line-plane-intersection",
    "chunk_text": "### High Performance Outline, Line-Plane Intersection\n\nToday let's talk mainly about geometric analysis and performance:\n\n- [High-performance outline optimisation](#2)\n    - [Solution](#2.1)\n- [Simple line-plane intersection](#3)\n- [Set base and survey clipped and unclipped](#4)\n- [Two German uni BIM360 construction cloud startups](#5)\n- [AI-based face streaming hits mainstream](#6)"
  },
  {
    "original_filename": "1868_outline_performance",
    "header_text": "High-Performance Outline Optimisation",
    "local_header_href": "#2",
    "chunk_text": "####<a name=\"2\"></a> High-Performance Outline Optimisation\n\nIf you are interested in high-performance use of the Revit API, you may be able to learn a trick or two from the StackOverflow discussion\non [how to get the bounding box for several elements](https://stackoverflow.com/questions/63083938/revit-api-how-can-i-get-bounding-box-for-several-elements).\n\n**Question:** I need to find an outline for many elements (>100'000 items).\nTarget elements come from a `FilteredElementCollector`.\nAs usual, I'm looking for the fastest possible way. \n\nFor now, I tried to iterate over all elements to get its `BoudingBox.Min` and `BoudingBox.Max` and find out `minX`, `minY`, `minZ`, `maxX`, `maxY`, `maxZ`.\nIt works pretty accurately but takes too much time.\n\nThe problem described above is a part of a bigger one:\n\nI need to find all the intersections of ducts, pipes and other curve-based elements from a linked model with walls, ceilings, columns, etc. in the general model and then place openings in the intersections.\n\nI tried to use a combination of `ElementIntersectElement` filter and ` IntersectSolidAndCurve` method to find a part of curve inside element.\n\nFirst, with an `ElementIntersectElement`, I tried to reduce a collection for further use of `IntersectSolidAndCurve`.\n\n`IntersectSolidAndCurve` takes two arguments, solid and curve, and has to work in two nested one in the other loops.\nSo, it takes for 54000 walls (after filtering) and 18000 pipes, in my case, 972'000'000 operations.\n\nWith the number of operations 10 ^ 5, the algorithm shows an acceptable time.\n\nI decided to reduce the number of elements by dividing the search areas by levels.\nThis works well for high-rise buildings, but is still bad for extended low structures.\nI decided to divide the building by length, but I did not find a method that finds boundaries for several elements (the whole building).\n\nI seem to be going in a wrong direction.\nIs there are right way to achieve this with the Revit API?\n\n**Answer:** In principle, what you describe is the proper approach and the only way to do it.\n\nHowever, there may be many possibilities to optimise your code.\nThe Building Coder provides various utility functions that may help.\nFor instance, to [determine the bounding box of an entire family](https://thebuildingcoder.typepad.com/blog/2017/03/family-bounding-box-and-aec-hackathon-munich.html#3).\nMany more in [The Building Coder samples `Util` module](https://github.com/jeremytammik/the_building_coder_samples/blob/master/BuildingCoder/BuildingCoder/Util.cs).\nSearch there for \"bounding box\".\nI am sure they can be further optimised as well for your case.\nFor instance, you may be able to extract all the `X` coordinates from all the individual elements' bounding box `Max` values and use a generic `Max` function to determine their maximum in one single call instead of comparing them one by one.\n[Benchmark your code](https://thebuildingcoder.typepad.com/blog/2012/01/timer-code-for-benchmarking.html) to discover optimisation possibilities and analyse their effect on the performance. \n\n**Response:** Thanks to Jeremy for advice and input on this issue.\nI published my final result below and did some research on performance and accuracy.\nThe code in my answer processed in 3-5 seconds / 100'000 elements and works accurate in most cases.\nHowever, there are cases where the `BoundingBoxIntersectsFilter` filters the item when it does not cross the `Outline`.\nThis happens if there is invisible geometry in the family.\nThere are other possible reasons that I have not yet found. More tests need to be done anyway.\n\n**Answer:** Thank you very much for your appreciation and sharing your interesting code.\nUsing the built-in Revit filtering mechanisms will definitely be a lot faster than anything you can achieve in .NET, outside Revit memory.\nHowever, I do not yet understand how you can use this to achieve the goal you describe above.\nI thought you needed the collective bounding box of all elements.\nYou, however, seem to have an input variable of 500 meters and o be checking whether that contains all the elements.\nCan you please explain the exact use of this algorithm, and the exact input and output data?\n\n**Response:** Jeremy, you're absolutely right.\nThe minimum and maximum points in 3d-space are fed to the input to the method, so that all the elements are inside the outline built on that points, then we find the extreme points along `x` `y` `z`.\nThe output is 2 outline points. \n\n####<a name=\"2.1\"></a> Solution\n\nTo find boundaries, we can take advantage of the binary search idea. \n\nThe difference from the classic binary search algorithm is there is not an array, and we should find two numbers instead of one.\n\nElements in Geometry space could be presented as a 3-dimensional sorted array of `XYZ` points. \n\nThe Revit API provides an excellent `Quick Filter`, the `BoundingBoxIntersectsFilter`, that takes an instance of an `Outline`.\n\nSo, let’s define an area that includes all the elements for which we want to find the boundaries.\nFor my case, for example 500 meters, and create `min` and `max` point for the initial outline:\n\n<pre class=\"code\">\n&nbsp;&nbsp;<span style=\"color:blue;\">double</span>&nbsp;b&nbsp;=&nbsp;500000&nbsp;/&nbsp;304.8;\n&nbsp;&nbsp;<span style=\"color:#2b91af;\">XYZ</span>&nbsp;min&nbsp;=&nbsp;<span style=\"color:blue;\">new</span>&nbsp;<span style=\"color:#2b91af;\">XYZ</span>(&nbsp;-b,&nbsp;-b,&nbsp;-b&nbsp;);\n&nbsp;&nbsp;<span style=\"color:#2b91af;\">XYZ</span>&nbsp;max&nbsp;=&nbsp;<span style=\"color:blue;\">new</span>&nbsp;<span style=\"color:#2b91af;\">XYZ</span>(&nbsp;b,&nbsp;b,&nbsp;b&nbsp;);\n</pre>\n\nBelow is an implementation for one direction; you can easily use it for three directions by calling and feeding the result of the previous iteration to the input:\n\n<pre class=\"code\">\n&nbsp;&nbsp;<span style=\"color:blue;\">double</span>&nbsp;precision&nbsp;=&nbsp;10e-6&nbsp;/&nbsp;304.8;\n&nbsp;&nbsp;<span style=\"color:blue;\">var</span>&nbsp;bb&nbsp;=&nbsp;<span style=\"color:blue;\">new</span>&nbsp;BinaryUpperLowerBoundsSearch(&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;doc,&nbsp;precision&nbsp;);\n \n&nbsp;&nbsp;<span style=\"color:#2b91af;\">XYZ</span>[]&nbsp;rx&nbsp;=&nbsp;bb.GetBoundaries(&nbsp;min,&nbsp;max,&nbsp;elems,&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;BinaryUpperLowerBoundsSearch.Direction.X&nbsp;);\n&nbsp;&nbsp;rx&nbsp;=&nbsp;bb.GetBoundaries(&nbsp;rx[&nbsp;0&nbsp;],&nbsp;rx[&nbsp;1&nbsp;],&nbsp;elems,&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;BinaryUpperLowerBoundsSearch.Direction.Y&nbsp;);\n&nbsp;&nbsp;rx&nbsp;=&nbsp;bb.GetBoundaries(&nbsp;rx[&nbsp;0&nbsp;],&nbsp;rx[&nbsp;1&nbsp;],&nbsp;elems,&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;BinaryUpperLowerBoundsSearch.Direction.Z&nbsp;);\n</pre>\n\nThe `GetBoundaries` method returns two `XYZ` points: lower and upper, which change only in the target direction; the other two dimensions remain unchanged:\n\n<pre class=\"code\">\n<span style=\"color:blue;\">public</span>&nbsp;<span style=\"color:blue;\">class</span>&nbsp;<span style=\"color:#2b91af;\">BinaryUpperLowerBoundsSearch</span>\n{\n&nbsp;&nbsp;<span style=\"color:blue;\">private</span>&nbsp;<span style=\"color:#2b91af;\">Document</span>&nbsp;doc;\n \n&nbsp;&nbsp;<span style=\"color:blue;\">private</span>&nbsp;<span style=\"color:blue;\">double</span>&nbsp;tolerance;\n&nbsp;&nbsp;<span style=\"color:blue;\">private</span>&nbsp;<span style=\"color:#2b91af;\">XYZ</span>&nbsp;min;\n&nbsp;&nbsp;<span style=\"color:blue;\">private</span>&nbsp;<span style=\"color:#2b91af;\">XYZ</span>&nbsp;max;\n&nbsp;&nbsp;<span style=\"color:blue;\">private</span>&nbsp;<span style=\"color:#2b91af;\">XYZ</span>&nbsp;direction;\n \n&nbsp;&nbsp;<span style=\"color:blue;\">public</span>&nbsp;BinaryUpperLowerBoundsSearch(&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:#2b91af;\">Document</span>&nbsp;document,&nbsp;<span style=\"color:blue;\">double</span>&nbsp;precision&nbsp;)\n&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;doc&nbsp;=&nbsp;document;\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">this</span>.tolerance&nbsp;=&nbsp;precision;\n&nbsp;&nbsp;}\n \n&nbsp;&nbsp;<span style=\"color:blue;\">public</span>&nbsp;<span style=\"color:blue;\">enum</span>&nbsp;<span style=\"color:#2b91af;\">Direction</span>\n&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;X,\n&nbsp;&nbsp;&nbsp;&nbsp;Y,\n&nbsp;&nbsp;&nbsp;&nbsp;Z\n&nbsp;&nbsp;}\n \n&nbsp;&nbsp;<span style=\"color:gray;\">///</span><span style=\"color:green;\">&nbsp;</span><span style=\"color:gray;\">&lt;</span><span style=\"color:gray;\">summary</span><span style=\"color:gray;\">&gt;</span>\n&nbsp;&nbsp;<span style=\"color:gray;\">///</span><span style=\"color:green;\">&nbsp;Searches&nbsp;for&nbsp;an&nbsp;area&nbsp;that&nbsp;completely&nbsp;includes&nbsp;</span>\n&nbsp;&nbsp;<span style=\"color:gray;\">///</span><span style=\"color:green;\">&nbsp;all&nbsp;elements&nbsp;within&nbsp;a&nbsp;given&nbsp;precision.</span>\n&nbsp;&nbsp;<span style=\"color:gray;\">///</span><span style=\"color:green;\">&nbsp;The&nbsp;minimum&nbsp;and&nbsp;maximum&nbsp;points&nbsp;are&nbsp;used&nbsp;for&nbsp;the&nbsp;</span>\n&nbsp;&nbsp;<span style=\"color:gray;\">///</span><span style=\"color:green;\">&nbsp;initial&nbsp;assessment.&nbsp;</span>\n&nbsp;&nbsp;<span style=\"color:gray;\">///</span><span style=\"color:green;\">&nbsp;The&nbsp;outline&nbsp;must&nbsp;contain&nbsp;all&nbsp;elements.</span>\n&nbsp;&nbsp;<span style=\"color:gray;\">///</span><span style=\"color:green;\">&nbsp;</span><span style=\"color:gray;\">&lt;/</span><span style=\"color:gray;\">summary</span><span style=\"color:gray;\">&gt;</span>\n&nbsp;&nbsp;<span style=\"color:gray;\">///</span><span style=\"color:green;\">&nbsp;</span><span style=\"color:gray;\">&lt;</span><span style=\"color:gray;\">param</span><span style=\"color:gray;\">&nbsp;name</span><span style=\"color:gray;\">=</span><span style=\"color:gray;\">&quot;</span>minPoint<span style=\"color:gray;\">&quot;</span><span style=\"color:gray;\">&gt;</span><span style=\"color:green;\">The&nbsp;minimum&nbsp;point&nbsp;of&nbsp;the&nbsp;</span>\n&nbsp;&nbsp;<span style=\"color:gray;\">///</span><span style=\"color:green;\">&nbsp;BoundBox&nbsp;used&nbsp;for&nbsp;the&nbsp;first&nbsp;approximation.</span><span style=\"color:gray;\">&lt;/</span><span style=\"color:gray;\">param</span><span style=\"color:gray;\">&gt;</span>\n&nbsp;&nbsp;<span style=\"color:gray;\">///</span><span style=\"color:green;\">&nbsp;</span><span style=\"color:gray;\">&lt;</span><span style=\"color:gray;\">param</span><span style=\"color:gray;\">&nbsp;name</span><span style=\"color:gray;\">=</span><span style=\"color:gray;\">&quot;</span>maxPoint<span style=\"color:gray;\">&quot;</span><span style=\"color:gray;\">&gt;</span><span style=\"color:green;\">The&nbsp;maximum&nbsp;point&nbsp;of&nbsp;the</span>\n&nbsp;&nbsp;<span style=\"color:gray;\">///</span><span style=\"color:green;\">&nbsp;BoundBox&nbsp;used&nbsp;for&nbsp;the&nbsp;first&nbsp;approximation.</span><span style=\"color:gray;\">&lt;/</span><span style=\"color:gray;\">param</span><span style=\"color:gray;\">&gt;</span>\n&nbsp;&nbsp;<span style=\"color:gray;\">///</span><span style=\"color:green;\">&nbsp;</span><span style=\"color:gray;\">&lt;</span><span style=\"color:gray;\">param</span><span style=\"color:gray;\">&nbsp;name</span><span style=\"color:gray;\">=</span><span style=\"color:gray;\">&quot;</span>elements<span style=\"color:gray;\">&quot;</span><span style=\"color:gray;\">&gt;</span><span style=\"color:green;\">Set&nbsp;of&nbsp;elements</span><span style=\"color:gray;\">&lt;/</span><span style=\"color:gray;\">param</span><span style=\"color:gray;\">&gt;</span>\n&nbsp;&nbsp;<span style=\"color:gray;\">///</span><span style=\"color:green;\">&nbsp;</span><span style=\"color:gray;\">&lt;</span><span style=\"color:gray;\">param</span><span style=\"color:gray;\">&nbsp;name</span><span style=\"color:gray;\">=</span><span style=\"color:gray;\">&quot;</span>axe<span style=\"color:gray;\">&quot;</span><span style=\"color:gray;\">&gt;</span><span style=\"color:green;\">The&nbsp;direction&nbsp;along&nbsp;which&nbsp;the&nbsp;</span>\n&nbsp;&nbsp;<span style=\"color:gray;\">///</span><span style=\"color:green;\">&nbsp;boundaries&nbsp;will&nbsp;be&nbsp;searched</span><span style=\"color:gray;\">&lt;/</span><span style=\"color:gray;\">param</span><span style=\"color:gray;\">&gt;</span>\n&nbsp;&nbsp;<span style=\"color:gray;\">///</span><span style=\"color:green;\">&nbsp;</span><span style=\"color:gray;\">&lt;</span><span style=\"color:gray;\">returns</span><span style=\"color:gray;\">&gt;</span><span style=\"color:green;\">Returns&nbsp;two&nbsp;points:&nbsp;first&nbsp;is&nbsp;the&nbsp;lower&nbsp;bound,&nbsp;</span>\n&nbsp;&nbsp;<span style=\"color:gray;\">///</span><span style=\"color:green;\">&nbsp;second&nbsp;is&nbsp;the&nbsp;upper&nbsp;bound</span><span style=\"color:gray;\">&lt;/</span><span style=\"color:gray;\">returns</span><span style=\"color:gray;\">&gt;</span>\n&nbsp;&nbsp;<span style=\"color:blue;\">public</span>&nbsp;<span style=\"color:#2b91af;\">XYZ</span>[]&nbsp;GetBoundaries(&nbsp;<span style=\"color:#2b91af;\">XYZ</span>&nbsp;minPoint,&nbsp;<span style=\"color:#2b91af;\">XYZ</span>&nbsp;maxPoint,\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:#2b91af;\">ICollection</span>&lt;<span style=\"color:#2b91af;\">ElementId</span>&gt;&nbsp;elements,&nbsp;<span style=\"color:#2b91af;\">Direction</span>&nbsp;axe&nbsp;)\n&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:green;\">//&nbsp;Since&nbsp;Outline&nbsp;is&nbsp;not&nbsp;derived&nbsp;from&nbsp;an&nbsp;Element&nbsp;class&nbsp;there&nbsp;</span>\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:green;\">//&nbsp;is&nbsp;no&nbsp;possibility&nbsp;to&nbsp;apply&nbsp;transformation,&nbsp;so</span>\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:green;\">//&nbsp;we&nbsp;have&nbsp;use&nbsp;as&nbsp;a&nbsp;possible&nbsp;directions&nbsp;only&nbsp;three&nbsp;vectors&nbsp;of&nbsp;basis</span>\n \n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">switch</span>(&nbsp;axe&nbsp;)\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">case</span>&nbsp;<span style=\"color:#2b91af;\">Direction</span>.X:\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;direction&nbsp;=&nbsp;<span style=\"color:#2b91af;\">XYZ</span>.BasisX;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">break</span>;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">case</span>&nbsp;<span style=\"color:#2b91af;\">Direction</span>.Y:\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;direction&nbsp;=&nbsp;<span style=\"color:#2b91af;\">XYZ</span>.BasisY;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">break</span>;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">case</span>&nbsp;<span style=\"color:#2b91af;\">Direction</span>.Z:\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;direction&nbsp;=&nbsp;<span style=\"color:#2b91af;\">XYZ</span>.BasisZ;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">break</span>;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">default</span>:\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">break</span>;\n&nbsp;&nbsp;&nbsp;&nbsp;}\n \n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:green;\">//&nbsp;Get&nbsp;the&nbsp;lower&nbsp;and&nbsp;upper&nbsp;bounds&nbsp;as&nbsp;a&nbsp;projection&nbsp;</span>\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:green;\">//&nbsp;on&nbsp;a&nbsp;direction&nbsp;vector</span>\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:green;\">//&nbsp;Projection&nbsp;is&nbsp;an&nbsp;extention&nbsp;method</span>\n \n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">double</span>&nbsp;lowerBound&nbsp;=&nbsp;minPoint.Projection(&nbsp;direction&nbsp;);\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">double</span>&nbsp;upperBound&nbsp;=&nbsp;maxPoint.Projection(&nbsp;direction&nbsp;);\n \n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:green;\">//&nbsp;Set&nbsp;the&nbsp;boundary&nbsp;points&nbsp;in&nbsp;the&nbsp;plane&nbsp;perpendicular&nbsp;</span>\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:green;\">//&nbsp;to&nbsp;the&nbsp;direction&nbsp;vector.&nbsp;</span>\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:green;\">//&nbsp;These&nbsp;points&nbsp;are&nbsp;needed&nbsp;to&nbsp;create&nbsp;BoundingBoxIntersectsFilter&nbsp;</span>\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:green;\">//&nbsp;when&nbsp;IsContainsElements&nbsp;calls.</span>\n \n&nbsp;&nbsp;&nbsp;&nbsp;min&nbsp;=&nbsp;minPoint&nbsp;-&nbsp;lowerBound&nbsp;*&nbsp;direction;\n&nbsp;&nbsp;&nbsp;&nbsp;max&nbsp;=&nbsp;maxPoint&nbsp;-&nbsp;upperBound&nbsp;*&nbsp;direction;\n \n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">double</span>[]&nbsp;res&nbsp;=&nbsp;UpperLower(&nbsp;lowerBound,&nbsp;upperBound,&nbsp;elements&nbsp;);\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">return</span>&nbsp;<span style=\"color:blue;\">new</span>&nbsp;<span style=\"color:#2b91af;\">XYZ</span>[&nbsp;2&nbsp;]\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;res[0]&nbsp;*&nbsp;direction&nbsp;+&nbsp;min,\n&nbsp;&nbsp;&nbsp;&nbsp;res[1]&nbsp;*&nbsp;direction&nbsp;+&nbsp;max,\n&nbsp;&nbsp;&nbsp;&nbsp;};\n&nbsp;&nbsp;}\n \n&nbsp;&nbsp;<span style=\"color:gray;\">///</span><span style=\"color:green;\">&nbsp;</span><span style=\"color:gray;\">&lt;</span><span style=\"color:gray;\">summary</span><span style=\"color:gray;\">&gt;</span>\n&nbsp;&nbsp;<span style=\"color:gray;\">///</span><span style=\"color:green;\">&nbsp;Check&nbsp;if&nbsp;there&nbsp;are&nbsp;any&nbsp;elements&nbsp;contains&nbsp;in&nbsp;</span>\n&nbsp;&nbsp;<span style=\"color:gray;\">///</span><span style=\"color:green;\">&nbsp;the&nbsp;segment&nbsp;[lower,&nbsp;upper]</span>\n&nbsp;&nbsp;<span style=\"color:gray;\">///</span><span style=\"color:green;\">&nbsp;</span><span style=\"color:gray;\">&lt;/</span><span style=\"color:gray;\">summary</span><span style=\"color:gray;\">&gt;</span>\n&nbsp;&nbsp;<span style=\"color:gray;\">///</span><span style=\"color:green;\">&nbsp;</span><span style=\"color:gray;\">&lt;</span><span style=\"color:gray;\">returns</span><span style=\"color:gray;\">&gt;</span><span style=\"color:green;\">True&nbsp;if&nbsp;any&nbsp;elements&nbsp;are&nbsp;in&nbsp;the&nbsp;segment</span><span style=\"color:gray;\">&lt;/</span><span style=\"color:gray;\">returns</span><span style=\"color:gray;\">&gt;</span>\n&nbsp;&nbsp;<span style=\"color:blue;\">private</span>&nbsp;<span style=\"color:#2b91af;\">ICollection</span>&lt;<span style=\"color:#2b91af;\">ElementId</span>&gt;&nbsp;IsContainsElements(&nbsp;<span style=\"color:blue;\">double</span>&nbsp;lower,\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">double</span>&nbsp;upper,&nbsp;<span style=\"color:#2b91af;\">ICollection</span>&lt;<span style=\"color:#2b91af;\">ElementId</span>&gt;&nbsp;ids&nbsp;)\n&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">var</span>&nbsp;outline&nbsp;=&nbsp;<span style=\"color:blue;\">new</span>&nbsp;<span style=\"color:#2b91af;\">Outline</span>(&nbsp;min&nbsp;+&nbsp;direction&nbsp;*&nbsp;lower,&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max&nbsp;+&nbsp;direction&nbsp;*&nbsp;upper&nbsp;);\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">return</span>&nbsp;<span style=\"color:blue;\">new</span>&nbsp;<span style=\"color:#2b91af;\">FilteredElementCollector</span>(&nbsp;doc,&nbsp;ids&nbsp;)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.WhereElementIsNotElementType()\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.WherePasses(&nbsp;<span style=\"color:blue;\">new</span>&nbsp;<span style=\"color:#2b91af;\">BoundingBoxIntersectsFilter</span>(&nbsp;outline&nbsp;)&nbsp;)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.ToElementIds();\n&nbsp;&nbsp;}\n \n&nbsp;&nbsp;<span style=\"color:blue;\">private</span>&nbsp;<span style=\"color:blue;\">double</span>[]&nbsp;UpperLower(&nbsp;<span style=\"color:blue;\">double</span>&nbsp;lower,\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">double</span>&nbsp;upper,&nbsp;<span style=\"color:#2b91af;\">ICollection</span>&lt;<span style=\"color:#2b91af;\">ElementId</span>&gt;&nbsp;ids&nbsp;)\n&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:green;\">//&nbsp;Get&nbsp;the&nbsp;Midpoint&nbsp;for&nbsp;segment&nbsp;mid&nbsp;=&nbsp;lower&nbsp;+&nbsp;0.5&nbsp;*&nbsp;(upper&nbsp;-&nbsp;lower)</span>\n \n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">var</span>&nbsp;mid&nbsp;=&nbsp;Midpoint(&nbsp;lower,&nbsp;upper&nbsp;);\n \n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:green;\">//&nbsp;Сheck&nbsp;if&nbsp;the&nbsp;first&nbsp;segment&nbsp;contains&nbsp;elements</span>\n \n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:#2b91af;\">ICollection</span>&lt;<span style=\"color:#2b91af;\">ElementId</span>&gt;&nbsp;idsFirst&nbsp;=&nbsp;IsContainsElements(&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lower,&nbsp;mid,&nbsp;ids&nbsp;);\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">bool</span>&nbsp;first&nbsp;=&nbsp;idsFirst.Any();\n \n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:green;\">//&nbsp;Сheck&nbsp;if&nbsp;the&nbsp;second&nbsp;segment&nbsp;contains&nbsp;elements</span>\n \n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:#2b91af;\">ICollection</span>&lt;<span style=\"color:#2b91af;\">ElementId</span>&gt;&nbsp;idsSecond&nbsp;=&nbsp;IsContainsElements(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mid,&nbsp;upper,&nbsp;ids&nbsp;);\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">bool</span>&nbsp;second&nbsp;=&nbsp;idsSecond.Any();\n \n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:green;\">//&nbsp;If&nbsp;elements&nbsp;are&nbsp;in&nbsp;both&nbsp;segments&nbsp;</span>\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:green;\">//&nbsp;then&nbsp;the&nbsp;first&nbsp;segment&nbsp;contains&nbsp;the&nbsp;lower&nbsp;border&nbsp;</span>\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:green;\">//&nbsp;and&nbsp;the&nbsp;second&nbsp;contains&nbsp;the&nbsp;upper</span>\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:green;\">//&nbsp;---------**|***--------</span>\n \n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">if</span>(&nbsp;first&nbsp;&amp;&amp;&nbsp;second&nbsp;)\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">return</span>&nbsp;<span style=\"color:blue;\">new</span>&nbsp;<span style=\"color:blue;\">double</span>[&nbsp;2&nbsp;]\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Lower(lower,&nbsp;mid,&nbsp;idsFirst),\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Upper(mid,&nbsp;upper,&nbsp;idsSecond),\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};\n&nbsp;&nbsp;&nbsp;&nbsp;}\n \n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:green;\">//&nbsp;If&nbsp;elements&nbsp;are&nbsp;only&nbsp;in&nbsp;the&nbsp;first&nbsp;segment&nbsp;it&nbsp;contains&nbsp;both&nbsp;borders.&nbsp;</span>\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:green;\">//&nbsp;We&nbsp;recursively&nbsp;call&nbsp;the&nbsp;method&nbsp;UpperLower&nbsp;until&nbsp;</span>\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:green;\">//&nbsp;the&nbsp;lower&nbsp;border&nbsp;turn&nbsp;out&nbsp;in&nbsp;the&nbsp;first&nbsp;segment&nbsp;and&nbsp;</span>\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:green;\">//&nbsp;the&nbsp;upper&nbsp;border&nbsp;is&nbsp;in&nbsp;the&nbsp;second</span>\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:green;\">//&nbsp;---*****---|-----------</span>\n \n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">else</span>&nbsp;<span style=\"color:blue;\">if</span>(&nbsp;first&nbsp;&amp;&amp;&nbsp;!second&nbsp;)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">return</span>&nbsp;UpperLower(&nbsp;lower,&nbsp;mid,&nbsp;idsFirst&nbsp;);\n \n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:green;\">//&nbsp;Do&nbsp;the&nbsp;same&nbsp;with&nbsp;the&nbsp;second&nbsp;segment</span>\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:green;\">//&nbsp;-----------|---*****---</span>\n \n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">else</span>&nbsp;<span style=\"color:blue;\">if</span>(&nbsp;!first&nbsp;&amp;&amp;&nbsp;second&nbsp;)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">return</span>&nbsp;UpperLower(&nbsp;mid,&nbsp;upper,&nbsp;idsSecond&nbsp;);\n \n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:green;\">//&nbsp;Elements&nbsp;are&nbsp;out&nbsp;of&nbsp;the&nbsp;segment</span>\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:green;\">//&nbsp;**&nbsp;-----------|-----------&nbsp;**</span>\n \n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">else</span>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">throw</span>&nbsp;<span style=\"color:blue;\">new</span>&nbsp;<span style=\"color:#2b91af;\">ArgumentException</span>(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:#a31515;\">&quot;Segment&nbsp;does&nbsp;not&nbsp;contains&nbsp;elements.&nbsp;Try&nbsp;to&nbsp;make&nbsp;initial&nbsp;boundaries&nbsp;wider&quot;</span>,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:#a31515;\">&quot;lower,&nbsp;upper&quot;</span>&nbsp;);\n&nbsp;&nbsp;}\n \n&nbsp;&nbsp;<span style=\"color:gray;\">///</span><span style=\"color:green;\">&nbsp;</span><span style=\"color:gray;\">&lt;</span><span style=\"color:gray;\">summary</span><span style=\"color:gray;\">&gt;</span>\n&nbsp;&nbsp;<span style=\"color:gray;\">///</span><span style=\"color:green;\">&nbsp;Search&nbsp;the&nbsp;lower&nbsp;boundary&nbsp;of&nbsp;a&nbsp;segment&nbsp;containing&nbsp;elements</span>\n&nbsp;&nbsp;<span style=\"color:gray;\">///</span><span style=\"color:green;\">&nbsp;</span><span style=\"color:gray;\">&lt;/</span><span style=\"color:gray;\">summary</span><span style=\"color:gray;\">&gt;</span>\n&nbsp;&nbsp;<span style=\"color:gray;\">///</span><span style=\"color:green;\">&nbsp;</span><span style=\"color:gray;\">&lt;</span><span style=\"color:gray;\">returns</span><span style=\"color:gray;\">&gt;</span><span style=\"color:green;\">Lower&nbsp;boundary</span><span style=\"color:gray;\">&lt;/</span><span style=\"color:gray;\">returns</span><span style=\"color:gray;\">&gt;</span>\n&nbsp;&nbsp;<span style=\"color:blue;\">private</span>&nbsp;<span style=\"color:blue;\">double</span>&nbsp;Lower(&nbsp;<span style=\"color:blue;\">double</span>&nbsp;lower,&nbsp;<span style=\"color:blue;\">double</span>&nbsp;upper,\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:#2b91af;\">ICollection</span>&lt;<span style=\"color:#2b91af;\">ElementId</span>&gt;&nbsp;ids&nbsp;)\n&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:green;\">//&nbsp;If&nbsp;the&nbsp;boundaries&nbsp;are&nbsp;within&nbsp;tolerance&nbsp;return&nbsp;lower&nbsp;bound</span>\n \n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">if</span>(&nbsp;IsInTolerance(&nbsp;lower,&nbsp;upper&nbsp;)&nbsp;)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">return</span>&nbsp;lower;\n \n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:green;\">//&nbsp;Get&nbsp;the&nbsp;Midpoint&nbsp;for&nbsp;segment&nbsp;mid&nbsp;=&nbsp;lower&nbsp;+&nbsp;0.5&nbsp;*&nbsp;(upper&nbsp;-&nbsp;lower)</span>\n \n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">var</span>&nbsp;mid&nbsp;=&nbsp;Midpoint(&nbsp;lower,&nbsp;upper&nbsp;);\n \n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:green;\">//&nbsp;Сheck&nbsp;if&nbsp;the&nbsp;segment&nbsp;contains&nbsp;elements</span>\n \n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:#2b91af;\">ICollection</span>&lt;<span style=\"color:#2b91af;\">ElementId</span>&gt;&nbsp;idsFirst&nbsp;=&nbsp;IsContainsElements(&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lower,&nbsp;mid,&nbsp;ids&nbsp;);\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">bool</span>&nbsp;first&nbsp;=&nbsp;idsFirst.Any();\n \n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:green;\">//&nbsp;---*****---|-----------</span>\n \n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">if</span>(&nbsp;first&nbsp;)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">return</span>&nbsp;Lower(&nbsp;lower,&nbsp;mid,&nbsp;idsFirst&nbsp;);\n \n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:green;\">//&nbsp;-----------|-----***---</span>\n \n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">else</span>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">return</span>&nbsp;Lower(&nbsp;mid,&nbsp;upper,&nbsp;ids&nbsp;);\n&nbsp;&nbsp;}\n \n&nbsp;&nbsp;<span style=\"color:gray;\">///</span><span style=\"color:green;\">&nbsp;</span><span style=\"color:gray;\">&lt;</span><span style=\"color:gray;\">summary</span><span style=\"color:gray;\">&gt;</span>\n&nbsp;&nbsp;<span style=\"color:gray;\">///</span><span style=\"color:green;\">&nbsp;Search&nbsp;the&nbsp;upper&nbsp;boundary&nbsp;of&nbsp;a&nbsp;segment&nbsp;containing&nbsp;elements</span>\n&nbsp;&nbsp;<span style=\"color:gray;\">///</span><span style=\"color:green;\">&nbsp;</span><span style=\"color:gray;\">&lt;/</span><span style=\"color:gray;\">summary</span><span style=\"color:gray;\">&gt;</span>\n&nbsp;&nbsp;<span style=\"color:gray;\">///</span><span style=\"color:green;\">&nbsp;</span><span style=\"color:gray;\">&lt;</span><span style=\"color:gray;\">returns</span><span style=\"color:gray;\">&gt;</span><span style=\"color:green;\">Upper&nbsp;boundary</span><span style=\"color:gray;\">&lt;/</span><span style=\"color:gray;\">returns</span><span style=\"color:gray;\">&gt;</span>\n&nbsp;&nbsp;<span style=\"color:blue;\">private</span>&nbsp;<span style=\"color:blue;\">double</span>&nbsp;Upper(&nbsp;<span style=\"color:blue;\">double</span>&nbsp;lower,&nbsp;<span style=\"color:blue;\">double</span>&nbsp;upper,\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:#2b91af;\">ICollection</span>&lt;<span style=\"color:#2b91af;\">ElementId</span>&gt;&nbsp;ids&nbsp;)\n&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:green;\">//&nbsp;If&nbsp;the&nbsp;boundaries&nbsp;are&nbsp;within&nbsp;tolerance&nbsp;return&nbsp;upper&nbsp;bound</span>\n \n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">if</span>(&nbsp;IsInTolerance(&nbsp;lower,&nbsp;upper&nbsp;)&nbsp;)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">return</span>&nbsp;upper;\n \n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:green;\">//&nbsp;Get&nbsp;the&nbsp;Midpoint&nbsp;for&nbsp;segment&nbsp;mid&nbsp;=&nbsp;lower&nbsp;+&nbsp;0.5&nbsp;*&nbsp;(upper&nbsp;-&nbsp;lower)</span>\n \n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">var</span>&nbsp;mid&nbsp;=&nbsp;Midpoint(&nbsp;lower,&nbsp;upper&nbsp;);\n \n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:green;\">//&nbsp;Сheck&nbsp;if&nbsp;the&nbsp;segment&nbsp;contains&nbsp;elements</span>\n \n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:#2b91af;\">ICollection</span>&lt;<span style=\"color:#2b91af;\">ElementId</span>&gt;&nbsp;idsSecond&nbsp;=&nbsp;IsContainsElements(&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mid,&nbsp;upper,&nbsp;ids&nbsp;);\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">bool</span>&nbsp;second&nbsp;=&nbsp;idsSecond.Any();\n \n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:green;\">//&nbsp;-----------|----*****--</span>\n \n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">if</span>(&nbsp;second&nbsp;)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">return</span>&nbsp;Upper(&nbsp;mid,&nbsp;upper,&nbsp;idsSecond&nbsp;);\n \n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:green;\">//&nbsp;---*****---|-----------</span>\n \n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">else</span>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">return</span>&nbsp;Upper(&nbsp;lower,&nbsp;mid,&nbsp;ids&nbsp;);\n&nbsp;&nbsp;}\n \n&nbsp;&nbsp;<span style=\"color:blue;\">private</span>&nbsp;<span style=\"color:blue;\">double</span>&nbsp;Midpoint(&nbsp;<span style=\"color:blue;\">double</span>&nbsp;lower,&nbsp;<span style=\"color:blue;\">double</span>&nbsp;upper&nbsp;)\n&nbsp;&nbsp;&nbsp;&nbsp;=&gt;&nbsp;lower&nbsp;+&nbsp;0.5&nbsp;*&nbsp;(upper&nbsp;-&nbsp;lower);\n \n&nbsp;&nbsp;<span style=\"color:blue;\">private</span>&nbsp;<span style=\"color:blue;\">bool</span>&nbsp;IsInTolerance(&nbsp;<span style=\"color:blue;\">double</span>&nbsp;lower,&nbsp;<span style=\"color:blue;\">double</span>&nbsp;upper&nbsp;)\n&nbsp;&nbsp;&nbsp;&nbsp;=&gt;&nbsp;upper&nbsp;-&nbsp;lower&nbsp;&lt;=&nbsp;tolerance;\n}\n</pre>\n\n`Projection` is an extension method for the vector class to determine the length of projection of one vector onto another:\n\n<pre class=\"code\">\n  <span style=\"color:blue;\">public</span>&nbsp;<span style=\"color:blue;\">static</span>&nbsp;<span style=\"color:blue;\">class</span>&nbsp;<span style=\"color:#2b91af;\">PointExt</span>\n  {\n  &nbsp;&nbsp;<span style=\"color:blue;\">public</span>&nbsp;<span style=\"color:blue;\">static</span>&nbsp;<span style=\"color:blue;\">double</span>&nbsp;Projection(\n  &nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">this</span>&nbsp;<span style=\"color:#2b91af;\">XYZ</span>&nbsp;vector,&nbsp;<span style=\"color:#2b91af;\">XYZ</span>&nbsp;other&nbsp;)&nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&gt;&nbsp;vector.DotProduct(&nbsp;other&nbsp;)&nbsp;\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;other.GetLength();\n  }\n</pre>\n\nMany thanks to [Alexey Ovchinnikov](https://stackoverflow.com/users/9958255/alexey-ovchinnikov) for his impressive analysis and research and sharing this powerful and useful result."
  },
  {
    "original_filename": "1868_outline_performance",
    "header_text": "Simple Line-Plane Intersection",
    "local_header_href": "#3",
    "chunk_text": "####<a name=\"3\"></a> Simple Line-Plane Intersection\n\nTalking about geometric calculations and performance, I just took a quick look at a simple line-plane intersection algorithm this morning to answer \nthe [Revit API discussion forum](http://forums.autodesk.com/t5/revit-api-forum/bd-p/160) thread\non [how to calculate the intersection between a plane and a penetrating line](https://forums.autodesk.com/t5/revit-api-forum/how-can-we-calculate-the-intersection-between-the-plane-and-the/m-p/9785834):\n\n**Question:** I have a question about the way to calculate intersection point.\nWe have four points and their coordinates.\nLet's assume we can create plane with these points.\nWhen there is a line penetrating the plane, I guess there is an intersection point which the plane and the line meet:\n\n<center>\n<img src=\"img/line_plane_intersection.png\" alt=\"Line-plane intersection\" title=\"Line-plane intersection\" width=\"350\"/> <!-- 700 -->\n</center>\n\nHow can we calculate the coordinates of the intersection point?\n\n**Answer:** You will only need three points to uniquely define the face, so the fourth point can actually be used to verify that all four are coplanar.\n\nCalculating the intersection between a straight line and a plane is pretty easy, so the most efficient method to achieve this may possibly be to do it yourself:\n\n- [Search the Internet for 'line plane intersect'](https://duckduckgo.com/?q=line+plane+intersect)\n- [Read about line-plane intersection on Wikipedia](https://en.wikipedia.org/wiki/Line%E2%80%93plane_intersection)\n- [Watch a YouTube video explaining the concepts](https://youtu.be/_W3aVWsMp14)\n- Many algorithms in different languages to [find the intersection of a line with a plane](https://rosettacode.org/wiki/Find_the_intersection_of_a_line_with_a_plane)\n- A StackOverflow discussion on [3D line-plane intersection](https://stackoverflow.com/questions/5666222/3d-line-plane-intersection)\n\nIf you prefer to use the official Revit API, you can refer to\nthe [`Face` `Intersect` method taking a `Curve` argument](https://www.revitapidocs.com/2020/3513f5e2-a274-4f60-4d8f-78145930a9e3.htm).\n\nI do not understand why you prefer to ask this question here instead of searching for these results yourself.\n\nIt took me much longer to write them down than to find them.\n\nI even went ahead and implemented a [line-plane intersection method `LinePlaneIntersection`](https://github.com/jeremytammik/the_building_coder_samples/blob/master/BuildingCoder/BuildingCoder/Util.cs#L638-L681) for\nyou in The Building Coder samples.\n\nHere is the code:\n\n<pre class=\"code\">\n<span style=\"color:gray;\">///</span><span style=\"color:green;\">&nbsp;</span><span style=\"color:gray;\">&lt;</span><span style=\"color:gray;\">summary</span><span style=\"color:gray;\">&gt;</span>\n<span style=\"color:gray;\">///</span><span style=\"color:green;\">&nbsp;Return&nbsp;the&nbsp;3D&nbsp;intersection&nbsp;point&nbsp;between</span>\n<span style=\"color:gray;\">///</span><span style=\"color:green;\">&nbsp;a&nbsp;line&nbsp;and&nbsp;a&nbsp;plane.</span>\n<span style=\"color:gray;\">///</span><span style=\"color:green;\">&nbsp;https://forums.autodesk.com/t5/revit-api-forum/how-can-we-calculate-the-intersection-between-the-plane-and-the/m-p/9785834</span>\n<span style=\"color:gray;\">///</span><span style=\"color:green;\">&nbsp;https://stackoverflow.com/questions/5666222/3d-line-plane-intersection</span>\n<span style=\"color:gray;\">///</span><span style=\"color:green;\">&nbsp;Determine&nbsp;the&nbsp;point&nbsp;of&nbsp;intersection&nbsp;between&nbsp;</span>\n<span style=\"color:gray;\">///</span><span style=\"color:green;\">&nbsp;a&nbsp;plane&nbsp;defined&nbsp;by&nbsp;a&nbsp;point&nbsp;and&nbsp;a&nbsp;normal&nbsp;vector&nbsp;</span>\n<span style=\"color:gray;\">///</span><span style=\"color:green;\">&nbsp;and&nbsp;a&nbsp;line&nbsp;defined&nbsp;by&nbsp;a&nbsp;point&nbsp;and&nbsp;a&nbsp;direction&nbsp;vector.</span>\n<span style=\"color:gray;\">///</span><span style=\"color:green;\">&nbsp;planePoint&nbsp;-&nbsp;A&nbsp;point&nbsp;on&nbsp;the&nbsp;plane.</span>\n<span style=\"color:gray;\">///</span><span style=\"color:green;\">&nbsp;planeNormal&nbsp;-&nbsp;The&nbsp;normal&nbsp;vector&nbsp;of&nbsp;the&nbsp;plane.</span>\n<span style=\"color:gray;\">///</span><span style=\"color:green;\">&nbsp;linePoint&nbsp;-&nbsp;A&nbsp;point&nbsp;on&nbsp;the&nbsp;line.</span>\n<span style=\"color:gray;\">///</span><span style=\"color:green;\">&nbsp;lineDirection&nbsp;-&nbsp;The&nbsp;direction&nbsp;vector&nbsp;of&nbsp;the&nbsp;line.</span>\n<span style=\"color:gray;\">///</span><span style=\"color:green;\">&nbsp;lineParameter&nbsp;-&nbsp;The&nbsp;intersection&nbsp;distance&nbsp;along&nbsp;the&nbsp;line.</span>\n<span style=\"color:gray;\">///</span><span style=\"color:green;\">&nbsp;Return&nbsp;-&nbsp;The&nbsp;point&nbsp;of&nbsp;intersection&nbsp;between&nbsp;the&nbsp;</span>\n<span style=\"color:gray;\">///</span><span style=\"color:green;\">&nbsp;line&nbsp;and&nbsp;the&nbsp;plane,&nbsp;null&nbsp;if&nbsp;the&nbsp;line&nbsp;is&nbsp;parallel&nbsp;</span>\n<span style=\"color:gray;\">///</span><span style=\"color:green;\">&nbsp;to&nbsp;the&nbsp;plane.</span>\n<span style=\"color:gray;\">///</span><span style=\"color:green;\">&nbsp;</span><span style=\"color:gray;\">&lt;/</span><span style=\"color:gray;\">summary</span><span style=\"color:gray;\">&gt;</span>\n<span style=\"color:blue;\">public</span>&nbsp;<span style=\"color:blue;\">static</span>&nbsp;<span style=\"color:#2b91af;\">XYZ</span>&nbsp;LinePlaneIntersection(\n&nbsp;&nbsp;<span style=\"color:#2b91af;\">Line</span>&nbsp;line,\n&nbsp;&nbsp;<span style=\"color:#2b91af;\">Plane</span>&nbsp;plane,\n&nbsp;&nbsp;<span style=\"color:blue;\">out</span>&nbsp;<span style=\"color:blue;\">double</span>&nbsp;lineParameter&nbsp;)\n{\n&nbsp;&nbsp;<span style=\"color:#2b91af;\">XYZ</span>&nbsp;planePoint&nbsp;=&nbsp;plane.Origin;\n&nbsp;&nbsp;<span style=\"color:#2b91af;\">XYZ</span>&nbsp;planeNormal&nbsp;=&nbsp;plane.Normal;\n&nbsp;&nbsp;<span style=\"color:#2b91af;\">XYZ</span>&nbsp;linePoint&nbsp;=&nbsp;line.GetEndPoint(&nbsp;0&nbsp;);\n \n&nbsp;&nbsp;<span style=\"color:#2b91af;\">XYZ</span>&nbsp;lineDirection&nbsp;=&nbsp;(line.GetEndPoint(&nbsp;1&nbsp;)&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;linePoint).Normalize();\n \n&nbsp;&nbsp;<span style=\"color:green;\">//&nbsp;Is&nbsp;the&nbsp;line&nbsp;parallel&nbsp;to&nbsp;the&nbsp;plane,&nbsp;i.e.,</span>\n&nbsp;&nbsp;<span style=\"color:green;\">//&nbsp;perpendicular&nbsp;to&nbsp;the&nbsp;plane&nbsp;normal?</span>\n \n&nbsp;&nbsp;<span style=\"color:blue;\">if</span>(&nbsp;IsZero(&nbsp;planeNormal.DotProduct(&nbsp;lineDirection&nbsp;)&nbsp;)&nbsp;)\n&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;lineParameter&nbsp;=&nbsp;<span style=\"color:blue;\">double</span>.NaN;\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">return</span>&nbsp;<span style=\"color:blue;\">null</span>;\n&nbsp;&nbsp;}\n \n&nbsp;&nbsp;lineParameter&nbsp;=&nbsp;(planeNormal.DotProduct(&nbsp;planePoint&nbsp;)&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;planeNormal.DotProduct(&nbsp;linePoint&nbsp;))&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;planeNormal.DotProduct(&nbsp;lineDirection&nbsp;);\n \n&nbsp;&nbsp;<span style=\"color:blue;\">return</span>&nbsp;linePoint&nbsp;+&nbsp;lineParameter&nbsp;*&nbsp;lineDirection;\n}\n</pre>\n\n**Response:** Thank you for offering sample code. Actually, I intended to find the solution only with Revit Official API.\n\nAh well.\n\nBy the way, for many other high performance intersection and clipping algorithms, you may want to check\nout [Wykobi](https://www.wykobi.com), an\n\n> extremely efficient, robust and simple to use C++ 2D/3D oriented computational geometry library.\n\n<center>\n<img src=\"img/wykobi_segmentint.png\" alt=\"Wykobi segment intersection\" title=\"Wykobi segment intersection\" width=\"568\"/> <!-- 568 -->\n</center>"
  },
  {
    "original_filename": "1868_outline_performance",
    "header_text": "Set Base and Survey Clipped and Unclipped",
    "local_header_href": "#4",
    "chunk_text": "####<a name=\"4\"></a> Set Base and Survey Clipped and Unclipped\n\nAs we pointed out in the discussion on [survey and project base points](https://thebuildingcoder.typepad.com/blog/2012/11/survey-and-project-base-point.html) in 2012, *the clipped/unclipped state of the base and survey points could not be set via the API. You could pin them using the Element.Pinned property*... back then.\n\nHappily and finally, Revit 2021.1 exposed a new property `Clipped` for the base point,\ncf. [Clipped state of BasePoint](https://thebuildingcoder.typepad.com/blog/2020/08/revit-20211-sdk-and-whats-new.html#6.3.2)\nin [What's New in the Revit 2021.1 API](https://thebuildingcoder.typepad.com/blog/2020/08/revit-20211-sdk-and-whats-new.html).\n\nSo, starting from this version, you have the ability to get and set the clipped state for the Survey Point.\nFor Project Base Point, the property is read-only and will always return false, since the PBP clipped state has been removed."
  },
  {
    "original_filename": "1868_outline_performance",
    "header_text": "Two German Uni BIM360 Construction Cloud Startups",
    "local_header_href": "#5",
    "chunk_text": "####<a name=\"5\"></a> Two German Uni BIM360 Construction Cloud Startups\n\nMoving away from the Revit API to other AEC topics, two innovative BIM360 apps from German Forge developer university startups\nare now live, [says](https://twitter.com/ADSK_Construct/status/1311699100312666113)\nPhil [@contech101](https://twitter.com/contech101) Mueller, cf.\nthe [15 new integrations with Autodesk construction cloud](https://constructionblog.autodesk.com/15-integrations-autodesk-construction):\n\n- [Gamma AR](https://construction.autodesk.com/integrations/gamma-ar) &ndash; RWTH Aachen \n- [4D-Planner](https://construction.autodesk.com/integrations/4d-planner) &ndash; TU Berlin"
  },
  {
    "original_filename": "1868_outline_performance",
    "header_text": "AI-Based Face Streaming hits Mainstream",
    "local_header_href": "#6",
    "chunk_text": "####<a name=\"6\"></a> AI-Based Face Streaming hits Mainstream\n\nMoving further away from pure AEC related topics, \nAI-based face recognition and reconstruction is entering the mainstream through\nthe [Nvidia Maxine Cloud-AI Video-Streaming Platform](https://developer.nvidia.com/maxine).\n\nIt aims to drastically reduce video conferencing bandwidth requirements by transmitting only animated face keypoint data instead of the entire video keyframe information, and reconstructing the animated current presenters face based on some initial video data and the face keypoint data.\n\nCheck out the two-and-a-half-minute video on [inventing virtual meetings of tomorrow with Nvidia AI research](https://youtu.be/NqmMnjJ6GEg):\n\n<center>\n<iframe width=\"480\" height=\"270\" src=\"https://www.youtube.com/embed/NqmMnjJ6GEg\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</center>\n\n> New AI breakthroughs in NVIDIA Maxine, cloud-native video streaming AI SDK, slash bandwidth use while making it possible to re-animate faces, correct gaze and animate characters for immersive and engaging meetings."
  }
]