[
  {
    "original_filename": "0303_extension_methods",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<head>\n<link href=\"bc.css\" rel=\"stylesheet\" type=\"text/css\"/>\n</head>"
  },
  {
    "original_filename": "0303_extension_methods",
    "header_text": "GetPolygon Extension Methods",
    "local_header_href": "#getpolygon-extension-methods",
    "chunk_text": "<h3>GetPolygon Extension Methods</h3><p>Here is a question from Daren Thomas of ETH, the technical university of Zürich, that has been sitting around in my inbox for quite a while.\nDaren works in the group\n\n<a href=\"http://www.gt.arch.ethz.ch\">Professur für Gebäudetechnik, Institut für Hochbautechnik</a>.\n\nOne area of their research is detailed building energy analysis, and one piece of basic utility functionality required for this analysis are\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2009/02/boolean-operations-for-2d-polygons.html\">\nBoolean operations</a> on\n\nthe polygonal areas of rooms on different levels.\n\n<p><strong>Question:</strong> We are developing a plug-in for Revit Architecture to perform energy calculations in a building model.\nTo do so, we need to read the model with its rooms and the relationships between all their surfaces such as walls, floors, ceilings etc.\n\n<p>We are still working on establishing the relationships between the rooms on one hand and floors and roofs or ceilings on the other.\nSpecifically, we would like to determine the intersections areas on a floor of the rooms below and above it.\nYou mentioned the\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2009/02/boolean-operations-for-2d-polygons.html\">\nGeneral Polygon Clipper GPC</a> library,\n\nand that looks like a good starting point, although it does require an additional library with the associated administrative overhead and licensing complications.\n\n<p>Can we use the Revit API determine the room boundaries above and below, like we can for the walls on the sides?\n\n<p><strong>Answer:</strong> Look at the Revit SDK sample\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2008/09/roomsroofs-sdk.html\">\nRoofsRooms</a>,\n\nand the\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2009/12/crop-3d-view-to-room.html\">\nClosedShell</a> property\n\non the Room class.\n\nYou can also make use of the\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2009/10/analytical-support-tolerance.html\">\nFindReferencesByDirection</a> method.\n\nWe suggested some further ideas when looking at the related problems of\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2009/01/room-and-wall-adjacency.html\">\nroom and wall adjacency</a>,\n\ntheir\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2009/01/room-and-wall-adjacent-area.html\">\nadjacent areas</a>, and\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2009/07/space-adjacency.html\">\nspace adjacency</a>.\n\n<p><strong>Response:</strong> Currently we are following the GPC route.\nThe library is really fast.\nAccording to our profiling results, most of the time is being spent in other stuff, unrelated to the polygon clipping.\nI expect to attack the problem from the \"Revit-API-only\" angle sometime next month, when license issues get more complicated – at the moment, we need to release a version quickly for students.\nA commercial version is not planned until later.\n\n<p>I will keep you informed if we try the \"Revit-API-only\" angle and my experiences with it.\nOne point that doesn't seem clear after looking at RoofsRooms and GeomUtil.cs is how to find the intersecting area – this is something the GPC library makes very easy.\n\n<p>The basic algorithm works as follows:\n\n<pre class=\"code\">\nfor floor in document:\n  for roomAbove in rooms_with_same_level_as_floor:\n    aboveIntersection = intersect\n      floor.GetPolygon() with roomBelow.GetPolygon()\n\n    if aboveIntersection is not empty:\n      for roomBelow in rooms_with_level_just_below_floor:\n        belowIntersection = intersect\n          aboveIntersection with roomBelow.GetPolygon()\n\n        aboveIntersection = difference of\n          aboveIntersection and belowIntersection\n\n        if belowIntersection is not empty:\n          =&gt; roomAbove and roomBelow share\n            belowIntersection of floor\n\n      if aboveIntersection is not empty:\n        =&gt; roomAbove has the remaining bits of\n          aboveIntersection of floor all to itself\n</pre>\n<p>Note: this algorithm has not been optimized for performance yet, but profiling indicates so far, that it is not a bottleneck and thus negligible for the moment.\n\n<p>I'm not quite sure if the exact C# code is of interest to you, as it works on an abstract building model that is not Revit specific.\nI wouldn't mind sharing some nifty stuff with\n\n<a href=\"http://msdn.microsoft.com/en-us/library/bb383977.aspx\">\nExtension Methods</a> –\n\na new technology in C# 3.0 that I find especially useful for working with plug-in APIs, as subclassing cannot be used to add functionality to types:\n\n<pre class=\"code\">\n<span class=\"blue\">internal</span> <span class=\"blue\">static</span> <span class=\"blue\">class</span> <span class=\"teal\">RevitFloorExtensions</span>\n{\n  <span class=\"blue\">internal</span> <span class=\"blue\">static</span> <span class=\"teal\">Polygon</span> GetPolygon(\n    <span class=\"blue\">this</span> <span class=\"teal\">Floor</span> floor )\n  {\n    <span class=\"green\">// code copied from here:</span>\n    <span class=\"green\">// http://thebuildingcoder.typepad.com/blog/2009/02/</span>\n    <span class=\"green\">// boolean-operations-for-2d-polygons.html</span>\n \n    <span class=\"teal\">Options</span> geomOptions\n      = floor.Document.Application\n        .Create.NewGeometryOptions();\n \n    <span class=\"teal\">Element</span> elem = floor.get_Geometry( geomOptions );\n \n    <span class=\"blue\">var</span> vertices = <span class=\"blue\">new</span> List();\n \n    <span class=\"blue\">foreach</span>( <span class=\"blue\">var</span> obj <span class=\"blue\">in</span> elem.Objects )\n    {\n      <span class=\"blue\">var</span> solid = obj <span class=\"blue\">as</span> <span class=\"teal\">Solid</span>;\n      <span class=\"blue\">if</span>( <span class=\"blue\">null</span> != solid )\n      {\n        <span class=\"teal\">Face</span> face = solid.Faces.get_Item( 0 );\n        <span class=\"teal\">EdgeArray</span> loop = face.EdgeLoops.get_Item( 0 );\n        <span class=\"blue\">foreach</span>( <span class=\"teal\">Edge</span> edge <span class=\"blue\">in</span> loop )\n        {\n          <span class=\"teal\">XYZArray</span> edgePts = edge.Tessellate();\n          <span class=\"blue\">int</span> n = edgePts.Size;\n          <span class=\"blue\">for</span>( <span class=\"blue\">int</span> i = 0; i &lt; n - 1; ++i )\n          {\n            <span class=\"teal\">XYZ</span> p = edgePts.get_Item( i );\n            vertices.Add( <span class=\"blue\">new</span> <span class=\"teal\">Vertex</span>(\n                p.X * Constant.FeetToMeter,\n                p.Y * Constant.FeetToMeter ) );\n          }\n        }\n        <span class=\"blue\">break</span>;\n      }\n    }\n    <span class=\"blue\">var</span> vertexList = <span class=\"blue\">new</span> <span class=\"teal\">VertexList</span>{\n      NofVertices = vertices.Count,\n      Vertex = vertices.ToArray() };\n \n    <span class=\"blue\">var</span> result = <span class=\"blue\">new</span> <span class=\"teal\">Polygon</span>();\n    result.AddContour( vertexList, <span class=\"blue\">false</span> );\n    <span class=\"blue\">return</span> result;\n  }\n}\n</pre>\n<p>The above code allows me to go floor.GetPolygon() – just syntactic sugar, but practical nonetheless.\n\n<p>Here is an equivalent method for rooms:\n\n<pre class=\"code\">\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n<span class=\"gray\">///</span><span class=\"green\"> Retrieves a polygon describing the room boundaries.</span>\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n<span class=\"blue\">public</span> <span class=\"blue\">static</span> <span class=\"teal\">Polygon</span> GetPolygon( <span class=\"blue\">this</span> <span class=\"teal\">Room</span> room )\n{\n  <span class=\"blue\">var</span> result = <span class=\"blue\">new</span> <span class=\"teal\">Polygon</span>();\n  <span class=\"blue\">var</span> vertices = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">Vertex</span>&gt;();\n \n  <span class=\"blue\">foreach</span>( <span class=\"teal\">BoundarySegmentArray</span> bsa <span class=\"blue\">in</span> room.Boundary )\n  {\n    <span class=\"blue\">foreach</span>( <span class=\"teal\">BoundarySegment</span> bs <span class=\"blue\">in</span> bsa )\n    {\n      <span class=\"blue\">var</span> revitWall = bs.Element <span class=\"blue\">as</span> <span class=\"teal\">Wall</span>;\n \n      <span class=\"blue\">if</span>( revitWall == <span class=\"blue\">null</span> ) <span class=\"blue\">continue</span>; <span class=\"green\">// ignore non-walls here</span>\n \n      <span class=\"blue\">var</span> X = bs.Curve.get_EndPoint( 0 ).X\n        * Constant.FeetToMeter;\n \n      <span class=\"blue\">var</span> Y = bs.Curve.get_EndPoint( 0 ).Y\n        * Constant.FeetToMeter;\n \n      vertices.Add( <span class=\"blue\">new</span> <span class=\"teal\">Vertex</span>( X, Y ) );\n    }\n    <span class=\"blue\">var</span> vertexList = <span class=\"blue\">new</span> <span class=\"teal\">VertexList</span>\n    {\n      NofVertices = vertices.Count,\n      Vertex = vertices.ToArray()\n    };\n    result.AddContour( vertexList, <span class=\"blue\">false</span> );\n  }\n  <span class=\"blue\">return</span> result;\n}\n</pre>\n<p>Using these, reading the area of a polygon intersection can be done like this:\n\n<pre class=\"code\">\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n<span class=\"gray\">///</span><span class=\"green\"> Calculates the area of a polygon. See:</span>\n<span class=\"gray\">///</span><span class=\"green\"> http://mathworld.wolfram.com/PolygonArea.html</span>\n<span class=\"gray\">///</span><span class=\"green\"> A GpcWrapper polygon is made up of one or more </span>\n<span class=\"gray\">///</span><span class=\"green\"> contours.</span>\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n<span class=\"blue\">internal</span> <span class=\"blue\">static</span> <span class=\"blue\">double</span> CalculateArea(\n  <span class=\"blue\">this</span> <span class=\"teal\">Polygon</span> polygon )\n{\n  <span class=\"blue\">double</span> area = 0.0;\n  <span class=\"blue\">for</span>( <span class=\"blue\">int</span> i = 0; i &lt; polygon.NofContours; ++i )\n  {\n    <span class=\"blue\">if</span>( polygon.ContourIsHole[i] )\n    {\n      area -= <span class=\"teal\">Math</span>.Abs(\n        polygon.Contour[i].CalculateArea() );\n    }\n    <span class=\"blue\">else</span>\n    {\n      area += <span class=\"teal\">Math</span>.Abs(\n        polygon.Contour[i].CalculateArea() );\n    }\n  }\n  <span class=\"blue\">return</span> area;\n}\n \n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n<span class=\"gray\">///</span><span class=\"green\"> Calculates the area of a polygon. See:</span>\n<span class=\"gray\">///</span><span class=\"green\"> http://mathworld.wolfram.com/PolygonArea.html</span>\n<span class=\"gray\">///</span><span class=\"green\"> A GpcWrapper contour is what would generally </span>\n<span class=\"gray\">///</span><span class=\"green\"> be called a polygon.</span>\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n<span class=\"blue\">internal</span> <span class=\"blue\">static</span> <span class=\"blue\">double</span> CalculateArea(\n  <span class=\"blue\">this</span> <span class=\"teal\">VertexList</span> contour )\n{\n  <span class=\"blue\">double</span> accumulator = 0.0;\n  <span class=\"blue\">for</span>( <span class=\"blue\">int</span> i = 0; i &lt; contour.NofVertices; i++ )\n  {\n    <span class=\"blue\">double</span> x1 = contour.Vertex[i].X;\n \n    <span class=\"blue\">double</span> x2 = contour.Vertex[( i + 1 )\n      % contour.NofVertices].X; <span class=\"green\">// wrap around</span>\n \n    <span class=\"blue\">double</span> y1 = contour.Vertex[i].Y;\n \n    <span class=\"blue\">double</span> y2 = contour.Vertex[( i + 1 )\n      % contour.NofVertices].Y; <span class=\"green\">// wrap around</span>\n \n    accumulator += x1 * y2;\n    accumulator -= x2 * y1;\n  }\n  <span class=\"blue\">return</span> accumulator / 2;\n}\n</pre>\n<p>This allows me to perform operations like the ones required in the pseudocode listed above, such as 'belowIntersection.CalculateArea()' – it is especially this functionality that I believe will be rather tricky to implement in the pure Revit API.\n\n<h4>Holidays</h4>\n<p>I am going on vacation to Andalusia tomorrow for the next ten days, so I will probably not be posting any more until March.\nI wish you all a wonderful time and hope that you will have many pleasant, exciting and illuminating Revit API adventures while I take some time off from them.\n</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p>"
  },
  {
    "original_filename": "0303_extension_methods",
    "header_text": "Holidays",
    "local_header_href": "#holidays",
    "chunk_text": "<h4>Holidays</h4><p>I am going on vacation to Andalusia tomorrow for the next ten days, so I will probably not be posting any more until March.\nI wish you all a wonderful time and hope that you will have many pleasant, exciting and illuminating Revit API adventures while I take some time off from them.\n</p>"
  }
]