[
  {
    "original_filename": "1291_thin_lines_app",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<head>\n<meta content=\"text/html; charset=utf-8\" http-equiv=\"Content-Type\"/>\n<link href=\"bc.css\" rel=\"stylesheet\" type=\"text/css\"/>\n</head>"
  },
  {
    "original_filename": "1291_thin_lines_app",
    "header_text": "Thin Lines Add-in Using UI Automation",
    "local_header_href": "#thin-lines-add-in-using-ui-automation",
    "chunk_text": "<h3>Thin Lines Add-in Using UI Automation</h3><p>Revit add-in developers have repeatedly requested access to the Thin Lines setting provided in the Revit user interface, leading to\n\n<a href=\"http://forums.autodesk.com/t5/revit-api/bd-p/160\">Revit API discussion forum</a> threads on\n\n<a href=\"http://forums.autodesk.com/t5/revit-api/view-thin-lines/m-p/2641406\">view thin lines</a>,\n\n<a href=\"http://forums.autodesk.com/t5/revit-api/exported-image-line-weight-thin-line-and-rendering-setting/m-p/5528318\">\nexported image line weight (thin line) and rendering setting</a> and\n\na Revit API wish list item CF-192 – <i>As an add-in developer, I need the API ability to detect and modify the \"Thin lines\" setting, so that the user can automatically get the environment configured in the way they like</i>.\n\n<p>Happily, that wish list item has now been closed off, since this functionality is provided in Revit 2015 R2, as described in the\n\n<a href=\"http://help.autodesk.com/view/RVT/2015/ENU/?guid=GUID-6084E92F-4C46-4047-B98C-2984E730A53D\">\nWhat's New in Revit 2015 R2 overview</a> section on\n\n<a href=\"http://help.autodesk.com/view/RVT/2015/ENU/?guid=GUID-9D26B850-026A-4734-BB76-997154ADE5F2\">\nGraphics Settings in Revit.ini</a>:</p>\n<a name=\"2\"></a>\n<h4>New in Revit 2015 R2</h4>\n<h5>Architectural Enhancements</h5>\n<ul>\n<li><b>Thin lines:</b> To improve consistency between Revit sessions, when you use the Thin Lines tool, the setting is stored in the Revit.ini file. When you launch Revit, the stored Thin Lines setting is used as the default. See Graphics Settings in Revit.ini.</li>\n</ul>\n<a name=\"3\"></a>\n<h4>Graphics Settings in Revit.ini</h4>\n<h5>ThinLinesEnabled</h5>\n<p>Stores the Thin Lines setting.</p>\n<ul>\n<li>Type = integer</li>\n<li>Valid values: 1 = enable thin lines (default), 0 = disable thin lines</li>\n</ul>\n<p>Note: This feature or functionality is available only to students and to Autodesk Maintenance and Desktop Subscription customers for Revit 2015 software releases.</p>\n<p>Better still, the thin lines setting provided in the INI file from Revit 2015 R2 onwards is also programmatically accessible:</p>\n<a name=\"4\"></a>\n<h4>Revit API Thin Lines Options</h4>\n<p>The utility class ThinLinesOptions contains settings related to the Thin Lines options displayed in the UI.</p>\n<p>The static property:</p>\n<ul><li>ThinLinesOptions.AreThinLinesEnabled</li></ul>\n<p>defines if the 'Thin Lines' setting is on or off in this session.</p>\n<a name=\"5\"></a>\n<h4>Separate APIs for Revit 2015 and Revit 2015 R2</h4>\n<p>One little problem remains for the moment: what to do if I do not have Revit 2015 R2 installed?</p>\n<p>Or even more relevant: how can I avoid the need to support separate versions of my add-in for Revit 2015 and Revit 2015 R2?</p>\n<p>This issue already came up in these discussion forum threads:</p>\n<ul>\n<li><a href=\"http://forums.autodesk.com/t5/revit-api/r2-vs-ur4/m-p/5382029\">R2 vs. UR4</a></li>\n<li><a href=\"http://forums.autodesk.com/t5/revit-api/worksets/m-p/5360275\">Workset API</a></li>\n</ul>\n<a name=\"6\"></a>\n<h4>ThinLines Add-in – UI Automation Workaround For Pre-R2 Usage</h4>\n<p>Once again, the cavalry comes to the rescue in the shape of\n\n<a href=\"http://forums.autodesk.com/t5/user/viewprofilepage/user-id/1103138\">Revitalizer</a>, aka\n\nRudolf Honke of <a href=\"http://www.acadgraph.de\">Mensch und Maschine acadGraph</a>,\n\nwho already contributed lots of tricks towards making use of the\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/automation\">\n.NET UI Automation library</a> to\n\nhack the Revit user interface.</p>\n<p>He uses UI Automation to determine the current state of the thin lines button, and PostCommand to invoke the built-in Revit Thin Lines command in case the current setting needs to be changed.</p>\n<p>Please note, as always,\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/about-the-author.html#4\">The Building Coder Disclaimer</a>:\n\nin the following, we present a workaround solution not covered by the officially supported Revit API, leading to an experimental implementation suitable only for a personal controlled usage that should not be relied upon for production use.</p>\n<a name=\"7\"></a>\n<h4>Implementation History and Ideas</h4>\n<p><strong>Rudolf says:</strong>\n\nAs usual, I think UIAutomation can be used to achieve that.</p>\n<p>I can get the TL state by reading the button’s state, but when I try to set it by invoking that button, it won’t work since I’m still on the button that invokes my own command.</p>\n<p>Cannot focus another button at the same time.</p>\n<p>Perhaps you could delay the execution of pressing the button by putting it into an Idling event handler.</p>\n<p>Hey, I see that there is a 'PostableCommand.ThinLines'</p>\n<p>So what about:</p>\n<pre>\n        <span class=\"teal\">RevitCommandId</span> commandId\n          = <span class=\"teal\">RevitCommandId</span>.LookupPostableCommandId(\n            <span class=\"teal\">PostableCommand</span>.ThinLines );\n \n        <span class=\"blue\">if</span>( app.CanPostCommand( commandId ) )\n        {\n          app.PostCommand( commandId );\n        }\n</pre>\n<p><strong>Rudolf says:</strong>\n\nAs far as I can see, the getter method works as expected.</p>\n<p>I think it would be useful to provide an add-in solution that shows how to reference the automation libraries etc.</p>\n<p><strong>Rudolf says:</strong>\n\nSetting the TL using the PostableCommand works very well!</p>\n<p>I will combine the getter and setter methods and send you a VS solution.</p>\n<p><strong>Rudolf says:</strong>\n\nHere is a VS project that addresses the ThinLines issues.</p>\n<p>There is a LineTools Tab containing these three buttons, which in fact just get the state of the TL button.</p>\n<!--\n<center>\n<img src=\"img/ThinLinesApp.png\" alt=\"ThinLines add-in\" width=\"508\"/>\n</center>\n-->\n<center>\n<img alt=\"ThinLines add-in\" src=\"img/ThinLinesApp2.png\" width=\"424\"/>\n</center>\n<p>A creative workaround to avoid the Revit API restrictions ('subscription API extensions only').</p>\n<p>Two remarks:</p>\n<ul>\n<li>It has to be tested if this will still work if the TL button is removed from Quick Access Toolbar.</li>\n<li>Also, I faced an exception saying 'command cannot be invoked several times' or so when clicking the buttons too fast.</li>\n</ul>\n<p>Too fast for Revit.</p>\n<p>Perhaps that could be encapsulated in a try/catch handler.</p>\n<a name=\"8\"></a>\n<h4>Implementation Notes and Download</h4>\n<p>The command ribbon button images are encapsulated in a proper resource file:</p>\n<center>\n<img alt=\"ThinLines add-in Visual Studio solution\" src=\"img/ThinLinesVs.png\" width=\"246\"/>\n</center>\n<p>We obviously need references to the various UI Automation libraries:</p>\n<center>\n<img alt=\"ThinLines add-in Visual Studio solution references\" src=\"img/ThinLinesReferences.png\" width=\"263\"/>\n</center>\n<p>All three external command implementations for thin lines, thick lines and to toggle line thickness are trivial one-liners, since they simply call back to the functionality and helper functions defined by the main external application class:</p>\n<pre class=\"code\">\n<span class=\"blue\">using</span> Autodesk.Revit.UI;\n \n<span class=\"blue\">namespace</span> ThinLines\n{\n  [Autodesk.Revit.Attributes.<span class=\"teal\">Transaction</span>(\n    Autodesk.Revit.Attributes.<span class=\"teal\">TransactionMode</span>.ReadOnly )]\n  [Autodesk.Revit.Attributes.<span class=\"teal\">Regeneration</span>(\n    Autodesk.Revit.Attributes.<span class=\"teal\">RegenerationOption</span>.Manual )]\n  <span class=\"blue\">public</span> <span class=\"blue\">class</span> <span class=\"teal\">Command_ThinLines</span> : <span class=\"teal\">IExternalCommand</span>\n  {\n    <span class=\"blue\">public</span> <span class=\"teal\">Result</span> Execute(\n      <span class=\"teal\">ExternalCommandData</span> commandData,\n      <span class=\"blue\">ref</span> <span class=\"blue\">string</span> message,\n      Autodesk.Revit.DB.<span class=\"teal\">ElementSet</span> elements )\n    {\n      <span class=\"teal\">ThinLinesApp</span>.SetThinLines( commandData.Application, <span class=\"blue\">true</span> );\n      <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Succeeded;\n    }\n  }\n}\n</pre>\n<p>The external application implementation demonstrates how to:</p>\n<ul>\n<li>Set up the custom ribbon panel</li>\n<li>Handle the external command ribbon button images</li>\n<li>Use P/Invoke to access and make use of the Windows API functionality defined in User32.dll to find and enumerate specific windows</li>\n<li>Use the Revit API PostCommand method to invoke the built-in Thin Lines command</li>\n<li>Access the Revit Thin Lines button and determine its current state</li>\n</ul>\n<p>Sounds cool?</p>\n<p>It is!</p>\n<p>Here is how:</p>\n<pre class=\"code\">\n<span class=\"blue\">using</span> Autodesk.Revit.UI;\n<span class=\"blue\">using</span> System;\n<span class=\"blue\">using</span> System.Collections.Generic;\n<span class=\"blue\">using</span> System.Drawing;\n<span class=\"blue\">using</span> System.Runtime.InteropServices;\n<span class=\"blue\">using</span> System.Windows;\n<span class=\"blue\">using</span> System.Windows.Automation;\n<span class=\"blue\">using</span> System.Windows.Interop;\n<span class=\"blue\">using</span> System.Windows.Media;\n<span class=\"blue\">using</span> System.Windows.Media.Imaging;\n \n<span class=\"blue\">namespace</span> ThinLines\n{\n  <span class=\"blue\">public</span> <span class=\"blue\">class</span> <span class=\"teal\">ThinLinesApp</span> : <span class=\"teal\">IExternalApplication</span>\n  {\n<span class=\"blue\">    #region</span> Windows API, get from pinvoke.net\n \n    [<span class=\"teal\">DllImport</span>( <span class=\"maroon\">\"user32.dll\"</span>, SetLastError = <span class=\"blue\">true</span> )]\n    <span class=\"blue\">static</span> <span class=\"blue\">extern</span> <span class=\"teal\">IntPtr</span> FindWindowEx(\n      <span class=\"teal\">IntPtr</span> hwndParent, <span class=\"teal\">IntPtr</span> hwndChildAfter,\n      <span class=\"blue\">string</span> lpszClass, <span class=\"blue\">string</span> lpszWindow );\n \n    [<span class=\"teal\">DllImport</span>( <span class=\"maroon\">\"user32.dll\"</span> )]\n    [<span class=\"blue\">return</span>: <span class=\"teal\">MarshalAs</span>( <span class=\"teal\">UnmanagedType</span>.Bool )]\n    <span class=\"blue\">public</span> <span class=\"blue\">static</span> <span class=\"blue\">extern</span> <span class=\"blue\">bool</span> EnumChildWindows(\n      <span class=\"teal\">IntPtr</span> window, <span class=\"teal\">EnumWindowProc</span> callback,\n      <span class=\"teal\">IntPtr</span> i );\n \n    <span class=\"blue\">public</span> <span class=\"blue\">delegate</span> <span class=\"blue\">bool</span> <span class=\"teal\">EnumWindowProc</span>(\n      <span class=\"teal\">IntPtr</span> hWnd, <span class=\"teal\">IntPtr</span> parameter );\n \n    <span class=\"blue\">public</span> <span class=\"blue\">static</span> <span class=\"blue\">bool</span> EnumWindow(\n      <span class=\"teal\">IntPtr</span> handle,\n      <span class=\"teal\">IntPtr</span> pointer )\n    {\n      <span class=\"teal\">GCHandle</span> gch = <span class=\"teal\">GCHandle</span>.FromIntPtr( pointer );\n      <span class=\"teal\">List</span>&lt;<span class=\"teal\">IntPtr</span>&gt; list = gch.Target <span class=\"blue\">as</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">IntPtr</span>&gt;;\n      <span class=\"blue\">if</span>( list != <span class=\"blue\">null</span> )\n      {\n        list.Add( handle );\n      }\n      <span class=\"blue\">return</span> <span class=\"blue\">true</span>;\n    }\n \n    <span class=\"blue\">public</span> <span class=\"blue\">static</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">IntPtr</span>&gt; GetChildWindows(\n      <span class=\"teal\">IntPtr</span> parent )\n    {\n      <span class=\"teal\">List</span>&lt;<span class=\"teal\">IntPtr</span>&gt; result = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">IntPtr</span>&gt;();\n      <span class=\"teal\">GCHandle</span> listHandle = <span class=\"teal\">GCHandle</span>.Alloc( result );\n      <span class=\"blue\">try</span>\n      {\n        <span class=\"teal\">EnumWindowProc</span> childProc = <span class=\"blue\">new</span> <span class=\"teal\">EnumWindowProc</span>(\n          EnumWindow );\n \n        EnumChildWindows( parent, childProc,\n          <span class=\"teal\">GCHandle</span>.ToIntPtr( listHandle ) );\n      }\n      <span class=\"blue\">finally</span>\n      {\n        <span class=\"blue\">if</span>( listHandle.IsAllocated )\n          listHandle.Free();\n      }\n      <span class=\"blue\">return</span> result;\n    }\n<span class=\"blue\">    #endregion</span>\n \n    <span class=\"blue\">public</span> <span class=\"teal\">Result</span> OnShutdown( <span class=\"teal\">UIControlledApplication</span> a )\n    {\n      <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Succeeded;\n    }\n \n    <span class=\"blue\">public</span> <span class=\"teal\">Result</span> OnStartup( <span class=\"teal\">UIControlledApplication</span> a )\n    {\n      <span class=\"blue\">string</span> tabName = <span class=\"maroon\">\"LineTools\"</span>;\n      <span class=\"blue\">string</span> panelName = <span class=\"maroon\">\"LineTools\"</span>;\n      <span class=\"blue\">string</span> buttonThinName = <span class=\"maroon\">\"Thin\"</span>;\n      <span class=\"blue\">string</span> buttonThickName = <span class=\"maroon\">\"Thick\"</span>;\n      <span class=\"blue\">string</span> buttonToggleName = <span class=\"maroon\">\"Toggle\"</span>;\n \n      <span class=\"blue\">try</span>\n      {\n        <span class=\"teal\">List</span>&lt;<span class=\"teal\">RibbonPanel</span>&gt; panels = a.GetRibbonPanels(\n          tabName );\n      }\n      <span class=\"blue\">catch</span>\n      {\n        a.CreateRibbonTab( tabName );\n      }\n \n      <span class=\"teal\">RibbonPanel</span> panelViewExport = a.CreateRibbonPanel(\n        tabName, panelName );\n \n      panelViewExport.Name = panelName;\n      panelViewExport.Title = panelName;\n \n      <span class=\"teal\">PushButtonData</span> buttonThin = <span class=\"blue\">new</span> <span class=\"teal\">PushButtonData</span>(\n        buttonThinName, buttonThinName,\n        System.Reflection.<span class=\"teal\">Assembly</span>.GetExecutingAssembly().Location,\n        <span class=\"blue\">typeof</span>( <span class=\"teal\">Command_ThinLines</span> ).FullName );\n \n      buttonThin.ToolTip = buttonThinName;\n      <span class=\"teal\">ImageSource</span> iconThin = GetIconSource( <span class=\"teal\">Images</span>.Thin );\n      buttonThin.LargeImage = iconThin;\n      buttonThin.Image = Thumbnail( iconThin );\n      panelViewExport.AddItem( buttonThin );\n \n      <span class=\"teal\">PushButtonData</span> buttonThick = <span class=\"blue\">new</span> <span class=\"teal\">PushButtonData</span>(\n        buttonThickName, buttonThickName,\n        System.Reflection.<span class=\"teal\">Assembly</span>.GetExecutingAssembly().Location,\n        <span class=\"blue\">typeof</span>( <span class=\"teal\">Command_ThickLines</span> ).FullName );\n \n      buttonThick.ToolTip = buttonThickName;\n      <span class=\"teal\">ImageSource</span> iconThick = GetIconSource( <span class=\"teal\">Images</span>.Thick );\n      buttonThick.LargeImage = iconThick;\n      buttonThick.Image = Thumbnail( iconThick );\n      panelViewExport.AddItem( buttonThick );\n \n      <span class=\"teal\">PushButtonData</span> buttonToggle = <span class=\"blue\">new</span> <span class=\"teal\">PushButtonData</span>(\n        buttonToggleName, buttonToggleName,\n        System.Reflection.<span class=\"teal\">Assembly</span>.GetExecutingAssembly().Location,\n        <span class=\"blue\">typeof</span>( <span class=\"teal\">Command_ToggleLineThickness</span> ).FullName );\n \n      buttonToggle.ToolTip = buttonToggleName;\n      <span class=\"teal\">ImageSource</span> iconToggle = GetIconSource( <span class=\"teal\">Images</span>.ToggleLineThickness );\n      buttonToggle.LargeImage = iconToggle;\n      buttonToggle.Image = Thumbnail( iconToggle );\n      panelViewExport.AddItem( buttonToggle );\n \n      <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Succeeded;\n    }\n \n    <span class=\"blue\">public</span> <span class=\"blue\">static</span> <span class=\"teal\">ImageSource</span> GetIconSource( <span class=\"teal\">Bitmap</span> bmp )\n    {\n      <span class=\"teal\">BitmapSource</span> icon\n        = <span class=\"teal\">Imaging</span>.CreateBitmapSourceFromHBitmap(\n        bmp.GetHbitmap(), <span class=\"teal\">IntPtr</span>.Zero, <span class=\"teal\">Int32Rect</span>.Empty,\n        System.Windows.Media.Imaging.<span class=\"teal\">BitmapSizeOptions</span>.FromEmptyOptions() );\n \n      <span class=\"blue\">return</span> (System.Windows.Media.<span class=\"teal\">ImageSource</span>) icon;\n    }\n \n    <span class=\"blue\">public</span> <span class=\"blue\">static</span> <span class=\"teal\">ImageSource</span> Thumbnail(\n      <span class=\"teal\">ImageSource</span> source )\n    {\n      <span class=\"teal\">Rect</span> rect = <span class=\"blue\">new</span> <span class=\"teal\">Rect</span>( 0, 0, 16, 16 );\n      <span class=\"teal\">DrawingVisual</span> drawingVisual = <span class=\"blue\">new</span> <span class=\"teal\">DrawingVisual</span>();\n \n      <span class=\"blue\">using</span>( <span class=\"teal\">DrawingContext</span> drawingContext\n        = drawingVisual.RenderOpen() )\n      {\n        drawingContext.DrawImage( source, rect );\n      }\n \n      <span class=\"teal\">RenderTargetBitmap</span> resizedImage\n        = <span class=\"blue\">new</span> <span class=\"teal\">RenderTargetBitmap</span>(\n          (<span class=\"blue\">int</span>) rect.Width, (<span class=\"blue\">int</span>) rect.Height, 96, 96,\n          <span class=\"teal\">PixelFormats</span>.Default );\n \n      resizedImage.Render( drawingVisual );\n \n      <span class=\"blue\">return</span> resizedImage;\n    }\n \n    <span class=\"blue\">public</span> <span class=\"blue\">static</span> <span class=\"teal\">AutomationElement</span> GetThinLinesButton()\n    {\n      <span class=\"teal\">IntPtr</span> revitHandle\n        = System.Diagnostics.<span class=\"teal\">Process</span>.GetCurrentProcess()\n          .MainWindowHandle;\n \n      <span class=\"teal\">IntPtr</span> outerToolFrame = FindWindowEx( revitHandle,\n        <span class=\"teal\">IntPtr</span>.Zero, <span class=\"maroon\">\"AdImpApplicationFrame\"</span>,\n        <span class=\"maroon\">\"AdImpApplicationFrame\"</span> );\n \n      <span class=\"teal\">IntPtr</span> innerToolFrame = GetChildWindows(\n        outerToolFrame )[0];\n \n      <span class=\"teal\">AutomationElement</span> innerToolFrameElement\n        = <span class=\"teal\">AutomationElement</span>.FromHandle( innerToolFrame );\n \n      <span class=\"teal\">PropertyCondition</span> typeRibbonCondition\n        = <span class=\"blue\">new</span> <span class=\"teal\">PropertyCondition</span>(\n          <span class=\"teal\">AutomationElement</span>.ControlTypeProperty,\n          <span class=\"teal\">ControlType</span>.Custom );\n \n      <span class=\"teal\">AutomationElement</span> lowestPanel\n        = innerToolFrameElement.FindFirst(\n          <span class=\"teal\">TreeScope</span>.Children, typeRibbonCondition );\n \n      <span class=\"teal\">PropertyCondition</span> nameRibbonCondition\n        = <span class=\"blue\">new</span> <span class=\"teal\">PropertyCondition</span>(\n          <span class=\"teal\">AutomationElement</span>.AutomationIdProperty,\n          <span class=\"maroon\">\"ID_THIN_LINES_RibbonItemControl\"</span> );\n \n      <span class=\"teal\">AndCondition</span> andCondition = <span class=\"blue\">new</span> <span class=\"teal\">AndCondition</span>(\n        typeRibbonCondition, nameRibbonCondition );\n \n      <span class=\"teal\">AutomationElement</span> buttonContainer\n        = lowestPanel.FindFirst( <span class=\"teal\">TreeScope</span>.Children,\n          andCondition );\n \n      <span class=\"teal\">PropertyCondition</span> typeButtonCondition\n        = <span class=\"blue\">new</span> <span class=\"teal\">PropertyCondition</span>(\n          <span class=\"teal\">AutomationElement</span>.ControlTypeProperty,\n          <span class=\"teal\">ControlType</span>.Button );\n \n      <span class=\"teal\">PropertyCondition</span> nameButtonCondition\n        = <span class=\"blue\">new</span> <span class=\"teal\">PropertyCondition</span>(\n          <span class=\"teal\">AutomationElement</span>.AutomationIdProperty,\n          <span class=\"maroon\">\"ID_THIN_LINES\"</span> );\n \n      <span class=\"teal\">AndCondition</span> andConditionButton = <span class=\"blue\">new</span> <span class=\"teal\">AndCondition</span>(\n        typeButtonCondition, nameButtonCondition );\n \n      <span class=\"teal\">AutomationElement</span> button = buttonContainer.FindFirst(\n        <span class=\"teal\">TreeScope</span>.Children, andConditionButton );\n \n      <span class=\"blue\">return</span> button;\n    }\n \n    <span class=\"blue\">public</span> <span class=\"blue\">static</span> <span class=\"blue\">void</span> SetThinLines(\n      <span class=\"teal\">UIApplication</span> app,\n      <span class=\"blue\">bool</span> makeThin )\n    {\n      <span class=\"blue\">bool</span> isAlreadyThin = IsThinLines();\n \n      <span class=\"blue\">if</span>( makeThin != isAlreadyThin )\n      {\n        <span class=\"green\">// Switch TL state by invoking </span>\n        <span class=\"green\">// PostableCommand.ThinLines</span>\n \n        <span class=\"teal\">RevitCommandId</span> commandId\n          = <span class=\"teal\">RevitCommandId</span>.LookupPostableCommandId(\n            <span class=\"teal\">PostableCommand</span>.ThinLines );\n \n        <span class=\"blue\">if</span>( app.CanPostCommand( commandId ) )\n        {\n          app.PostCommand( commandId );\n        }\n      }\n    }\n \n    <span class=\"blue\">public</span> <span class=\"blue\">static</span> <span class=\"blue\">bool</span> IsThinLines()\n    {\n      <span class=\"teal\">AutomationElement</span> button = GetThinLinesButton();\n \n      <span class=\"teal\">TogglePattern</span> togglePattern\n        = button.GetCurrentPattern(\n          <span class=\"teal\">TogglePattern</span>.Pattern ) <span class=\"blue\">as</span> <span class=\"teal\">TogglePattern</span>;\n \n      <span class=\"blue\">string</span> state = togglePattern.Current\n        .ToggleState.ToString().ToUpper();\n \n      <span class=\"blue\">return</span> ( state == <span class=\"maroon\">\"ON\"</span> );\n    }\n  }\n}\n</pre>\n<p>The complete source code, Visual Studio solution and add-in manifest are provided in the\n\n<a href=\"https://github.com/jeremytammik/ThinLines\">\nThinLines GitHub repository</a>,\n\nand the version described here is\n\n<a href=\"https://github.com/jeremytammik/ThinLines/releases/tag/2015.0.0.1\">\nrelease 2015.0.0.1</a>.</p>\n<p>As said, please be aware of\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/about-the-author.html#4\">The Building Coder Disclaimer</a> before\n\nyou even dream of making use of this.</p>\n<p>Many thanks to Rudi for his research and nice, clean implementation!</p></p>"
  },
  {
    "original_filename": "1291_thin_lines_app",
    "header_text": "New in Revit 2015 R2",
    "local_header_href": "#new-in-revit-2015-r2",
    "chunk_text": "<h4>New in Revit 2015 R2</h4>"
  },
  {
    "original_filename": "1291_thin_lines_app",
    "header_text": "Architectural Enhancements",
    "local_header_href": "#architectural-enhancements",
    "chunk_text": "<h5>Architectural Enhancements</h5><ul>\n<li><b>Thin lines:</b> To improve consistency between Revit sessions, when you use the Thin Lines tool, the setting is stored in the Revit.ini file. When you launch Revit, the stored Thin Lines setting is used as the default. See Graphics Settings in Revit.ini.</li>\n</ul><a name=\"3\"></a>"
  },
  {
    "original_filename": "1291_thin_lines_app",
    "header_text": "Graphics Settings in Revit.ini",
    "local_header_href": "#graphics-settings-in-revitini",
    "chunk_text": "<h4>Graphics Settings in Revit.ini</h4>"
  },
  {
    "original_filename": "1291_thin_lines_app",
    "header_text": "ThinLinesEnabled",
    "local_header_href": "#thinlinesenabled",
    "chunk_text": "<h5>ThinLinesEnabled</h5><p>Stores the Thin Lines setting.</p><ul>\n<li>Type = integer</li>\n<li>Valid values: 1 = enable thin lines (default), 0 = disable thin lines</li>\n</ul><p>Note: This feature or functionality is available only to students and to Autodesk Maintenance and Desktop Subscription customers for Revit 2015 software releases.</p><p>Better still, the thin lines setting provided in the INI file from Revit 2015 R2 onwards is also programmatically accessible:</p><a name=\"4\"></a>"
  },
  {
    "original_filename": "1291_thin_lines_app",
    "header_text": "Revit API Thin Lines Options",
    "local_header_href": "#revit-api-thin-lines-options",
    "chunk_text": "<h4>Revit API Thin Lines Options</h4><p>The utility class ThinLinesOptions contains settings related to the Thin Lines options displayed in the UI.</p><p>The static property:</p><ul><li>ThinLinesOptions.AreThinLinesEnabled</li></ul><p>defines if the 'Thin Lines' setting is on or off in this session.</p><a name=\"5\"></a>"
  },
  {
    "original_filename": "1291_thin_lines_app",
    "header_text": "Separate APIs for Revit 2015 and Revit 2015 R2",
    "local_header_href": "#separate-apis-for-revit-2015-and-revit-2015-r2",
    "chunk_text": "<h4>Separate APIs for Revit 2015 and Revit 2015 R2</h4><p>One little problem remains for the moment: what to do if I do not have Revit 2015 R2 installed?</p><p>Or even more relevant: how can I avoid the need to support separate versions of my add-in for Revit 2015 and Revit 2015 R2?</p><p>This issue already came up in these discussion forum threads:</p><ul>\n<li><a href=\"http://forums.autodesk.com/t5/revit-api/r2-vs-ur4/m-p/5382029\">R2 vs. UR4</a></li>\n<li><a href=\"http://forums.autodesk.com/t5/revit-api/worksets/m-p/5360275\">Workset API</a></li>\n</ul><a name=\"6\"></a>"
  },
  {
    "original_filename": "1291_thin_lines_app",
    "header_text": "ThinLines Add-in – UI Automation Workaround For Pre-R2 Usage",
    "local_header_href": "#thinlines-add-in-ui-automation-workaround-for-pre-r2-usage",
    "chunk_text": "<h4>ThinLines Add-in – UI Automation Workaround For Pre-R2 Usage</h4><p>Once again, the cavalry comes to the rescue in the shape of\n\n<a href=\"http://forums.autodesk.com/t5/user/viewprofilepage/user-id/1103138\">Revitalizer</a>, aka\n\nRudolf Honke of <a href=\"http://www.acadgraph.de\">Mensch und Maschine acadGraph</a>,\n\nwho already contributed lots of tricks towards making use of the\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/automation\">\n.NET UI Automation library</a> to\n\nhack the Revit user interface.</p><p>He uses UI Automation to determine the current state of the thin lines button, and PostCommand to invoke the built-in Revit Thin Lines command in case the current setting needs to be changed.</p><p>Please note, as always,\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/about-the-author.html#4\">The Building Coder Disclaimer</a>:\n\nin the following, we present a workaround solution not covered by the officially supported Revit API, leading to an experimental implementation suitable only for a personal controlled usage that should not be relied upon for production use.</p><a name=\"7\"></a>"
  },
  {
    "original_filename": "1291_thin_lines_app",
    "header_text": "Implementation History and Ideas",
    "local_header_href": "#implementation-history-and-ideas",
    "chunk_text": "<h4>Implementation History and Ideas</h4><p><strong>Rudolf says:</strong>\n\nAs usual, I think UIAutomation can be used to achieve that.</p><p>I can get the TL state by reading the button’s state, but when I try to set it by invoking that button, it won’t work since I’m still on the button that invokes my own command.</p><p>Cannot focus another button at the same time.</p><p>Perhaps you could delay the execution of pressing the button by putting it into an Idling event handler.</p><p>Hey, I see that there is a 'PostableCommand.ThinLines'</p><p>So what about:</p><pre>\n        <span class=\"teal\">RevitCommandId</span> commandId\n          = <span class=\"teal\">RevitCommandId</span>.LookupPostableCommandId(\n            <span class=\"teal\">PostableCommand</span>.ThinLines );\n \n        <span class=\"blue\">if</span>( app.CanPostCommand( commandId ) )\n        {\n          app.PostCommand( commandId );\n        }\n</pre><p><strong>Rudolf says:</strong>\n\nAs far as I can see, the getter method works as expected.</p><p>I think it would be useful to provide an add-in solution that shows how to reference the automation libraries etc.</p><p><strong>Rudolf says:</strong>\n\nSetting the TL using the PostableCommand works very well!</p><p>I will combine the getter and setter methods and send you a VS solution.</p><p><strong>Rudolf says:</strong>\n\nHere is a VS project that addresses the ThinLines issues.</p><p>There is a LineTools Tab containing these three buttons, which in fact just get the state of the TL button.</p><center>\n<img alt=\"ThinLines add-in\" src=\"img/ThinLinesApp2.png\" width=\"424\"/>\n</center><p>A creative workaround to avoid the Revit API restrictions ('subscription API extensions only').</p><p>Two remarks:</p><ul>\n<li>It has to be tested if this will still work if the TL button is removed from Quick Access Toolbar.</li>\n<li>Also, I faced an exception saying 'command cannot be invoked several times' or so when clicking the buttons too fast.</li>\n</ul><p>Too fast for Revit.</p><p>Perhaps that could be encapsulated in a try/catch handler.</p><a name=\"8\"></a>"
  },
  {
    "original_filename": "1291_thin_lines_app",
    "header_text": "Implementation Notes and Download",
    "local_header_href": "#implementation-notes-and-download",
    "chunk_text": "<h4>Implementation Notes and Download</h4><p>The command ribbon button images are encapsulated in a proper resource file:</p><center>\n<img alt=\"ThinLines add-in Visual Studio solution\" src=\"img/ThinLinesVs.png\" width=\"246\"/>\n</center><p>We obviously need references to the various UI Automation libraries:</p><center>\n<img alt=\"ThinLines add-in Visual Studio solution references\" src=\"img/ThinLinesReferences.png\" width=\"263\"/>\n</center><p>All three external command implementations for thin lines, thick lines and to toggle line thickness are trivial one-liners, since they simply call back to the functionality and helper functions defined by the main external application class:</p><pre class=\"code\">\n<span class=\"blue\">using</span> Autodesk.Revit.UI;\n \n<span class=\"blue\">namespace</span> ThinLines\n{\n  [Autodesk.Revit.Attributes.<span class=\"teal\">Transaction</span>(\n    Autodesk.Revit.Attributes.<span class=\"teal\">TransactionMode</span>.ReadOnly )]\n  [Autodesk.Revit.Attributes.<span class=\"teal\">Regeneration</span>(\n    Autodesk.Revit.Attributes.<span class=\"teal\">RegenerationOption</span>.Manual )]\n  <span class=\"blue\">public</span> <span class=\"blue\">class</span> <span class=\"teal\">Command_ThinLines</span> : <span class=\"teal\">IExternalCommand</span>\n  {\n    <span class=\"blue\">public</span> <span class=\"teal\">Result</span> Execute(\n      <span class=\"teal\">ExternalCommandData</span> commandData,\n      <span class=\"blue\">ref</span> <span class=\"blue\">string</span> message,\n      Autodesk.Revit.DB.<span class=\"teal\">ElementSet</span> elements )\n    {\n      <span class=\"teal\">ThinLinesApp</span>.SetThinLines( commandData.Application, <span class=\"blue\">true</span> );\n      <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Succeeded;\n    }\n  }\n}\n</pre><p>The external application implementation demonstrates how to:</p><ul>\n<li>Set up the custom ribbon panel</li>\n<li>Handle the external command ribbon button images</li>\n<li>Use P/Invoke to access and make use of the Windows API functionality defined in User32.dll to find and enumerate specific windows</li>\n<li>Use the Revit API PostCommand method to invoke the built-in Thin Lines command</li>\n<li>Access the Revit Thin Lines button and determine its current state</li>\n</ul><p>Sounds cool?</p><p>It is!</p><p>Here is how:</p><pre class=\"code\">\n<span class=\"blue\">using</span> Autodesk.Revit.UI;\n<span class=\"blue\">using</span> System;\n<span class=\"blue\">using</span> System.Collections.Generic;\n<span class=\"blue\">using</span> System.Drawing;\n<span class=\"blue\">using</span> System.Runtime.InteropServices;\n<span class=\"blue\">using</span> System.Windows;\n<span class=\"blue\">using</span> System.Windows.Automation;\n<span class=\"blue\">using</span> System.Windows.Interop;\n<span class=\"blue\">using</span> System.Windows.Media;\n<span class=\"blue\">using</span> System.Windows.Media.Imaging;\n \n<span class=\"blue\">namespace</span> ThinLines\n{\n  <span class=\"blue\">public</span> <span class=\"blue\">class</span> <span class=\"teal\">ThinLinesApp</span> : <span class=\"teal\">IExternalApplication</span>\n  {\n<span class=\"blue\">    #region</span> Windows API, get from pinvoke.net\n \n    [<span class=\"teal\">DllImport</span>( <span class=\"maroon\">\"user32.dll\"</span>, SetLastError = <span class=\"blue\">true</span> )]\n    <span class=\"blue\">static</span> <span class=\"blue\">extern</span> <span class=\"teal\">IntPtr</span> FindWindowEx(\n      <span class=\"teal\">IntPtr</span> hwndParent, <span class=\"teal\">IntPtr</span> hwndChildAfter,\n      <span class=\"blue\">string</span> lpszClass, <span class=\"blue\">string</span> lpszWindow );\n \n    [<span class=\"teal\">DllImport</span>( <span class=\"maroon\">\"user32.dll\"</span> )]\n    [<span class=\"blue\">return</span>: <span class=\"teal\">MarshalAs</span>( <span class=\"teal\">UnmanagedType</span>.Bool )]\n    <span class=\"blue\">public</span> <span class=\"blue\">static</span> <span class=\"blue\">extern</span> <span class=\"blue\">bool</span> EnumChildWindows(\n      <span class=\"teal\">IntPtr</span> window, <span class=\"teal\">EnumWindowProc</span> callback,\n      <span class=\"teal\">IntPtr</span> i );\n \n    <span class=\"blue\">public</span> <span class=\"blue\">delegate</span> <span class=\"blue\">bool</span> <span class=\"teal\">EnumWindowProc</span>(\n      <span class=\"teal\">IntPtr</span> hWnd, <span class=\"teal\">IntPtr</span> parameter );\n \n    <span class=\"blue\">public</span> <span class=\"blue\">static</span> <span class=\"blue\">bool</span> EnumWindow(\n      <span class=\"teal\">IntPtr</span> handle,\n      <span class=\"teal\">IntPtr</span> pointer )\n    {\n      <span class=\"teal\">GCHandle</span> gch = <span class=\"teal\">GCHandle</span>.FromIntPtr( pointer );\n      <span class=\"teal\">List</span>&lt;<span class=\"teal\">IntPtr</span>&gt; list = gch.Target <span class=\"blue\">as</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">IntPtr</span>&gt;;\n      <span class=\"blue\">if</span>( list != <span class=\"blue\">null</span> )\n      {\n        list.Add( handle );\n      }\n      <span class=\"blue\">return</span> <span class=\"blue\">true</span>;\n    }\n \n    <span class=\"blue\">public</span> <span class=\"blue\">static</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">IntPtr</span>&gt; GetChildWindows(\n      <span class=\"teal\">IntPtr</span> parent )\n    {\n      <span class=\"teal\">List</span>&lt;<span class=\"teal\">IntPtr</span>&gt; result = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">IntPtr</span>&gt;();\n      <span class=\"teal\">GCHandle</span> listHandle = <span class=\"teal\">GCHandle</span>.Alloc( result );\n      <span class=\"blue\">try</span>\n      {\n        <span class=\"teal\">EnumWindowProc</span> childProc = <span class=\"blue\">new</span> <span class=\"teal\">EnumWindowProc</span>(\n          EnumWindow );\n \n        EnumChildWindows( parent, childProc,\n          <span class=\"teal\">GCHandle</span>.ToIntPtr( listHandle ) );\n      }\n      <span class=\"blue\">finally</span>\n      {\n        <span class=\"blue\">if</span>( listHandle.IsAllocated )\n          listHandle.Free();\n      }\n      <span class=\"blue\">return</span> result;\n    }\n<span class=\"blue\">    #endregion</span>\n \n    <span class=\"blue\">public</span> <span class=\"teal\">Result</span> OnShutdown( <span class=\"teal\">UIControlledApplication</span> a )\n    {\n      <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Succeeded;\n    }\n \n    <span class=\"blue\">public</span> <span class=\"teal\">Result</span> OnStartup( <span class=\"teal\">UIControlledApplication</span> a )\n    {\n      <span class=\"blue\">string</span> tabName = <span class=\"maroon\">\"LineTools\"</span>;\n      <span class=\"blue\">string</span> panelName = <span class=\"maroon\">\"LineTools\"</span>;\n      <span class=\"blue\">string</span> buttonThinName = <span class=\"maroon\">\"Thin\"</span>;\n      <span class=\"blue\">string</span> buttonThickName = <span class=\"maroon\">\"Thick\"</span>;\n      <span class=\"blue\">string</span> buttonToggleName = <span class=\"maroon\">\"Toggle\"</span>;\n \n      <span class=\"blue\">try</span>\n      {\n        <span class=\"teal\">List</span>&lt;<span class=\"teal\">RibbonPanel</span>&gt; panels = a.GetRibbonPanels(\n          tabName );\n      }\n      <span class=\"blue\">catch</span>\n      {\n        a.CreateRibbonTab( tabName );\n      }\n \n      <span class=\"teal\">RibbonPanel</span> panelViewExport = a.CreateRibbonPanel(\n        tabName, panelName );\n \n      panelViewExport.Name = panelName;\n      panelViewExport.Title = panelName;\n \n      <span class=\"teal\">PushButtonData</span> buttonThin = <span class=\"blue\">new</span> <span class=\"teal\">PushButtonData</span>(\n        buttonThinName, buttonThinName,\n        System.Reflection.<span class=\"teal\">Assembly</span>.GetExecutingAssembly().Location,\n        <span class=\"blue\">typeof</span>( <span class=\"teal\">Command_ThinLines</span> ).FullName );\n \n      buttonThin.ToolTip = buttonThinName;\n      <span class=\"teal\">ImageSource</span> iconThin = GetIconSource( <span class=\"teal\">Images</span>.Thin );\n      buttonThin.LargeImage = iconThin;\n      buttonThin.Image = Thumbnail( iconThin );\n      panelViewExport.AddItem( buttonThin );\n \n      <span class=\"teal\">PushButtonData</span> buttonThick = <span class=\"blue\">new</span> <span class=\"teal\">PushButtonData</span>(\n        buttonThickName, buttonThickName,\n        System.Reflection.<span class=\"teal\">Assembly</span>.GetExecutingAssembly().Location,\n        <span class=\"blue\">typeof</span>( <span class=\"teal\">Command_ThickLines</span> ).FullName );\n \n      buttonThick.ToolTip = buttonThickName;\n      <span class=\"teal\">ImageSource</span> iconThick = GetIconSource( <span class=\"teal\">Images</span>.Thick );\n      buttonThick.LargeImage = iconThick;\n      buttonThick.Image = Thumbnail( iconThick );\n      panelViewExport.AddItem( buttonThick );\n \n      <span class=\"teal\">PushButtonData</span> buttonToggle = <span class=\"blue\">new</span> <span class=\"teal\">PushButtonData</span>(\n        buttonToggleName, buttonToggleName,\n        System.Reflection.<span class=\"teal\">Assembly</span>.GetExecutingAssembly().Location,\n        <span class=\"blue\">typeof</span>( <span class=\"teal\">Command_ToggleLineThickness</span> ).FullName );\n \n      buttonToggle.ToolTip = buttonToggleName;\n      <span class=\"teal\">ImageSource</span> iconToggle = GetIconSource( <span class=\"teal\">Images</span>.ToggleLineThickness );\n      buttonToggle.LargeImage = iconToggle;\n      buttonToggle.Image = Thumbnail( iconToggle );\n      panelViewExport.AddItem( buttonToggle );\n \n      <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Succeeded;\n    }\n \n    <span class=\"blue\">public</span> <span class=\"blue\">static</span> <span class=\"teal\">ImageSource</span> GetIconSource( <span class=\"teal\">Bitmap</span> bmp )\n    {\n      <span class=\"teal\">BitmapSource</span> icon\n        = <span class=\"teal\">Imaging</span>.CreateBitmapSourceFromHBitmap(\n        bmp.GetHbitmap(), <span class=\"teal\">IntPtr</span>.Zero, <span class=\"teal\">Int32Rect</span>.Empty,\n        System.Windows.Media.Imaging.<span class=\"teal\">BitmapSizeOptions</span>.FromEmptyOptions() );\n \n      <span class=\"blue\">return</span> (System.Windows.Media.<span class=\"teal\">ImageSource</span>) icon;\n    }\n \n    <span class=\"blue\">public</span> <span class=\"blue\">static</span> <span class=\"teal\">ImageSource</span> Thumbnail(\n      <span class=\"teal\">ImageSource</span> source )\n    {\n      <span class=\"teal\">Rect</span> rect = <span class=\"blue\">new</span> <span class=\"teal\">Rect</span>( 0, 0, 16, 16 );\n      <span class=\"teal\">DrawingVisual</span> drawingVisual = <span class=\"blue\">new</span> <span class=\"teal\">DrawingVisual</span>();\n \n      <span class=\"blue\">using</span>( <span class=\"teal\">DrawingContext</span> drawingContext\n        = drawingVisual.RenderOpen() )\n      {\n        drawingContext.DrawImage( source, rect );\n      }\n \n      <span class=\"teal\">RenderTargetBitmap</span> resizedImage\n        = <span class=\"blue\">new</span> <span class=\"teal\">RenderTargetBitmap</span>(\n          (<span class=\"blue\">int</span>) rect.Width, (<span class=\"blue\">int</span>) rect.Height, 96, 96,\n          <span class=\"teal\">PixelFormats</span>.Default );\n \n      resizedImage.Render( drawingVisual );\n \n      <span class=\"blue\">return</span> resizedImage;\n    }\n \n    <span class=\"blue\">public</span> <span class=\"blue\">static</span> <span class=\"teal\">AutomationElement</span> GetThinLinesButton()\n    {\n      <span class=\"teal\">IntPtr</span> revitHandle\n        = System.Diagnostics.<span class=\"teal\">Process</span>.GetCurrentProcess()\n          .MainWindowHandle;\n \n      <span class=\"teal\">IntPtr</span> outerToolFrame = FindWindowEx( revitHandle,\n        <span class=\"teal\">IntPtr</span>.Zero, <span class=\"maroon\">\"AdImpApplicationFrame\"</span>,\n        <span class=\"maroon\">\"AdImpApplicationFrame\"</span> );\n \n      <span class=\"teal\">IntPtr</span> innerToolFrame = GetChildWindows(\n        outerToolFrame )[0];\n \n      <span class=\"teal\">AutomationElement</span> innerToolFrameElement\n        = <span class=\"teal\">AutomationElement</span>.FromHandle( innerToolFrame );\n \n      <span class=\"teal\">PropertyCondition</span> typeRibbonCondition\n        = <span class=\"blue\">new</span> <span class=\"teal\">PropertyCondition</span>(\n          <span class=\"teal\">AutomationElement</span>.ControlTypeProperty,\n          <span class=\"teal\">ControlType</span>.Custom );\n \n      <span class=\"teal\">AutomationElement</span> lowestPanel\n        = innerToolFrameElement.FindFirst(\n          <span class=\"teal\">TreeScope</span>.Children, typeRibbonCondition );\n \n      <span class=\"teal\">PropertyCondition</span> nameRibbonCondition\n        = <span class=\"blue\">new</span> <span class=\"teal\">PropertyCondition</span>(\n          <span class=\"teal\">AutomationElement</span>.AutomationIdProperty,\n          <span class=\"maroon\">\"ID_THIN_LINES_RibbonItemControl\"</span> );\n \n      <span class=\"teal\">AndCondition</span> andCondition = <span class=\"blue\">new</span> <span class=\"teal\">AndCondition</span>(\n        typeRibbonCondition, nameRibbonCondition );\n \n      <span class=\"teal\">AutomationElement</span> buttonContainer\n        = lowestPanel.FindFirst( <span class=\"teal\">TreeScope</span>.Children,\n          andCondition );\n \n      <span class=\"teal\">PropertyCondition</span> typeButtonCondition\n        = <span class=\"blue\">new</span> <span class=\"teal\">PropertyCondition</span>(\n          <span class=\"teal\">AutomationElement</span>.ControlTypeProperty,\n          <span class=\"teal\">ControlType</span>.Button );\n \n      <span class=\"teal\">PropertyCondition</span> nameButtonCondition\n        = <span class=\"blue\">new</span> <span class=\"teal\">PropertyCondition</span>(\n          <span class=\"teal\">AutomationElement</span>.AutomationIdProperty,\n          <span class=\"maroon\">\"ID_THIN_LINES\"</span> );\n \n      <span class=\"teal\">AndCondition</span> andConditionButton = <span class=\"blue\">new</span> <span class=\"teal\">AndCondition</span>(\n        typeButtonCondition, nameButtonCondition );\n \n      <span class=\"teal\">AutomationElement</span> button = buttonContainer.FindFirst(\n        <span class=\"teal\">TreeScope</span>.Children, andConditionButton );\n \n      <span class=\"blue\">return</span> button;\n    }\n \n    <span class=\"blue\">public</span> <span class=\"blue\">static</span> <span class=\"blue\">void</span> SetThinLines(\n      <span class=\"teal\">UIApplication</span> app,\n      <span class=\"blue\">bool</span> makeThin )\n    {\n      <span class=\"blue\">bool</span> isAlreadyThin = IsThinLines();\n \n      <span class=\"blue\">if</span>( makeThin != isAlreadyThin )\n      {\n        <span class=\"green\">// Switch TL state by invoking </span>\n        <span class=\"green\">// PostableCommand.ThinLines</span>\n \n        <span class=\"teal\">RevitCommandId</span> commandId\n          = <span class=\"teal\">RevitCommandId</span>.LookupPostableCommandId(\n            <span class=\"teal\">PostableCommand</span>.ThinLines );\n \n        <span class=\"blue\">if</span>( app.CanPostCommand( commandId ) )\n        {\n          app.PostCommand( commandId );\n        }\n      }\n    }\n \n    <span class=\"blue\">public</span> <span class=\"blue\">static</span> <span class=\"blue\">bool</span> IsThinLines()\n    {\n      <span class=\"teal\">AutomationElement</span> button = GetThinLinesButton();\n \n      <span class=\"teal\">TogglePattern</span> togglePattern\n        = button.GetCurrentPattern(\n          <span class=\"teal\">TogglePattern</span>.Pattern ) <span class=\"blue\">as</span> <span class=\"teal\">TogglePattern</span>;\n \n      <span class=\"blue\">string</span> state = togglePattern.Current\n        .ToggleState.ToString().ToUpper();\n \n      <span class=\"blue\">return</span> ( state == <span class=\"maroon\">\"ON\"</span> );\n    }\n  }\n}\n</pre><p>The complete source code, Visual Studio solution and add-in manifest are provided in the\n\n<a href=\"https://github.com/jeremytammik/ThinLines\">\nThinLines GitHub repository</a>,\n\nand the version described here is\n\n<a href=\"https://github.com/jeremytammik/ThinLines/releases/tag/2015.0.0.1\">\nrelease 2015.0.0.1</a>.</p><p>As said, please be aware of\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/about-the-author.html#4\">The Building Coder Disclaimer</a> before\n\nyou even dream of making use of this.</p><p>Many thanks to Rudi for his research and nice, clean implementation!</p>"
  }
]