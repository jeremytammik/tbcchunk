[
  {
    "original_filename": "1223_text_width",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<head>\n<meta content=\"text/html; charset=utf-8\" http-equiv=\"Content-Type\"/>\n<link href=\"bc.css\" rel=\"stylesheet\" type=\"text/css\"/>\n<script src=\"http://thebuildingcoder.typepad.com/google-code-prettify/run_prettify.js\"></script>\n</head>"
  },
  {
    "original_filename": "1223_text_width",
    "header_text": "New Text Note and Text Width Calculation",
    "local_header_href": "#new-text-note-and-text-width-calculation",
    "chunk_text": "<h3>New Text Note and Text Width Calculation</h3><p>How can I determine the exact width of a Revit text note?</p><p>This is the topic of the Revit API discussion thread on\n\n<a href=\"http://forums.autodesk.com/t5/revit-api/textnote-width-calculate-minimum/m-p/5322447\">\ntextnote width calculate minimum</a>.</p><p>We worked through a whole series of implementation attempts, mostly suggested by Scott Wilson, who also finally suggested the one that currently seems to be optimal and near perfect:</p><p><strong>Question:</strong> When creating a new TextNote I'm given the option to give the TextNote a LineWidth Property.\nI understand this is the 1:1 scale of the width and the real Width would be that number * the scale factor of the View.\nSo here's the code I'm using to create the TextNote:</p><pre class=\"code\">\n  <span class=\"teal\">TextNoteType</span> Bold = doc.GetElement(\n    <span class=\"blue\">new</span> <span class=\"teal\">ElementId</span>( 1212838 ) ) <span class=\"blue\">as</span> <span class=\"teal\">TextNoteType</span>;\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">Transaction</span> t = <span class=\"blue\">new</span> <span class=\"teal\">Transaction</span>( doc ) )\n  {\n    t.Start( <span class=\"maroon\">\"Create TextNotes\"</span> );\n    <span class=\"teal\">TextNote</span> txNote = doc.Create.NewTextNote(\n      doc.ActiveView, <span class=\"teal\">XYZ</span>.Zero, <span class=\"teal\">XYZ</span>.BasisX,\n      <span class=\"teal\">XYZ</span>.BasisY, 0.06, <span class=\"teal\">TextAlignFlags</span>.TEF_ALIGN_LEFT\n      | <span class=\"teal\">TextAlignFlags</span>.TEF_ALIGN_BOTTOM, <span class=\"maroon\">\"TEST BOLD\"</span> );\n \n    txNote.TextNoteType = Bold;\n    t.Commit();\n  }\n</pre><p>This works fine so long as the string doesn't get longer.\nIf I need to change the length of the string (which I am) I'd need to give it a new LineWidth, or set the Width Property after I change the TextNoteType.  This is important because I need to create a new TextNote after this bolded String and I want to make sure it's not too far from the last letter of the bolded string I just created.</p><p>So, is there a way to calculate the minimum Width of a TextNote without it wrapping?</p><p><strong>Answer:</strong> When I used to do text rendering in game engines, I made use of Windows GDI to measure the size of text strings for a particular font. Maybe you could combine this kind of technique with other known information of the text note and view scale to get what you need?</p><p>I did a quick google and found what looks like\n\n<a href=\"http://msdn.microsoft.com/en-us/library/9bt8ty58(v=vs.110).aspx\">\nthe .NET way of doing this</a>.</p><p><strong>Response:</strong> Thanks for the suggestion, that worked out perfect in the following specific case!</p><p>I had to do some manipulation and calculations to try and figure out how tall my font in pixels and how to convert the width from pixels to inches, but I got it close enough to do a sentence (and I only need a few words) so this code works pretty good:</p><pre class=\"code\">\n  <span class=\"teal\">TextNoteType</span> Bold = doc.GetElement(\n    <span class=\"blue\">new</span> <span class=\"teal\">ElementId</span>( 1212838 ) )\n      <span class=\"blue\">as</span> <span class=\"teal\">TextNoteType</span>; <span class=\"green\">// Arial 3/32\" Bold</span>\n \n  <span class=\"teal\">Font</span> ArialBoldFont = <span class=\"blue\">new</span> <span class=\"teal\">Font</span>( <span class=\"maroon\">\"Arial\"</span>, 9,\n    <span class=\"teal\">FontStyle</span>.Bold );\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">Transaction</span> t = <span class=\"blue\">new</span> <span class=\"teal\">Transaction</span>( doc ) )\n  {\n    t.Start( <span class=\"maroon\">\"Create TextNote\"</span> );\n \n    <span class=\"blue\">string</span> s = <span class=\"maroon\">\"TEST BOLD\"</span>;\n \n    <span class=\"teal\">Size</span> txtBox = TextRenderer.MeasureText( s,\n      ArialBoldFont );\n \n    <span class=\"blue\">double</span> newWidth = ( (<span class=\"blue\">double</span>) txtBox.Width / 86 )\n      / 12;\n \n    <span class=\"teal\">TextNote</span> txNote = doc.Create.NewTextNote(\n      doc.ActiveView, <span class=\"teal\">XYZ</span>.Zero, <span class=\"teal\">XYZ</span>.BasisX,\n      <span class=\"teal\">XYZ</span>.BasisY, 0.1, <span class=\"teal\">TextAlignFlags</span>.TEF_ALIGN_LEFT\n      | <span class=\"teal\">TextAlignFlags</span>.TEF_ALIGN_BOTTOM, s );\n \n    txNote.TextNoteType = Bold;\n    txNote.Width = newWidth;\n    t.Commit();\n  }\n</pre><p><strong>Response 2:</strong> I do not understand how you get from the 3/32\" font size defined in the Revit text type to the number 9 that you specify as the em-size in points of the new .NET font.</p><p>Also, vice versa, MeasureText returns the size in pixels. Why do you divide this by 86? Would that mean 86 pixels per inch? Does that depend on the Revit scale? If it is pixels, it also depends on the device, doesn't it? And the division by 12 transforms that to feet, of course.</p><p>Can you explain, please?</p><p>Actually, trying to make general use of the solution above does not seem to work for me.</p><p>I looked at ways to improve it, making it work in my context, and would like to hear your opinion on the following expanded experiment:</p><p>It performs the following steps:</p><ul>\n<li>Pick a text insertion point.</li>\n<li>Grab the first text note type encountered.</li>\n<li>Convert the text note type nominal size to points, i.e. 1/72\".</li>\n<li>Create the appropriate .NET font.</li>\n<li>Measure the text size in pixels in this font.</li>\n<li>Determine the current display horizontal dots per inch resolution.</li>\n<li>Use that to convert the size in pixels to inches.</li>\n<li>Determine the Revit view scale.</li>\n<li>Scale the width in inches according to that.</li>\n<li>Add a factor to account for imprecision, currently the experimentally determined factor 1.4.</li>\n</ul><p>That seems to work for me and produces the following result:</p><center>\n<img alt=\"Text note width\" src=\"img/text_width_1_1.4.png\" width=\"461\"/>\n</center><p>Here is the current version of the external command source code producing that result:</p><pre class=\"code\">\n  [<span class=\"teal\">Transaction</span>( <span class=\"teal\">TransactionMode</span>.Manual )]\n  <span class=\"blue\">class</span> <span class=\"teal\">CmdNewTextNote</span> : <span class=\"teal\">IExternalCommand</span>\n  {\n    [<span class=\"teal\">DllImport</span>( <span class=\"maroon\">\"user32.dll\"</span> )]\n    <span class=\"blue\">private</span> <span class=\"blue\">static</span> <span class=\"blue\">extern</span> <span class=\"teal\">IntPtr</span> GetDC( <span class=\"teal\">IntPtr</span> hwnd );\n \n    [<span class=\"teal\">DllImport</span>( <span class=\"maroon\">\"user32.dll\"</span> )]\n    <span class=\"blue\">private</span> <span class=\"blue\">static</span> <span class=\"blue\">extern</span> <span class=\"teal\">Int32</span> ReleaseDC( <span class=\"teal\">IntPtr</span> hwnd );\n \n    <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n    <span class=\"gray\">///</span><span class=\"green\"> Determine the current display</span>\n    <span class=\"gray\">///</span><span class=\"green\"> horizontal dots per inch.</span>\n    <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n    <span class=\"blue\">static</span> <span class=\"blue\">float</span> DpiX\n    {\n      <span class=\"blue\">get</span>\n      {\n        <span class=\"teal\">Single</span> xDpi, yDpi;\n \n        <span class=\"teal\">IntPtr</span> dc = GetDC( <span class=\"teal\">IntPtr</span>.Zero );\n \n        <span class=\"blue\">using</span>( <span class=\"teal\">Graphics</span> g = <span class=\"teal\">Graphics</span>.FromHdc( dc ) )\n        {\n          xDpi = g.DpiX;\n          yDpi = g.DpiY;\n        }\n \n        <span class=\"blue\">if</span>( ReleaseDC( <span class=\"teal\">IntPtr</span>.Zero ) != 0 )\n        {\n          <span class=\"green\">// GetLastError and handle...</span>\n        }\n        <span class=\"blue\">return</span> xDpi;\n      }\n    }\n \n    <span class=\"blue\">public</span> <span class=\"teal\">Result</span> Execute(\n      <span class=\"teal\">ExternalCommandData</span> commandData,\n      <span class=\"blue\">ref</span> <span class=\"blue\">string</span> message,\n      <span class=\"teal\">ElementSet</span> elements )\n    {\n      <span class=\"teal\">UIApplication</span> uiapp = commandData.Application;\n      <span class=\"teal\">UIDocument</span> uidoc = uiapp.ActiveUIDocument;\n      <span class=\"teal\">Document</span> doc = uidoc.Document;\n      <span class=\"teal\">View</span> view = doc.ActiveView;\n \n      <span class=\"teal\">XYZ</span> p;\n \n      <span class=\"blue\">try</span>\n      {\n        p = uidoc.Selection.PickPoint(\n          <span class=\"maroon\">\"Please pick text insertion point\"</span> );\n      }\n      <span class=\"blue\">catch</span>( Autodesk.Revit.Exceptions.<span class=\"teal\">OperationCanceledException</span> )\n      {\n        <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Cancelled;\n      }\n \n      <span class=\"green\">//TextNoteType boldTextType = doc.GetElement(</span>\n      <span class=\"green\">//  new ElementId( 1212838 ) ) as TextNoteType; // Arial 3/32\" Bold</span>\n \n      <span class=\"green\">// 1 inch = 72 points</span>\n      <span class=\"green\">// 3/32\" = 72*3/32 points =</span>\n \n      <span class=\"teal\">TextNoteType</span> textType\n        = <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( doc )\n          .OfClass( <span class=\"blue\">typeof</span>( <span class=\"teal\">TextNoteType</span> ) )\n          .FirstElement() <span class=\"blue\">as</span> <span class=\"teal\">TextNoteType</span>;\n \n      <span class=\"teal\">Debug</span>.Print( textType.Name );\n \n      <span class=\"green\">// 6 mm Arial happens to be the first text type found</span>\n      <span class=\"green\">// 6 mm = 6 / 25.4 inch = 72 * 6 / 25.4 points = 17 pt</span>\n \n      <span class=\"teal\">Font</span> font = <span class=\"blue\">new</span> <span class=\"teal\">Font</span>( <span class=\"maroon\">\"Arial\"</span>, 17, <span class=\"teal\">FontStyle</span>.Bold );\n \n      <span class=\"blue\">using</span>( <span class=\"teal\">Transaction</span> t = <span class=\"blue\">new</span> <span class=\"teal\">Transaction</span>( doc ) )\n      {\n        t.Start( <span class=\"maroon\">\"Create TextNote\"</span> );\n \n        <span class=\"blue\">string</span> s = <span class=\"maroon\">\"The quick brown fox jumped over the lazy dog\"</span>;\n \n        <span class=\"teal\">Size</span> txtBox = System.Windows.Forms.<span class=\"teal\">TextRenderer</span>\n          .MeasureText( s, font );\n \n        <span class=\"blue\">double</span> w_inch = txtBox.Width / DpiX;\n        <span class=\"blue\">double</span> v_scale = view.Scale; <span class=\"green\">// ratio of true model size to paper size</span>\n \n        <span class=\"teal\">Debug</span>.Print(\n          <span class=\"maroon\">\"Text box width in pixels {0} = {1} inch, scale {2}\"</span>,\n          txtBox.Width, w_inch, v_scale );\n \n        <span class=\"green\">//double newWidth</span>\n        <span class=\"green\">//  = ( (double) txtBox.Width / 86 ) / 12;</span>\n \n        <span class=\"blue\">double</span> newWidth = w_inch / 12;\n \n        newWidth = newWidth * v_scale;\n \n        newWidth *= 1.4;\n \n        <span class=\"teal\">TextNote</span> txNote = doc.Create.NewTextNote(\n          doc.ActiveView, p, <span class=\"teal\">XYZ</span>.BasisX, <span class=\"teal\">XYZ</span>.BasisY,\n          0.1, <span class=\"teal\">TextAlignFlags</span>.TEF_ALIGN_LEFT\n          | <span class=\"teal\">TextAlignFlags</span>.TEF_ALIGN_BOTTOM, s );\n \n        txNote.TextNoteType = textType;\n        txNote.Width = newWidth;\n \n        t.Commit();\n      }\n      <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Succeeded;\n    }\n  }\n</pre><p>I would love to hear your comments on this.</p><p>I am sure it includes at least lots of room for improvement, and potentially serious errors.</p><p>I do wonder how your simple solution presented above could work as well as you say it does.</p><p>Does it really?</p><p>Thank you!</p><p>Actually, the factor 1.4 is a bit large for the lower case test sentence:</p><center>\n<img alt=\"Text note width using factor 1.4\" src=\"img/text_width_1_1.4.png\" width=\"461\"/>\n</center><p>Further experiments prove that a factor of 1.3 is too small for upper case text.</p><p>It works for the lower case test sentence:</p><center>\n<img alt=\"Text note width using factor 1.3\" src=\"img/text_width_2_1.3.png\" width=\"385\"/>\n</center><p>The width calculated using a factor of 1.3 for upper case words is insufficient, however, and they are wrapped:</p><center>\n<img alt=\"Upper case text note width using factor 1.3\" src=\"img/text_width_3_1.3.png\" width=\"280\"/>\n</center><p><strong>Answer:</strong> Fortunately, I have the luxury of only having to deal with one specific font (Arial), one specific height (3/32\"), one view scale (1:1), and very short phrases, so my code does work with the crazy math.  I used 9 for the TextRenderer because I was going to use 1/8\" text (which, at 72DPI, is 9em), but then changed to 3/32\", I just forgot to change the 9 to 6.75, which might be why I had to use 86 for my DPI.  Once I got it to work I was just like, \"got it, don't change anything\".</p><p>I did update my code to 6.75 em and changed the division to be by 72.27 DPI, and it still gets pretty close to accurate, see attached PNG.</p><p>If you can improve the code it would be great, because I do think it would be a great help (at least until we can override characters in a TextBox to be bold like we can with the GUI).</p><p>I realize the DPI could be different on each user's screen, but wouldn't you be able to always use the same 72 DPI to calculate the width?  The width of the TextNote doesn't rely on the DPI of the user's screen, so I feel like the DPI division should be a constant.  Also, the Width of the TextNote will include the BuiltInParameter.LEADER_OFFSET_SHEET (times 2), but the TextRenderer wouldn't.  You'll have to take that into account for the Width too.</p><p>I had a bit of a play with the enhanced code to see what I could discover.\nI generalised it further to read in the size of the text style, width factor and border offset and then calculate the rest on the fly without hard-coding any values. I think the magic scaling factor of 1.4 is actually due to Revit treating fonts as 96 DPI (which I believe is the standard for Windows these days) instead of 72 (1.3333 factor). If I calculate the point size at 96 dpi I am able to discard the final scaling step and still get similar results.</p><p>I also played around a little with other common typographic units such as the\n\n<a href=\"http://www.translatorscafe.com/cafe/EN/units-converter/typography/7-4/pixel_(X)-millimeter\">\npixel to millimeter converter</a>.</p><p>However, nothing else could explain the ~1.4 figure (I also considered that 1.4 is quite close to sqrt(2) which is a scaling factor used for ISO paper sizes, but that didn't really make sense).</p><p>The text measure method from Windows.Forms returns the size in whole pixels and therefore will be rounded. I have noticed that the variance between actual shortest line length and the calculated value is inconsistent between text sizes (sometimes the calculated value is larger, sometimes it is smaller and sometimes almost spot on), this is probably related to this integer rounding. The Graphics.MeasureString method that I originally suggested returns the width in fractional pixels without rounding, so is more consistent, but the value returned is always too large and still fluctuates a little depending on text size.</p><p>This is I believe caused by non-standard font sizes causing the text rendering system to perform its own rounding while scaling the font for drawing (and calculating string widths). I've found that if I round my calculated point size up to the nearest 8th of a point (0.125) then multiply that by 10 (then of course dividing the resulting text width by 10) to gain more resolution the end result is much more consistent.</p><p>I tested several sizes ranging from 1 mm up to 12 mm and found that a few sizes just don't behave very well (3 mm and 5 mm for example) and will calculate a length just a little too short while the rest are fine. To compensate for this I then added 2.5 points to my scaled up font size and it then worked for all sizes.</p><p>It's a pretty good length approximation that is usually just a little larger than required. There are still a few sizes that don't behave though, so there's more analysis required to pin down a proper generalised solution. I think the inconsistency comes from Revit dealing with font size point rounding and scaling in a different way to the methods we are using, sometimes the rounding is in synch, other times it will diverge.\nIt would be handy to know the actual method Revit uses so that it could be mimicked.</p><p>Also, be sure to apply the text type's Width Factor and then add twice the border offset defined by the  BuiltInParameter.LEADER_OFFSET_SHEET.</p><p><strong>Response:</strong> Wow, thank you very much indeed for your valuable additional research.</p><p>That is more than I could have hoped for.</p><p>It sounds like this provides the basis for a pretty complete solution.</p><p>I implemented this partially as follows:</p><pre class=\"code\">\n  [<span class=\"teal\">Transaction</span>( <span class=\"teal\">TransactionMode</span>.Manual )]\n  <span class=\"blue\">class</span> <span class=\"teal\">CmdNewTextNote</span> : <span class=\"teal\">IExternalCommand</span>\n  {\n    [<span class=\"teal\">DllImport</span>( <span class=\"maroon\">\"user32.dll\"</span> )]\n    <span class=\"blue\">private</span> <span class=\"blue\">static</span> <span class=\"blue\">extern</span> <span class=\"teal\">IntPtr</span> GetDC( <span class=\"teal\">IntPtr</span> hwnd );\n \n    [<span class=\"teal\">DllImport</span>( <span class=\"maroon\">\"user32.dll\"</span> )]\n    <span class=\"blue\">private</span> <span class=\"blue\">static</span> <span class=\"blue\">extern</span> <span class=\"teal\">Int32</span> ReleaseDC( <span class=\"teal\">IntPtr</span> hwnd );\n \n    <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n    <span class=\"gray\">///</span><span class=\"green\"> Determine the current display</span>\n    <span class=\"gray\">///</span><span class=\"green\"> horizontal dots per inch.</span>\n    <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n    <span class=\"blue\">static</span> <span class=\"blue\">float</span> DpiX\n    {\n      <span class=\"blue\">get</span>\n      {\n        <span class=\"teal\">Single</span> xDpi, yDpi;\n \n        <span class=\"teal\">IntPtr</span> dc = GetDC( <span class=\"teal\">IntPtr</span>.Zero );\n \n        <span class=\"blue\">using</span>( <span class=\"teal\">Graphics</span> g = <span class=\"teal\">Graphics</span>.FromHdc( dc ) )\n        {\n          xDpi = g.DpiX;\n          yDpi = g.DpiY;\n        }\n \n        <span class=\"blue\">if</span>( ReleaseDC( <span class=\"teal\">IntPtr</span>.Zero ) != 0 )\n        {\n          <span class=\"green\">// GetLastError and handle...</span>\n        }\n        <span class=\"blue\">return</span> xDpi;\n      }\n    }\n \n    <span class=\"blue\">public</span> <span class=\"teal\">Result</span> Execute(\n      <span class=\"teal\">ExternalCommandData</span> commandData,\n      <span class=\"blue\">ref</span> <span class=\"blue\">string</span> message,\n      <span class=\"teal\">ElementSet</span> elements )\n    {\n      <span class=\"teal\">UIApplication</span> uiapp = commandData.Application;\n      <span class=\"teal\">UIDocument</span> uidoc = uiapp.ActiveUIDocument;\n      <span class=\"teal\">Document</span> doc = uidoc.Document;\n      <span class=\"teal\">View</span> view = doc.ActiveView;\n \n      <span class=\"teal\">XYZ</span> p;\n \n      <span class=\"blue\">try</span>\n      {\n        p = uidoc.Selection.PickPoint(\n          <span class=\"maroon\">\"Please pick text insertion point\"</span> );\n      }\n      <span class=\"blue\">catch</span>( Autodesk.Revit.Exceptions.<span class=\"teal\">OperationCanceledException</span> )\n      {\n        <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Cancelled;\n      }\n \n      <span class=\"teal\">TextNoteType</span> textType\n        = <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( doc )\n          .OfClass( <span class=\"blue\">typeof</span>( <span class=\"teal\">TextNoteType</span> ) )\n          .FirstElement() <span class=\"blue\">as</span> <span class=\"teal\">TextNoteType</span>;\n \n      <span class=\"teal\">Debug</span>.Print( <span class=\"maroon\">\"TextNoteType.Name = \"</span> + textType.Name );\n \n      <span class=\"green\">// 6 mm Arial happens to be the first text type found</span>\n      <span class=\"green\">// 6 mm = 6 / 25.4 inch = 72 * 6 / 25.4 points = 17 pt.</span>\n      <span class=\"green\">// Nowadays, Windows does not assume that a point is</span>\n      <span class=\"green\">// 1/72\", but moved to 1/96\" instead.</span>\n \n      <span class=\"blue\">float</span> text_type_height_mm = 6;\n \n      <span class=\"blue\">float</span> mm_per_inch = 25.4f;\n \n      <span class=\"blue\">float</span> points_per_inch = 96; <span class=\"green\">// not 72</span>\n \n      <span class=\"blue\">float</span> em_size = points_per_inch\n        * ( text_type_height_mm / mm_per_inch );\n \n      em_size += 2.5f;\n \n      <span class=\"teal\">Font</span> font = <span class=\"blue\">new</span> <span class=\"teal\">Font</span>( <span class=\"maroon\">\"Arial\"</span>, em_size,\n        <span class=\"teal\">FontStyle</span>.Regular );\n \n      <span class=\"blue\">using</span>( <span class=\"teal\">Transaction</span> t = <span class=\"blue\">new</span> <span class=\"teal\">Transaction</span>( doc ) )\n      {\n        t.Start( <span class=\"maroon\">\"Create TextNote\"</span> );\n \n        <span class=\"blue\">string</span> s = <span class=\"maroon\">\"The quick brown fox jumps over the lazy dog\"</span>;\n \n        <span class=\"teal\">Size</span> txtBox = System.Windows.Forms.<span class=\"teal\">TextRenderer</span>\n          .MeasureText( s, font );\n \n        <span class=\"blue\">double</span> w_inch = txtBox.Width / DpiX;\n        <span class=\"blue\">double</span> v_scale = view.Scale; <span class=\"green\">// ratio of true model size to paper size</span>\n \n        <span class=\"teal\">Debug</span>.Print(\n          <span class=\"maroon\">\"Text box width in pixels {0} = {1} inch, \"</span>\n          + <span class=\"maroon\">\"view scale = {2}\"</span>,\n          txtBox.Width, w_inch, v_scale );\n \n        <span class=\"blue\">double</span> newWidth = w_inch / 12;\n \n        <span class=\"teal\">TextNote</span> txNote = doc.Create.NewTextNote(\n          doc.ActiveView, p, <span class=\"teal\">XYZ</span>.BasisX, <span class=\"teal\">XYZ</span>.BasisY,\n          newWidth, <span class=\"teal\">TextAlignFlags</span>.TEF_ALIGN_LEFT\n          | <span class=\"teal\">TextAlignFlags</span>.TEF_ALIGN_BOTTOM, s );\n \n        txNote.TextNoteType = textType;\n \n        <span class=\"teal\">Debug</span>.Print(\n          <span class=\"maroon\">\"NewTextNote lineWidth {0} times view scale \"</span>\n          + <span class=\"maroon\">\"{1} = {2} generated TextNote.Width {3}\"</span>,\n          <span class=\"teal\">Util</span>.RealString( newWidth ),\n          <span class=\"teal\">Util</span>.RealString( v_scale ),\n          <span class=\"teal\">Util</span>.RealString( newWidth * v_scale ),\n          <span class=\"teal\">Util</span>.RealString( txNote.Width ) );\n \n        <span class=\"green\">// This fails.</span>\n \n        <span class=\"green\">//Debug.Assert(</span>\n        <span class=\"green\">//  Util.IsEqual( newWidth * v_scale, txNote.Width ),</span>\n        <span class=\"green\">//  \"expected the NewTextNote lineWidth \"</span>\n        <span class=\"green\">//  + \"argument to determine the resulting \"</span>\n        <span class=\"green\">//  + \"text note width\" );</span>\n \n        txNote.Width = newWidth * v_scale;\n \n        t.Commit();\n      }\n      <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Succeeded;\n    }\n  }\n</pre><p>Does that match your intentions and explanation, Scott?</p><p>I do not see where to obtain the \"text type's Width Factor\" that you mention. Where is that stored?</p><p>Furthermore, what element hosts the BuiltInParameter.LEADER_OFFSET_SHEET?</p><p>It sounds like you tested this for various different fonts and text string samples.</p><p>Have you written some kind of test framework iterating over the available text note types, matching them with .NET fonts and trying them out with different strings?</p><p>In order to use this approach in a serious production environment, I would definitely set up and use such a system and a corresponding unit test to verify that the chosen adjustments really do work correctly in all cases encountered.</p><p><strong>Answer:</strong> That looks pretty close Jeremy.\nOne extra thing my solution does is scale the font point size up by 10x then divides the resulting string width by 10 afterwards so that we can get sub-pixel accuracy out of the MeasureText method. I do this upscaling before adding the 2.5 points (magic number unfortunately...).</p><p>The command I developed is based upon your code, but iterates through all available textnote types calculating the font metrics and placing a note for each just below the preceding one. It works fine for each note type in my testing template (ranging from 1 through to 12mm), none of them wrap, but some sizes do have a little more line length than I would like. I'll clean it up a little to remove the references to my framework and post it up.</p><p>BuiltInParameter.LEADER_OFFSET_SHEET is the Leader/Border offset parameter found in the TextNoteType element. The font height and width factor can also be found there. One thing my code doesn't do just yet is handle font styles such as bold and italics; it'll only take 5 min to throw that in before I post it up though.</p><p>Ok...</p><p>After a little more testing I've decided that using TextRenderer.MeasureText() is not the way to go.\nThe results are too inconsistent and require too much hand-waving to normalise.\nI believe that TextRenderer.MeasureText() uses standard GDI to calculate the text dimensions while Graphics.MeasureString() makes use of GDI+. I would think that Revit would itself be using GDI+, so it would make sense to use the same system for our calculations.</p><p>I stripped away all of the scaling and magic numbers and used Graphics.MeasureString().\nI found that although the line lengths do end up a little larger than you would like, the results are much more stable (although it isn't perfect, I was able to cause a line wrap with an Arial bold, italic, underlined 16.5mm font). I also stripped out the User32 Interop stuff as it is quite easy to get at the same data using managed code.</p><p>Anyway here is the full external command class for you to play with, I won't go as far as to say it is a complete solution as there are still a few instances where it will cause a line wrap. I just think that Revit is doing some odd things internally with regard to calculation of line wrapping and we'll never know for sure until it is one day (hopefully) exposed to the API.</p><pre class=\"code\">\n  <span class=\"blue\">static</span> <span class=\"blue\">float</span> GetDpiX()\n  {\n    <span class=\"blue\">float</span> xDpi, yDpi;\n \n    <span class=\"blue\">using</span>( <span class=\"teal\">Graphics</span> g = <span class=\"teal\">Graphics</span>.FromHwnd( <span class=\"teal\">IntPtr</span>.Zero ) )\n    {\n      xDpi = g.DpiX;\n      yDpi = g.DpiY;\n    }\n    <span class=\"blue\">return</span> xDpi;\n  }\n \n  <span class=\"blue\">static</span> <span class=\"blue\">double</span> GetStringWidth( <span class=\"blue\">string</span> text, <span class=\"teal\">Font</span> font )\n  {\n    <span class=\"blue\">double</span> textWidth = 0.0;\n \n    <span class=\"blue\">using</span>( <span class=\"teal\">Graphics</span> g = <span class=\"teal\">Graphics</span>.FromHwnd( <span class=\"teal\">IntPtr</span>.Zero ) )\n    {\n      textWidth = g.MeasureString( text, font ).Width;\n    }\n    <span class=\"blue\">return</span> textWidth;\n  }\n \n  <span class=\"blue\">public</span> <span class=\"teal\">Result</span> Execute(\n    <span class=\"teal\">ExternalCommandData</span> commandData,\n    <span class=\"blue\">ref</span> <span class=\"blue\">string</span> message,\n    <span class=\"teal\">ElementSet</span> elements )\n  {\n    <span class=\"teal\">Result</span> commandResult = <span class=\"teal\">Result</span>.Succeeded;\n \n    <span class=\"blue\">try</span>\n    {\n      <span class=\"teal\">UIApplication</span> uiApp = commandData.Application;\n      <span class=\"teal\">UIDocument</span> uiDoc = uiApp.ActiveUIDocument;\n      <span class=\"teal\">Document</span> dbDoc = uiDoc.Document;\n      <span class=\"teal\">View</span> view = uiDoc.ActiveGraphicalView;\n \n      <span class=\"teal\">XYZ</span> pLoc = <span class=\"teal\">XYZ</span>.Zero;\n \n      <span class=\"blue\">try</span>\n      {\n        pLoc = uiDoc.Selection.PickPoint(\n          <span class=\"maroon\">\"Please pick text insertion point\"</span> );\n      }\n      <span class=\"blue\">catch</span>( Autodesk.Revit.Exceptions.<span class=\"teal\">OperationCanceledException</span> )\n      {\n        <span class=\"teal\">Debug</span>.WriteLine( <span class=\"maroon\">\"Operation cancelled.\"</span> );\n        message = <span class=\"maroon\">\"Operation cancelled.\"</span>;\n \n        <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Succeeded;\n      }\n \n      <span class=\"teal\">List</span>&lt;<span class=\"teal\">TextNoteType</span>&gt; noteTypeList\n        = <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( dbDoc )\n          .OfClass( <span class=\"blue\">typeof</span>( <span class=\"teal\">TextNoteType</span> ) )\n          .Cast&lt;<span class=\"teal\">TextNoteType</span>&gt;()\n          .ToList();\n \n      <span class=\"green\">// Sort note types into ascending text size</span>\n \n      <span class=\"teal\">BuiltInParameter</span> bipTextSize\n        = <span class=\"teal\">BuiltInParameter</span>.TEXT_SIZE;\n \n      noteTypeList.Sort( ( a, b )\n        =&gt; a.get_Parameter( bipTextSize ).AsDouble()\n          .CompareTo(\n            b.get_Parameter( bipTextSize ).AsDouble() ) );\n \n      <span class=\"blue\">foreach</span>( <span class=\"teal\">TextNoteType</span> textType <span class=\"blue\">in</span> noteTypeList )\n      {\n        <span class=\"teal\">Debug</span>.WriteLine( textType.Name );\n \n        <span class=\"teal\">Parameter</span> paramTextFont\n          = textType.get_Parameter(\n            <span class=\"teal\">BuiltInParameter</span>.TEXT_FONT );\n \n        <span class=\"teal\">Parameter</span> paramTextSize\n          = textType.get_Parameter(\n            <span class=\"teal\">BuiltInParameter</span>.TEXT_SIZE );\n \n        <span class=\"teal\">Parameter</span> paramBorderSize\n          = textType.get_Parameter(\n            <span class=\"teal\">BuiltInParameter</span>.LEADER_OFFSET_SHEET );\n \n        <span class=\"teal\">Parameter</span> paramTextBold\n          = textType.get_Parameter(\n            <span class=\"teal\">BuiltInParameter</span>.TEXT_STYLE_BOLD );\n \n        <span class=\"teal\">Parameter</span> paramTextItalic\n          = textType.get_Parameter(\n            <span class=\"teal\">BuiltInParameter</span>.TEXT_STYLE_ITALIC );\n \n        <span class=\"teal\">Parameter</span> paramTextUnderline\n          = textType.get_Parameter(\n            <span class=\"teal\">BuiltInParameter</span>.TEXT_STYLE_UNDERLINE );\n \n        <span class=\"teal\">Parameter</span> paramTextWidthScale\n          = textType.get_Parameter(\n            <span class=\"teal\">BuiltInParameter</span>.TEXT_WIDTH_SCALE );\n \n        <span class=\"blue\">string</span> fontName = paramTextFont.AsString();\n \n        <span class=\"blue\">double</span> textHeight = paramTextSize.AsDouble();\n \n        <span class=\"blue\">bool</span> textBold = paramTextBold.AsInteger() == 1\n          ? <span class=\"blue\">true</span> : <span class=\"blue\">false</span>;\n \n        <span class=\"blue\">bool</span> textItalic = paramTextItalic.AsInteger() == 1\n          ? <span class=\"blue\">true</span> : <span class=\"blue\">false</span>;\n \n        <span class=\"blue\">bool</span> textUnderline = paramTextUnderline.AsInteger() == 1\n          ? <span class=\"blue\">true</span> : <span class=\"blue\">false</span>;\n \n        <span class=\"blue\">double</span> textBorder = paramBorderSize.AsDouble();\n \n        <span class=\"blue\">double</span> textWidthScale = paramTextWidthScale.AsDouble();\n \n        <span class=\"teal\">FontStyle</span> textStyle = <span class=\"teal\">FontStyle</span>.Regular;\n \n        <span class=\"blue\">if</span>( textBold )\n        {\n          textStyle |= <span class=\"teal\">FontStyle</span>.Bold;\n        }\n \n        <span class=\"blue\">if</span>( textItalic )\n        {\n          textStyle |= <span class=\"teal\">FontStyle</span>.Italic;\n        }\n \n        <span class=\"blue\">if</span>( textUnderline )\n        {\n          textStyle |= <span class=\"teal\">FontStyle</span>.Underline;\n        }\n \n        <span class=\"blue\">float</span> fontHeightInch = (<span class=\"blue\">float</span>) textHeight * 12.0f;\n        <span class=\"blue\">float</span> displayDpiX = GetDpiX();\n \n        <span class=\"blue\">float</span> fontDpi = 96.0f;\n        <span class=\"blue\">float</span> pointSize = (<span class=\"blue\">float</span>) ( textHeight * 12.0 * fontDpi );\n \n        <span class=\"teal\">Font</span> font = <span class=\"blue\">new</span> <span class=\"teal\">Font</span>( fontName, pointSize, textStyle );\n \n        <span class=\"blue\">int</span> viewScale = view.Scale;\n \n        <span class=\"blue\">using</span>( <span class=\"teal\">Transaction</span> t = <span class=\"blue\">new</span> <span class=\"teal\">Transaction</span>( dbDoc ) )\n        {\n          t.Start( <span class=\"maroon\">\"Test TextNote lineWidth calculation\"</span> );\n \n          <span class=\"blue\">string</span> textString = textType.Name\n            + <span class=\"maroon\">\" (\"</span> + fontName + <span class=\"maroon\">\" \"</span>\n            + ( textHeight * 304.8 ).ToString( <span class=\"maroon\">\"0.##\"</span> ) + <span class=\"maroon\">\"mm, \"</span>\n            + textStyle.ToString() + <span class=\"maroon\">\", \"</span>\n            + ( textWidthScale * 100.0 ).ToString( <span class=\"maroon\">\"0.##\"</span> )\n            + <span class=\"maroon\">\"%): The quick brown fox jumps over the lazy dog.\"</span>;\n \n          <span class=\"blue\">double</span> stringWidthPx = GetStringWidth( textString, font );\n \n          <span class=\"blue\">double</span> stringWidthIn = stringWidthPx / displayDpiX;\n \n          <span class=\"teal\">Debug</span>.WriteLine( <span class=\"maroon\">\"String Width in pixels: \"</span>\n            + stringWidthPx.ToString( <span class=\"maroon\">\"F3\"</span> ) );\n          <span class=\"teal\">Debug</span>.WriteLine( ( stringWidthIn * 25.4 * viewScale ).ToString( <span class=\"maroon\">\"F3\"</span> )\n            + <span class=\"maroon\">\" mm at 1:\"</span> + viewScale.ToString() );\n \n          <span class=\"blue\">double</span> stringWidthFt = stringWidthIn / 12.0;\n \n          <span class=\"blue\">double</span> lineWidth = ( ( stringWidthFt * textWidthScale )\n            + ( textBorder * 2.0 ) ) * viewScale;\n \n          <span class=\"teal\">TextNote</span> textNote = dbDoc.Create.NewTextNote(\n            view, pLoc, <span class=\"teal\">XYZ</span>.BasisX, <span class=\"teal\">XYZ</span>.BasisY, 0.001,\n            <span class=\"teal\">TextAlignFlags</span>.TEF_ALIGN_LEFT\n            | <span class=\"teal\">TextAlignFlags</span>.TEF_ALIGN_TOP, textString );\n \n          textNote.TextNoteType = textType;\n          textNote.Width = lineWidth;\n \n          t.Commit();\n        }\n \n        <span class=\"green\">// Place next text note below this one with 5 mm gap</span>\n \n        pLoc += view.UpDirection.Multiply(\n          ( textHeight + ( 5.0 / 304.8 ) )\n            * viewScale ).Negate();\n      }\n    }\n    <span class=\"blue\">catch</span>( Autodesk.Revit.Exceptions.<span class=\"teal\">ExternalApplicationException</span> e )\n    {\n      message = e.Message;\n      <span class=\"teal\">Debug</span>.WriteLine( <span class=\"maroon\">\"Exception Encountered (Application)\\n\"</span>\n        + e.Message + <span class=\"maroon\">\"\\nStack Trace: \"</span> + e.StackTrace );\n \n      commandResult = <span class=\"teal\">Result</span>.Failed;\n    }\n    <span class=\"blue\">catch</span>( <span class=\"teal\">Exception</span> e )\n    {\n      message = e.Message;\n      <span class=\"teal\">Debug</span>.WriteLine( <span class=\"maroon\">\"Exception Encountered (General)\\n\"</span>\n        + e.Message + <span class=\"maroon\">\"\\nStack Trace: \"</span> + e.StackTrace );\n \n      commandResult = <span class=\"teal\">Result</span>.Failed;\n    }\n    <span class=\"blue\">return</span> commandResult;\n  }\n</pre><p>This provides good results.\nPlease test it out with various combinations of textnote styles with width factors like 0.75 and you'll see that it does sometimes fail at larger text heights, e.g. &gt; 16mm.\nOverall I'm happy with it, though, and will be adding it to my framework as a basis for several commands I've been meaning to add for a while now.</p><p><strong>Response:</strong> Your new implementation based on Graphics.MeasureString instead of TextRenderer.MeasureText works perfectly for me in all the simple standard cases:</p><center>\n<img alt=\"Text note width using Graphics.MeasureString\" src=\"img/text_width_4_iterate.png\" width=\"827\"/>\n</center><p>I added this as a new external command CmdNewTextNote to\n\n<a href=\"https://github.com/jeremytammik/the_building_coder_samples\">The Building Coder samples</a> published\n\non GitHub.</p><p>Your current code is tagged as\n\n<a href=\"https://github.com/jeremytammik/the_building_coder_samples/releases/tag/2015.0.114.2\">\nrelease 2015.0.114.2</a>.</p><p>Thank you!</p>"
  }
]