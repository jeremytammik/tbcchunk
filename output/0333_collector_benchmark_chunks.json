[
  {
    "original_filename": "0333_collector_benchmark",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<head>\n<link href=\"bc.css\" rel=\"stylesheet\" type=\"text/css\"/>\n</head>"
  },
  {
    "original_filename": "0333_collector_benchmark",
    "header_text": "Collector Benchmark",
    "local_header_href": "#collector-benchmark",
    "chunk_text": "<h3>Collector Benchmark</h3><p>After all the preparation creating a\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/03/performance-profiling.html\">\nprofiling tool</a>,\n\nlet us now put it to use on the Revit 2011 collectors, which is one of the areas that has been most heavily reworked in this release and at the same time affects more applications than any other, in fact just about every single one.\nThis has led to a rather huge post for today, but I really wanted to share these important results with just as soon as possible.\n\n<p>First of all, what is this all about?\nHere is a quick first introduction to the Revit 2011 filtering and pointers to further reading:\n\n<h4>New Element Iteration Interfaces</h4>\n<p>The element iteration part of the Revit API has been completely redesigned.\nThis will affect virtually all existing add-ins, since they all need to access elements to query or modify their properties.\nThe new API is much more aligned and provides better access to internal optimised functionality within Revit, providing a significant speed increase and smaller memory footprint.\nHere are some of its advantages:\n\n<ul>\n<li>Iterate and filter elements from a document, or only elements from an arbitrary list of element ids, or elements visible in a view (replacing View.Elements).\n<li>Clearly identify so-called quick filters which are designed for best performance and do not expand the element in memory when evaluating whether it passes the filter.\n<li>Use chained shortcuts which automatically apply commonly used filters:\n\n<pre class=\"code\">\ncollector\n  .OfClass( <span class=\"blue\">typeof</span>( <span class=\"teal\">Wall</span> ) )\n  .ContainedInDesignOption( myDesignOptionId );\n</pre>\n<li>Logically group more than two filters.\n<li>Match derived types automatically when using the type filter and type filter shortcut.\n<li>Iterate elements from all design options or from any specific design option.\n<li>Process the collector results using foreach statements and LINQ queries:\n\n<pre class=\"code\">\n<span class=\"teal\">IEnumerable</span>&lt;<span class=\"teal\">FamilySymbol</span>&gt; symbols =\n  <span class=\"blue\">from</span> <span class=\"teal\">FamilySymbol</span> fs <span class=\"blue\">in</span> collector\n  <span class=\"blue\">where</span> fs.Family.Name == familyName\n  <span class=\"blue\">select</span> fs;\n</pre>\n</li></li></li></li></li></li></li></ul>\n<p>The element filtering is performed by FilteredElementCollector instances which are instantiated for a given document, view or list of elements to work with.\nNumerous filtering options can be applied, and a collection of elements matching the specified criteria is returned.\nThis collection supports further filtering using .NET functionality such as foreach and\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2009/07/language-integrated-query-linq.html\">\nLINQ</a>.\n\n<p>Here is a small VSTA sample that looks for a specific family and returns all its symbols:\n\n<pre class=\"code\">\n<span class=\"blue\">public</span> <span class=\"blue\">void</span> MyTest()\n{\n  <span class=\"blue\">string</span> familyName = <span class=\"maroon\">\"Single-Flush\"</span>;\n  <span class=\"teal\">Document</span> doc = <span class=\"blue\">this</span>.ActiveUIDocument.Document;\n \n  <span class=\"green\">// get the family we want</span>\n \n  <span class=\"teal\">FilteredElementCollector</span> fec\n    = <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( doc );\n \n  fec.OfClass( <span class=\"blue\">typeof</span>( <span class=\"teal\">Family</span> ) );\n \n  <span class=\"teal\">IEnumerable</span>&lt;<span class=\"teal\">Family</span>&gt; families =\n    <span class=\"blue\">from</span> <span class=\"teal\">Family</span> f <span class=\"blue\">in</span> fec\n    <span class=\"blue\">where</span> f.Name == familyName\n    <span class=\"blue\">select</span> f;\n \n  <span class=\"green\">// get the symbols of that family</span>\n \n  <span class=\"teal\">FamilySymbolFilter</span> fsf\n    = <span class=\"blue\">new</span> <span class=\"teal\">FamilySymbolFilter</span>(\n        families.First&lt;<span class=\"teal\">Family</span>&gt;().Id );\n \n  fec = <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( doc );\n  fec.WherePasses( fsf );\n \n  <span class=\"green\">// list them</span>\n \n  StringBuilder str = <span class=\"blue\">new</span> StringBuilder();\n  <span class=\"blue\">foreach</span>( <span class=\"teal\">FamilySymbol</span> fs <span class=\"blue\">in</span> fec )\n    str.Append( fs.Name + <span class=\"maroon\">\"\\n\"</span> );\n \n  System.Windows.Forms.<span class=\"teal\">MessageBox</span>.Show(\n    str.ToString(),\n    <span class=\"maroon\">\"FamilySymbols of \"</span> + familyName );\n}\n</pre>\n<p>Further information on this topic is provided in the Revit 2011 SDK, in the API Reference RevitAPI.chm, in the sections on Whats New and Element Iteration API, and also in the Developer Guide.\n\n<p>So with the introduction out of the way, let's get on with our research and analysis to find out how to make optimal use of it.\n\n\n<h4>Benchmarking Element Iteration Collectors</h4>\n<p>I implemented a new command CmdCollectorPerformance in The Building Coder sample application, the first pure Revit 2011 one.\nIt performs the following three steps:\n\n<ol>\n<li>Create a largish number of levels for us to play making use of the CreateLevel helper method, which simply creates a new level at a given elevation.\n<li>BenchmarkAllLevels –\n     Benchmark various approaches to using\n     filtered collectors to retrieve\n     all levels in the model,\n     and measure the time required to\n     create IList and List collections from them.\n<li>BenchmarkSpecificLevel –\n     Benchmark using a parameter filter versus\n     various kinds of post processing of the\n     results returned by the filtered element\n     collector to find the level specified by\n     iLevel.\n</li></li></li></ol>\n<h4>Setting up the Test Model</h4>\n<p>We simply use a number of levels as a test set.\nHere is the code used to create an individual level:\n\n<pre class=\"code\">\n<span class=\"teal\">Level</span> CreateLevel( <span class=\"blue\">int</span> elevation )\n{\n  <span class=\"teal\">Level</span> level = _doc.Create.NewLevel( elevation );\n  level.Name = <span class=\"maroon\">\"Level \"</span> + elevation.ToString();\n  <span class=\"blue\">return</span> level;\n}\n</pre>\n<p>This loop is used to drive it to create a large number of levels:\n\n<pre class=\"code\">\n  <span class=\"blue\">int</span> maxLevel = 1000;\n  <span class=\"blue\">for</span>( <span class=\"blue\">int</span> i = 3; i &lt; maxLevel; ++i )\n  {\n    CreateLevel( i );\n  }\n</pre>\n<p>If this is run in a default new Revit Architecture model, we will end up with the two pre-defined levels 1 and 2 plus newly generated ones numbered up to 999 for a total of 999 levels in all.\n\n<h4>Test Methods to Retrieve all Levels</h4>\n<p>In the following benchmarking tests, I always included a test using an empty method that does nothing at all, just to ensure that the minimal overhead of calling the method and running the test itself is negligible compared to the functionality that I am actually benchmarking.\nThat is the reason for implementing these pretty trivial test methods:\n\n<pre class=\"code\">\n<span class=\"teal\">Element</span> EmptyMethod( <span class=\"teal\">Type</span> type )\n{\n  <span class=\"blue\">return</span> <span class=\"blue\">null</span>;\n}\n \n<span class=\"teal\">Element</span> EmptyMethod( <span class=\"teal\">Type</span> type, <span class=\"blue\">string</span> name )\n{\n  <span class=\"blue\">return</span> <span class=\"blue\">null</span>;\n}\n</pre>\n<p>Here are the basic minimal collector methods which we need to get any access at all to the Revit database elements:\n\n<ul>\n<li>GetNonElementTypeElements – Return all non ElementType elements.\n<li>GetElementsOfType – Return a collector of all elements of the given type.\n<li>GetFirstElementOfType – Return the first element of the given type without any further filtering.\n</li></li></li></ul>\n<p>The first is used to return all elements which are not derived from ElementType.\nThis is used to compare the time required to check the type of elements manually against the time it takes the dedicated Revit filtering functionality used by GetElementsOfType to do the same thing.\n\n<pre class=\"code\">\n<span class=\"teal\">FilteredElementCollector</span> GetNonElementTypeElements()\n{\n  <span class=\"blue\">return</span> <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( _doc )\n    .WhereElementIsNotElementType();\n}\n \n<span class=\"teal\">FilteredElementCollector</span> GetElementsOfType(\n  <span class=\"teal\">Type</span> type )\n{\n  <span class=\"blue\">return</span> <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( _doc )\n    .OfClass( type );\n}\n \n<span class=\"teal\">Element</span> GetFirstElementOfType(\n  <span class=\"teal\">Type</span> type )\n{\n  <span class=\"blue\">return</span> <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( _doc )\n    .OfClass( type )\n    .FirstElement();\n}\n</pre>\n<p>Here are two methods that use explicit coding and a LINQ query to filter for a specific element type:\n\n<ul>\n<li>GetElementsOfTypeUsingExplicitCode –\n     Return a list of all elements matching\n     the given type using explicit code to test\n     the element type.\n<li>GetElementsOfTypeUsingLinq –\n     Return a list of all elements matching\n     the given type using a LINQ query to test\n     the element type.\n</li></li></ul>\n<pre class=\"code\">\n<span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt; GetElementsOfTypeUsingExplicitCode(\n  <span class=\"teal\">Type</span> type )\n{\n  <span class=\"teal\">FilteredElementCollector</span> a\n    = GetNonElementTypeElements();\n \n  <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt; b = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt;();\n  <span class=\"blue\">foreach</span>( <span class=\"teal\">Element</span> e <span class=\"blue\">in</span> a )\n  {\n    <span class=\"blue\">if</span>( e.GetType().Equals( type ) )\n    {\n      b.Add( e );\n    }\n  }\n  <span class=\"blue\">return</span> b;\n}\n \n<span class=\"teal\">IEnumerable</span>&lt;<span class=\"teal\">Element</span>&gt; GetElementsOfTypeUsingLinq(\n  <span class=\"teal\">Type</span> type )\n{\n  <span class=\"teal\">FilteredElementCollector</span> a\n    = GetNonElementTypeElements();\n \n  <span class=\"teal\">IEnumerable</span>&lt;<span class=\"teal\">Element</span>&gt; b =\n    <span class=\"blue\">from</span> e <span class=\"blue\">in</span> a\n    <span class=\"blue\">where</span> e.GetType().Equals( type )\n    <span class=\"blue\">select</span> e;\n \n  <span class=\"blue\">return</span> b;\n}\n</pre>\n<p>The performance of these is then compared with GetElementsOfType using the OfClass method to achieve the same thing.\n\n<h4>Benchmarking Retrieval of all Levels</h4>\n<p>Here is the mainline code that we use to drive the benchmarking of the time required to retrieve all levels in different ways:\n\n<pre class=\"code\">\n  <span class=\"blue\">int</span> nLevels = GetElementsOfType( <span class=\"blue\">typeof</span>( <span class=\"teal\">Level</span> ) )\n    .ToElements().Count;\n \n  <span class=\"blue\">int</span> nRuns = 1000;\n \n  <span class=\"teal\">JtTimer</span> totalTimer = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>(\n    <span class=\"maroon\">\"TOTAL TIME\"</span> );\n \n  <span class=\"blue\">using</span>( totalTimer )\n  {\n    <span class=\"blue\">for</span>( <span class=\"blue\">int</span> i = 0; i &lt; nRuns; ++i )\n    {\n      BenchmarkAllLevels( nLevels );\n    }\n  }\n \n  totalTimer.Report( <span class=\"maroon\">\"Retrieve all levels:\"</span> );\n</pre>\n<p>The interesting question now is what exactly happens in the BenchmarkAllLevels method, and what the reported results look like.\n\n<p>BenchmarkAllLevels takes one argument, the count of levels, which is simply used to verify that the results from some of the test methods make sense.\nIt benchmarks several different approaches to using filtered collectors to retrieve all levels in the model and measure the time required to create IList and List collections from them:\n\n<pre class=\"code\">\n<span class=\"blue\">void</span> BenchmarkAllLevels( <span class=\"blue\">int</span> nLevels )\n{\n  <span class=\"teal\">Type</span> t = <span class=\"blue\">typeof</span>( <span class=\"teal\">Level</span> );\n  <span class=\"blue\">int</span> n;\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>(\n    <span class=\"maroon\">\"Empty method *\"</span> ) )\n  {\n    EmptyMethod( t );\n  }\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>(\n    <span class=\"maroon\">\"NotElementType *\"</span> ) )\n  {\n    <span class=\"teal\">FilteredElementCollector</span> a\n      = GetNonElementTypeElements();\n  }\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>(\n    <span class=\"maroon\">\"NotElementType as IList *\"</span> ) )\n  {\n    <span class=\"teal\">IList</span>&lt;<span class=\"teal\">Element</span>&gt; a\n      = GetNonElementTypeElements().ToElements();\n    n = a.Count;\n  }\n  <span class=\"teal\">Debug</span>.Assert( nLevels &lt;= n,\n    <span class=\"maroon\">\"expected to retrieve all non-element-type elements\"</span> );\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>(\n    <span class=\"maroon\">\"NotElementType as List *\"</span> ) )\n  {\n    <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt; a = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt;(\n      GetNonElementTypeElements() );\n \n    n = a.Count;\n  }\n  <span class=\"teal\">Debug</span>.Assert( nLevels &lt;= n,\n    <span class=\"maroon\">\"expected to retrieve all non-element-type elements\"</span> );\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>( <span class=\"maroon\">\"Explicit\"</span> ) )\n  {\n    <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt; a\n      = GetElementsOfTypeUsingExplicitCode( t );\n \n    n = a.Count;\n  }\n  <span class=\"teal\">Debug</span>.Assert( nLevels == n,\n    <span class=\"maroon\">\"expected to retrieve all levels\"</span> );\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>( <span class=\"maroon\">\"Linq\"</span> ) )\n  {\n    <span class=\"teal\">IEnumerable</span>&lt;<span class=\"teal\">Element</span>&gt; a =\n      GetElementsOfTypeUsingLinq( t );\n \n    n = a.Count&lt;<span class=\"teal\">Element</span>&gt;();\n  }\n  <span class=\"teal\">Debug</span>.Assert( nLevels == n,\n    <span class=\"maroon\">\"expected to retrieve all levels\"</span> );\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>(\n    <span class=\"maroon\">\"Linq as List\"</span> ) )\n  {\n    <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt; a = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt;(\n      GetElementsOfTypeUsingLinq( t ) );\n \n    n = a.Count;\n  }\n  <span class=\"teal\">Debug</span>.Assert( nLevels == n,\n    <span class=\"maroon\">\"expected to retrieve all levels\"</span> );\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>( <span class=\"maroon\">\"Collector\"</span> ) )\n  {\n    <span class=\"teal\">FilteredElementCollector</span> a\n      = GetElementsOfType( t );\n  }\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>(\n    <span class=\"maroon\">\"Collector as IList\"</span> ) )\n  {\n    <span class=\"teal\">IList</span>&lt;<span class=\"teal\">Element</span>&gt; a\n      = GetElementsOfType( t ).ToElements();\n \n    n = a.Count;\n  }\n  <span class=\"teal\">Debug</span>.Assert( nLevels == n,\n    <span class=\"maroon\">\"expected to retrieve all levels\"</span> );\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>(\n    <span class=\"maroon\">\"Collector as List\"</span> ) )\n  {\n    <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt; a = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt;(\n      GetElementsOfType( t ) );\n \n    n = a.Count;\n  }\n  <span class=\"teal\">Debug</span>.Assert( nLevels == n,\n    <span class=\"maroon\">\"expected to retrieve all levels\"</span> );\n}\n</pre>\n<p>Here are the results of running this, i.e. 1000 repetitions of retrieving all the 999 levels in several different ways:\n\n<pre>\n------------------------------------------------------------------------\nRetrieve all levels:\n Percentage   Seconds   Calls   Process\n------------------------------------------------------------------------\n      0.00%      0.00    1000   Empty method *\n      0.01%      0.01    1000   NotElementType *\n      0.02%      0.03    1000   Collector\n      3.85%      7.95    1000   Collector as IList\n      6.42%     13.26    1000   Collector as List\n      9.24%     19.07    1000   NotElementType as IList *\n     20.03%     41.37    1000   Explicit\n     20.07%     41.46    1000   Linq\n     20.12%     41.54    1000   NotElementType as List *\n     20.21%     41.73    1000   Linq as List\n    100.00%    206.51       1   TOTAL TIME\n------------------------------------------------------------------------\n</pre>\n<p>The entries marked with an asterisk * do not perform the full operation that the others complete.\nThey have been added to measure specific minimum overhead delays.\nFor example, we call an empty method to determine the overhead of the function call itself and to prove that this is completely negligible in comparison to the overall time.\n\n<p>There are lots of things to point out here:\n\n<ul>\n<li>The calls to the empty method really are negligible.\n<li>The three calls to NotElementType return over 3000 elements, i.e. more than just the levels, and do not have any overhead for filtering out any specific type.\nThey also give us an idea of the overhead required to convert the collector results to a generic IList and List instance.\nAs one might expect, creating a List causes a significantly larger overhead than an IList.\nAn IList is returned directly by the collector ToElements method, whereas a List requires an explicit call to a copy constructor.\n<li>The pure collector call using OfClass is fastest and easiest. Again, conversion to IList or List is much more expensive than the filtering operation itself.\n<li>Using explicit code or LINQ to filter is a thousand times as expensive as using the built-in collector filtering.\n<li>There is hardly any performance difference between using LINQ or explicit code.\n</li></li></li></li></li></ul>\n<p>I find these results very interesting and illuminating.\n\n<p>The really good news is that the Revit filtering is extremely efficient, and anything you add to it, such as converting the results to generic List, will cost much more time than the filtering operation itself.\n\n<p>I want to discuss the results of selecting an individual element as well, but I will have to postpone that until after Easter, because I am really running out of time here.\n\n<p>Or no, I will just cut it really short.\n\n\n<h4>Benchmarking Retrieval of a Specific Named Level</h4>\n<p>The following BenchmarkSpecificLevel method lists the various tests that I implemented and compared to retrieve a specific named element.\nIt benchmarks the use of a parameter filter versus\n     various kinds of post processing of the\n     results returned by the filtered element\n     collector to find the level specified by the iLevel argument:\n\n<pre class=\"code\">\n<span class=\"blue\">void</span> BenchmarkSpecificLevel( <span class=\"blue\">int</span> iLevel )\n{\n  <span class=\"teal\">Type</span> t = <span class=\"blue\">typeof</span>( <span class=\"teal\">Level</span> );\n  <span class=\"blue\">string</span> name = <span class=\"maroon\">\"Level \"</span> + iLevel.ToString();\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>(\n    <span class=\"maroon\">\"Empty method *\"</span> ) )\n  {\n    <span class=\"teal\">Element</span> level\n      = EmptyMethod(\n        t, name );\n  }\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>(\n    <span class=\"maroon\">\"Collector with no name check *\"</span> ) )\n  {\n    <span class=\"teal\">Element</span> level = GetFirstElementOfType( t );\n  }\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>(\n    <span class=\"maroon\">\"Parameter filter\"</span> ) )\n  {\n    <span class=\"teal\">Element</span> level\n      = GetFirstNamedElementOfTypeUsingParameterFilter(\n        t, name );\n  }\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>( <span class=\"maroon\">\"Explicit\"</span> ) )\n  {\n    <span class=\"teal\">Element</span> level\n      = GetFirstNamedElementOfTypeUsingExplicitCode(\n        t, name );\n  }\n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>( <span class=\"maroon\">\"Linq\"</span> ) )\n  {\n    <span class=\"teal\">Element</span> level\n      = GetFirstNamedElementOfTypeUsingLinq(\n        t, name );\n  }\n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>(\n    <span class=\"maroon\">\"Anonymous named\"</span> ) )\n  {\n    <span class=\"teal\">Element</span> level\n      = GetFirstNamedElementOfTypeUsingAnonymousButNamedMethod(\n        t, name );\n  }\n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>( <span class=\"maroon\">\"Anonymous\"</span> ) )\n  {\n    <span class=\"teal\">Element</span> level\n      = GetFirstNamedElementOfTypeUsingAnonymousMethod(\n        t, name );\n  }\n}\n</pre>\n<p>Ah yes, we still have not presented all the test methods that we are comparing yet.\nThey are:\n\n<ul>\n<li>GetFirstNamedElementOfTypeUsingExplicitCode – Return the first element of the given type and name using explicit code.\n<li>GetFirstNamedElementOfTypeUsingLinq – Return the first element of the given type and name using LINQ.\n<li>GetFirstNamedElementOfTypeUsingAnonymousButNamedMethod – Return the first element of the given type and name using an anonymous method to define a named method.\n<li>GetFirstNamedElementOfTypeUsingAnonymousMethod – Return the first element of the given type and name using an anonymous method.\n</li></li></li></li></ul>\n<pre class=\"code\">\n<span class=\"teal\">Element</span> GetFirstNamedElementOfTypeUsingExplicitCode(\n  <span class=\"teal\">Type</span> type,\n  <span class=\"blue\">string</span> name )\n{\n  <span class=\"teal\">FilteredElementCollector</span> a\n    = GetElementsOfType( type );\n  <span class=\"green\">//</span>\n  <span class=\"green\">// explicit iteration and manual checking of a property:</span>\n  <span class=\"green\">//</span>\n  <span class=\"teal\">Element</span> ret = <span class=\"blue\">null</span>;\n  <span class=\"blue\">foreach</span>( <span class=\"teal\">Element</span> e <span class=\"blue\">in</span> a )\n  {\n    <span class=\"blue\">if</span>( e.Name.Equals( name ) )\n    {\n      ret = e;\n      <span class=\"blue\">break</span>;\n    }\n  }\n  <span class=\"blue\">return</span> ret;\n}\n \n<span class=\"teal\">Element</span> GetFirstNamedElementOfTypeUsingLinq(\n  <span class=\"teal\">Type</span> type,\n  <span class=\"blue\">string</span> name )\n{\n  <span class=\"teal\">FilteredElementCollector</span> a\n    = GetElementsOfType( type );\n  <span class=\"green\">//</span>\n  <span class=\"green\">// using LINQ:</span>\n  <span class=\"green\">//</span>\n  <span class=\"teal\">IEnumerable</span>&lt;<span class=\"teal\">Element</span>&gt; elementsByName =\n    <span class=\"blue\">from</span> e <span class=\"blue\">in</span> a\n    <span class=\"blue\">where</span> e.Name.Equals( name )\n    <span class=\"blue\">select</span> e;\n \n  <span class=\"blue\">return</span> elementsByName.First&lt;<span class=\"teal\">Element</span>&gt;();\n}\n \n<span class=\"teal\">Element</span> GetFirstNamedElementOfTypeUsingAnonymousButNamedMethod(\n  <span class=\"teal\">Type</span> type,\n  <span class=\"blue\">string</span> name )\n{\n  <span class=\"teal\">FilteredElementCollector</span> a\n    = GetElementsOfType( type );\n  <span class=\"green\">//</span>\n  <span class=\"green\">// using an anonymous method to define a named method:</span>\n  <span class=\"green\">//</span>\n  <span class=\"teal\">Func</span>&lt;<span class=\"teal\">Element</span>, <span class=\"blue\">bool</span>&gt; nameEquals = e =&gt; e.Name.Equals( name );\n  <span class=\"blue\">return</span> a.First&lt;<span class=\"teal\">Element</span>&gt;( nameEquals );\n}\n \n<span class=\"teal\">Element</span> GetFirstNamedElementOfTypeUsingAnonymousMethod(\n  <span class=\"teal\">Type</span> type,\n  <span class=\"blue\">string</span> name )\n{\n  <span class=\"teal\">FilteredElementCollector</span> a\n    = GetElementsOfType( type );\n  <span class=\"green\">//</span>\n  <span class=\"green\">// using an anonymous method:</span>\n  <span class=\"green\">//</span>\n  <span class=\"blue\">return</span> a.First&lt;<span class=\"teal\">Element</span>&gt;(\n    e =&gt; e.Name.Equals( name ) );\n}\n</pre>\n<p>The most important method of all, as we shall see, is the one making use of the Revit filtering API to search for the named level.\nSetting up a parameter filter is a little bit convoluted, since you need to make use of a number of different helper classes to specify separately the provider, evaluator, rule and filter, but have a look further down to convince yourself that it is worthwhile.\nThis method returns the first element of the given type and name using a parameter filter:\n\n<pre class=\"code\">\n<span class=\"teal\">Element</span> GetFirstNamedElementOfTypeUsingParameterFilter(\n  <span class=\"teal\">Type</span> type,\n  <span class=\"blue\">string</span> name )\n{\n  <span class=\"teal\">FilteredElementCollector</span> a\n    = GetElementsOfType( type );\n \n  <span class=\"teal\">BuiltInParameter</span> bip\n    = <span class=\"teal\">BuiltInParameter</span>.ELEM_NAME_PARAM;\n \n  <span class=\"teal\">ParameterValueProvider</span> provider\n    = <span class=\"blue\">new</span> <span class=\"teal\">ParameterValueProvider</span>(\n      <span class=\"blue\">new</span> <span class=\"teal\">ElementId</span>( bip ) );\n \n  <span class=\"teal\">FilterStringRuleEvaluator</span> evaluator\n    = <span class=\"blue\">new</span> <span class=\"teal\">FilterStringEquals</span>();\n \n  <span class=\"teal\">FilterRule</span> rule = <span class=\"blue\">new</span> <span class=\"teal\">FilterStringRule</span>(\n    provider, evaluator, name, <span class=\"blue\">true</span> );\n \n  <span class=\"teal\">ElementParameterFilter</span> filter\n    = <span class=\"blue\">new</span> <span class=\"teal\">ElementParameterFilter</span>( rule );\n \n  <span class=\"blue\">return</span> a.WherePasses( filter ).FirstElement();\n}\n</pre>\n<p>I drive this by selecting some target level at random and searching for it by name, and repeating that 1000 times over, as follows:\n\n<pre class=\"code\">\n  nRuns = 1000;\n  <span class=\"teal\">Random</span> rand = <span class=\"blue\">new</span> <span class=\"teal\">Random</span>();\n  totalTimer.Restart( <span class=\"maroon\">\"TOTAL TIME\"</span> );\n \n  <span class=\"blue\">using</span>( totalTimer )\n  {\n    <span class=\"blue\">for</span>( <span class=\"blue\">int</span> i = 0; i &lt; nRuns; ++i )\n    {\n      <span class=\"blue\">int</span> iLevel = rand.Next( 1, maxLevel );\n      BenchmarkSpecificLevel( iLevel );\n    }\n  }\n \n  totalTimer.Report(\n    <span class=\"maroon\">\"Retrieve specific named level:\"</span> );\n</pre>\n<p>Here are the results of running this test, i.e. 1000 repetitions of retrieving one specific level from the 999 levels in the model by searching for it by name:\n\n<pre>\n---------------------------------------------------------------\nRetrieve specific named level:\n Percentage   Seconds   Calls   Process\n---------------------------------------------------------------\n      0.00%      0.00    1000   Empty method *\n      0.16%      0.10    1000   Collector with no name check *\n     12.65%      7.96    1000   Parameter filter\n     21.60%     13.60    1000   Anonymous named\n     21.75%     13.70    1000   Explicit\n     21.85%     13.76    1000   Anonymous\n     21.88%     13.77    1000   Linq\n    100.00%     62.96       1   TOTAL TIME\n---------------------------------------------------------------\n</pre>\n<p>Again, the entries marked with an asterisk * do not do the full job and are just included  for baseline comparison purposes.\nThe empty method entry does nothing at all.\nThe collector with no name check collects all levels and simply returns the first one without checking its name.\n\n<p>The important conclusions that I draw from this are:\n\n<ul>\n<li>Once again, making use of the Revit filtering API by using the parameter filter is by far the most efficient approach.\nThe parameter filter is a slow filter, not a quick one, but it is still a lot faster than resorting to any other means.\n<li>There is virtually no performance difference at all between explicit coding, LINQ, and using generic algorithms with anonymous methods.\n</li></li></ul>\n<p>Once again, very illuminating, I would say.\n\n<p>In quintessence, you should do everything that you possibly can using the Revit filters, and avoid all post-processing and manual if at all possible.\n\n<p>Here is\n\n<a href=\"zip/bc_11_63.zip\">\nversion 2011.0.0.63</a>\n\nof the complete Building Coder source code and Visual Studio solution including the new CmdCollectorPerformance external command and the JtTimer profiling classes.</p>\n<p>I hope this keeps you happily informed and occupied over Easter and wish you good luck searching for eggs.\n\n<p>Since I am giving the Revit API training class in Warsaw next week, the posts may become sparse for a while.\n\n<p><strong>Correction:</strong> Please note that the method GetFirstNamedElementOfTypeUsingParameterFilter does not work properly using the built-in parameter ELEM_NAME_PARAM, because it should be looking at DATUM_TEXT instead.\nFor more details, please refer to the subsequent\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/06/element-name-parameter-filter-correction.html\">\nelement name parameter filter correction</a>.\n</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p>"
  },
  {
    "original_filename": "0333_collector_benchmark",
    "header_text": "New Element Iteration Interfaces",
    "local_header_href": "#new-element-iteration-interfaces",
    "chunk_text": "<h4>New Element Iteration Interfaces</h4><p>The element iteration part of the Revit API has been completely redesigned.\nThis will affect virtually all existing add-ins, since they all need to access elements to query or modify their properties.\nThe new API is much more aligned and provides better access to internal optimised functionality within Revit, providing a significant speed increase and smaller memory footprint.\nHere are some of its advantages:\n\n<ul>\n<li>Iterate and filter elements from a document, or only elements from an arbitrary list of element ids, or elements visible in a view (replacing View.Elements).\n<li>Clearly identify so-called quick filters which are designed for best performance and do not expand the element in memory when evaluating whether it passes the filter.\n<li>Use chained shortcuts which automatically apply commonly used filters:\n\n<pre class=\"code\">\ncollector\n  .OfClass( <span class=\"blue\">typeof</span>( <span class=\"teal\">Wall</span> ) )\n  .ContainedInDesignOption( myDesignOptionId );\n</pre>\n<li>Logically group more than two filters.\n<li>Match derived types automatically when using the type filter and type filter shortcut.\n<li>Iterate elements from all design options or from any specific design option.\n<li>Process the collector results using foreach statements and LINQ queries:\n\n<pre class=\"code\">\n<span class=\"teal\">IEnumerable</span>&lt;<span class=\"teal\">FamilySymbol</span>&gt; symbols =\n  <span class=\"blue\">from</span> <span class=\"teal\">FamilySymbol</span> fs <span class=\"blue\">in</span> collector\n  <span class=\"blue\">where</span> fs.Family.Name == familyName\n  <span class=\"blue\">select</span> fs;\n</pre>\n</li></li></li></li></li></li></li></ul>\n<p>The element filtering is performed by FilteredElementCollector instances which are instantiated for a given document, view or list of elements to work with.\nNumerous filtering options can be applied, and a collection of elements matching the specified criteria is returned.\nThis collection supports further filtering using .NET functionality such as foreach and\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2009/07/language-integrated-query-linq.html\">\nLINQ</a>.\n\n<p>Here is a small VSTA sample that looks for a specific family and returns all its symbols:\n\n<pre class=\"code\">\n<span class=\"blue\">public</span> <span class=\"blue\">void</span> MyTest()\n{\n  <span class=\"blue\">string</span> familyName = <span class=\"maroon\">\"Single-Flush\"</span>;\n  <span class=\"teal\">Document</span> doc = <span class=\"blue\">this</span>.ActiveUIDocument.Document;\n \n  <span class=\"green\">// get the family we want</span>\n \n  <span class=\"teal\">FilteredElementCollector</span> fec\n    = <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( doc );\n \n  fec.OfClass( <span class=\"blue\">typeof</span>( <span class=\"teal\">Family</span> ) );\n \n  <span class=\"teal\">IEnumerable</span>&lt;<span class=\"teal\">Family</span>&gt; families =\n    <span class=\"blue\">from</span> <span class=\"teal\">Family</span> f <span class=\"blue\">in</span> fec\n    <span class=\"blue\">where</span> f.Name == familyName\n    <span class=\"blue\">select</span> f;\n \n  <span class=\"green\">// get the symbols of that family</span>\n \n  <span class=\"teal\">FamilySymbolFilter</span> fsf\n    = <span class=\"blue\">new</span> <span class=\"teal\">FamilySymbolFilter</span>(\n        families.First&lt;<span class=\"teal\">Family</span>&gt;().Id );\n \n  fec = <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( doc );\n  fec.WherePasses( fsf );\n \n  <span class=\"green\">// list them</span>\n \n  StringBuilder str = <span class=\"blue\">new</span> StringBuilder();\n  <span class=\"blue\">foreach</span>( <span class=\"teal\">FamilySymbol</span> fs <span class=\"blue\">in</span> fec )\n    str.Append( fs.Name + <span class=\"maroon\">\"\\n\"</span> );\n \n  System.Windows.Forms.<span class=\"teal\">MessageBox</span>.Show(\n    str.ToString(),\n    <span class=\"maroon\">\"FamilySymbols of \"</span> + familyName );\n}\n</pre>\n<p>Further information on this topic is provided in the Revit 2011 SDK, in the API Reference RevitAPI.chm, in the sections on Whats New and Element Iteration API, and also in the Developer Guide.\n\n<p>So with the introduction out of the way, let's get on with our research and analysis to find out how to make optimal use of it.\n\n\n<h4>Benchmarking Element Iteration Collectors</h4>\n<p>I implemented a new command CmdCollectorPerformance in The Building Coder sample application, the first pure Revit 2011 one.\nIt performs the following three steps:\n\n<ol>\n<li>Create a largish number of levels for us to play making use of the CreateLevel helper method, which simply creates a new level at a given elevation.\n<li>BenchmarkAllLevels –\n     Benchmark various approaches to using\n     filtered collectors to retrieve\n     all levels in the model,\n     and measure the time required to\n     create IList and List collections from them.\n<li>BenchmarkSpecificLevel –\n     Benchmark using a parameter filter versus\n     various kinds of post processing of the\n     results returned by the filtered element\n     collector to find the level specified by\n     iLevel.\n</li></li></li></ol>\n<h4>Setting up the Test Model</h4>\n<p>We simply use a number of levels as a test set.\nHere is the code used to create an individual level:\n\n<pre class=\"code\">\n<span class=\"teal\">Level</span> CreateLevel( <span class=\"blue\">int</span> elevation )\n{\n  <span class=\"teal\">Level</span> level = _doc.Create.NewLevel( elevation );\n  level.Name = <span class=\"maroon\">\"Level \"</span> + elevation.ToString();\n  <span class=\"blue\">return</span> level;\n}\n</pre>\n<p>This loop is used to drive it to create a large number of levels:\n\n<pre class=\"code\">\n  <span class=\"blue\">int</span> maxLevel = 1000;\n  <span class=\"blue\">for</span>( <span class=\"blue\">int</span> i = 3; i &lt; maxLevel; ++i )\n  {\n    CreateLevel( i );\n  }\n</pre>\n<p>If this is run in a default new Revit Architecture model, we will end up with the two pre-defined levels 1 and 2 plus newly generated ones numbered up to 999 for a total of 999 levels in all.\n\n<h4>Test Methods to Retrieve all Levels</h4>\n<p>In the following benchmarking tests, I always included a test using an empty method that does nothing at all, just to ensure that the minimal overhead of calling the method and running the test itself is negligible compared to the functionality that I am actually benchmarking.\nThat is the reason for implementing these pretty trivial test methods:\n\n<pre class=\"code\">\n<span class=\"teal\">Element</span> EmptyMethod( <span class=\"teal\">Type</span> type )\n{\n  <span class=\"blue\">return</span> <span class=\"blue\">null</span>;\n}\n \n<span class=\"teal\">Element</span> EmptyMethod( <span class=\"teal\">Type</span> type, <span class=\"blue\">string</span> name )\n{\n  <span class=\"blue\">return</span> <span class=\"blue\">null</span>;\n}\n</pre>\n<p>Here are the basic minimal collector methods which we need to get any access at all to the Revit database elements:\n\n<ul>\n<li>GetNonElementTypeElements – Return all non ElementType elements.\n<li>GetElementsOfType – Return a collector of all elements of the given type.\n<li>GetFirstElementOfType – Return the first element of the given type without any further filtering.\n</li></li></li></ul>\n<p>The first is used to return all elements which are not derived from ElementType.\nThis is used to compare the time required to check the type of elements manually against the time it takes the dedicated Revit filtering functionality used by GetElementsOfType to do the same thing.\n\n<pre class=\"code\">\n<span class=\"teal\">FilteredElementCollector</span> GetNonElementTypeElements()\n{\n  <span class=\"blue\">return</span> <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( _doc )\n    .WhereElementIsNotElementType();\n}\n \n<span class=\"teal\">FilteredElementCollector</span> GetElementsOfType(\n  <span class=\"teal\">Type</span> type )\n{\n  <span class=\"blue\">return</span> <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( _doc )\n    .OfClass( type );\n}\n \n<span class=\"teal\">Element</span> GetFirstElementOfType(\n  <span class=\"teal\">Type</span> type )\n{\n  <span class=\"blue\">return</span> <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( _doc )\n    .OfClass( type )\n    .FirstElement();\n}\n</pre>\n<p>Here are two methods that use explicit coding and a LINQ query to filter for a specific element type:\n\n<ul>\n<li>GetElementsOfTypeUsingExplicitCode –\n     Return a list of all elements matching\n     the given type using explicit code to test\n     the element type.\n<li>GetElementsOfTypeUsingLinq –\n     Return a list of all elements matching\n     the given type using a LINQ query to test\n     the element type.\n</li></li></ul>\n<pre class=\"code\">\n<span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt; GetElementsOfTypeUsingExplicitCode(\n  <span class=\"teal\">Type</span> type )\n{\n  <span class=\"teal\">FilteredElementCollector</span> a\n    = GetNonElementTypeElements();\n \n  <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt; b = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt;();\n  <span class=\"blue\">foreach</span>( <span class=\"teal\">Element</span> e <span class=\"blue\">in</span> a )\n  {\n    <span class=\"blue\">if</span>( e.GetType().Equals( type ) )\n    {\n      b.Add( e );\n    }\n  }\n  <span class=\"blue\">return</span> b;\n}\n \n<span class=\"teal\">IEnumerable</span>&lt;<span class=\"teal\">Element</span>&gt; GetElementsOfTypeUsingLinq(\n  <span class=\"teal\">Type</span> type )\n{\n  <span class=\"teal\">FilteredElementCollector</span> a\n    = GetNonElementTypeElements();\n \n  <span class=\"teal\">IEnumerable</span>&lt;<span class=\"teal\">Element</span>&gt; b =\n    <span class=\"blue\">from</span> e <span class=\"blue\">in</span> a\n    <span class=\"blue\">where</span> e.GetType().Equals( type )\n    <span class=\"blue\">select</span> e;\n \n  <span class=\"blue\">return</span> b;\n}\n</pre>\n<p>The performance of these is then compared with GetElementsOfType using the OfClass method to achieve the same thing.\n\n<h4>Benchmarking Retrieval of all Levels</h4>\n<p>Here is the mainline code that we use to drive the benchmarking of the time required to retrieve all levels in different ways:\n\n<pre class=\"code\">\n  <span class=\"blue\">int</span> nLevels = GetElementsOfType( <span class=\"blue\">typeof</span>( <span class=\"teal\">Level</span> ) )\n    .ToElements().Count;\n \n  <span class=\"blue\">int</span> nRuns = 1000;\n \n  <span class=\"teal\">JtTimer</span> totalTimer = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>(\n    <span class=\"maroon\">\"TOTAL TIME\"</span> );\n \n  <span class=\"blue\">using</span>( totalTimer )\n  {\n    <span class=\"blue\">for</span>( <span class=\"blue\">int</span> i = 0; i &lt; nRuns; ++i )\n    {\n      BenchmarkAllLevels( nLevels );\n    }\n  }\n \n  totalTimer.Report( <span class=\"maroon\">\"Retrieve all levels:\"</span> );\n</pre>\n<p>The interesting question now is what exactly happens in the BenchmarkAllLevels method, and what the reported results look like.\n\n<p>BenchmarkAllLevels takes one argument, the count of levels, which is simply used to verify that the results from some of the test methods make sense.\nIt benchmarks several different approaches to using filtered collectors to retrieve all levels in the model and measure the time required to create IList and List collections from them:\n\n<pre class=\"code\">\n<span class=\"blue\">void</span> BenchmarkAllLevels( <span class=\"blue\">int</span> nLevels )\n{\n  <span class=\"teal\">Type</span> t = <span class=\"blue\">typeof</span>( <span class=\"teal\">Level</span> );\n  <span class=\"blue\">int</span> n;\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>(\n    <span class=\"maroon\">\"Empty method *\"</span> ) )\n  {\n    EmptyMethod( t );\n  }\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>(\n    <span class=\"maroon\">\"NotElementType *\"</span> ) )\n  {\n    <span class=\"teal\">FilteredElementCollector</span> a\n      = GetNonElementTypeElements();\n  }\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>(\n    <span class=\"maroon\">\"NotElementType as IList *\"</span> ) )\n  {\n    <span class=\"teal\">IList</span>&lt;<span class=\"teal\">Element</span>&gt; a\n      = GetNonElementTypeElements().ToElements();\n    n = a.Count;\n  }\n  <span class=\"teal\">Debug</span>.Assert( nLevels &lt;= n,\n    <span class=\"maroon\">\"expected to retrieve all non-element-type elements\"</span> );\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>(\n    <span class=\"maroon\">\"NotElementType as List *\"</span> ) )\n  {\n    <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt; a = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt;(\n      GetNonElementTypeElements() );\n \n    n = a.Count;\n  }\n  <span class=\"teal\">Debug</span>.Assert( nLevels &lt;= n,\n    <span class=\"maroon\">\"expected to retrieve all non-element-type elements\"</span> );\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>( <span class=\"maroon\">\"Explicit\"</span> ) )\n  {\n    <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt; a\n      = GetElementsOfTypeUsingExplicitCode( t );\n \n    n = a.Count;\n  }\n  <span class=\"teal\">Debug</span>.Assert( nLevels == n,\n    <span class=\"maroon\">\"expected to retrieve all levels\"</span> );\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>( <span class=\"maroon\">\"Linq\"</span> ) )\n  {\n    <span class=\"teal\">IEnumerable</span>&lt;<span class=\"teal\">Element</span>&gt; a =\n      GetElementsOfTypeUsingLinq( t );\n \n    n = a.Count&lt;<span class=\"teal\">Element</span>&gt;();\n  }\n  <span class=\"teal\">Debug</span>.Assert( nLevels == n,\n    <span class=\"maroon\">\"expected to retrieve all levels\"</span> );\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>(\n    <span class=\"maroon\">\"Linq as List\"</span> ) )\n  {\n    <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt; a = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt;(\n      GetElementsOfTypeUsingLinq( t ) );\n \n    n = a.Count;\n  }\n  <span class=\"teal\">Debug</span>.Assert( nLevels == n,\n    <span class=\"maroon\">\"expected to retrieve all levels\"</span> );\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>( <span class=\"maroon\">\"Collector\"</span> ) )\n  {\n    <span class=\"teal\">FilteredElementCollector</span> a\n      = GetElementsOfType( t );\n  }\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>(\n    <span class=\"maroon\">\"Collector as IList\"</span> ) )\n  {\n    <span class=\"teal\">IList</span>&lt;<span class=\"teal\">Element</span>&gt; a\n      = GetElementsOfType( t ).ToElements();\n \n    n = a.Count;\n  }\n  <span class=\"teal\">Debug</span>.Assert( nLevels == n,\n    <span class=\"maroon\">\"expected to retrieve all levels\"</span> );\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>(\n    <span class=\"maroon\">\"Collector as List\"</span> ) )\n  {\n    <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt; a = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt;(\n      GetElementsOfType( t ) );\n \n    n = a.Count;\n  }\n  <span class=\"teal\">Debug</span>.Assert( nLevels == n,\n    <span class=\"maroon\">\"expected to retrieve all levels\"</span> );\n}\n</pre>\n<p>Here are the results of running this, i.e. 1000 repetitions of retrieving all the 999 levels in several different ways:\n\n<pre>\n------------------------------------------------------------------------\nRetrieve all levels:\n Percentage   Seconds   Calls   Process\n------------------------------------------------------------------------\n      0.00%      0.00    1000   Empty method *\n      0.01%      0.01    1000   NotElementType *\n      0.02%      0.03    1000   Collector\n      3.85%      7.95    1000   Collector as IList\n      6.42%     13.26    1000   Collector as List\n      9.24%     19.07    1000   NotElementType as IList *\n     20.03%     41.37    1000   Explicit\n     20.07%     41.46    1000   Linq\n     20.12%     41.54    1000   NotElementType as List *\n     20.21%     41.73    1000   Linq as List\n    100.00%    206.51       1   TOTAL TIME\n------------------------------------------------------------------------\n</pre>\n<p>The entries marked with an asterisk * do not perform the full operation that the others complete.\nThey have been added to measure specific minimum overhead delays.\nFor example, we call an empty method to determine the overhead of the function call itself and to prove that this is completely negligible in comparison to the overall time.\n\n<p>There are lots of things to point out here:\n\n<ul>\n<li>The calls to the empty method really are negligible.\n<li>The three calls to NotElementType return over 3000 elements, i.e. more than just the levels, and do not have any overhead for filtering out any specific type.\nThey also give us an idea of the overhead required to convert the collector results to a generic IList and List instance.\nAs one might expect, creating a List causes a significantly larger overhead than an IList.\nAn IList is returned directly by the collector ToElements method, whereas a List requires an explicit call to a copy constructor.\n<li>The pure collector call using OfClass is fastest and easiest. Again, conversion to IList or List is much more expensive than the filtering operation itself.\n<li>Using explicit code or LINQ to filter is a thousand times as expensive as using the built-in collector filtering.\n<li>There is hardly any performance difference between using LINQ or explicit code.\n</li></li></li></li></li></ul>\n<p>I find these results very interesting and illuminating.\n\n<p>The really good news is that the Revit filtering is extremely efficient, and anything you add to it, such as converting the results to generic List, will cost much more time than the filtering operation itself.\n\n<p>I want to discuss the results of selecting an individual element as well, but I will have to postpone that until after Easter, because I am really running out of time here.\n\n<p>Or no, I will just cut it really short.\n\n\n<h4>Benchmarking Retrieval of a Specific Named Level</h4>\n<p>The following BenchmarkSpecificLevel method lists the various tests that I implemented and compared to retrieve a specific named element.\nIt benchmarks the use of a parameter filter versus\n     various kinds of post processing of the\n     results returned by the filtered element\n     collector to find the level specified by the iLevel argument:\n\n<pre class=\"code\">\n<span class=\"blue\">void</span> BenchmarkSpecificLevel( <span class=\"blue\">int</span> iLevel )\n{\n  <span class=\"teal\">Type</span> t = <span class=\"blue\">typeof</span>( <span class=\"teal\">Level</span> );\n  <span class=\"blue\">string</span> name = <span class=\"maroon\">\"Level \"</span> + iLevel.ToString();\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>(\n    <span class=\"maroon\">\"Empty method *\"</span> ) )\n  {\n    <span class=\"teal\">Element</span> level\n      = EmptyMethod(\n        t, name );\n  }\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>(\n    <span class=\"maroon\">\"Collector with no name check *\"</span> ) )\n  {\n    <span class=\"teal\">Element</span> level = GetFirstElementOfType( t );\n  }\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>(\n    <span class=\"maroon\">\"Parameter filter\"</span> ) )\n  {\n    <span class=\"teal\">Element</span> level\n      = GetFirstNamedElementOfTypeUsingParameterFilter(\n        t, name );\n  }\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>( <span class=\"maroon\">\"Explicit\"</span> ) )\n  {\n    <span class=\"teal\">Element</span> level\n      = GetFirstNamedElementOfTypeUsingExplicitCode(\n        t, name );\n  }\n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>( <span class=\"maroon\">\"Linq\"</span> ) )\n  {\n    <span class=\"teal\">Element</span> level\n      = GetFirstNamedElementOfTypeUsingLinq(\n        t, name );\n  }\n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>(\n    <span class=\"maroon\">\"Anonymous named\"</span> ) )\n  {\n    <span class=\"teal\">Element</span> level\n      = GetFirstNamedElementOfTypeUsingAnonymousButNamedMethod(\n        t, name );\n  }\n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>( <span class=\"maroon\">\"Anonymous\"</span> ) )\n  {\n    <span class=\"teal\">Element</span> level\n      = GetFirstNamedElementOfTypeUsingAnonymousMethod(\n        t, name );\n  }\n}\n</pre>\n<p>Ah yes, we still have not presented all the test methods that we are comparing yet.\nThey are:\n\n<ul>\n<li>GetFirstNamedElementOfTypeUsingExplicitCode – Return the first element of the given type and name using explicit code.\n<li>GetFirstNamedElementOfTypeUsingLinq – Return the first element of the given type and name using LINQ.\n<li>GetFirstNamedElementOfTypeUsingAnonymousButNamedMethod – Return the first element of the given type and name using an anonymous method to define a named method.\n<li>GetFirstNamedElementOfTypeUsingAnonymousMethod – Return the first element of the given type and name using an anonymous method.\n</li></li></li></li></ul>\n<pre class=\"code\">\n<span class=\"teal\">Element</span> GetFirstNamedElementOfTypeUsingExplicitCode(\n  <span class=\"teal\">Type</span> type,\n  <span class=\"blue\">string</span> name )\n{\n  <span class=\"teal\">FilteredElementCollector</span> a\n    = GetElementsOfType( type );\n  <span class=\"green\">//</span>\n  <span class=\"green\">// explicit iteration and manual checking of a property:</span>\n  <span class=\"green\">//</span>\n  <span class=\"teal\">Element</span> ret = <span class=\"blue\">null</span>;\n  <span class=\"blue\">foreach</span>( <span class=\"teal\">Element</span> e <span class=\"blue\">in</span> a )\n  {\n    <span class=\"blue\">if</span>( e.Name.Equals( name ) )\n    {\n      ret = e;\n      <span class=\"blue\">break</span>;\n    }\n  }\n  <span class=\"blue\">return</span> ret;\n}\n \n<span class=\"teal\">Element</span> GetFirstNamedElementOfTypeUsingLinq(\n  <span class=\"teal\">Type</span> type,\n  <span class=\"blue\">string</span> name )\n{\n  <span class=\"teal\">FilteredElementCollector</span> a\n    = GetElementsOfType( type );\n  <span class=\"green\">//</span>\n  <span class=\"green\">// using LINQ:</span>\n  <span class=\"green\">//</span>\n  <span class=\"teal\">IEnumerable</span>&lt;<span class=\"teal\">Element</span>&gt; elementsByName =\n    <span class=\"blue\">from</span> e <span class=\"blue\">in</span> a\n    <span class=\"blue\">where</span> e.Name.Equals( name )\n    <span class=\"blue\">select</span> e;\n \n  <span class=\"blue\">return</span> elementsByName.First&lt;<span class=\"teal\">Element</span>&gt;();\n}\n \n<span class=\"teal\">Element</span> GetFirstNamedElementOfTypeUsingAnonymousButNamedMethod(\n  <span class=\"teal\">Type</span> type,\n  <span class=\"blue\">string</span> name )\n{\n  <span class=\"teal\">FilteredElementCollector</span> a\n    = GetElementsOfType( type );\n  <span class=\"green\">//</span>\n  <span class=\"green\">// using an anonymous method to define a named method:</span>\n  <span class=\"green\">//</span>\n  <span class=\"teal\">Func</span>&lt;<span class=\"teal\">Element</span>, <span class=\"blue\">bool</span>&gt; nameEquals = e =&gt; e.Name.Equals( name );\n  <span class=\"blue\">return</span> a.First&lt;<span class=\"teal\">Element</span>&gt;( nameEquals );\n}\n \n<span class=\"teal\">Element</span> GetFirstNamedElementOfTypeUsingAnonymousMethod(\n  <span class=\"teal\">Type</span> type,\n  <span class=\"blue\">string</span> name )\n{\n  <span class=\"teal\">FilteredElementCollector</span> a\n    = GetElementsOfType( type );\n  <span class=\"green\">//</span>\n  <span class=\"green\">// using an anonymous method:</span>\n  <span class=\"green\">//</span>\n  <span class=\"blue\">return</span> a.First&lt;<span class=\"teal\">Element</span>&gt;(\n    e =&gt; e.Name.Equals( name ) );\n}\n</pre>\n<p>The most important method of all, as we shall see, is the one making use of the Revit filtering API to search for the named level.\nSetting up a parameter filter is a little bit convoluted, since you need to make use of a number of different helper classes to specify separately the provider, evaluator, rule and filter, but have a look further down to convince yourself that it is worthwhile.\nThis method returns the first element of the given type and name using a parameter filter:\n\n<pre class=\"code\">\n<span class=\"teal\">Element</span> GetFirstNamedElementOfTypeUsingParameterFilter(\n  <span class=\"teal\">Type</span> type,\n  <span class=\"blue\">string</span> name )\n{\n  <span class=\"teal\">FilteredElementCollector</span> a\n    = GetElementsOfType( type );\n \n  <span class=\"teal\">BuiltInParameter</span> bip\n    = <span class=\"teal\">BuiltInParameter</span>.ELEM_NAME_PARAM;\n \n  <span class=\"teal\">ParameterValueProvider</span> provider\n    = <span class=\"blue\">new</span> <span class=\"teal\">ParameterValueProvider</span>(\n      <span class=\"blue\">new</span> <span class=\"teal\">ElementId</span>( bip ) );\n \n  <span class=\"teal\">FilterStringRuleEvaluator</span> evaluator\n    = <span class=\"blue\">new</span> <span class=\"teal\">FilterStringEquals</span>();\n \n  <span class=\"teal\">FilterRule</span> rule = <span class=\"blue\">new</span> <span class=\"teal\">FilterStringRule</span>(\n    provider, evaluator, name, <span class=\"blue\">true</span> );\n \n  <span class=\"teal\">ElementParameterFilter</span> filter\n    = <span class=\"blue\">new</span> <span class=\"teal\">ElementParameterFilter</span>( rule );\n \n  <span class=\"blue\">return</span> a.WherePasses( filter ).FirstElement();\n}\n</pre>\n<p>I drive this by selecting some target level at random and searching for it by name, and repeating that 1000 times over, as follows:\n\n<pre class=\"code\">\n  nRuns = 1000;\n  <span class=\"teal\">Random</span> rand = <span class=\"blue\">new</span> <span class=\"teal\">Random</span>();\n  totalTimer.Restart( <span class=\"maroon\">\"TOTAL TIME\"</span> );\n \n  <span class=\"blue\">using</span>( totalTimer )\n  {\n    <span class=\"blue\">for</span>( <span class=\"blue\">int</span> i = 0; i &lt; nRuns; ++i )\n    {\n      <span class=\"blue\">int</span> iLevel = rand.Next( 1, maxLevel );\n      BenchmarkSpecificLevel( iLevel );\n    }\n  }\n \n  totalTimer.Report(\n    <span class=\"maroon\">\"Retrieve specific named level:\"</span> );\n</pre>\n<p>Here are the results of running this test, i.e. 1000 repetitions of retrieving one specific level from the 999 levels in the model by searching for it by name:\n\n<pre>\n---------------------------------------------------------------\nRetrieve specific named level:\n Percentage   Seconds   Calls   Process\n---------------------------------------------------------------\n      0.00%      0.00    1000   Empty method *\n      0.16%      0.10    1000   Collector with no name check *\n     12.65%      7.96    1000   Parameter filter\n     21.60%     13.60    1000   Anonymous named\n     21.75%     13.70    1000   Explicit\n     21.85%     13.76    1000   Anonymous\n     21.88%     13.77    1000   Linq\n    100.00%     62.96       1   TOTAL TIME\n---------------------------------------------------------------\n</pre>\n<p>Again, the entries marked with an asterisk * do not do the full job and are just included  for baseline comparison purposes.\nThe empty method entry does nothing at all.\nThe collector with no name check collects all levels and simply returns the first one without checking its name.\n\n<p>The important conclusions that I draw from this are:\n\n<ul>\n<li>Once again, making use of the Revit filtering API by using the parameter filter is by far the most efficient approach.\nThe parameter filter is a slow filter, not a quick one, but it is still a lot faster than resorting to any other means.\n<li>There is virtually no performance difference at all between explicit coding, LINQ, and using generic algorithms with anonymous methods.\n</li></li></ul>\n<p>Once again, very illuminating, I would say.\n\n<p>In quintessence, you should do everything that you possibly can using the Revit filters, and avoid all post-processing and manual if at all possible.\n\n<p>Here is\n\n<a href=\"zip/bc_11_63.zip\">\nversion 2011.0.0.63</a>\n\nof the complete Building Coder source code and Visual Studio solution including the new CmdCollectorPerformance external command and the JtTimer profiling classes.</p>\n<p>I hope this keeps you happily informed and occupied over Easter and wish you good luck searching for eggs.\n\n<p>Since I am giving the Revit API training class in Warsaw next week, the posts may become sparse for a while.\n\n<p><strong>Correction:</strong> Please note that the method GetFirstNamedElementOfTypeUsingParameterFilter does not work properly using the built-in parameter ELEM_NAME_PARAM, because it should be looking at DATUM_TEXT instead.\nFor more details, please refer to the subsequent\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/06/element-name-parameter-filter-correction.html\">\nelement name parameter filter correction</a>.\n</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p>"
  },
  {
    "original_filename": "0333_collector_benchmark",
    "header_text": "Benchmarking Element Iteration Collectors",
    "local_header_href": "#benchmarking-element-iteration-collectors",
    "chunk_text": "<h4>Benchmarking Element Iteration Collectors</h4><p>I implemented a new command CmdCollectorPerformance in The Building Coder sample application, the first pure Revit 2011 one.\nIt performs the following three steps:\n\n<ol>\n<li>Create a largish number of levels for us to play making use of the CreateLevel helper method, which simply creates a new level at a given elevation.\n<li>BenchmarkAllLevels –\n     Benchmark various approaches to using\n     filtered collectors to retrieve\n     all levels in the model,\n     and measure the time required to\n     create IList and List collections from them.\n<li>BenchmarkSpecificLevel –\n     Benchmark using a parameter filter versus\n     various kinds of post processing of the\n     results returned by the filtered element\n     collector to find the level specified by\n     iLevel.\n</li></li></li></ol>\n<h4>Setting up the Test Model</h4>\n<p>We simply use a number of levels as a test set.\nHere is the code used to create an individual level:\n\n<pre class=\"code\">\n<span class=\"teal\">Level</span> CreateLevel( <span class=\"blue\">int</span> elevation )\n{\n  <span class=\"teal\">Level</span> level = _doc.Create.NewLevel( elevation );\n  level.Name = <span class=\"maroon\">\"Level \"</span> + elevation.ToString();\n  <span class=\"blue\">return</span> level;\n}\n</pre>\n<p>This loop is used to drive it to create a large number of levels:\n\n<pre class=\"code\">\n  <span class=\"blue\">int</span> maxLevel = 1000;\n  <span class=\"blue\">for</span>( <span class=\"blue\">int</span> i = 3; i &lt; maxLevel; ++i )\n  {\n    CreateLevel( i );\n  }\n</pre>\n<p>If this is run in a default new Revit Architecture model, we will end up with the two pre-defined levels 1 and 2 plus newly generated ones numbered up to 999 for a total of 999 levels in all.\n\n<h4>Test Methods to Retrieve all Levels</h4>\n<p>In the following benchmarking tests, I always included a test using an empty method that does nothing at all, just to ensure that the minimal overhead of calling the method and running the test itself is negligible compared to the functionality that I am actually benchmarking.\nThat is the reason for implementing these pretty trivial test methods:\n\n<pre class=\"code\">\n<span class=\"teal\">Element</span> EmptyMethod( <span class=\"teal\">Type</span> type )\n{\n  <span class=\"blue\">return</span> <span class=\"blue\">null</span>;\n}\n \n<span class=\"teal\">Element</span> EmptyMethod( <span class=\"teal\">Type</span> type, <span class=\"blue\">string</span> name )\n{\n  <span class=\"blue\">return</span> <span class=\"blue\">null</span>;\n}\n</pre>\n<p>Here are the basic minimal collector methods which we need to get any access at all to the Revit database elements:\n\n<ul>\n<li>GetNonElementTypeElements – Return all non ElementType elements.\n<li>GetElementsOfType – Return a collector of all elements of the given type.\n<li>GetFirstElementOfType – Return the first element of the given type without any further filtering.\n</li></li></li></ul>\n<p>The first is used to return all elements which are not derived from ElementType.\nThis is used to compare the time required to check the type of elements manually against the time it takes the dedicated Revit filtering functionality used by GetElementsOfType to do the same thing.\n\n<pre class=\"code\">\n<span class=\"teal\">FilteredElementCollector</span> GetNonElementTypeElements()\n{\n  <span class=\"blue\">return</span> <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( _doc )\n    .WhereElementIsNotElementType();\n}\n \n<span class=\"teal\">FilteredElementCollector</span> GetElementsOfType(\n  <span class=\"teal\">Type</span> type )\n{\n  <span class=\"blue\">return</span> <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( _doc )\n    .OfClass( type );\n}\n \n<span class=\"teal\">Element</span> GetFirstElementOfType(\n  <span class=\"teal\">Type</span> type )\n{\n  <span class=\"blue\">return</span> <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( _doc )\n    .OfClass( type )\n    .FirstElement();\n}\n</pre>\n<p>Here are two methods that use explicit coding and a LINQ query to filter for a specific element type:\n\n<ul>\n<li>GetElementsOfTypeUsingExplicitCode –\n     Return a list of all elements matching\n     the given type using explicit code to test\n     the element type.\n<li>GetElementsOfTypeUsingLinq –\n     Return a list of all elements matching\n     the given type using a LINQ query to test\n     the element type.\n</li></li></ul>\n<pre class=\"code\">\n<span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt; GetElementsOfTypeUsingExplicitCode(\n  <span class=\"teal\">Type</span> type )\n{\n  <span class=\"teal\">FilteredElementCollector</span> a\n    = GetNonElementTypeElements();\n \n  <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt; b = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt;();\n  <span class=\"blue\">foreach</span>( <span class=\"teal\">Element</span> e <span class=\"blue\">in</span> a )\n  {\n    <span class=\"blue\">if</span>( e.GetType().Equals( type ) )\n    {\n      b.Add( e );\n    }\n  }\n  <span class=\"blue\">return</span> b;\n}\n \n<span class=\"teal\">IEnumerable</span>&lt;<span class=\"teal\">Element</span>&gt; GetElementsOfTypeUsingLinq(\n  <span class=\"teal\">Type</span> type )\n{\n  <span class=\"teal\">FilteredElementCollector</span> a\n    = GetNonElementTypeElements();\n \n  <span class=\"teal\">IEnumerable</span>&lt;<span class=\"teal\">Element</span>&gt; b =\n    <span class=\"blue\">from</span> e <span class=\"blue\">in</span> a\n    <span class=\"blue\">where</span> e.GetType().Equals( type )\n    <span class=\"blue\">select</span> e;\n \n  <span class=\"blue\">return</span> b;\n}\n</pre>\n<p>The performance of these is then compared with GetElementsOfType using the OfClass method to achieve the same thing.\n\n<h4>Benchmarking Retrieval of all Levels</h4>\n<p>Here is the mainline code that we use to drive the benchmarking of the time required to retrieve all levels in different ways:\n\n<pre class=\"code\">\n  <span class=\"blue\">int</span> nLevels = GetElementsOfType( <span class=\"blue\">typeof</span>( <span class=\"teal\">Level</span> ) )\n    .ToElements().Count;\n \n  <span class=\"blue\">int</span> nRuns = 1000;\n \n  <span class=\"teal\">JtTimer</span> totalTimer = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>(\n    <span class=\"maroon\">\"TOTAL TIME\"</span> );\n \n  <span class=\"blue\">using</span>( totalTimer )\n  {\n    <span class=\"blue\">for</span>( <span class=\"blue\">int</span> i = 0; i &lt; nRuns; ++i )\n    {\n      BenchmarkAllLevels( nLevels );\n    }\n  }\n \n  totalTimer.Report( <span class=\"maroon\">\"Retrieve all levels:\"</span> );\n</pre>\n<p>The interesting question now is what exactly happens in the BenchmarkAllLevels method, and what the reported results look like.\n\n<p>BenchmarkAllLevels takes one argument, the count of levels, which is simply used to verify that the results from some of the test methods make sense.\nIt benchmarks several different approaches to using filtered collectors to retrieve all levels in the model and measure the time required to create IList and List collections from them:\n\n<pre class=\"code\">\n<span class=\"blue\">void</span> BenchmarkAllLevels( <span class=\"blue\">int</span> nLevels )\n{\n  <span class=\"teal\">Type</span> t = <span class=\"blue\">typeof</span>( <span class=\"teal\">Level</span> );\n  <span class=\"blue\">int</span> n;\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>(\n    <span class=\"maroon\">\"Empty method *\"</span> ) )\n  {\n    EmptyMethod( t );\n  }\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>(\n    <span class=\"maroon\">\"NotElementType *\"</span> ) )\n  {\n    <span class=\"teal\">FilteredElementCollector</span> a\n      = GetNonElementTypeElements();\n  }\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>(\n    <span class=\"maroon\">\"NotElementType as IList *\"</span> ) )\n  {\n    <span class=\"teal\">IList</span>&lt;<span class=\"teal\">Element</span>&gt; a\n      = GetNonElementTypeElements().ToElements();\n    n = a.Count;\n  }\n  <span class=\"teal\">Debug</span>.Assert( nLevels &lt;= n,\n    <span class=\"maroon\">\"expected to retrieve all non-element-type elements\"</span> );\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>(\n    <span class=\"maroon\">\"NotElementType as List *\"</span> ) )\n  {\n    <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt; a = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt;(\n      GetNonElementTypeElements() );\n \n    n = a.Count;\n  }\n  <span class=\"teal\">Debug</span>.Assert( nLevels &lt;= n,\n    <span class=\"maroon\">\"expected to retrieve all non-element-type elements\"</span> );\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>( <span class=\"maroon\">\"Explicit\"</span> ) )\n  {\n    <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt; a\n      = GetElementsOfTypeUsingExplicitCode( t );\n \n    n = a.Count;\n  }\n  <span class=\"teal\">Debug</span>.Assert( nLevels == n,\n    <span class=\"maroon\">\"expected to retrieve all levels\"</span> );\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>( <span class=\"maroon\">\"Linq\"</span> ) )\n  {\n    <span class=\"teal\">IEnumerable</span>&lt;<span class=\"teal\">Element</span>&gt; a =\n      GetElementsOfTypeUsingLinq( t );\n \n    n = a.Count&lt;<span class=\"teal\">Element</span>&gt;();\n  }\n  <span class=\"teal\">Debug</span>.Assert( nLevels == n,\n    <span class=\"maroon\">\"expected to retrieve all levels\"</span> );\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>(\n    <span class=\"maroon\">\"Linq as List\"</span> ) )\n  {\n    <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt; a = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt;(\n      GetElementsOfTypeUsingLinq( t ) );\n \n    n = a.Count;\n  }\n  <span class=\"teal\">Debug</span>.Assert( nLevels == n,\n    <span class=\"maroon\">\"expected to retrieve all levels\"</span> );\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>( <span class=\"maroon\">\"Collector\"</span> ) )\n  {\n    <span class=\"teal\">FilteredElementCollector</span> a\n      = GetElementsOfType( t );\n  }\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>(\n    <span class=\"maroon\">\"Collector as IList\"</span> ) )\n  {\n    <span class=\"teal\">IList</span>&lt;<span class=\"teal\">Element</span>&gt; a\n      = GetElementsOfType( t ).ToElements();\n \n    n = a.Count;\n  }\n  <span class=\"teal\">Debug</span>.Assert( nLevels == n,\n    <span class=\"maroon\">\"expected to retrieve all levels\"</span> );\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>(\n    <span class=\"maroon\">\"Collector as List\"</span> ) )\n  {\n    <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt; a = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt;(\n      GetElementsOfType( t ) );\n \n    n = a.Count;\n  }\n  <span class=\"teal\">Debug</span>.Assert( nLevels == n,\n    <span class=\"maroon\">\"expected to retrieve all levels\"</span> );\n}\n</pre>\n<p>Here are the results of running this, i.e. 1000 repetitions of retrieving all the 999 levels in several different ways:\n\n<pre>\n------------------------------------------------------------------------\nRetrieve all levels:\n Percentage   Seconds   Calls   Process\n------------------------------------------------------------------------\n      0.00%      0.00    1000   Empty method *\n      0.01%      0.01    1000   NotElementType *\n      0.02%      0.03    1000   Collector\n      3.85%      7.95    1000   Collector as IList\n      6.42%     13.26    1000   Collector as List\n      9.24%     19.07    1000   NotElementType as IList *\n     20.03%     41.37    1000   Explicit\n     20.07%     41.46    1000   Linq\n     20.12%     41.54    1000   NotElementType as List *\n     20.21%     41.73    1000   Linq as List\n    100.00%    206.51       1   TOTAL TIME\n------------------------------------------------------------------------\n</pre>\n<p>The entries marked with an asterisk * do not perform the full operation that the others complete.\nThey have been added to measure specific minimum overhead delays.\nFor example, we call an empty method to determine the overhead of the function call itself and to prove that this is completely negligible in comparison to the overall time.\n\n<p>There are lots of things to point out here:\n\n<ul>\n<li>The calls to the empty method really are negligible.\n<li>The three calls to NotElementType return over 3000 elements, i.e. more than just the levels, and do not have any overhead for filtering out any specific type.\nThey also give us an idea of the overhead required to convert the collector results to a generic IList and List instance.\nAs one might expect, creating a List causes a significantly larger overhead than an IList.\nAn IList is returned directly by the collector ToElements method, whereas a List requires an explicit call to a copy constructor.\n<li>The pure collector call using OfClass is fastest and easiest. Again, conversion to IList or List is much more expensive than the filtering operation itself.\n<li>Using explicit code or LINQ to filter is a thousand times as expensive as using the built-in collector filtering.\n<li>There is hardly any performance difference between using LINQ or explicit code.\n</li></li></li></li></li></ul>\n<p>I find these results very interesting and illuminating.\n\n<p>The really good news is that the Revit filtering is extremely efficient, and anything you add to it, such as converting the results to generic List, will cost much more time than the filtering operation itself.\n\n<p>I want to discuss the results of selecting an individual element as well, but I will have to postpone that until after Easter, because I am really running out of time here.\n\n<p>Or no, I will just cut it really short.\n\n\n<h4>Benchmarking Retrieval of a Specific Named Level</h4>\n<p>The following BenchmarkSpecificLevel method lists the various tests that I implemented and compared to retrieve a specific named element.\nIt benchmarks the use of a parameter filter versus\n     various kinds of post processing of the\n     results returned by the filtered element\n     collector to find the level specified by the iLevel argument:\n\n<pre class=\"code\">\n<span class=\"blue\">void</span> BenchmarkSpecificLevel( <span class=\"blue\">int</span> iLevel )\n{\n  <span class=\"teal\">Type</span> t = <span class=\"blue\">typeof</span>( <span class=\"teal\">Level</span> );\n  <span class=\"blue\">string</span> name = <span class=\"maroon\">\"Level \"</span> + iLevel.ToString();\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>(\n    <span class=\"maroon\">\"Empty method *\"</span> ) )\n  {\n    <span class=\"teal\">Element</span> level\n      = EmptyMethod(\n        t, name );\n  }\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>(\n    <span class=\"maroon\">\"Collector with no name check *\"</span> ) )\n  {\n    <span class=\"teal\">Element</span> level = GetFirstElementOfType( t );\n  }\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>(\n    <span class=\"maroon\">\"Parameter filter\"</span> ) )\n  {\n    <span class=\"teal\">Element</span> level\n      = GetFirstNamedElementOfTypeUsingParameterFilter(\n        t, name );\n  }\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>( <span class=\"maroon\">\"Explicit\"</span> ) )\n  {\n    <span class=\"teal\">Element</span> level\n      = GetFirstNamedElementOfTypeUsingExplicitCode(\n        t, name );\n  }\n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>( <span class=\"maroon\">\"Linq\"</span> ) )\n  {\n    <span class=\"teal\">Element</span> level\n      = GetFirstNamedElementOfTypeUsingLinq(\n        t, name );\n  }\n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>(\n    <span class=\"maroon\">\"Anonymous named\"</span> ) )\n  {\n    <span class=\"teal\">Element</span> level\n      = GetFirstNamedElementOfTypeUsingAnonymousButNamedMethod(\n        t, name );\n  }\n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>( <span class=\"maroon\">\"Anonymous\"</span> ) )\n  {\n    <span class=\"teal\">Element</span> level\n      = GetFirstNamedElementOfTypeUsingAnonymousMethod(\n        t, name );\n  }\n}\n</pre>\n<p>Ah yes, we still have not presented all the test methods that we are comparing yet.\nThey are:\n\n<ul>\n<li>GetFirstNamedElementOfTypeUsingExplicitCode – Return the first element of the given type and name using explicit code.\n<li>GetFirstNamedElementOfTypeUsingLinq – Return the first element of the given type and name using LINQ.\n<li>GetFirstNamedElementOfTypeUsingAnonymousButNamedMethod – Return the first element of the given type and name using an anonymous method to define a named method.\n<li>GetFirstNamedElementOfTypeUsingAnonymousMethod – Return the first element of the given type and name using an anonymous method.\n</li></li></li></li></ul>\n<pre class=\"code\">\n<span class=\"teal\">Element</span> GetFirstNamedElementOfTypeUsingExplicitCode(\n  <span class=\"teal\">Type</span> type,\n  <span class=\"blue\">string</span> name )\n{\n  <span class=\"teal\">FilteredElementCollector</span> a\n    = GetElementsOfType( type );\n  <span class=\"green\">//</span>\n  <span class=\"green\">// explicit iteration and manual checking of a property:</span>\n  <span class=\"green\">//</span>\n  <span class=\"teal\">Element</span> ret = <span class=\"blue\">null</span>;\n  <span class=\"blue\">foreach</span>( <span class=\"teal\">Element</span> e <span class=\"blue\">in</span> a )\n  {\n    <span class=\"blue\">if</span>( e.Name.Equals( name ) )\n    {\n      ret = e;\n      <span class=\"blue\">break</span>;\n    }\n  }\n  <span class=\"blue\">return</span> ret;\n}\n \n<span class=\"teal\">Element</span> GetFirstNamedElementOfTypeUsingLinq(\n  <span class=\"teal\">Type</span> type,\n  <span class=\"blue\">string</span> name )\n{\n  <span class=\"teal\">FilteredElementCollector</span> a\n    = GetElementsOfType( type );\n  <span class=\"green\">//</span>\n  <span class=\"green\">// using LINQ:</span>\n  <span class=\"green\">//</span>\n  <span class=\"teal\">IEnumerable</span>&lt;<span class=\"teal\">Element</span>&gt; elementsByName =\n    <span class=\"blue\">from</span> e <span class=\"blue\">in</span> a\n    <span class=\"blue\">where</span> e.Name.Equals( name )\n    <span class=\"blue\">select</span> e;\n \n  <span class=\"blue\">return</span> elementsByName.First&lt;<span class=\"teal\">Element</span>&gt;();\n}\n \n<span class=\"teal\">Element</span> GetFirstNamedElementOfTypeUsingAnonymousButNamedMethod(\n  <span class=\"teal\">Type</span> type,\n  <span class=\"blue\">string</span> name )\n{\n  <span class=\"teal\">FilteredElementCollector</span> a\n    = GetElementsOfType( type );\n  <span class=\"green\">//</span>\n  <span class=\"green\">// using an anonymous method to define a named method:</span>\n  <span class=\"green\">//</span>\n  <span class=\"teal\">Func</span>&lt;<span class=\"teal\">Element</span>, <span class=\"blue\">bool</span>&gt; nameEquals = e =&gt; e.Name.Equals( name );\n  <span class=\"blue\">return</span> a.First&lt;<span class=\"teal\">Element</span>&gt;( nameEquals );\n}\n \n<span class=\"teal\">Element</span> GetFirstNamedElementOfTypeUsingAnonymousMethod(\n  <span class=\"teal\">Type</span> type,\n  <span class=\"blue\">string</span> name )\n{\n  <span class=\"teal\">FilteredElementCollector</span> a\n    = GetElementsOfType( type );\n  <span class=\"green\">//</span>\n  <span class=\"green\">// using an anonymous method:</span>\n  <span class=\"green\">//</span>\n  <span class=\"blue\">return</span> a.First&lt;<span class=\"teal\">Element</span>&gt;(\n    e =&gt; e.Name.Equals( name ) );\n}\n</pre>\n<p>The most important method of all, as we shall see, is the one making use of the Revit filtering API to search for the named level.\nSetting up a parameter filter is a little bit convoluted, since you need to make use of a number of different helper classes to specify separately the provider, evaluator, rule and filter, but have a look further down to convince yourself that it is worthwhile.\nThis method returns the first element of the given type and name using a parameter filter:\n\n<pre class=\"code\">\n<span class=\"teal\">Element</span> GetFirstNamedElementOfTypeUsingParameterFilter(\n  <span class=\"teal\">Type</span> type,\n  <span class=\"blue\">string</span> name )\n{\n  <span class=\"teal\">FilteredElementCollector</span> a\n    = GetElementsOfType( type );\n \n  <span class=\"teal\">BuiltInParameter</span> bip\n    = <span class=\"teal\">BuiltInParameter</span>.ELEM_NAME_PARAM;\n \n  <span class=\"teal\">ParameterValueProvider</span> provider\n    = <span class=\"blue\">new</span> <span class=\"teal\">ParameterValueProvider</span>(\n      <span class=\"blue\">new</span> <span class=\"teal\">ElementId</span>( bip ) );\n \n  <span class=\"teal\">FilterStringRuleEvaluator</span> evaluator\n    = <span class=\"blue\">new</span> <span class=\"teal\">FilterStringEquals</span>();\n \n  <span class=\"teal\">FilterRule</span> rule = <span class=\"blue\">new</span> <span class=\"teal\">FilterStringRule</span>(\n    provider, evaluator, name, <span class=\"blue\">true</span> );\n \n  <span class=\"teal\">ElementParameterFilter</span> filter\n    = <span class=\"blue\">new</span> <span class=\"teal\">ElementParameterFilter</span>( rule );\n \n  <span class=\"blue\">return</span> a.WherePasses( filter ).FirstElement();\n}\n</pre>\n<p>I drive this by selecting some target level at random and searching for it by name, and repeating that 1000 times over, as follows:\n\n<pre class=\"code\">\n  nRuns = 1000;\n  <span class=\"teal\">Random</span> rand = <span class=\"blue\">new</span> <span class=\"teal\">Random</span>();\n  totalTimer.Restart( <span class=\"maroon\">\"TOTAL TIME\"</span> );\n \n  <span class=\"blue\">using</span>( totalTimer )\n  {\n    <span class=\"blue\">for</span>( <span class=\"blue\">int</span> i = 0; i &lt; nRuns; ++i )\n    {\n      <span class=\"blue\">int</span> iLevel = rand.Next( 1, maxLevel );\n      BenchmarkSpecificLevel( iLevel );\n    }\n  }\n \n  totalTimer.Report(\n    <span class=\"maroon\">\"Retrieve specific named level:\"</span> );\n</pre>\n<p>Here are the results of running this test, i.e. 1000 repetitions of retrieving one specific level from the 999 levels in the model by searching for it by name:\n\n<pre>\n---------------------------------------------------------------\nRetrieve specific named level:\n Percentage   Seconds   Calls   Process\n---------------------------------------------------------------\n      0.00%      0.00    1000   Empty method *\n      0.16%      0.10    1000   Collector with no name check *\n     12.65%      7.96    1000   Parameter filter\n     21.60%     13.60    1000   Anonymous named\n     21.75%     13.70    1000   Explicit\n     21.85%     13.76    1000   Anonymous\n     21.88%     13.77    1000   Linq\n    100.00%     62.96       1   TOTAL TIME\n---------------------------------------------------------------\n</pre>\n<p>Again, the entries marked with an asterisk * do not do the full job and are just included  for baseline comparison purposes.\nThe empty method entry does nothing at all.\nThe collector with no name check collects all levels and simply returns the first one without checking its name.\n\n<p>The important conclusions that I draw from this are:\n\n<ul>\n<li>Once again, making use of the Revit filtering API by using the parameter filter is by far the most efficient approach.\nThe parameter filter is a slow filter, not a quick one, but it is still a lot faster than resorting to any other means.\n<li>There is virtually no performance difference at all between explicit coding, LINQ, and using generic algorithms with anonymous methods.\n</li></li></ul>\n<p>Once again, very illuminating, I would say.\n\n<p>In quintessence, you should do everything that you possibly can using the Revit filters, and avoid all post-processing and manual if at all possible.\n\n<p>Here is\n\n<a href=\"zip/bc_11_63.zip\">\nversion 2011.0.0.63</a>\n\nof the complete Building Coder source code and Visual Studio solution including the new CmdCollectorPerformance external command and the JtTimer profiling classes.</p>\n<p>I hope this keeps you happily informed and occupied over Easter and wish you good luck searching for eggs.\n\n<p>Since I am giving the Revit API training class in Warsaw next week, the posts may become sparse for a while.\n\n<p><strong>Correction:</strong> Please note that the method GetFirstNamedElementOfTypeUsingParameterFilter does not work properly using the built-in parameter ELEM_NAME_PARAM, because it should be looking at DATUM_TEXT instead.\nFor more details, please refer to the subsequent\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/06/element-name-parameter-filter-correction.html\">\nelement name parameter filter correction</a>.\n</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p>"
  },
  {
    "original_filename": "0333_collector_benchmark",
    "header_text": "Setting up the Test Model",
    "local_header_href": "#setting-up-the-test-model",
    "chunk_text": "<h4>Setting up the Test Model</h4><p>We simply use a number of levels as a test set.\nHere is the code used to create an individual level:\n\n<pre class=\"code\">\n<span class=\"teal\">Level</span> CreateLevel( <span class=\"blue\">int</span> elevation )\n{\n  <span class=\"teal\">Level</span> level = _doc.Create.NewLevel( elevation );\n  level.Name = <span class=\"maroon\">\"Level \"</span> + elevation.ToString();\n  <span class=\"blue\">return</span> level;\n}\n</pre>\n<p>This loop is used to drive it to create a large number of levels:\n\n<pre class=\"code\">\n  <span class=\"blue\">int</span> maxLevel = 1000;\n  <span class=\"blue\">for</span>( <span class=\"blue\">int</span> i = 3; i &lt; maxLevel; ++i )\n  {\n    CreateLevel( i );\n  }\n</pre>\n<p>If this is run in a default new Revit Architecture model, we will end up with the two pre-defined levels 1 and 2 plus newly generated ones numbered up to 999 for a total of 999 levels in all.\n\n<h4>Test Methods to Retrieve all Levels</h4>\n<p>In the following benchmarking tests, I always included a test using an empty method that does nothing at all, just to ensure that the minimal overhead of calling the method and running the test itself is negligible compared to the functionality that I am actually benchmarking.\nThat is the reason for implementing these pretty trivial test methods:\n\n<pre class=\"code\">\n<span class=\"teal\">Element</span> EmptyMethod( <span class=\"teal\">Type</span> type )\n{\n  <span class=\"blue\">return</span> <span class=\"blue\">null</span>;\n}\n \n<span class=\"teal\">Element</span> EmptyMethod( <span class=\"teal\">Type</span> type, <span class=\"blue\">string</span> name )\n{\n  <span class=\"blue\">return</span> <span class=\"blue\">null</span>;\n}\n</pre>\n<p>Here are the basic minimal collector methods which we need to get any access at all to the Revit database elements:\n\n<ul>\n<li>GetNonElementTypeElements – Return all non ElementType elements.\n<li>GetElementsOfType – Return a collector of all elements of the given type.\n<li>GetFirstElementOfType – Return the first element of the given type without any further filtering.\n</li></li></li></ul>\n<p>The first is used to return all elements which are not derived from ElementType.\nThis is used to compare the time required to check the type of elements manually against the time it takes the dedicated Revit filtering functionality used by GetElementsOfType to do the same thing.\n\n<pre class=\"code\">\n<span class=\"teal\">FilteredElementCollector</span> GetNonElementTypeElements()\n{\n  <span class=\"blue\">return</span> <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( _doc )\n    .WhereElementIsNotElementType();\n}\n \n<span class=\"teal\">FilteredElementCollector</span> GetElementsOfType(\n  <span class=\"teal\">Type</span> type )\n{\n  <span class=\"blue\">return</span> <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( _doc )\n    .OfClass( type );\n}\n \n<span class=\"teal\">Element</span> GetFirstElementOfType(\n  <span class=\"teal\">Type</span> type )\n{\n  <span class=\"blue\">return</span> <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( _doc )\n    .OfClass( type )\n    .FirstElement();\n}\n</pre>\n<p>Here are two methods that use explicit coding and a LINQ query to filter for a specific element type:\n\n<ul>\n<li>GetElementsOfTypeUsingExplicitCode –\n     Return a list of all elements matching\n     the given type using explicit code to test\n     the element type.\n<li>GetElementsOfTypeUsingLinq –\n     Return a list of all elements matching\n     the given type using a LINQ query to test\n     the element type.\n</li></li></ul>\n<pre class=\"code\">\n<span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt; GetElementsOfTypeUsingExplicitCode(\n  <span class=\"teal\">Type</span> type )\n{\n  <span class=\"teal\">FilteredElementCollector</span> a\n    = GetNonElementTypeElements();\n \n  <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt; b = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt;();\n  <span class=\"blue\">foreach</span>( <span class=\"teal\">Element</span> e <span class=\"blue\">in</span> a )\n  {\n    <span class=\"blue\">if</span>( e.GetType().Equals( type ) )\n    {\n      b.Add( e );\n    }\n  }\n  <span class=\"blue\">return</span> b;\n}\n \n<span class=\"teal\">IEnumerable</span>&lt;<span class=\"teal\">Element</span>&gt; GetElementsOfTypeUsingLinq(\n  <span class=\"teal\">Type</span> type )\n{\n  <span class=\"teal\">FilteredElementCollector</span> a\n    = GetNonElementTypeElements();\n \n  <span class=\"teal\">IEnumerable</span>&lt;<span class=\"teal\">Element</span>&gt; b =\n    <span class=\"blue\">from</span> e <span class=\"blue\">in</span> a\n    <span class=\"blue\">where</span> e.GetType().Equals( type )\n    <span class=\"blue\">select</span> e;\n \n  <span class=\"blue\">return</span> b;\n}\n</pre>\n<p>The performance of these is then compared with GetElementsOfType using the OfClass method to achieve the same thing.\n\n<h4>Benchmarking Retrieval of all Levels</h4>\n<p>Here is the mainline code that we use to drive the benchmarking of the time required to retrieve all levels in different ways:\n\n<pre class=\"code\">\n  <span class=\"blue\">int</span> nLevels = GetElementsOfType( <span class=\"blue\">typeof</span>( <span class=\"teal\">Level</span> ) )\n    .ToElements().Count;\n \n  <span class=\"blue\">int</span> nRuns = 1000;\n \n  <span class=\"teal\">JtTimer</span> totalTimer = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>(\n    <span class=\"maroon\">\"TOTAL TIME\"</span> );\n \n  <span class=\"blue\">using</span>( totalTimer )\n  {\n    <span class=\"blue\">for</span>( <span class=\"blue\">int</span> i = 0; i &lt; nRuns; ++i )\n    {\n      BenchmarkAllLevels( nLevels );\n    }\n  }\n \n  totalTimer.Report( <span class=\"maroon\">\"Retrieve all levels:\"</span> );\n</pre>\n<p>The interesting question now is what exactly happens in the BenchmarkAllLevels method, and what the reported results look like.\n\n<p>BenchmarkAllLevels takes one argument, the count of levels, which is simply used to verify that the results from some of the test methods make sense.\nIt benchmarks several different approaches to using filtered collectors to retrieve all levels in the model and measure the time required to create IList and List collections from them:\n\n<pre class=\"code\">\n<span class=\"blue\">void</span> BenchmarkAllLevels( <span class=\"blue\">int</span> nLevels )\n{\n  <span class=\"teal\">Type</span> t = <span class=\"blue\">typeof</span>( <span class=\"teal\">Level</span> );\n  <span class=\"blue\">int</span> n;\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>(\n    <span class=\"maroon\">\"Empty method *\"</span> ) )\n  {\n    EmptyMethod( t );\n  }\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>(\n    <span class=\"maroon\">\"NotElementType *\"</span> ) )\n  {\n    <span class=\"teal\">FilteredElementCollector</span> a\n      = GetNonElementTypeElements();\n  }\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>(\n    <span class=\"maroon\">\"NotElementType as IList *\"</span> ) )\n  {\n    <span class=\"teal\">IList</span>&lt;<span class=\"teal\">Element</span>&gt; a\n      = GetNonElementTypeElements().ToElements();\n    n = a.Count;\n  }\n  <span class=\"teal\">Debug</span>.Assert( nLevels &lt;= n,\n    <span class=\"maroon\">\"expected to retrieve all non-element-type elements\"</span> );\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>(\n    <span class=\"maroon\">\"NotElementType as List *\"</span> ) )\n  {\n    <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt; a = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt;(\n      GetNonElementTypeElements() );\n \n    n = a.Count;\n  }\n  <span class=\"teal\">Debug</span>.Assert( nLevels &lt;= n,\n    <span class=\"maroon\">\"expected to retrieve all non-element-type elements\"</span> );\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>( <span class=\"maroon\">\"Explicit\"</span> ) )\n  {\n    <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt; a\n      = GetElementsOfTypeUsingExplicitCode( t );\n \n    n = a.Count;\n  }\n  <span class=\"teal\">Debug</span>.Assert( nLevels == n,\n    <span class=\"maroon\">\"expected to retrieve all levels\"</span> );\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>( <span class=\"maroon\">\"Linq\"</span> ) )\n  {\n    <span class=\"teal\">IEnumerable</span>&lt;<span class=\"teal\">Element</span>&gt; a =\n      GetElementsOfTypeUsingLinq( t );\n \n    n = a.Count&lt;<span class=\"teal\">Element</span>&gt;();\n  }\n  <span class=\"teal\">Debug</span>.Assert( nLevels == n,\n    <span class=\"maroon\">\"expected to retrieve all levels\"</span> );\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>(\n    <span class=\"maroon\">\"Linq as List\"</span> ) )\n  {\n    <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt; a = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt;(\n      GetElementsOfTypeUsingLinq( t ) );\n \n    n = a.Count;\n  }\n  <span class=\"teal\">Debug</span>.Assert( nLevels == n,\n    <span class=\"maroon\">\"expected to retrieve all levels\"</span> );\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>( <span class=\"maroon\">\"Collector\"</span> ) )\n  {\n    <span class=\"teal\">FilteredElementCollector</span> a\n      = GetElementsOfType( t );\n  }\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>(\n    <span class=\"maroon\">\"Collector as IList\"</span> ) )\n  {\n    <span class=\"teal\">IList</span>&lt;<span class=\"teal\">Element</span>&gt; a\n      = GetElementsOfType( t ).ToElements();\n \n    n = a.Count;\n  }\n  <span class=\"teal\">Debug</span>.Assert( nLevels == n,\n    <span class=\"maroon\">\"expected to retrieve all levels\"</span> );\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>(\n    <span class=\"maroon\">\"Collector as List\"</span> ) )\n  {\n    <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt; a = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt;(\n      GetElementsOfType( t ) );\n \n    n = a.Count;\n  }\n  <span class=\"teal\">Debug</span>.Assert( nLevels == n,\n    <span class=\"maroon\">\"expected to retrieve all levels\"</span> );\n}\n</pre>\n<p>Here are the results of running this, i.e. 1000 repetitions of retrieving all the 999 levels in several different ways:\n\n<pre>\n------------------------------------------------------------------------\nRetrieve all levels:\n Percentage   Seconds   Calls   Process\n------------------------------------------------------------------------\n      0.00%      0.00    1000   Empty method *\n      0.01%      0.01    1000   NotElementType *\n      0.02%      0.03    1000   Collector\n      3.85%      7.95    1000   Collector as IList\n      6.42%     13.26    1000   Collector as List\n      9.24%     19.07    1000   NotElementType as IList *\n     20.03%     41.37    1000   Explicit\n     20.07%     41.46    1000   Linq\n     20.12%     41.54    1000   NotElementType as List *\n     20.21%     41.73    1000   Linq as List\n    100.00%    206.51       1   TOTAL TIME\n------------------------------------------------------------------------\n</pre>\n<p>The entries marked with an asterisk * do not perform the full operation that the others complete.\nThey have been added to measure specific minimum overhead delays.\nFor example, we call an empty method to determine the overhead of the function call itself and to prove that this is completely negligible in comparison to the overall time.\n\n<p>There are lots of things to point out here:\n\n<ul>\n<li>The calls to the empty method really are negligible.\n<li>The three calls to NotElementType return over 3000 elements, i.e. more than just the levels, and do not have any overhead for filtering out any specific type.\nThey also give us an idea of the overhead required to convert the collector results to a generic IList and List instance.\nAs one might expect, creating a List causes a significantly larger overhead than an IList.\nAn IList is returned directly by the collector ToElements method, whereas a List requires an explicit call to a copy constructor.\n<li>The pure collector call using OfClass is fastest and easiest. Again, conversion to IList or List is much more expensive than the filtering operation itself.\n<li>Using explicit code or LINQ to filter is a thousand times as expensive as using the built-in collector filtering.\n<li>There is hardly any performance difference between using LINQ or explicit code.\n</li></li></li></li></li></ul>\n<p>I find these results very interesting and illuminating.\n\n<p>The really good news is that the Revit filtering is extremely efficient, and anything you add to it, such as converting the results to generic List, will cost much more time than the filtering operation itself.\n\n<p>I want to discuss the results of selecting an individual element as well, but I will have to postpone that until after Easter, because I am really running out of time here.\n\n<p>Or no, I will just cut it really short.\n\n\n<h4>Benchmarking Retrieval of a Specific Named Level</h4>\n<p>The following BenchmarkSpecificLevel method lists the various tests that I implemented and compared to retrieve a specific named element.\nIt benchmarks the use of a parameter filter versus\n     various kinds of post processing of the\n     results returned by the filtered element\n     collector to find the level specified by the iLevel argument:\n\n<pre class=\"code\">\n<span class=\"blue\">void</span> BenchmarkSpecificLevel( <span class=\"blue\">int</span> iLevel )\n{\n  <span class=\"teal\">Type</span> t = <span class=\"blue\">typeof</span>( <span class=\"teal\">Level</span> );\n  <span class=\"blue\">string</span> name = <span class=\"maroon\">\"Level \"</span> + iLevel.ToString();\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>(\n    <span class=\"maroon\">\"Empty method *\"</span> ) )\n  {\n    <span class=\"teal\">Element</span> level\n      = EmptyMethod(\n        t, name );\n  }\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>(\n    <span class=\"maroon\">\"Collector with no name check *\"</span> ) )\n  {\n    <span class=\"teal\">Element</span> level = GetFirstElementOfType( t );\n  }\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>(\n    <span class=\"maroon\">\"Parameter filter\"</span> ) )\n  {\n    <span class=\"teal\">Element</span> level\n      = GetFirstNamedElementOfTypeUsingParameterFilter(\n        t, name );\n  }\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>( <span class=\"maroon\">\"Explicit\"</span> ) )\n  {\n    <span class=\"teal\">Element</span> level\n      = GetFirstNamedElementOfTypeUsingExplicitCode(\n        t, name );\n  }\n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>( <span class=\"maroon\">\"Linq\"</span> ) )\n  {\n    <span class=\"teal\">Element</span> level\n      = GetFirstNamedElementOfTypeUsingLinq(\n        t, name );\n  }\n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>(\n    <span class=\"maroon\">\"Anonymous named\"</span> ) )\n  {\n    <span class=\"teal\">Element</span> level\n      = GetFirstNamedElementOfTypeUsingAnonymousButNamedMethod(\n        t, name );\n  }\n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>( <span class=\"maroon\">\"Anonymous\"</span> ) )\n  {\n    <span class=\"teal\">Element</span> level\n      = GetFirstNamedElementOfTypeUsingAnonymousMethod(\n        t, name );\n  }\n}\n</pre>\n<p>Ah yes, we still have not presented all the test methods that we are comparing yet.\nThey are:\n\n<ul>\n<li>GetFirstNamedElementOfTypeUsingExplicitCode – Return the first element of the given type and name using explicit code.\n<li>GetFirstNamedElementOfTypeUsingLinq – Return the first element of the given type and name using LINQ.\n<li>GetFirstNamedElementOfTypeUsingAnonymousButNamedMethod – Return the first element of the given type and name using an anonymous method to define a named method.\n<li>GetFirstNamedElementOfTypeUsingAnonymousMethod – Return the first element of the given type and name using an anonymous method.\n</li></li></li></li></ul>\n<pre class=\"code\">\n<span class=\"teal\">Element</span> GetFirstNamedElementOfTypeUsingExplicitCode(\n  <span class=\"teal\">Type</span> type,\n  <span class=\"blue\">string</span> name )\n{\n  <span class=\"teal\">FilteredElementCollector</span> a\n    = GetElementsOfType( type );\n  <span class=\"green\">//</span>\n  <span class=\"green\">// explicit iteration and manual checking of a property:</span>\n  <span class=\"green\">//</span>\n  <span class=\"teal\">Element</span> ret = <span class=\"blue\">null</span>;\n  <span class=\"blue\">foreach</span>( <span class=\"teal\">Element</span> e <span class=\"blue\">in</span> a )\n  {\n    <span class=\"blue\">if</span>( e.Name.Equals( name ) )\n    {\n      ret = e;\n      <span class=\"blue\">break</span>;\n    }\n  }\n  <span class=\"blue\">return</span> ret;\n}\n \n<span class=\"teal\">Element</span> GetFirstNamedElementOfTypeUsingLinq(\n  <span class=\"teal\">Type</span> type,\n  <span class=\"blue\">string</span> name )\n{\n  <span class=\"teal\">FilteredElementCollector</span> a\n    = GetElementsOfType( type );\n  <span class=\"green\">//</span>\n  <span class=\"green\">// using LINQ:</span>\n  <span class=\"green\">//</span>\n  <span class=\"teal\">IEnumerable</span>&lt;<span class=\"teal\">Element</span>&gt; elementsByName =\n    <span class=\"blue\">from</span> e <span class=\"blue\">in</span> a\n    <span class=\"blue\">where</span> e.Name.Equals( name )\n    <span class=\"blue\">select</span> e;\n \n  <span class=\"blue\">return</span> elementsByName.First&lt;<span class=\"teal\">Element</span>&gt;();\n}\n \n<span class=\"teal\">Element</span> GetFirstNamedElementOfTypeUsingAnonymousButNamedMethod(\n  <span class=\"teal\">Type</span> type,\n  <span class=\"blue\">string</span> name )\n{\n  <span class=\"teal\">FilteredElementCollector</span> a\n    = GetElementsOfType( type );\n  <span class=\"green\">//</span>\n  <span class=\"green\">// using an anonymous method to define a named method:</span>\n  <span class=\"green\">//</span>\n  <span class=\"teal\">Func</span>&lt;<span class=\"teal\">Element</span>, <span class=\"blue\">bool</span>&gt; nameEquals = e =&gt; e.Name.Equals( name );\n  <span class=\"blue\">return</span> a.First&lt;<span class=\"teal\">Element</span>&gt;( nameEquals );\n}\n \n<span class=\"teal\">Element</span> GetFirstNamedElementOfTypeUsingAnonymousMethod(\n  <span class=\"teal\">Type</span> type,\n  <span class=\"blue\">string</span> name )\n{\n  <span class=\"teal\">FilteredElementCollector</span> a\n    = GetElementsOfType( type );\n  <span class=\"green\">//</span>\n  <span class=\"green\">// using an anonymous method:</span>\n  <span class=\"green\">//</span>\n  <span class=\"blue\">return</span> a.First&lt;<span class=\"teal\">Element</span>&gt;(\n    e =&gt; e.Name.Equals( name ) );\n}\n</pre>\n<p>The most important method of all, as we shall see, is the one making use of the Revit filtering API to search for the named level.\nSetting up a parameter filter is a little bit convoluted, since you need to make use of a number of different helper classes to specify separately the provider, evaluator, rule and filter, but have a look further down to convince yourself that it is worthwhile.\nThis method returns the first element of the given type and name using a parameter filter:\n\n<pre class=\"code\">\n<span class=\"teal\">Element</span> GetFirstNamedElementOfTypeUsingParameterFilter(\n  <span class=\"teal\">Type</span> type,\n  <span class=\"blue\">string</span> name )\n{\n  <span class=\"teal\">FilteredElementCollector</span> a\n    = GetElementsOfType( type );\n \n  <span class=\"teal\">BuiltInParameter</span> bip\n    = <span class=\"teal\">BuiltInParameter</span>.ELEM_NAME_PARAM;\n \n  <span class=\"teal\">ParameterValueProvider</span> provider\n    = <span class=\"blue\">new</span> <span class=\"teal\">ParameterValueProvider</span>(\n      <span class=\"blue\">new</span> <span class=\"teal\">ElementId</span>( bip ) );\n \n  <span class=\"teal\">FilterStringRuleEvaluator</span> evaluator\n    = <span class=\"blue\">new</span> <span class=\"teal\">FilterStringEquals</span>();\n \n  <span class=\"teal\">FilterRule</span> rule = <span class=\"blue\">new</span> <span class=\"teal\">FilterStringRule</span>(\n    provider, evaluator, name, <span class=\"blue\">true</span> );\n \n  <span class=\"teal\">ElementParameterFilter</span> filter\n    = <span class=\"blue\">new</span> <span class=\"teal\">ElementParameterFilter</span>( rule );\n \n  <span class=\"blue\">return</span> a.WherePasses( filter ).FirstElement();\n}\n</pre>\n<p>I drive this by selecting some target level at random and searching for it by name, and repeating that 1000 times over, as follows:\n\n<pre class=\"code\">\n  nRuns = 1000;\n  <span class=\"teal\">Random</span> rand = <span class=\"blue\">new</span> <span class=\"teal\">Random</span>();\n  totalTimer.Restart( <span class=\"maroon\">\"TOTAL TIME\"</span> );\n \n  <span class=\"blue\">using</span>( totalTimer )\n  {\n    <span class=\"blue\">for</span>( <span class=\"blue\">int</span> i = 0; i &lt; nRuns; ++i )\n    {\n      <span class=\"blue\">int</span> iLevel = rand.Next( 1, maxLevel );\n      BenchmarkSpecificLevel( iLevel );\n    }\n  }\n \n  totalTimer.Report(\n    <span class=\"maroon\">\"Retrieve specific named level:\"</span> );\n</pre>\n<p>Here are the results of running this test, i.e. 1000 repetitions of retrieving one specific level from the 999 levels in the model by searching for it by name:\n\n<pre>\n---------------------------------------------------------------\nRetrieve specific named level:\n Percentage   Seconds   Calls   Process\n---------------------------------------------------------------\n      0.00%      0.00    1000   Empty method *\n      0.16%      0.10    1000   Collector with no name check *\n     12.65%      7.96    1000   Parameter filter\n     21.60%     13.60    1000   Anonymous named\n     21.75%     13.70    1000   Explicit\n     21.85%     13.76    1000   Anonymous\n     21.88%     13.77    1000   Linq\n    100.00%     62.96       1   TOTAL TIME\n---------------------------------------------------------------\n</pre>\n<p>Again, the entries marked with an asterisk * do not do the full job and are just included  for baseline comparison purposes.\nThe empty method entry does nothing at all.\nThe collector with no name check collects all levels and simply returns the first one without checking its name.\n\n<p>The important conclusions that I draw from this are:\n\n<ul>\n<li>Once again, making use of the Revit filtering API by using the parameter filter is by far the most efficient approach.\nThe parameter filter is a slow filter, not a quick one, but it is still a lot faster than resorting to any other means.\n<li>There is virtually no performance difference at all between explicit coding, LINQ, and using generic algorithms with anonymous methods.\n</li></li></ul>\n<p>Once again, very illuminating, I would say.\n\n<p>In quintessence, you should do everything that you possibly can using the Revit filters, and avoid all post-processing and manual if at all possible.\n\n<p>Here is\n\n<a href=\"zip/bc_11_63.zip\">\nversion 2011.0.0.63</a>\n\nof the complete Building Coder source code and Visual Studio solution including the new CmdCollectorPerformance external command and the JtTimer profiling classes.</p>\n<p>I hope this keeps you happily informed and occupied over Easter and wish you good luck searching for eggs.\n\n<p>Since I am giving the Revit API training class in Warsaw next week, the posts may become sparse for a while.\n\n<p><strong>Correction:</strong> Please note that the method GetFirstNamedElementOfTypeUsingParameterFilter does not work properly using the built-in parameter ELEM_NAME_PARAM, because it should be looking at DATUM_TEXT instead.\nFor more details, please refer to the subsequent\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/06/element-name-parameter-filter-correction.html\">\nelement name parameter filter correction</a>.\n</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p>"
  },
  {
    "original_filename": "0333_collector_benchmark",
    "header_text": "Test Methods to Retrieve all Levels",
    "local_header_href": "#test-methods-to-retrieve-all-levels",
    "chunk_text": "<h4>Test Methods to Retrieve all Levels</h4><p>In the following benchmarking tests, I always included a test using an empty method that does nothing at all, just to ensure that the minimal overhead of calling the method and running the test itself is negligible compared to the functionality that I am actually benchmarking.\nThat is the reason for implementing these pretty trivial test methods:\n\n<pre class=\"code\">\n<span class=\"teal\">Element</span> EmptyMethod( <span class=\"teal\">Type</span> type )\n{\n  <span class=\"blue\">return</span> <span class=\"blue\">null</span>;\n}\n \n<span class=\"teal\">Element</span> EmptyMethod( <span class=\"teal\">Type</span> type, <span class=\"blue\">string</span> name )\n{\n  <span class=\"blue\">return</span> <span class=\"blue\">null</span>;\n}\n</pre>\n<p>Here are the basic minimal collector methods which we need to get any access at all to the Revit database elements:\n\n<ul>\n<li>GetNonElementTypeElements – Return all non ElementType elements.\n<li>GetElementsOfType – Return a collector of all elements of the given type.\n<li>GetFirstElementOfType – Return the first element of the given type without any further filtering.\n</li></li></li></ul>\n<p>The first is used to return all elements which are not derived from ElementType.\nThis is used to compare the time required to check the type of elements manually against the time it takes the dedicated Revit filtering functionality used by GetElementsOfType to do the same thing.\n\n<pre class=\"code\">\n<span class=\"teal\">FilteredElementCollector</span> GetNonElementTypeElements()\n{\n  <span class=\"blue\">return</span> <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( _doc )\n    .WhereElementIsNotElementType();\n}\n \n<span class=\"teal\">FilteredElementCollector</span> GetElementsOfType(\n  <span class=\"teal\">Type</span> type )\n{\n  <span class=\"blue\">return</span> <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( _doc )\n    .OfClass( type );\n}\n \n<span class=\"teal\">Element</span> GetFirstElementOfType(\n  <span class=\"teal\">Type</span> type )\n{\n  <span class=\"blue\">return</span> <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( _doc )\n    .OfClass( type )\n    .FirstElement();\n}\n</pre>\n<p>Here are two methods that use explicit coding and a LINQ query to filter for a specific element type:\n\n<ul>\n<li>GetElementsOfTypeUsingExplicitCode –\n     Return a list of all elements matching\n     the given type using explicit code to test\n     the element type.\n<li>GetElementsOfTypeUsingLinq –\n     Return a list of all elements matching\n     the given type using a LINQ query to test\n     the element type.\n</li></li></ul>\n<pre class=\"code\">\n<span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt; GetElementsOfTypeUsingExplicitCode(\n  <span class=\"teal\">Type</span> type )\n{\n  <span class=\"teal\">FilteredElementCollector</span> a\n    = GetNonElementTypeElements();\n \n  <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt; b = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt;();\n  <span class=\"blue\">foreach</span>( <span class=\"teal\">Element</span> e <span class=\"blue\">in</span> a )\n  {\n    <span class=\"blue\">if</span>( e.GetType().Equals( type ) )\n    {\n      b.Add( e );\n    }\n  }\n  <span class=\"blue\">return</span> b;\n}\n \n<span class=\"teal\">IEnumerable</span>&lt;<span class=\"teal\">Element</span>&gt; GetElementsOfTypeUsingLinq(\n  <span class=\"teal\">Type</span> type )\n{\n  <span class=\"teal\">FilteredElementCollector</span> a\n    = GetNonElementTypeElements();\n \n  <span class=\"teal\">IEnumerable</span>&lt;<span class=\"teal\">Element</span>&gt; b =\n    <span class=\"blue\">from</span> e <span class=\"blue\">in</span> a\n    <span class=\"blue\">where</span> e.GetType().Equals( type )\n    <span class=\"blue\">select</span> e;\n \n  <span class=\"blue\">return</span> b;\n}\n</pre>\n<p>The performance of these is then compared with GetElementsOfType using the OfClass method to achieve the same thing.\n\n<h4>Benchmarking Retrieval of all Levels</h4>\n<p>Here is the mainline code that we use to drive the benchmarking of the time required to retrieve all levels in different ways:\n\n<pre class=\"code\">\n  <span class=\"blue\">int</span> nLevels = GetElementsOfType( <span class=\"blue\">typeof</span>( <span class=\"teal\">Level</span> ) )\n    .ToElements().Count;\n \n  <span class=\"blue\">int</span> nRuns = 1000;\n \n  <span class=\"teal\">JtTimer</span> totalTimer = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>(\n    <span class=\"maroon\">\"TOTAL TIME\"</span> );\n \n  <span class=\"blue\">using</span>( totalTimer )\n  {\n    <span class=\"blue\">for</span>( <span class=\"blue\">int</span> i = 0; i &lt; nRuns; ++i )\n    {\n      BenchmarkAllLevels( nLevels );\n    }\n  }\n \n  totalTimer.Report( <span class=\"maroon\">\"Retrieve all levels:\"</span> );\n</pre>\n<p>The interesting question now is what exactly happens in the BenchmarkAllLevels method, and what the reported results look like.\n\n<p>BenchmarkAllLevels takes one argument, the count of levels, which is simply used to verify that the results from some of the test methods make sense.\nIt benchmarks several different approaches to using filtered collectors to retrieve all levels in the model and measure the time required to create IList and List collections from them:\n\n<pre class=\"code\">\n<span class=\"blue\">void</span> BenchmarkAllLevels( <span class=\"blue\">int</span> nLevels )\n{\n  <span class=\"teal\">Type</span> t = <span class=\"blue\">typeof</span>( <span class=\"teal\">Level</span> );\n  <span class=\"blue\">int</span> n;\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>(\n    <span class=\"maroon\">\"Empty method *\"</span> ) )\n  {\n    EmptyMethod( t );\n  }\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>(\n    <span class=\"maroon\">\"NotElementType *\"</span> ) )\n  {\n    <span class=\"teal\">FilteredElementCollector</span> a\n      = GetNonElementTypeElements();\n  }\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>(\n    <span class=\"maroon\">\"NotElementType as IList *\"</span> ) )\n  {\n    <span class=\"teal\">IList</span>&lt;<span class=\"teal\">Element</span>&gt; a\n      = GetNonElementTypeElements().ToElements();\n    n = a.Count;\n  }\n  <span class=\"teal\">Debug</span>.Assert( nLevels &lt;= n,\n    <span class=\"maroon\">\"expected to retrieve all non-element-type elements\"</span> );\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>(\n    <span class=\"maroon\">\"NotElementType as List *\"</span> ) )\n  {\n    <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt; a = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt;(\n      GetNonElementTypeElements() );\n \n    n = a.Count;\n  }\n  <span class=\"teal\">Debug</span>.Assert( nLevels &lt;= n,\n    <span class=\"maroon\">\"expected to retrieve all non-element-type elements\"</span> );\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>( <span class=\"maroon\">\"Explicit\"</span> ) )\n  {\n    <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt; a\n      = GetElementsOfTypeUsingExplicitCode( t );\n \n    n = a.Count;\n  }\n  <span class=\"teal\">Debug</span>.Assert( nLevels == n,\n    <span class=\"maroon\">\"expected to retrieve all levels\"</span> );\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>( <span class=\"maroon\">\"Linq\"</span> ) )\n  {\n    <span class=\"teal\">IEnumerable</span>&lt;<span class=\"teal\">Element</span>&gt; a =\n      GetElementsOfTypeUsingLinq( t );\n \n    n = a.Count&lt;<span class=\"teal\">Element</span>&gt;();\n  }\n  <span class=\"teal\">Debug</span>.Assert( nLevels == n,\n    <span class=\"maroon\">\"expected to retrieve all levels\"</span> );\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>(\n    <span class=\"maroon\">\"Linq as List\"</span> ) )\n  {\n    <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt; a = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt;(\n      GetElementsOfTypeUsingLinq( t ) );\n \n    n = a.Count;\n  }\n  <span class=\"teal\">Debug</span>.Assert( nLevels == n,\n    <span class=\"maroon\">\"expected to retrieve all levels\"</span> );\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>( <span class=\"maroon\">\"Collector\"</span> ) )\n  {\n    <span class=\"teal\">FilteredElementCollector</span> a\n      = GetElementsOfType( t );\n  }\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>(\n    <span class=\"maroon\">\"Collector as IList\"</span> ) )\n  {\n    <span class=\"teal\">IList</span>&lt;<span class=\"teal\">Element</span>&gt; a\n      = GetElementsOfType( t ).ToElements();\n \n    n = a.Count;\n  }\n  <span class=\"teal\">Debug</span>.Assert( nLevels == n,\n    <span class=\"maroon\">\"expected to retrieve all levels\"</span> );\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>(\n    <span class=\"maroon\">\"Collector as List\"</span> ) )\n  {\n    <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt; a = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt;(\n      GetElementsOfType( t ) );\n \n    n = a.Count;\n  }\n  <span class=\"teal\">Debug</span>.Assert( nLevels == n,\n    <span class=\"maroon\">\"expected to retrieve all levels\"</span> );\n}\n</pre>\n<p>Here are the results of running this, i.e. 1000 repetitions of retrieving all the 999 levels in several different ways:\n\n<pre>\n------------------------------------------------------------------------\nRetrieve all levels:\n Percentage   Seconds   Calls   Process\n------------------------------------------------------------------------\n      0.00%      0.00    1000   Empty method *\n      0.01%      0.01    1000   NotElementType *\n      0.02%      0.03    1000   Collector\n      3.85%      7.95    1000   Collector as IList\n      6.42%     13.26    1000   Collector as List\n      9.24%     19.07    1000   NotElementType as IList *\n     20.03%     41.37    1000   Explicit\n     20.07%     41.46    1000   Linq\n     20.12%     41.54    1000   NotElementType as List *\n     20.21%     41.73    1000   Linq as List\n    100.00%    206.51       1   TOTAL TIME\n------------------------------------------------------------------------\n</pre>\n<p>The entries marked with an asterisk * do not perform the full operation that the others complete.\nThey have been added to measure specific minimum overhead delays.\nFor example, we call an empty method to determine the overhead of the function call itself and to prove that this is completely negligible in comparison to the overall time.\n\n<p>There are lots of things to point out here:\n\n<ul>\n<li>The calls to the empty method really are negligible.\n<li>The three calls to NotElementType return over 3000 elements, i.e. more than just the levels, and do not have any overhead for filtering out any specific type.\nThey also give us an idea of the overhead required to convert the collector results to a generic IList and List instance.\nAs one might expect, creating a List causes a significantly larger overhead than an IList.\nAn IList is returned directly by the collector ToElements method, whereas a List requires an explicit call to a copy constructor.\n<li>The pure collector call using OfClass is fastest and easiest. Again, conversion to IList or List is much more expensive than the filtering operation itself.\n<li>Using explicit code or LINQ to filter is a thousand times as expensive as using the built-in collector filtering.\n<li>There is hardly any performance difference between using LINQ or explicit code.\n</li></li></li></li></li></ul>\n<p>I find these results very interesting and illuminating.\n\n<p>The really good news is that the Revit filtering is extremely efficient, and anything you add to it, such as converting the results to generic List, will cost much more time than the filtering operation itself.\n\n<p>I want to discuss the results of selecting an individual element as well, but I will have to postpone that until after Easter, because I am really running out of time here.\n\n<p>Or no, I will just cut it really short.\n\n\n<h4>Benchmarking Retrieval of a Specific Named Level</h4>\n<p>The following BenchmarkSpecificLevel method lists the various tests that I implemented and compared to retrieve a specific named element.\nIt benchmarks the use of a parameter filter versus\n     various kinds of post processing of the\n     results returned by the filtered element\n     collector to find the level specified by the iLevel argument:\n\n<pre class=\"code\">\n<span class=\"blue\">void</span> BenchmarkSpecificLevel( <span class=\"blue\">int</span> iLevel )\n{\n  <span class=\"teal\">Type</span> t = <span class=\"blue\">typeof</span>( <span class=\"teal\">Level</span> );\n  <span class=\"blue\">string</span> name = <span class=\"maroon\">\"Level \"</span> + iLevel.ToString();\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>(\n    <span class=\"maroon\">\"Empty method *\"</span> ) )\n  {\n    <span class=\"teal\">Element</span> level\n      = EmptyMethod(\n        t, name );\n  }\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>(\n    <span class=\"maroon\">\"Collector with no name check *\"</span> ) )\n  {\n    <span class=\"teal\">Element</span> level = GetFirstElementOfType( t );\n  }\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>(\n    <span class=\"maroon\">\"Parameter filter\"</span> ) )\n  {\n    <span class=\"teal\">Element</span> level\n      = GetFirstNamedElementOfTypeUsingParameterFilter(\n        t, name );\n  }\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>( <span class=\"maroon\">\"Explicit\"</span> ) )\n  {\n    <span class=\"teal\">Element</span> level\n      = GetFirstNamedElementOfTypeUsingExplicitCode(\n        t, name );\n  }\n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>( <span class=\"maroon\">\"Linq\"</span> ) )\n  {\n    <span class=\"teal\">Element</span> level\n      = GetFirstNamedElementOfTypeUsingLinq(\n        t, name );\n  }\n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>(\n    <span class=\"maroon\">\"Anonymous named\"</span> ) )\n  {\n    <span class=\"teal\">Element</span> level\n      = GetFirstNamedElementOfTypeUsingAnonymousButNamedMethod(\n        t, name );\n  }\n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>( <span class=\"maroon\">\"Anonymous\"</span> ) )\n  {\n    <span class=\"teal\">Element</span> level\n      = GetFirstNamedElementOfTypeUsingAnonymousMethod(\n        t, name );\n  }\n}\n</pre>\n<p>Ah yes, we still have not presented all the test methods that we are comparing yet.\nThey are:\n\n<ul>\n<li>GetFirstNamedElementOfTypeUsingExplicitCode – Return the first element of the given type and name using explicit code.\n<li>GetFirstNamedElementOfTypeUsingLinq – Return the first element of the given type and name using LINQ.\n<li>GetFirstNamedElementOfTypeUsingAnonymousButNamedMethod – Return the first element of the given type and name using an anonymous method to define a named method.\n<li>GetFirstNamedElementOfTypeUsingAnonymousMethod – Return the first element of the given type and name using an anonymous method.\n</li></li></li></li></ul>\n<pre class=\"code\">\n<span class=\"teal\">Element</span> GetFirstNamedElementOfTypeUsingExplicitCode(\n  <span class=\"teal\">Type</span> type,\n  <span class=\"blue\">string</span> name )\n{\n  <span class=\"teal\">FilteredElementCollector</span> a\n    = GetElementsOfType( type );\n  <span class=\"green\">//</span>\n  <span class=\"green\">// explicit iteration and manual checking of a property:</span>\n  <span class=\"green\">//</span>\n  <span class=\"teal\">Element</span> ret = <span class=\"blue\">null</span>;\n  <span class=\"blue\">foreach</span>( <span class=\"teal\">Element</span> e <span class=\"blue\">in</span> a )\n  {\n    <span class=\"blue\">if</span>( e.Name.Equals( name ) )\n    {\n      ret = e;\n      <span class=\"blue\">break</span>;\n    }\n  }\n  <span class=\"blue\">return</span> ret;\n}\n \n<span class=\"teal\">Element</span> GetFirstNamedElementOfTypeUsingLinq(\n  <span class=\"teal\">Type</span> type,\n  <span class=\"blue\">string</span> name )\n{\n  <span class=\"teal\">FilteredElementCollector</span> a\n    = GetElementsOfType( type );\n  <span class=\"green\">//</span>\n  <span class=\"green\">// using LINQ:</span>\n  <span class=\"green\">//</span>\n  <span class=\"teal\">IEnumerable</span>&lt;<span class=\"teal\">Element</span>&gt; elementsByName =\n    <span class=\"blue\">from</span> e <span class=\"blue\">in</span> a\n    <span class=\"blue\">where</span> e.Name.Equals( name )\n    <span class=\"blue\">select</span> e;\n \n  <span class=\"blue\">return</span> elementsByName.First&lt;<span class=\"teal\">Element</span>&gt;();\n}\n \n<span class=\"teal\">Element</span> GetFirstNamedElementOfTypeUsingAnonymousButNamedMethod(\n  <span class=\"teal\">Type</span> type,\n  <span class=\"blue\">string</span> name )\n{\n  <span class=\"teal\">FilteredElementCollector</span> a\n    = GetElementsOfType( type );\n  <span class=\"green\">//</span>\n  <span class=\"green\">// using an anonymous method to define a named method:</span>\n  <span class=\"green\">//</span>\n  <span class=\"teal\">Func</span>&lt;<span class=\"teal\">Element</span>, <span class=\"blue\">bool</span>&gt; nameEquals = e =&gt; e.Name.Equals( name );\n  <span class=\"blue\">return</span> a.First&lt;<span class=\"teal\">Element</span>&gt;( nameEquals );\n}\n \n<span class=\"teal\">Element</span> GetFirstNamedElementOfTypeUsingAnonymousMethod(\n  <span class=\"teal\">Type</span> type,\n  <span class=\"blue\">string</span> name )\n{\n  <span class=\"teal\">FilteredElementCollector</span> a\n    = GetElementsOfType( type );\n  <span class=\"green\">//</span>\n  <span class=\"green\">// using an anonymous method:</span>\n  <span class=\"green\">//</span>\n  <span class=\"blue\">return</span> a.First&lt;<span class=\"teal\">Element</span>&gt;(\n    e =&gt; e.Name.Equals( name ) );\n}\n</pre>\n<p>The most important method of all, as we shall see, is the one making use of the Revit filtering API to search for the named level.\nSetting up a parameter filter is a little bit convoluted, since you need to make use of a number of different helper classes to specify separately the provider, evaluator, rule and filter, but have a look further down to convince yourself that it is worthwhile.\nThis method returns the first element of the given type and name using a parameter filter:\n\n<pre class=\"code\">\n<span class=\"teal\">Element</span> GetFirstNamedElementOfTypeUsingParameterFilter(\n  <span class=\"teal\">Type</span> type,\n  <span class=\"blue\">string</span> name )\n{\n  <span class=\"teal\">FilteredElementCollector</span> a\n    = GetElementsOfType( type );\n \n  <span class=\"teal\">BuiltInParameter</span> bip\n    = <span class=\"teal\">BuiltInParameter</span>.ELEM_NAME_PARAM;\n \n  <span class=\"teal\">ParameterValueProvider</span> provider\n    = <span class=\"blue\">new</span> <span class=\"teal\">ParameterValueProvider</span>(\n      <span class=\"blue\">new</span> <span class=\"teal\">ElementId</span>( bip ) );\n \n  <span class=\"teal\">FilterStringRuleEvaluator</span> evaluator\n    = <span class=\"blue\">new</span> <span class=\"teal\">FilterStringEquals</span>();\n \n  <span class=\"teal\">FilterRule</span> rule = <span class=\"blue\">new</span> <span class=\"teal\">FilterStringRule</span>(\n    provider, evaluator, name, <span class=\"blue\">true</span> );\n \n  <span class=\"teal\">ElementParameterFilter</span> filter\n    = <span class=\"blue\">new</span> <span class=\"teal\">ElementParameterFilter</span>( rule );\n \n  <span class=\"blue\">return</span> a.WherePasses( filter ).FirstElement();\n}\n</pre>\n<p>I drive this by selecting some target level at random and searching for it by name, and repeating that 1000 times over, as follows:\n\n<pre class=\"code\">\n  nRuns = 1000;\n  <span class=\"teal\">Random</span> rand = <span class=\"blue\">new</span> <span class=\"teal\">Random</span>();\n  totalTimer.Restart( <span class=\"maroon\">\"TOTAL TIME\"</span> );\n \n  <span class=\"blue\">using</span>( totalTimer )\n  {\n    <span class=\"blue\">for</span>( <span class=\"blue\">int</span> i = 0; i &lt; nRuns; ++i )\n    {\n      <span class=\"blue\">int</span> iLevel = rand.Next( 1, maxLevel );\n      BenchmarkSpecificLevel( iLevel );\n    }\n  }\n \n  totalTimer.Report(\n    <span class=\"maroon\">\"Retrieve specific named level:\"</span> );\n</pre>\n<p>Here are the results of running this test, i.e. 1000 repetitions of retrieving one specific level from the 999 levels in the model by searching for it by name:\n\n<pre>\n---------------------------------------------------------------\nRetrieve specific named level:\n Percentage   Seconds   Calls   Process\n---------------------------------------------------------------\n      0.00%      0.00    1000   Empty method *\n      0.16%      0.10    1000   Collector with no name check *\n     12.65%      7.96    1000   Parameter filter\n     21.60%     13.60    1000   Anonymous named\n     21.75%     13.70    1000   Explicit\n     21.85%     13.76    1000   Anonymous\n     21.88%     13.77    1000   Linq\n    100.00%     62.96       1   TOTAL TIME\n---------------------------------------------------------------\n</pre>\n<p>Again, the entries marked with an asterisk * do not do the full job and are just included  for baseline comparison purposes.\nThe empty method entry does nothing at all.\nThe collector with no name check collects all levels and simply returns the first one without checking its name.\n\n<p>The important conclusions that I draw from this are:\n\n<ul>\n<li>Once again, making use of the Revit filtering API by using the parameter filter is by far the most efficient approach.\nThe parameter filter is a slow filter, not a quick one, but it is still a lot faster than resorting to any other means.\n<li>There is virtually no performance difference at all between explicit coding, LINQ, and using generic algorithms with anonymous methods.\n</li></li></ul>\n<p>Once again, very illuminating, I would say.\n\n<p>In quintessence, you should do everything that you possibly can using the Revit filters, and avoid all post-processing and manual if at all possible.\n\n<p>Here is\n\n<a href=\"zip/bc_11_63.zip\">\nversion 2011.0.0.63</a>\n\nof the complete Building Coder source code and Visual Studio solution including the new CmdCollectorPerformance external command and the JtTimer profiling classes.</p>\n<p>I hope this keeps you happily informed and occupied over Easter and wish you good luck searching for eggs.\n\n<p>Since I am giving the Revit API training class in Warsaw next week, the posts may become sparse for a while.\n\n<p><strong>Correction:</strong> Please note that the method GetFirstNamedElementOfTypeUsingParameterFilter does not work properly using the built-in parameter ELEM_NAME_PARAM, because it should be looking at DATUM_TEXT instead.\nFor more details, please refer to the subsequent\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/06/element-name-parameter-filter-correction.html\">\nelement name parameter filter correction</a>.\n</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p>"
  },
  {
    "original_filename": "0333_collector_benchmark",
    "header_text": "Benchmarking Retrieval of all Levels",
    "local_header_href": "#benchmarking-retrieval-of-all-levels",
    "chunk_text": "<h4>Benchmarking Retrieval of all Levels</h4><p>Here is the mainline code that we use to drive the benchmarking of the time required to retrieve all levels in different ways:\n\n<pre class=\"code\">\n  <span class=\"blue\">int</span> nLevels = GetElementsOfType( <span class=\"blue\">typeof</span>( <span class=\"teal\">Level</span> ) )\n    .ToElements().Count;\n \n  <span class=\"blue\">int</span> nRuns = 1000;\n \n  <span class=\"teal\">JtTimer</span> totalTimer = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>(\n    <span class=\"maroon\">\"TOTAL TIME\"</span> );\n \n  <span class=\"blue\">using</span>( totalTimer )\n  {\n    <span class=\"blue\">for</span>( <span class=\"blue\">int</span> i = 0; i &lt; nRuns; ++i )\n    {\n      BenchmarkAllLevels( nLevels );\n    }\n  }\n \n  totalTimer.Report( <span class=\"maroon\">\"Retrieve all levels:\"</span> );\n</pre>\n<p>The interesting question now is what exactly happens in the BenchmarkAllLevels method, and what the reported results look like.\n\n<p>BenchmarkAllLevels takes one argument, the count of levels, which is simply used to verify that the results from some of the test methods make sense.\nIt benchmarks several different approaches to using filtered collectors to retrieve all levels in the model and measure the time required to create IList and List collections from them:\n\n<pre class=\"code\">\n<span class=\"blue\">void</span> BenchmarkAllLevels( <span class=\"blue\">int</span> nLevels )\n{\n  <span class=\"teal\">Type</span> t = <span class=\"blue\">typeof</span>( <span class=\"teal\">Level</span> );\n  <span class=\"blue\">int</span> n;\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>(\n    <span class=\"maroon\">\"Empty method *\"</span> ) )\n  {\n    EmptyMethod( t );\n  }\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>(\n    <span class=\"maroon\">\"NotElementType *\"</span> ) )\n  {\n    <span class=\"teal\">FilteredElementCollector</span> a\n      = GetNonElementTypeElements();\n  }\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>(\n    <span class=\"maroon\">\"NotElementType as IList *\"</span> ) )\n  {\n    <span class=\"teal\">IList</span>&lt;<span class=\"teal\">Element</span>&gt; a\n      = GetNonElementTypeElements().ToElements();\n    n = a.Count;\n  }\n  <span class=\"teal\">Debug</span>.Assert( nLevels &lt;= n,\n    <span class=\"maroon\">\"expected to retrieve all non-element-type elements\"</span> );\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>(\n    <span class=\"maroon\">\"NotElementType as List *\"</span> ) )\n  {\n    <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt; a = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt;(\n      GetNonElementTypeElements() );\n \n    n = a.Count;\n  }\n  <span class=\"teal\">Debug</span>.Assert( nLevels &lt;= n,\n    <span class=\"maroon\">\"expected to retrieve all non-element-type elements\"</span> );\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>( <span class=\"maroon\">\"Explicit\"</span> ) )\n  {\n    <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt; a\n      = GetElementsOfTypeUsingExplicitCode( t );\n \n    n = a.Count;\n  }\n  <span class=\"teal\">Debug</span>.Assert( nLevels == n,\n    <span class=\"maroon\">\"expected to retrieve all levels\"</span> );\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>( <span class=\"maroon\">\"Linq\"</span> ) )\n  {\n    <span class=\"teal\">IEnumerable</span>&lt;<span class=\"teal\">Element</span>&gt; a =\n      GetElementsOfTypeUsingLinq( t );\n \n    n = a.Count&lt;<span class=\"teal\">Element</span>&gt;();\n  }\n  <span class=\"teal\">Debug</span>.Assert( nLevels == n,\n    <span class=\"maroon\">\"expected to retrieve all levels\"</span> );\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>(\n    <span class=\"maroon\">\"Linq as List\"</span> ) )\n  {\n    <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt; a = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt;(\n      GetElementsOfTypeUsingLinq( t ) );\n \n    n = a.Count;\n  }\n  <span class=\"teal\">Debug</span>.Assert( nLevels == n,\n    <span class=\"maroon\">\"expected to retrieve all levels\"</span> );\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>( <span class=\"maroon\">\"Collector\"</span> ) )\n  {\n    <span class=\"teal\">FilteredElementCollector</span> a\n      = GetElementsOfType( t );\n  }\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>(\n    <span class=\"maroon\">\"Collector as IList\"</span> ) )\n  {\n    <span class=\"teal\">IList</span>&lt;<span class=\"teal\">Element</span>&gt; a\n      = GetElementsOfType( t ).ToElements();\n \n    n = a.Count;\n  }\n  <span class=\"teal\">Debug</span>.Assert( nLevels == n,\n    <span class=\"maroon\">\"expected to retrieve all levels\"</span> );\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>(\n    <span class=\"maroon\">\"Collector as List\"</span> ) )\n  {\n    <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt; a = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt;(\n      GetElementsOfType( t ) );\n \n    n = a.Count;\n  }\n  <span class=\"teal\">Debug</span>.Assert( nLevels == n,\n    <span class=\"maroon\">\"expected to retrieve all levels\"</span> );\n}\n</pre>\n<p>Here are the results of running this, i.e. 1000 repetitions of retrieving all the 999 levels in several different ways:\n\n<pre>\n------------------------------------------------------------------------\nRetrieve all levels:\n Percentage   Seconds   Calls   Process\n------------------------------------------------------------------------\n      0.00%      0.00    1000   Empty method *\n      0.01%      0.01    1000   NotElementType *\n      0.02%      0.03    1000   Collector\n      3.85%      7.95    1000   Collector as IList\n      6.42%     13.26    1000   Collector as List\n      9.24%     19.07    1000   NotElementType as IList *\n     20.03%     41.37    1000   Explicit\n     20.07%     41.46    1000   Linq\n     20.12%     41.54    1000   NotElementType as List *\n     20.21%     41.73    1000   Linq as List\n    100.00%    206.51       1   TOTAL TIME\n------------------------------------------------------------------------\n</pre>\n<p>The entries marked with an asterisk * do not perform the full operation that the others complete.\nThey have been added to measure specific minimum overhead delays.\nFor example, we call an empty method to determine the overhead of the function call itself and to prove that this is completely negligible in comparison to the overall time.\n\n<p>There are lots of things to point out here:\n\n<ul>\n<li>The calls to the empty method really are negligible.\n<li>The three calls to NotElementType return over 3000 elements, i.e. more than just the levels, and do not have any overhead for filtering out any specific type.\nThey also give us an idea of the overhead required to convert the collector results to a generic IList and List instance.\nAs one might expect, creating a List causes a significantly larger overhead than an IList.\nAn IList is returned directly by the collector ToElements method, whereas a List requires an explicit call to a copy constructor.\n<li>The pure collector call using OfClass is fastest and easiest. Again, conversion to IList or List is much more expensive than the filtering operation itself.\n<li>Using explicit code or LINQ to filter is a thousand times as expensive as using the built-in collector filtering.\n<li>There is hardly any performance difference between using LINQ or explicit code.\n</li></li></li></li></li></ul>\n<p>I find these results very interesting and illuminating.\n\n<p>The really good news is that the Revit filtering is extremely efficient, and anything you add to it, such as converting the results to generic List, will cost much more time than the filtering operation itself.\n\n<p>I want to discuss the results of selecting an individual element as well, but I will have to postpone that until after Easter, because I am really running out of time here.\n\n<p>Or no, I will just cut it really short.\n\n\n<h4>Benchmarking Retrieval of a Specific Named Level</h4>\n<p>The following BenchmarkSpecificLevel method lists the various tests that I implemented and compared to retrieve a specific named element.\nIt benchmarks the use of a parameter filter versus\n     various kinds of post processing of the\n     results returned by the filtered element\n     collector to find the level specified by the iLevel argument:\n\n<pre class=\"code\">\n<span class=\"blue\">void</span> BenchmarkSpecificLevel( <span class=\"blue\">int</span> iLevel )\n{\n  <span class=\"teal\">Type</span> t = <span class=\"blue\">typeof</span>( <span class=\"teal\">Level</span> );\n  <span class=\"blue\">string</span> name = <span class=\"maroon\">\"Level \"</span> + iLevel.ToString();\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>(\n    <span class=\"maroon\">\"Empty method *\"</span> ) )\n  {\n    <span class=\"teal\">Element</span> level\n      = EmptyMethod(\n        t, name );\n  }\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>(\n    <span class=\"maroon\">\"Collector with no name check *\"</span> ) )\n  {\n    <span class=\"teal\">Element</span> level = GetFirstElementOfType( t );\n  }\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>(\n    <span class=\"maroon\">\"Parameter filter\"</span> ) )\n  {\n    <span class=\"teal\">Element</span> level\n      = GetFirstNamedElementOfTypeUsingParameterFilter(\n        t, name );\n  }\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>( <span class=\"maroon\">\"Explicit\"</span> ) )\n  {\n    <span class=\"teal\">Element</span> level\n      = GetFirstNamedElementOfTypeUsingExplicitCode(\n        t, name );\n  }\n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>( <span class=\"maroon\">\"Linq\"</span> ) )\n  {\n    <span class=\"teal\">Element</span> level\n      = GetFirstNamedElementOfTypeUsingLinq(\n        t, name );\n  }\n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>(\n    <span class=\"maroon\">\"Anonymous named\"</span> ) )\n  {\n    <span class=\"teal\">Element</span> level\n      = GetFirstNamedElementOfTypeUsingAnonymousButNamedMethod(\n        t, name );\n  }\n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>( <span class=\"maroon\">\"Anonymous\"</span> ) )\n  {\n    <span class=\"teal\">Element</span> level\n      = GetFirstNamedElementOfTypeUsingAnonymousMethod(\n        t, name );\n  }\n}\n</pre>\n<p>Ah yes, we still have not presented all the test methods that we are comparing yet.\nThey are:\n\n<ul>\n<li>GetFirstNamedElementOfTypeUsingExplicitCode – Return the first element of the given type and name using explicit code.\n<li>GetFirstNamedElementOfTypeUsingLinq – Return the first element of the given type and name using LINQ.\n<li>GetFirstNamedElementOfTypeUsingAnonymousButNamedMethod – Return the first element of the given type and name using an anonymous method to define a named method.\n<li>GetFirstNamedElementOfTypeUsingAnonymousMethod – Return the first element of the given type and name using an anonymous method.\n</li></li></li></li></ul>\n<pre class=\"code\">\n<span class=\"teal\">Element</span> GetFirstNamedElementOfTypeUsingExplicitCode(\n  <span class=\"teal\">Type</span> type,\n  <span class=\"blue\">string</span> name )\n{\n  <span class=\"teal\">FilteredElementCollector</span> a\n    = GetElementsOfType( type );\n  <span class=\"green\">//</span>\n  <span class=\"green\">// explicit iteration and manual checking of a property:</span>\n  <span class=\"green\">//</span>\n  <span class=\"teal\">Element</span> ret = <span class=\"blue\">null</span>;\n  <span class=\"blue\">foreach</span>( <span class=\"teal\">Element</span> e <span class=\"blue\">in</span> a )\n  {\n    <span class=\"blue\">if</span>( e.Name.Equals( name ) )\n    {\n      ret = e;\n      <span class=\"blue\">break</span>;\n    }\n  }\n  <span class=\"blue\">return</span> ret;\n}\n \n<span class=\"teal\">Element</span> GetFirstNamedElementOfTypeUsingLinq(\n  <span class=\"teal\">Type</span> type,\n  <span class=\"blue\">string</span> name )\n{\n  <span class=\"teal\">FilteredElementCollector</span> a\n    = GetElementsOfType( type );\n  <span class=\"green\">//</span>\n  <span class=\"green\">// using LINQ:</span>\n  <span class=\"green\">//</span>\n  <span class=\"teal\">IEnumerable</span>&lt;<span class=\"teal\">Element</span>&gt; elementsByName =\n    <span class=\"blue\">from</span> e <span class=\"blue\">in</span> a\n    <span class=\"blue\">where</span> e.Name.Equals( name )\n    <span class=\"blue\">select</span> e;\n \n  <span class=\"blue\">return</span> elementsByName.First&lt;<span class=\"teal\">Element</span>&gt;();\n}\n \n<span class=\"teal\">Element</span> GetFirstNamedElementOfTypeUsingAnonymousButNamedMethod(\n  <span class=\"teal\">Type</span> type,\n  <span class=\"blue\">string</span> name )\n{\n  <span class=\"teal\">FilteredElementCollector</span> a\n    = GetElementsOfType( type );\n  <span class=\"green\">//</span>\n  <span class=\"green\">// using an anonymous method to define a named method:</span>\n  <span class=\"green\">//</span>\n  <span class=\"teal\">Func</span>&lt;<span class=\"teal\">Element</span>, <span class=\"blue\">bool</span>&gt; nameEquals = e =&gt; e.Name.Equals( name );\n  <span class=\"blue\">return</span> a.First&lt;<span class=\"teal\">Element</span>&gt;( nameEquals );\n}\n \n<span class=\"teal\">Element</span> GetFirstNamedElementOfTypeUsingAnonymousMethod(\n  <span class=\"teal\">Type</span> type,\n  <span class=\"blue\">string</span> name )\n{\n  <span class=\"teal\">FilteredElementCollector</span> a\n    = GetElementsOfType( type );\n  <span class=\"green\">//</span>\n  <span class=\"green\">// using an anonymous method:</span>\n  <span class=\"green\">//</span>\n  <span class=\"blue\">return</span> a.First&lt;<span class=\"teal\">Element</span>&gt;(\n    e =&gt; e.Name.Equals( name ) );\n}\n</pre>\n<p>The most important method of all, as we shall see, is the one making use of the Revit filtering API to search for the named level.\nSetting up a parameter filter is a little bit convoluted, since you need to make use of a number of different helper classes to specify separately the provider, evaluator, rule and filter, but have a look further down to convince yourself that it is worthwhile.\nThis method returns the first element of the given type and name using a parameter filter:\n\n<pre class=\"code\">\n<span class=\"teal\">Element</span> GetFirstNamedElementOfTypeUsingParameterFilter(\n  <span class=\"teal\">Type</span> type,\n  <span class=\"blue\">string</span> name )\n{\n  <span class=\"teal\">FilteredElementCollector</span> a\n    = GetElementsOfType( type );\n \n  <span class=\"teal\">BuiltInParameter</span> bip\n    = <span class=\"teal\">BuiltInParameter</span>.ELEM_NAME_PARAM;\n \n  <span class=\"teal\">ParameterValueProvider</span> provider\n    = <span class=\"blue\">new</span> <span class=\"teal\">ParameterValueProvider</span>(\n      <span class=\"blue\">new</span> <span class=\"teal\">ElementId</span>( bip ) );\n \n  <span class=\"teal\">FilterStringRuleEvaluator</span> evaluator\n    = <span class=\"blue\">new</span> <span class=\"teal\">FilterStringEquals</span>();\n \n  <span class=\"teal\">FilterRule</span> rule = <span class=\"blue\">new</span> <span class=\"teal\">FilterStringRule</span>(\n    provider, evaluator, name, <span class=\"blue\">true</span> );\n \n  <span class=\"teal\">ElementParameterFilter</span> filter\n    = <span class=\"blue\">new</span> <span class=\"teal\">ElementParameterFilter</span>( rule );\n \n  <span class=\"blue\">return</span> a.WherePasses( filter ).FirstElement();\n}\n</pre>\n<p>I drive this by selecting some target level at random and searching for it by name, and repeating that 1000 times over, as follows:\n\n<pre class=\"code\">\n  nRuns = 1000;\n  <span class=\"teal\">Random</span> rand = <span class=\"blue\">new</span> <span class=\"teal\">Random</span>();\n  totalTimer.Restart( <span class=\"maroon\">\"TOTAL TIME\"</span> );\n \n  <span class=\"blue\">using</span>( totalTimer )\n  {\n    <span class=\"blue\">for</span>( <span class=\"blue\">int</span> i = 0; i &lt; nRuns; ++i )\n    {\n      <span class=\"blue\">int</span> iLevel = rand.Next( 1, maxLevel );\n      BenchmarkSpecificLevel( iLevel );\n    }\n  }\n \n  totalTimer.Report(\n    <span class=\"maroon\">\"Retrieve specific named level:\"</span> );\n</pre>\n<p>Here are the results of running this test, i.e. 1000 repetitions of retrieving one specific level from the 999 levels in the model by searching for it by name:\n\n<pre>\n---------------------------------------------------------------\nRetrieve specific named level:\n Percentage   Seconds   Calls   Process\n---------------------------------------------------------------\n      0.00%      0.00    1000   Empty method *\n      0.16%      0.10    1000   Collector with no name check *\n     12.65%      7.96    1000   Parameter filter\n     21.60%     13.60    1000   Anonymous named\n     21.75%     13.70    1000   Explicit\n     21.85%     13.76    1000   Anonymous\n     21.88%     13.77    1000   Linq\n    100.00%     62.96       1   TOTAL TIME\n---------------------------------------------------------------\n</pre>\n<p>Again, the entries marked with an asterisk * do not do the full job and are just included  for baseline comparison purposes.\nThe empty method entry does nothing at all.\nThe collector with no name check collects all levels and simply returns the first one without checking its name.\n\n<p>The important conclusions that I draw from this are:\n\n<ul>\n<li>Once again, making use of the Revit filtering API by using the parameter filter is by far the most efficient approach.\nThe parameter filter is a slow filter, not a quick one, but it is still a lot faster than resorting to any other means.\n<li>There is virtually no performance difference at all between explicit coding, LINQ, and using generic algorithms with anonymous methods.\n</li></li></ul>\n<p>Once again, very illuminating, I would say.\n\n<p>In quintessence, you should do everything that you possibly can using the Revit filters, and avoid all post-processing and manual if at all possible.\n\n<p>Here is\n\n<a href=\"zip/bc_11_63.zip\">\nversion 2011.0.0.63</a>\n\nof the complete Building Coder source code and Visual Studio solution including the new CmdCollectorPerformance external command and the JtTimer profiling classes.</p>\n<p>I hope this keeps you happily informed and occupied over Easter and wish you good luck searching for eggs.\n\n<p>Since I am giving the Revit API training class in Warsaw next week, the posts may become sparse for a while.\n\n<p><strong>Correction:</strong> Please note that the method GetFirstNamedElementOfTypeUsingParameterFilter does not work properly using the built-in parameter ELEM_NAME_PARAM, because it should be looking at DATUM_TEXT instead.\nFor more details, please refer to the subsequent\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/06/element-name-parameter-filter-correction.html\">\nelement name parameter filter correction</a>.\n</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p>"
  },
  {
    "original_filename": "0333_collector_benchmark",
    "header_text": "Benchmarking Retrieval of a Specific Named Level",
    "local_header_href": "#benchmarking-retrieval-of-a-specific-named-level",
    "chunk_text": "<h4>Benchmarking Retrieval of a Specific Named Level</h4><p>The following BenchmarkSpecificLevel method lists the various tests that I implemented and compared to retrieve a specific named element.\nIt benchmarks the use of a parameter filter versus\n     various kinds of post processing of the\n     results returned by the filtered element\n     collector to find the level specified by the iLevel argument:\n\n<pre class=\"code\">\n<span class=\"blue\">void</span> BenchmarkSpecificLevel( <span class=\"blue\">int</span> iLevel )\n{\n  <span class=\"teal\">Type</span> t = <span class=\"blue\">typeof</span>( <span class=\"teal\">Level</span> );\n  <span class=\"blue\">string</span> name = <span class=\"maroon\">\"Level \"</span> + iLevel.ToString();\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>(\n    <span class=\"maroon\">\"Empty method *\"</span> ) )\n  {\n    <span class=\"teal\">Element</span> level\n      = EmptyMethod(\n        t, name );\n  }\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>(\n    <span class=\"maroon\">\"Collector with no name check *\"</span> ) )\n  {\n    <span class=\"teal\">Element</span> level = GetFirstElementOfType( t );\n  }\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>(\n    <span class=\"maroon\">\"Parameter filter\"</span> ) )\n  {\n    <span class=\"teal\">Element</span> level\n      = GetFirstNamedElementOfTypeUsingParameterFilter(\n        t, name );\n  }\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>( <span class=\"maroon\">\"Explicit\"</span> ) )\n  {\n    <span class=\"teal\">Element</span> level\n      = GetFirstNamedElementOfTypeUsingExplicitCode(\n        t, name );\n  }\n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>( <span class=\"maroon\">\"Linq\"</span> ) )\n  {\n    <span class=\"teal\">Element</span> level\n      = GetFirstNamedElementOfTypeUsingLinq(\n        t, name );\n  }\n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>(\n    <span class=\"maroon\">\"Anonymous named\"</span> ) )\n  {\n    <span class=\"teal\">Element</span> level\n      = GetFirstNamedElementOfTypeUsingAnonymousButNamedMethod(\n        t, name );\n  }\n  <span class=\"blue\">using</span>( <span class=\"teal\">JtTimer</span> pt = <span class=\"blue\">new</span> <span class=\"teal\">JtTimer</span>( <span class=\"maroon\">\"Anonymous\"</span> ) )\n  {\n    <span class=\"teal\">Element</span> level\n      = GetFirstNamedElementOfTypeUsingAnonymousMethod(\n        t, name );\n  }\n}\n</pre>\n<p>Ah yes, we still have not presented all the test methods that we are comparing yet.\nThey are:\n\n<ul>\n<li>GetFirstNamedElementOfTypeUsingExplicitCode – Return the first element of the given type and name using explicit code.\n<li>GetFirstNamedElementOfTypeUsingLinq – Return the first element of the given type and name using LINQ.\n<li>GetFirstNamedElementOfTypeUsingAnonymousButNamedMethod – Return the first element of the given type and name using an anonymous method to define a named method.\n<li>GetFirstNamedElementOfTypeUsingAnonymousMethod – Return the first element of the given type and name using an anonymous method.\n</li></li></li></li></ul>\n<pre class=\"code\">\n<span class=\"teal\">Element</span> GetFirstNamedElementOfTypeUsingExplicitCode(\n  <span class=\"teal\">Type</span> type,\n  <span class=\"blue\">string</span> name )\n{\n  <span class=\"teal\">FilteredElementCollector</span> a\n    = GetElementsOfType( type );\n  <span class=\"green\">//</span>\n  <span class=\"green\">// explicit iteration and manual checking of a property:</span>\n  <span class=\"green\">//</span>\n  <span class=\"teal\">Element</span> ret = <span class=\"blue\">null</span>;\n  <span class=\"blue\">foreach</span>( <span class=\"teal\">Element</span> e <span class=\"blue\">in</span> a )\n  {\n    <span class=\"blue\">if</span>( e.Name.Equals( name ) )\n    {\n      ret = e;\n      <span class=\"blue\">break</span>;\n    }\n  }\n  <span class=\"blue\">return</span> ret;\n}\n \n<span class=\"teal\">Element</span> GetFirstNamedElementOfTypeUsingLinq(\n  <span class=\"teal\">Type</span> type,\n  <span class=\"blue\">string</span> name )\n{\n  <span class=\"teal\">FilteredElementCollector</span> a\n    = GetElementsOfType( type );\n  <span class=\"green\">//</span>\n  <span class=\"green\">// using LINQ:</span>\n  <span class=\"green\">//</span>\n  <span class=\"teal\">IEnumerable</span>&lt;<span class=\"teal\">Element</span>&gt; elementsByName =\n    <span class=\"blue\">from</span> e <span class=\"blue\">in</span> a\n    <span class=\"blue\">where</span> e.Name.Equals( name )\n    <span class=\"blue\">select</span> e;\n \n  <span class=\"blue\">return</span> elementsByName.First&lt;<span class=\"teal\">Element</span>&gt;();\n}\n \n<span class=\"teal\">Element</span> GetFirstNamedElementOfTypeUsingAnonymousButNamedMethod(\n  <span class=\"teal\">Type</span> type,\n  <span class=\"blue\">string</span> name )\n{\n  <span class=\"teal\">FilteredElementCollector</span> a\n    = GetElementsOfType( type );\n  <span class=\"green\">//</span>\n  <span class=\"green\">// using an anonymous method to define a named method:</span>\n  <span class=\"green\">//</span>\n  <span class=\"teal\">Func</span>&lt;<span class=\"teal\">Element</span>, <span class=\"blue\">bool</span>&gt; nameEquals = e =&gt; e.Name.Equals( name );\n  <span class=\"blue\">return</span> a.First&lt;<span class=\"teal\">Element</span>&gt;( nameEquals );\n}\n \n<span class=\"teal\">Element</span> GetFirstNamedElementOfTypeUsingAnonymousMethod(\n  <span class=\"teal\">Type</span> type,\n  <span class=\"blue\">string</span> name )\n{\n  <span class=\"teal\">FilteredElementCollector</span> a\n    = GetElementsOfType( type );\n  <span class=\"green\">//</span>\n  <span class=\"green\">// using an anonymous method:</span>\n  <span class=\"green\">//</span>\n  <span class=\"blue\">return</span> a.First&lt;<span class=\"teal\">Element</span>&gt;(\n    e =&gt; e.Name.Equals( name ) );\n}\n</pre>\n<p>The most important method of all, as we shall see, is the one making use of the Revit filtering API to search for the named level.\nSetting up a parameter filter is a little bit convoluted, since you need to make use of a number of different helper classes to specify separately the provider, evaluator, rule and filter, but have a look further down to convince yourself that it is worthwhile.\nThis method returns the first element of the given type and name using a parameter filter:\n\n<pre class=\"code\">\n<span class=\"teal\">Element</span> GetFirstNamedElementOfTypeUsingParameterFilter(\n  <span class=\"teal\">Type</span> type,\n  <span class=\"blue\">string</span> name )\n{\n  <span class=\"teal\">FilteredElementCollector</span> a\n    = GetElementsOfType( type );\n \n  <span class=\"teal\">BuiltInParameter</span> bip\n    = <span class=\"teal\">BuiltInParameter</span>.ELEM_NAME_PARAM;\n \n  <span class=\"teal\">ParameterValueProvider</span> provider\n    = <span class=\"blue\">new</span> <span class=\"teal\">ParameterValueProvider</span>(\n      <span class=\"blue\">new</span> <span class=\"teal\">ElementId</span>( bip ) );\n \n  <span class=\"teal\">FilterStringRuleEvaluator</span> evaluator\n    = <span class=\"blue\">new</span> <span class=\"teal\">FilterStringEquals</span>();\n \n  <span class=\"teal\">FilterRule</span> rule = <span class=\"blue\">new</span> <span class=\"teal\">FilterStringRule</span>(\n    provider, evaluator, name, <span class=\"blue\">true</span> );\n \n  <span class=\"teal\">ElementParameterFilter</span> filter\n    = <span class=\"blue\">new</span> <span class=\"teal\">ElementParameterFilter</span>( rule );\n \n  <span class=\"blue\">return</span> a.WherePasses( filter ).FirstElement();\n}\n</pre>\n<p>I drive this by selecting some target level at random and searching for it by name, and repeating that 1000 times over, as follows:\n\n<pre class=\"code\">\n  nRuns = 1000;\n  <span class=\"teal\">Random</span> rand = <span class=\"blue\">new</span> <span class=\"teal\">Random</span>();\n  totalTimer.Restart( <span class=\"maroon\">\"TOTAL TIME\"</span> );\n \n  <span class=\"blue\">using</span>( totalTimer )\n  {\n    <span class=\"blue\">for</span>( <span class=\"blue\">int</span> i = 0; i &lt; nRuns; ++i )\n    {\n      <span class=\"blue\">int</span> iLevel = rand.Next( 1, maxLevel );\n      BenchmarkSpecificLevel( iLevel );\n    }\n  }\n \n  totalTimer.Report(\n    <span class=\"maroon\">\"Retrieve specific named level:\"</span> );\n</pre>\n<p>Here are the results of running this test, i.e. 1000 repetitions of retrieving one specific level from the 999 levels in the model by searching for it by name:\n\n<pre>\n---------------------------------------------------------------\nRetrieve specific named level:\n Percentage   Seconds   Calls   Process\n---------------------------------------------------------------\n      0.00%      0.00    1000   Empty method *\n      0.16%      0.10    1000   Collector with no name check *\n     12.65%      7.96    1000   Parameter filter\n     21.60%     13.60    1000   Anonymous named\n     21.75%     13.70    1000   Explicit\n     21.85%     13.76    1000   Anonymous\n     21.88%     13.77    1000   Linq\n    100.00%     62.96       1   TOTAL TIME\n---------------------------------------------------------------\n</pre>\n<p>Again, the entries marked with an asterisk * do not do the full job and are just included  for baseline comparison purposes.\nThe empty method entry does nothing at all.\nThe collector with no name check collects all levels and simply returns the first one without checking its name.\n\n<p>The important conclusions that I draw from this are:\n\n<ul>\n<li>Once again, making use of the Revit filtering API by using the parameter filter is by far the most efficient approach.\nThe parameter filter is a slow filter, not a quick one, but it is still a lot faster than resorting to any other means.\n<li>There is virtually no performance difference at all between explicit coding, LINQ, and using generic algorithms with anonymous methods.\n</li></li></ul>\n<p>Once again, very illuminating, I would say.\n\n<p>In quintessence, you should do everything that you possibly can using the Revit filters, and avoid all post-processing and manual if at all possible.\n\n<p>Here is\n\n<a href=\"zip/bc_11_63.zip\">\nversion 2011.0.0.63</a>\n\nof the complete Building Coder source code and Visual Studio solution including the new CmdCollectorPerformance external command and the JtTimer profiling classes.</p>\n<p>I hope this keeps you happily informed and occupied over Easter and wish you good luck searching for eggs.\n\n<p>Since I am giving the Revit API training class in Warsaw next week, the posts may become sparse for a while.\n\n<p><strong>Correction:</strong> Please note that the method GetFirstNamedElementOfTypeUsingParameterFilter does not work properly using the built-in parameter ELEM_NAME_PARAM, because it should be looking at DATUM_TEXT instead.\nFor more details, please refer to the subsequent\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/06/element-name-parameter-filter-correction.html\">\nelement name parameter filter correction</a>.\n</p></p></p></p></p></p></p></p></p></p></p></p>"
  }
]