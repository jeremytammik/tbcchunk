[
  {
    "original_filename": "0576_iteration_constancy",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<head>\n<link href=\"bc.css\" rel=\"stylesheet\" type=\"text/css\"/>\n</head>"
  },
  {
    "original_filename": "0576_iteration_constancy",
    "header_text": "Iteration and Springtime – Change is the Only Constant",
    "local_header_href": "#iteration-and-springtime-change-is-the-only-constant",
    "chunk_text": "<h3>Iteration and Springtime – Change is the Only Constant</h3><p>I am back again from a wonderful relaxing Easter holiday with beautiful weather and an almost obscene wealth of blossoming trees and flowers in the Swiss \n\n<a href=\"http://en.wikipedia.org/wiki/Emmental\">Emmental</a> region:</p><center>\n<img alt=\"Emmental in bloom\" src=\"img/emmental_in_bloom.jpg\"/>\n</center><p>Spring time really gives us an overwhelming impression of nature's capacity for rapid change!\nAnd change is the only constant...\nAnd, as we see below, change is a constant challenge in programming as well...\n\n<p>Meanwhile, here are quick pointers to two of the many noteworthy items that cropped up during the past week:\n\n<ul>\n<li>Jose Guia'S bimKICKS <a href=\"http://blog.bimkicks.com/post/2011/04/01/REVIT-COMMAND-PROMPT-aww-yeah!!!!!!!.aspx\">Revit command prompt</a>.\n<li><a href=\"http://www.revitappstore.com\">Revit AppStore</a> updated for Revit 2012.\n</li></li></ul>\n<p>For my own contribution on my first official day back at work and in the blogosphere, here is a summary of an issue I was dealing with just before Easter:\n\n<p>I heard of several different developers struggling with iterations over collections returned by properties of the Revit API classes.\nThe last one we looked into was related to the\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2011/02/iterating-over-an-unordered-set-property.html\">\niteration over an unordered set</a> returned \n\nby the CurtainGrid Cells property.\n\n<p>Now the question was encountered again, in a seemingly different form, yet with a similar answer.\nIn this case, both the question and the solution to it were found by Winston Yaw of \n\n<a href=\"http://www.risatech.com\">\nRISA Technologies</a>:\n\n<!-- <p>How in heaven's name can we ensure that people don't continue running into this issue again and again in ever different guises? -->\n<p><strong>Question:</strong> I ran the following code on a simple Revit Structure model that only has one structural wall and I got an index of -1 for the first layer in the wall's compound structure. \nThat makes no sense.\nI probably overlooked something simply, but what?\n\n<pre class=\"code\">\n  FilteredElementIterator ^elementsIter;\n \n  FilteredElementCollector ^filteredCollection \n    = <span class=\"blue\">gcnew</span> FilteredElementCollector(\n      pApplication-&gt;ActiveUIDocument-&gt;Document );\n \n  filteredCollection-&gt;OfClass( Wall::<span class=\"blue\">typeid</span> );\n \n  elementsIter = filteredCollection\n    -&gt;GetElementIterator();\n \n  Wall ^testWall = <span class=\"blue\">nullptr</span>;\n \n  <span class=\"green\">// Get a wall</span>\n \n  <span class=\"blue\">while</span>( elementsIter-&gt;MoveNext() )\n  {\n    testWall = <span class=\"blue\">dynamic_cast</span>&lt;Wall^&gt;(\n      elementsIter-&gt;Current );\n \n    <span class=\"blue\">if</span>( testWall )\n    {\n      <span class=\"green\">// Look at compound structure</span>\n \n      CompoundStructure^ pCompound \n        = testWall-&gt;WallType-&gt;GetCompoundStructure();\n \n      <span class=\"blue\">if</span>( pCompound )\n      {\n        <span class=\"green\">// Look at first layer</span>\n \n        System::Collections::IEnumerator ^layerIter \n          = pCompound-&gt;GetLayers()-&gt;GetEnumerator();\n \n        <span class=\"blue\">while</span>( layerIter-&gt;MoveNext() )\n        {\n          CompoundStructureLayer^ pLayer \n            = <span class=\"blue\">dynamic_cast</span>&lt;CompoundStructureLayer^&gt;(\n              layerIter-&gt;Current );\n \n          <span class=\"green\">// Get index of first layer</span>\n          Int32 index = pCompound-&gt;GetLayers()-&gt;IndexOf(\n            pLayer );\n \n          <span class=\"green\">// Display in MessageBox</span>\n \n          MessageBox::Show( index.ToString() );\n        }\n      }\n    }\n  }\n \n</pre>\n<p>In this case, I was expecting a zero-valued index to be displayed. \nCan you tell me what's wrong, please? \nThanks.\n\n<p><strong>Answer:</strong> I found the problem myself. \nThe code above is calling the GetLayers method twice: once to get the Enumerator, and again to use IndexOf. \n\n<p>In summary, the code is doing something like this:\n\n<ul>\n<li>GetLayers()-&gt;GetEnumerator();\n<li>GetLayers()-&gt;IndexOf(layer);\n</li></li></ul>\n<p>The problem doesn't occur when an intermediate variable to store the collection returned is introduced as follows:\n\n<ul>\n<li>IList&lt;&gt; ^layers = GetLayers();\n<li>layers-&gt;GetEnumerator();\n<li>layers-&gt;IndexOf();\n</li></li></li></ul>\n<p>Jeremy responds: Yes, exactly. \nCongratulations on finding the root of the problem!\nAs said, we have seen similar issues in the past, e.g. related to the \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2011/02/iterating-over-an-unordered-set-property.html\">\niteration over an unordered set property</a>.\n\n<h4>Accessing the Compound Layer Structure in Revit 2012</h4>\n<p>For completeness sake, I tested accessing the compound layer structure and the IndexOf method using C# on both an architectural wall in Revit Architecture 2012 and a structural wall in Revit Structure 2012.\nSince I store the layer collection returned by the GetLayers method in an intermediate variable, just as suggested in your solution, I obviously don't see the problem you describe.\nHere is the code that I used, which includes comments to highlight the differences between the Revit 2011 and 2012 APIs, excerpted from the external command CmdWallLayers in\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2011/02/iterating-over-an-unordered-set-property.html\">\nThe Building Coder samples migrated to Revit 2012 API</a> and\n\nwith a call added to exercise the IndexOf method instead of using an additional variable 'i' for the index:\n\n<pre class=\"code\">\n[<span class=\"teal\">Transaction</span>( <span class=\"teal\">TransactionMode</span>.Automatic )]\n<span class=\"blue\">class</span> <span class=\"teal\">CmdWallLayers</span> : <span class=\"teal\">IExternalCommand</span>\n{\n  <span class=\"blue\">public</span> <span class=\"teal\">Result</span> Execute(\n    <span class=\"teal\">ExternalCommandData</span> commandData,\n    <span class=\"blue\">ref</span> <span class=\"blue\">string</span> message,\n    <span class=\"teal\">ElementSet</span> elements )\n  {\n    <span class=\"teal\">UIApplication</span> app = commandData.Application;\n    <span class=\"teal\">UIDocument</span> uidoc = app.ActiveUIDocument;\n    <span class=\"teal\">Document</span> doc = app.ActiveUIDocument.Document;\n \n    <span class=\"green\">// retrieve selected walls, or all walls,</span>\n    <span class=\"green\">// if nothing is selected:</span>\n \n    <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt; walls = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt;();\n    <span class=\"blue\">if</span>( !<span class=\"teal\">Util</span>.GetSelectedElementsOrAll(\n      walls, uidoc, <span class=\"blue\">typeof</span>( <span class=\"teal\">Wall</span> ) ) )\n    {\n      <span class=\"teal\">Selection</span> sel = uidoc.Selection;\n      message = ( 0 &lt; sel.Elements.Size )\n        ? <span class=\"maroon\">\"Please select some wall elements.\"</span>\n        : <span class=\"maroon\">\"No wall elements found.\"</span>;\n      <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n    }\n \n    <span class=\"green\">//int i; // 2011</span>\n    <span class=\"blue\">int</span> n;\n    <span class=\"blue\">double</span> halfThickness, layerOffset;\n    <span class=\"teal\">Creator</span> creator = <span class=\"blue\">new</span> <span class=\"teal\">Creator</span>( doc );\n    <span class=\"teal\">XYZ</span> lcstart, lcend, v, w, p, q;\n \n    <span class=\"blue\">foreach</span>( <span class=\"teal\">Wall</span> wall <span class=\"blue\">in</span> walls )\n    {\n      <span class=\"blue\">string</span> desc = <span class=\"teal\">Util</span>.ElementDescription( wall );\n \n      <span class=\"teal\">LocationCurve</span> curve\n        = wall.Location <span class=\"blue\">as</span> <span class=\"teal\">LocationCurve</span>;\n \n      <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == curve )\n      {\n        message = desc + <span class=\"maroon\">\": No wall curve found.\"</span>;\n        <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n      }\n \n      <span class=\"green\">// wall centre line and thickness:</span>\n \n      lcstart = curve.Curve.get_EndPoint( 0 );\n      lcend = curve.Curve.get_EndPoint( 1 );\n      halfThickness = 0.5 * wall.WallType.Width;\n      v = lcend - lcstart;\n      v = v.Normalize(); <span class=\"green\">// one foot long</span>\n      w = <span class=\"teal\">XYZ</span>.BasisZ.CrossProduct( v ).Normalize();\n      <span class=\"blue\">if</span>( wall.Flipped ) { w = -w; }\n \n      p = lcstart - 2 * v;\n      q = lcend + 2 * v;\n      creator.CreateModelLine( p, q );\n \n      q = p + halfThickness * w;\n      creator.CreateModelLine( p, q );\n \n      <span class=\"green\">// exterior edge</span>\n \n      p = lcstart - v + halfThickness * w;\n      q = lcend + v + halfThickness * w;\n      creator.CreateModelLine( p, q );\n \n      <span class=\"green\">//CompoundStructure structure = wall.WallType.CompoundStructure; // 2011</span>\n      <span class=\"teal\">CompoundStructure</span> structure = wall.WallType.GetCompoundStructure(); <span class=\"green\">// 2012</span>\n \n      <span class=\"green\">//CompoundStructureLayerArray layers = structure.Layers; // 2011</span>\n      <span class=\"teal\">IList</span>&lt;<span class=\"teal\">CompoundStructureLayer</span>&gt; layers = structure.GetLayers(); <span class=\"green\">// 2012</span>\n \n      <span class=\"green\">//i = 0; // 2011</span>\n      <span class=\"green\">//n = layers.Size; // 2011</span>\n      n = layers.Count; <span class=\"green\">// 2012</span>\n \n      <span class=\"teal\">Debug</span>.Print(\n        <span class=\"maroon\">\"{0} with thickness {1}\"</span>\n        + <span class=\"maroon\">\" has {2} layer{3}{4}\"</span>,\n        desc,\n        <span class=\"teal\">Util</span>.MmString( 2 * halfThickness ),\n        n, <span class=\"teal\">Util</span>.PluralSuffix( n ),\n        <span class=\"teal\">Util</span>.DotOrColon( n ) );\n \n      <span class=\"blue\">if</span>( 0 == n )\n      {\n        <span class=\"green\">// interior edge</span>\n        p = lcstart - v - halfThickness * w;\n        q = lcend + v - halfThickness * w;\n        creator.CreateModelLine( p, q );\n      }\n      <span class=\"blue\">else</span>\n      {\n        layerOffset = halfThickness;\n        <span class=\"blue\">foreach</span>( <span class=\"teal\">CompoundStructureLayer</span> layer\n          <span class=\"blue\">in</span> layers )\n        {\n          <span class=\"teal\">Debug</span>.Print(\n            <span class=\"maroon\">\"  Layer {0}: function {1}, \"</span>\n            + <span class=\"maroon\">\"thickness {2}\"</span>,\n            <span class=\"green\">//++i, // 2011</span>\n            layers.IndexOf( layer ), <span class=\"green\">// 2012</span>\n            layer.Function,\n            <span class=\"teal\">Util</span>.MmString( layer.Width ) );\n \n          <span class=\"green\">//layerOffset -= layer.Thickness; // 2011</span>\n          layerOffset -= layer.Width; <span class=\"green\">// 2012</span>\n \n          p = lcstart - v + layerOffset * w;\n          q = lcend + v + layerOffset * w;\n          creator.CreateModelLine( p, q );\n        }\n      }\n    }\n    <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Succeeded;\n  }\n}\n</pre>\n<p>Here is the result of running this on a structural wall:\n\n<pre>\nWalls &lt;246407 Generic - 8\"&gt; with thickness 203.2 mm has 1 layer:\n  Layer 0: function Structure, thickness 203.2 mm\n</pre>\n<p>As said, there is no problem with the IndexOf method itself.\nAs you noted yourself, the issue you observed was due to the repeated call to GetLayers to retrieve the collection multiple times while iterating over it at the same time.\n\n</p></p></p></p></p></p></p></p></p></p></p></p></p></p>"
  },
  {
    "original_filename": "0576_iteration_constancy",
    "header_text": "Accessing the Compound Layer Structure in Revit 2012",
    "local_header_href": "#accessing-the-compound-layer-structure-in-revit-2012",
    "chunk_text": "<h4>Accessing the Compound Layer Structure in Revit 2012</h4><p>For completeness sake, I tested accessing the compound layer structure and the IndexOf method using C# on both an architectural wall in Revit Architecture 2012 and a structural wall in Revit Structure 2012.\nSince I store the layer collection returned by the GetLayers method in an intermediate variable, just as suggested in your solution, I obviously don't see the problem you describe.\nHere is the code that I used, which includes comments to highlight the differences between the Revit 2011 and 2012 APIs, excerpted from the external command CmdWallLayers in\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2011/02/iterating-over-an-unordered-set-property.html\">\nThe Building Coder samples migrated to Revit 2012 API</a> and\n\nwith a call added to exercise the IndexOf method instead of using an additional variable 'i' for the index:\n\n<pre class=\"code\">\n[<span class=\"teal\">Transaction</span>( <span class=\"teal\">TransactionMode</span>.Automatic )]\n<span class=\"blue\">class</span> <span class=\"teal\">CmdWallLayers</span> : <span class=\"teal\">IExternalCommand</span>\n{\n  <span class=\"blue\">public</span> <span class=\"teal\">Result</span> Execute(\n    <span class=\"teal\">ExternalCommandData</span> commandData,\n    <span class=\"blue\">ref</span> <span class=\"blue\">string</span> message,\n    <span class=\"teal\">ElementSet</span> elements )\n  {\n    <span class=\"teal\">UIApplication</span> app = commandData.Application;\n    <span class=\"teal\">UIDocument</span> uidoc = app.ActiveUIDocument;\n    <span class=\"teal\">Document</span> doc = app.ActiveUIDocument.Document;\n \n    <span class=\"green\">// retrieve selected walls, or all walls,</span>\n    <span class=\"green\">// if nothing is selected:</span>\n \n    <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt; walls = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt;();\n    <span class=\"blue\">if</span>( !<span class=\"teal\">Util</span>.GetSelectedElementsOrAll(\n      walls, uidoc, <span class=\"blue\">typeof</span>( <span class=\"teal\">Wall</span> ) ) )\n    {\n      <span class=\"teal\">Selection</span> sel = uidoc.Selection;\n      message = ( 0 &lt; sel.Elements.Size )\n        ? <span class=\"maroon\">\"Please select some wall elements.\"</span>\n        : <span class=\"maroon\">\"No wall elements found.\"</span>;\n      <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n    }\n \n    <span class=\"green\">//int i; // 2011</span>\n    <span class=\"blue\">int</span> n;\n    <span class=\"blue\">double</span> halfThickness, layerOffset;\n    <span class=\"teal\">Creator</span> creator = <span class=\"blue\">new</span> <span class=\"teal\">Creator</span>( doc );\n    <span class=\"teal\">XYZ</span> lcstart, lcend, v, w, p, q;\n \n    <span class=\"blue\">foreach</span>( <span class=\"teal\">Wall</span> wall <span class=\"blue\">in</span> walls )\n    {\n      <span class=\"blue\">string</span> desc = <span class=\"teal\">Util</span>.ElementDescription( wall );\n \n      <span class=\"teal\">LocationCurve</span> curve\n        = wall.Location <span class=\"blue\">as</span> <span class=\"teal\">LocationCurve</span>;\n \n      <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == curve )\n      {\n        message = desc + <span class=\"maroon\">\": No wall curve found.\"</span>;\n        <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n      }\n \n      <span class=\"green\">// wall centre line and thickness:</span>\n \n      lcstart = curve.Curve.get_EndPoint( 0 );\n      lcend = curve.Curve.get_EndPoint( 1 );\n      halfThickness = 0.5 * wall.WallType.Width;\n      v = lcend - lcstart;\n      v = v.Normalize(); <span class=\"green\">// one foot long</span>\n      w = <span class=\"teal\">XYZ</span>.BasisZ.CrossProduct( v ).Normalize();\n      <span class=\"blue\">if</span>( wall.Flipped ) { w = -w; }\n \n      p = lcstart - 2 * v;\n      q = lcend + 2 * v;\n      creator.CreateModelLine( p, q );\n \n      q = p + halfThickness * w;\n      creator.CreateModelLine( p, q );\n \n      <span class=\"green\">// exterior edge</span>\n \n      p = lcstart - v + halfThickness * w;\n      q = lcend + v + halfThickness * w;\n      creator.CreateModelLine( p, q );\n \n      <span class=\"green\">//CompoundStructure structure = wall.WallType.CompoundStructure; // 2011</span>\n      <span class=\"teal\">CompoundStructure</span> structure = wall.WallType.GetCompoundStructure(); <span class=\"green\">// 2012</span>\n \n      <span class=\"green\">//CompoundStructureLayerArray layers = structure.Layers; // 2011</span>\n      <span class=\"teal\">IList</span>&lt;<span class=\"teal\">CompoundStructureLayer</span>&gt; layers = structure.GetLayers(); <span class=\"green\">// 2012</span>\n \n      <span class=\"green\">//i = 0; // 2011</span>\n      <span class=\"green\">//n = layers.Size; // 2011</span>\n      n = layers.Count; <span class=\"green\">// 2012</span>\n \n      <span class=\"teal\">Debug</span>.Print(\n        <span class=\"maroon\">\"{0} with thickness {1}\"</span>\n        + <span class=\"maroon\">\" has {2} layer{3}{4}\"</span>,\n        desc,\n        <span class=\"teal\">Util</span>.MmString( 2 * halfThickness ),\n        n, <span class=\"teal\">Util</span>.PluralSuffix( n ),\n        <span class=\"teal\">Util</span>.DotOrColon( n ) );\n \n      <span class=\"blue\">if</span>( 0 == n )\n      {\n        <span class=\"green\">// interior edge</span>\n        p = lcstart - v - halfThickness * w;\n        q = lcend + v - halfThickness * w;\n        creator.CreateModelLine( p, q );\n      }\n      <span class=\"blue\">else</span>\n      {\n        layerOffset = halfThickness;\n        <span class=\"blue\">foreach</span>( <span class=\"teal\">CompoundStructureLayer</span> layer\n          <span class=\"blue\">in</span> layers )\n        {\n          <span class=\"teal\">Debug</span>.Print(\n            <span class=\"maroon\">\"  Layer {0}: function {1}, \"</span>\n            + <span class=\"maroon\">\"thickness {2}\"</span>,\n            <span class=\"green\">//++i, // 2011</span>\n            layers.IndexOf( layer ), <span class=\"green\">// 2012</span>\n            layer.Function,\n            <span class=\"teal\">Util</span>.MmString( layer.Width ) );\n \n          <span class=\"green\">//layerOffset -= layer.Thickness; // 2011</span>\n          layerOffset -= layer.Width; <span class=\"green\">// 2012</span>\n \n          p = lcstart - v + layerOffset * w;\n          q = lcend + v + layerOffset * w;\n          creator.CreateModelLine( p, q );\n        }\n      }\n    }\n    <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Succeeded;\n  }\n}\n</pre>\n<p>Here is the result of running this on a structural wall:\n\n<pre>\nWalls &lt;246407 Generic - 8\"&gt; with thickness 203.2 mm has 1 layer:\n  Layer 0: function Structure, thickness 203.2 mm\n</pre>\n<p>As said, there is no problem with the IndexOf method itself.\nAs you noted yourself, the issue you observed was due to the repeated call to GetLayers to retrieve the collection multiple times while iterating over it at the same time.\n\n</p></p></p>"
  }
]