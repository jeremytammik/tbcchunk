[
  {
    "original_filename": "0556_toposurf_points",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<head>\n<link href=\"bc.css\" rel=\"stylesheet\" type=\"text/css\"/>\n</head>"
  },
  {
    "original_filename": "0556_toposurf_points",
    "header_text": "Toposurface Interior and Boundary Points",
    "local_header_href": "#toposurface-interior-and-boundary-points",
    "chunk_text": "<h3>Toposurface Interior and Boundary Points</h3><p>I arrived here in \n\n<a href=\"http://en.wikipedia.org/wiki/Jeddah\">\nJeddah</a> last night.\n\nI have not seen anything of it at all yet except through the hotel window, but I will go out exploring today. \nThe Revit API training I am here to give begins on Sunday.\nThe weekend here is on Thursday and Friday, so today is the holiest day of the week.\n\n<p>Meanwhile, here is a recent question that gave me a very welcome chance to try my hand at implementing a little algorithm which requires at least a little bit of geometrical and logical analysis, something I love but unfortunately don't get to do as much as I would like.\n\n<p><strong>Question:</strong> I can access the points of the toposurface.\nHow can I determine which of them are inner and which are boundary points?\n\n<p>Here is the lower left corner boundary point of a surface:</p>\n<center>\n<img alt=\"Toposurface boundary point\" src=\"img/toposurface_boundary_point.png\"/>\n</center>\n<p>Here is its middle interior point:</p>\n<center>\n<img alt=\"Toposurface interior point\" src=\"img/toposurface_interior_point.png\"/>\n</center>\n<p>I tried to enumerate all the mesh triangles and determine whether a point is interior or boundary depending on how many triangles it belongs to, assuming if it just belongs to one or two it would be exterior and three interior, but that seems to be totally wrong.\nCould you explain why, please?\n\n<p>Here is part of my testing code, but, as said, it does not work at all:\n\n<pre class=\"code\">\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n<span class=\"gray\">///</span><span class=\"green\"> For each point of the given mesh,</span>\n<span class=\"gray\">///</span><span class=\"green\"> determine how many triangles it belongs to.</span>\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n<span class=\"blue\">void</span> DetermineTriangleCountForPoints( <span class=\"teal\">Mesh</span> mesh )\n{\n  <span class=\"blue\">int</span> np = mesh.Vertices.Count;\n  <span class=\"blue\">int</span> nt = mesh.NumTriangles;\n \n  <span class=\"teal\">Debug</span>.Print( <span class=\"maroon\">\"Mesh has {0} point{1} and {2} triangle{3}.\"</span>,\n    np, PluralSuffix( np ), nt, PluralSuffix( nt ) );\n \n  <span class=\"teal\">MapVertexToTriangleIndices</span> map \n    = <span class=\"blue\">new</span> <span class=\"teal\">MapVertexToTriangleIndices</span>();\n \n  <span class=\"blue\">for</span>( <span class=\"blue\">int</span> i = 0; i &lt; nt; ++i )\n  {\n    <span class=\"teal\">MeshTriangle</span> t = mesh.get_Triangle( i );\n \n    <span class=\"blue\">for</span>( <span class=\"blue\">int</span> j = 0; j &lt; 3; ++j )\n    {\n      map.AddVertex( t.get_Vertex( j ), i );\n    }\n  }\n  <span class=\"teal\">List</span>&lt;<span class=\"teal\">XYZ</span>&gt; pts = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">XYZ</span>&gt;( map.Keys );\n  pts.Sort( Compare );\n \n  <span class=\"blue\">foreach</span>( <span class=\"teal\">XYZ</span> p <span class=\"blue\">in</span> pts )\n  {\n    <span class=\"blue\">int</span> n = map[p].Count;\n \n    <span class=\"teal\">Debug</span>.Print( <span class=\"maroon\">\"  vertex {0} belongs to {1} triangle{2}\"</span>, \n      PointString( p ), n, PluralSuffix( n ) );\n  }\n}\n</pre>\n<p>Here is the result of running it on the surface above before I discovered that the interior versus boundary classification is completely wrong:\n\n<pre class=\"code\">\nTopographySurface 128689:\nMesh has 6 points and 5 triangles.\n  (-35.952648163, -68.290878296, 0.000000000) \n    belongs to 3 triangles and is therefore interior\n  (-34.969902039, -57.134258270, 0.000000000) \n    belongs to 1 triangle and is therefore exterior\n  (-24.212404251, -76.898384094, 0.000000000) \n    belongs to 2 triangles and is therefore exterior\n  (-23.932262421, -60.340045929, 0.000000000) \n    belongs to 3 triangles and is therefore interior\n  (-23.100381851, -69.003776550, 0.000000000) \n    belongs to 4 triangles and is therefore exterior\n  (-14.513459206, -65.842926025, 0.000000000) \n    belongs to 2 triangles and is therefore exterior\n</pre>\n<p>Could you please suggest a working method to distinguish boundary and interior toposurface mesh points?\n\n<p>As Revit tells me whether a point is boundary or interior in the user interface, where does it get this info from?\n\n<p>By the way, is there any way to display the mesh triangles and possibly even their indices in the Revit UI?\n\n\n<p><strong>Answer:</strong> There is currently no built-in Revit API functionality that will provide this info. \nWe are aware of a few gaps in the current toposurface API.\nHere is a host of public \n\n<a href=\"http://en.wikipedia.org/wiki/Convex_hull_algorithms\">\nconvex hull algorithms</a> that \n\nyou could try, though.\n\n<p>Remember, Z should be ignorable, if you are only looking for boundaries it's really about XY location \n\nfor a toposurface.\n\n<p>Revit's internal functions to determine the boundary of a mesh are based on the following algorithm idea: \n\n<p>In order to identify boundary points, one has to first identify boundary edges. \n\nA boundary edge is an edge belonging to only one triangle. \nAll other (interior) edges are shared by two triangles. \nDetermining if an edge is shared by one or two triangles is a bit tricky. \n\n<p>I implemented an algorithm based on this idea, and it seems to work fine. \nI worked on it through several stages. \n\n<p>In a first step, I determine the triangle count for each mesh vertex just as you did above in the implementation of DetermineTriangleCountForPoints. \nAs you discovered, this information is insufficient to classify the point into boundary or interior. \n\n<p>In a second step, I determine whether an edge is an interior edge or not, implemented in the method DetermineTriangleCountForEdges. \n\n<p>This works reliably, and just needs one further step to classify the points. \n\n<h4>Identifying Points</h4>\n<p>At this point, I changed something else as well, though.\nI was initially identifying the points and edges using their coordinate values. \nBefore proceeding to the third stage, I decided to identify them by the vertex indices of the points in the list of mesh vertices instead.\nIt is obviously much more reliable and efficient to identify the points by one single integer value rather than a fuzzy comparison of three real values.\n\n<p>For example, DetermineTriangleCountForEdges is based on a helper class to represent the triangle edges \n\nwhich stores the complete XYZ start and end point data of each edge:\n\n<pre class=\"code\">\n<span class=\"blue\">public</span> <span class=\"blue\">class</span> <span class=\"teal\">MeshTriangleEdge</span>\n{\n  <span class=\"blue\">public</span> <span class=\"teal\">XYZ</span> A { <span class=\"blue\">get</span>; <span class=\"blue\">set</span>; }\n  <span class=\"blue\">public</span> <span class=\"teal\">XYZ</span> B { <span class=\"blue\">get</span>; <span class=\"blue\">set</span>; }\n \n  <span class=\"blue\">public</span> MeshTriangleEdge( <span class=\"teal\">XYZ</span> a, <span class=\"teal\">XYZ</span> b )\n  {\n    <span class=\"blue\">int</span> d = Compare( a, b );\n \n    <span class=\"teal\">Debug</span>.Assert( 0 != d, <span class=\"maroon\">\"expected non-equal edge vertices\"</span> );\n \n    A = ( 0 &lt; d ) ? a : b;\n    B = ( 0 &lt; d ) ? b : a;\n  }\n}\n</pre>\n<p>After deciding that a method storing the edges based on the mesh vertex index of their start and end points instead of the XYZ coordinates is more efficient and reliable, I switched to that representation in the third step using the following class to represent the edges:\n\n<pre class=\"code\">\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n<span class=\"gray\">///</span><span class=\"green\"> Manage a mesh triangle edge by storing the </span>\n<span class=\"gray\">///</span><span class=\"green\"> index of the mesh vertex corresponing to</span>\n<span class=\"gray\">///</span><span class=\"green\"> the edge start and end point.</span>\n<span class=\"gray\">///</span><span class=\"green\"> For reliable comparison purposes, the </span>\n<span class=\"gray\">///</span><span class=\"green\"> lower index is always stored in A and </span>\n<span class=\"gray\">///</span><span class=\"green\"> the higher in B.</span>\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n<span class=\"blue\">public</span> <span class=\"blue\">class</span> <span class=\"teal\">JtEdge</span>\n{\n  <span class=\"blue\">public</span> <span class=\"blue\">int</span> A { <span class=\"blue\">get</span>; <span class=\"blue\">set</span>; }\n  <span class=\"blue\">public</span> <span class=\"blue\">int</span> B { <span class=\"blue\">get</span>; <span class=\"blue\">set</span>; }\n \n  <span class=\"blue\">public</span> JtEdge( <span class=\"blue\">int</span> a, <span class=\"blue\">int</span> b )\n  {\n    <span class=\"teal\">Debug</span>.Assert( a != b, <span class=\"maroon\">\"expected non-equal edge vertices\"</span> );\n \n    A = ( a &lt; b ) ? a : b;\n    B = ( a &lt; b ) ? b : a;\n  }\n}\n</pre>\n<h4>Classifying Points</h4>\n<p>The third step consists in determining whether a point is interior or boundary, implemented in the method ClassifyPoints. A point is interior if all of the edges it belongs to also are. If one single edge is a boundary, then so is the point.\n\n<p>I make use of a couple of helper classes implementing dictionaries to simplify the mainline of the code. \nOne is MapEdgeToTriangles, which  maps a mesh triangle edge to a list of the indices of all the triangles it belongs to:\n\n<pre class=\"code\">\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n<span class=\"gray\">///</span><span class=\"green\"> Map mesh triangle edges to a list of the </span>\n<span class=\"gray\">///</span><span class=\"green\"> indices of all the triangles they belong to.</span>\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n<span class=\"blue\">class</span> <span class=\"teal\">MapEdgeToTriangles</span>\n  : <span class=\"teal\">Dictionary</span>&lt;<span class=\"teal\">JtEdge</span>, <span class=\"teal\">List</span>&lt;<span class=\"blue\">int</span>&gt;&gt;\n{\n  <span class=\"blue\">public</span> MapEdgeToTriangles()\n    : <span class=\"blue\">base</span>( <span class=\"blue\">new</span> <span class=\"teal\">JtEdgeEqualityComparer</span>() )\n  {\n  }\n \n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n  <span class=\"gray\">///</span><span class=\"green\"> Add a new edge.</span>\n  <span class=\"gray\">///</span><span class=\"green\"> If it is already known, append the triangle </span>\n  <span class=\"gray\">///</span><span class=\"green\"> index of the current triangle. Otherwise, </span>\n  <span class=\"gray\">///</span><span class=\"green\"> generate a new key for it.</span>\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n  <span class=\"blue\">public</span> <span class=\"blue\">void</span> AddEdge(\n    <span class=\"teal\">JtEdge</span> e,\n    <span class=\"blue\">int</span> triangleIndex )\n  {\n    <span class=\"blue\">if</span>( !ContainsKey( e ) )\n    {\n      Add( e, <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"blue\">int</span>&gt;( 2 ) );\n    }\n    ( <span class=\"blue\">this</span> )[e].Add( triangleIndex );\n  }\n}\n</pre>\n<p>Another is MapVertexToEdges, mapping a mesh vertex index to a list of the edges the vertex belongs to.\n\n<pre class=\"code\">\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n<span class=\"gray\">///</span><span class=\"green\"> Map mesh vertex index to a list of the edges </span>\n<span class=\"gray\">///</span><span class=\"green\"> the vertex belongs to.</span>\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n<span class=\"blue\">class</span> <span class=\"teal\">MapVertexToEdges</span>\n  : <span class=\"teal\">Dictionary</span>&lt;<span class=\"blue\">int</span>, <span class=\"teal\">List</span>&lt;<span class=\"teal\">JtEdge</span>&gt;&gt;\n{\n  <span class=\"blue\">public</span> MapVertexToEdges( <span class=\"blue\">int</span> capacity )\n    : <span class=\"blue\">base</span>( capacity )\n  {\n  }\n \n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n  <span class=\"gray\">///</span><span class=\"green\"> Append a new edge for a given vertex.</span>\n  <span class=\"gray\">///</span><span class=\"green\"> If the vertex is new, generate a new key for it.</span>\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n  <span class=\"blue\">public</span> <span class=\"blue\">void</span> AddVertexEdge(\n    <span class=\"blue\">int</span> vertexIndex,\n    <span class=\"teal\">JtEdge</span> e )\n  {\n    <span class=\"blue\">if</span>( !ContainsKey( vertexIndex ) )\n    {\n      Add( vertexIndex, <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">JtEdge</span>&gt;( 2 ) );\n    }\n    ( <span class=\"blue\">this</span> )[vertexIndex].Add( e );\n  }\n}\n</pre>\n<p>Both of these basically just provide an enhanced method for adding a new element to the dictionary.\n\n<p>Here is the implementation of the main algorithm:\n\n<pre class=\"code\">\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n<span class=\"gray\">///</span><span class=\"green\"> For each point of the given mesh,</span>\n<span class=\"gray\">///</span><span class=\"green\"> determine whether it is interior or boundary.</span>\n<span class=\"gray\">///</span><span class=\"green\"> The algorithm goes like this:</span>\n<span class=\"gray\">///</span><span class=\"green\"> Every triangle edge belongs to either one or two triangles,</span>\n<span class=\"gray\">///</span><span class=\"green\"> depending on whether it it boundary or interior.</span>\n<span class=\"gray\">///</span><span class=\"green\"> For each edge, determine whether it is boundary </span>\n<span class=\"gray\">///</span><span class=\"green\"> or interior. A point is interior if all of the edges it </span>\n<span class=\"gray\">///</span><span class=\"green\"> belongs to are interior.</span>\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;returns&gt;</span><span class=\"green\">A dictionary mapping each mesh vertex index </span>\n<span class=\"gray\">///</span><span class=\"green\"> to a Boolean which is true if the corresponding point </span>\n<span class=\"gray\">///</span><span class=\"green\"> is interior and false if it is on the boundary</span><span class=\"gray\">&lt;/returns&gt;</span>\n<span class=\"teal\">Dictionary</span>&lt;<span class=\"blue\">int</span>, <span class=\"blue\">bool</span>&gt; ClassifyPoints( <span class=\"teal\">Mesh</span> mesh )\n{\n  <span class=\"blue\">int</span> nv = mesh.Vertices.Count;\n  <span class=\"blue\">int</span> nt = mesh.NumTriangles;\n  <span class=\"blue\">int</span> i, n;\n \n  <span class=\"teal\">Debug</span>.Print( <span class=\"maroon\">\"\\nClassifyPoints: mesh has {0} point{1} and {2} triangle{3}:\"</span>,\n    nv, PluralSuffix( nv ), nt, PluralSuffix( nt ) );\n \n  <span class=\"green\">// set up a map to determine the vertex </span>\n  <span class=\"green\">// index of a given triangle vertex;</span>\n  <span class=\"green\">// this is needed because the </span>\n  <span class=\"green\">// MeshTriangle.get_Vertex method</span>\n  <span class=\"green\">// returns the XYZ but not the index,</span>\n  <span class=\"green\">// and we base our edges on the index:</span>\n \n  <span class=\"teal\">Dictionary</span>&lt;<span class=\"teal\">XYZ</span>, <span class=\"blue\">int</span>&gt; vertexIndex\n    = <span class=\"blue\">new</span> <span class=\"teal\">Dictionary</span>&lt;<span class=\"teal\">XYZ</span>, <span class=\"blue\">int</span>&gt;( nv, <span class=\"blue\">new</span> <span class=\"teal\">XyzEqualityComparer</span>() );\n \n  <span class=\"blue\">for</span>( i = 0; i &lt; nv; ++i )\n  {\n    <span class=\"teal\">XYZ</span> p = mesh.Vertices[i];\n    <span class=\"teal\">Debug</span>.Print( <span class=\"maroon\">\"  mesh vertex {0}: {1}\"</span>, i, PointString( p ) );\n    vertexIndex[p] = i;\n  }\n \n  <span class=\"green\">// set up a map to determine which </span>\n  <span class=\"green\">// edges a given vertex belongs to:</span>\n \n  <span class=\"teal\">MapVertexToEdges</span> vertexEdges\n    = <span class=\"blue\">new</span> <span class=\"teal\">MapVertexToEdges</span>( nv );\n \n  <span class=\"green\">// set up a map to determine which </span>\n  <span class=\"green\">// triangles a given edge belongs to;</span>\n  <span class=\"green\">// this is used to determine the edge's</span>\n  <span class=\"green\">// interior or boundary status:</span>\n \n  <span class=\"teal\">MapEdgeToTriangles</span> map\n    = <span class=\"blue\">new</span> <span class=\"teal\">MapEdgeToTriangles</span>();\n \n  <span class=\"blue\">for</span>( i = 0; i &lt; nt; ++i )\n  {\n    <span class=\"teal\">MeshTriangle</span> t = mesh.get_Triangle( i );\n \n    <span class=\"blue\">for</span>( <span class=\"blue\">int</span> j = 0; j &lt; 3; ++j )\n    {\n      <span class=\"green\">// get the start and end vertex </span>\n      <span class=\"green\">// of the current triangle edge:</span>\n \n      <span class=\"blue\">int</span> a = vertexIndex[t.get_Vertex( 0 == j ? 2 : j - 1 )];\n      <span class=\"blue\">int</span> b = vertexIndex[t.get_Vertex( j )];\n \n      <span class=\"teal\">JtEdge</span> e = <span class=\"blue\">new</span> <span class=\"teal\">JtEdge</span>( a, b );\n \n      map.AddEdge( e, i );\n \n      vertexEdges.AddVertexEdge( a, e );\n      vertexEdges.AddVertexEdge( b, e );\n    }\n  }\n \n  <span class=\"blue\">int</span> nBoundaryEdges;\n  <span class=\"blue\">int</span> nInteriorPoints = 0;\n \n  <span class=\"teal\">Dictionary</span>&lt;<span class=\"blue\">int</span>, <span class=\"blue\">bool</span>&gt; dict = <span class=\"blue\">new</span> <span class=\"teal\">Dictionary</span>&lt;<span class=\"blue\">int</span>,<span class=\"blue\">bool</span>&gt;( nv );\n \n  <span class=\"teal\">Debug</span>.Print( <span class=\"maroon\">\"Classify the {0} point{1}:\"</span>, nv, PluralSuffix( nv ) );\n \n  <span class=\"blue\">for</span>( i = 0; i &lt; nv; ++i )\n  {\n    nBoundaryEdges = 0;\n    n = vertexEdges[i].Count;\n \n    nBoundaryEdges = vertexEdges[i].Count&lt;<span class=\"teal\">JtEdge</span>&gt;( \n      e =&gt; 1 == map[e].Count );\n \n    dict[i] = ( 0 == nBoundaryEdges );\n \n    <span class=\"teal\">XYZ</span> p = mesh.Vertices[i];\n \n    <span class=\"blue\">if</span>( 0 == nBoundaryEdges )\n    {\n      ++nInteriorPoints;\n    }\n \n    <span class=\"teal\">Debug</span>.Print( <span class=\"maroon\">\"  point {0} {1} belongs to {2} edge{3}, \"</span>\n      + <span class=\"maroon\">\"{4} interior and {5} boundary and is therefore {6}\"</span>,\n      i, PointString( p ), n, PluralSuffix( n ),\n      n - nBoundaryEdges, nBoundaryEdges,\n      ( 0 == nBoundaryEdges ? <span class=\"maroon\">\"interior\"</span> : <span class=\"maroon\">\"boundary\"</span> ) );\n  }\n  <span class=\"teal\">Debug</span>.Print( <span class=\"maroon\">\"{0} boundary and {1} interior points detected.\"</span>,\n    nv - nInteriorPoints, nInteriorPoints );\n \n  <span class=\"blue\">return</span> dict;\n}\n</pre>\n<p>I tested this on the following topo surfaces of increasing complexity:\n\n<ul>\n<li>a triangle, \n<li>a quadrilateral with four boundary points, \n<li>another quadrilateral with an additional interior point, and\n<li>a larger surface with 26 points\n</li></li></li></li></ul>\n<p>They look like this in Revit:</p>\n<center>\n<img alt=\"Toposurfaces\" src=\"img/toposurfaces.png\"/>\n</center>\n<p>Here are the results (please copy to a text editor to see the full untruncated lines):\n\n<pre class=\"code\">\nTopographySurface 128701:\n\nClassifyPoints: mesh has 3 points and 1 triangle:\n  mesh vertex 0: (-14.39,11.53,0)\n  mesh vertex 1: (2.81,12.55,0)\n  mesh vertex 2: (-7.4,22.76,0)\n  triangle 0 vertex 0: (-14.39,11.53,0)\n  triangle 0 vertex 1: (2.81,12.55,0)\n  triangle 0 vertex 2: (-7.4,22.76,0)\nClassify the 3 edges:\n  edge 0-&gt;1 belongs to 1 triangle and is therefore boundary\n  edge 0-&gt;2 belongs to 1 triangle and is therefore boundary\n  edge 1-&gt;2 belongs to 1 triangle and is therefore boundary\nClassify the 3 points:\n  point 0 (-14.39,11.53,0) belongs to 2 edges, 0 interior and 2 boundary and is therefore boundary\n  point 1 (2.81,12.55,0) belongs to 2 edges, 0 interior and 2 boundary and is therefore boundary\n  point 2 (-7.4,22.76,0) belongs to 2 edges, 0 interior and 2 boundary and is therefore boundary\n3 boundary and 0 interior points detected.\n\nTopographySurface 128712:\n\nClassifyPoints: mesh has 4 points and 2 triangles:\n  mesh vertex 0: (25.45,10.77,0)\n  mesh vertex 1: (25.01,23.65,0)\n  mesh vertex 2: (38.32,11.22,0)\n  mesh vertex 3: (38.77,24.09,0)\n  triangle 0 vertex 0: (25.01,23.65,0)\n  triangle 0 vertex 1: (25.45,10.77,0)\n  triangle 0 vertex 2: (38.32,11.22,0)\n  triangle 1 vertex 0: (38.32,11.22,0)\n  triangle 1 vertex 1: (38.77,24.09,0)\n  triangle 1 vertex 2: (25.01,23.65,0)\nClassify the 5 edges:\n  edge 0-&gt;1 belongs to 1 triangle and is therefore boundary\n  edge 0-&gt;2 belongs to 1 triangle and is therefore boundary\n  edge 1-&gt;2 belongs to 2 triangles and is therefore interior\n  edge 1-&gt;3 belongs to 1 triangle and is therefore boundary\n  edge 2-&gt;3 belongs to 1 triangle and is therefore boundary\nClassify the 4 points:\n  point 0 (25.45,10.77,0) belongs to 2 edges, 0 interior and 2 boundary and is therefore boundary\n  point 1 (25.01,23.65,0) belongs to 4 edges, 2 interior and 2 boundary and is therefore boundary\n  point 2 (38.32,11.22,0) belongs to 4 edges, 2 interior and 2 boundary and is therefore boundary\n  point 3 (38.77,24.09,0) belongs to 2 edges, 0 interior and 2 boundary and is therefore boundary\n4 boundary and 0 interior points detected.\n\nTopographySurface 128718:\n\nClassifyPoints: mesh has 5 points and 4 triangles:\n  mesh vertex 0: (80.05,28.53,0)\n  mesh vertex 1: (63.18,39.63,0)\n  mesh vertex 2: (84.49,41.85,0)\n  mesh vertex 3: (75.61,52.06,0)\n  mesh vertex 4: (98.7,45.84,0)\n  triangle 0 vertex 0: (75.61,52.06,0)\n  triangle 0 vertex 1: (63.18,39.63,0)\n  triangle 0 vertex 2: (84.49,41.85,0)\n  triangle 1 vertex 0: (80.05,28.53,0)\n  triangle 1 vertex 1: (98.7,45.84,0)\n  triangle 1 vertex 2: (84.49,41.85,0)\n  triangle 2 vertex 0: (84.49,41.85,0)\n  triangle 2 vertex 1: (98.7,45.84,0)\n  triangle 2 vertex 2: (75.61,52.06,0)\n  triangle 3 vertex 0: (80.05,28.53,0)\n  triangle 3 vertex 1: (84.49,41.85,0)\n  triangle 3 vertex 2: (63.18,39.63,0)\nClassify the 8 edges:\n  edge 0-&gt;1 belongs to 1 triangle and is therefore boundary\n  edge 0-&gt;2 belongs to 2 triangles and is therefore interior\n  edge 0-&gt;4 belongs to 1 triangle and is therefore boundary\n  edge 1-&gt;2 belongs to 2 triangles and is therefore interior\n  edge 1-&gt;3 belongs to 1 triangle and is therefore boundary\n  edge 2-&gt;3 belongs to 2 triangles and is therefore interior\n  edge 2-&gt;4 belongs to 2 triangles and is therefore interior\n  edge 3-&gt;4 belongs to 1 triangle and is therefore boundary\nClassify the 5 points:\n  point 0 (80.05,28.53,0) belongs to 4 edges, 2 interior and 2 boundary and is therefore boundary\n  point 1 (63.18,39.63,0) belongs to 4 edges, 2 interior and 2 boundary and is therefore boundary\n  point 2 (84.49,41.85,0) belongs to 8 edges, 8 interior and 0 boundary and is therefore interior\n  point 3 (75.61,52.06,0) belongs to 4 edges, 2 interior and 2 boundary and is therefore boundary\n  point 4 (98.7,45.84,0) belongs to 4 edges, 2 interior and 2 boundary and is therefore boundary\n4 boundary and 1 interior points detected.\n\nTopographySurface 128725:\n\nClassifyPoints: mesh has 26 points and 39 triangles:\n  mesh vertex 0: (-87.01,-44.72,0)\n  mesh vertex 1: (-75.47,-26.96,0)\n  . . .\n  mesh vertex 25: (-83.46,-24.3,0)\n  triangle 0 vertex 0: (-87.01,-44.72,0)\n  triangle 0 vertex 1: (-77.69,-55.82,0)\n  . . .\n  triangle 38 vertex 2: (-75.47,-26.96,0)\nClassify the 64 edges:\n  edge 0-&gt;8 belongs to 1 triangle and is therefore boundary\n  edge 0-&gt;11 belongs to 1 triangle and is therefore boundary\n  . . .\n  edge 24-&gt;25 belongs to 1 triangle and is therefore boundary\nClassify the 26 points:\n  point 0 (-87.01,-44.72,0) belongs to 6 edges, 4 interior and 2 boundary and is therefore boundary\n point 1 (-75.47,-26.96,0) belongs to 10 edges, 10 interior and 0 boundary and is therefore interior\n  point 2 (-55.49,-19.86,0) belongs to 10 edges, 10 interior and 0 boundary and is therefore interior\n  point 3 (-53.71,-33.18,0) belongs to 12 edges, 12 interior and 0 boundary and is therefore interior\n  point 4 (-43.06,-26.96,0) belongs to 8 edges, 6 interior and 2 boundary and is therefore boundary\n  point 5 (-43.06,-42.5,0) belongs to 10 edges, 10 interior and 0 boundary and is therefore interior\n  point 6 (-65.26,-35.4,0) belongs to 12 edges, 12 interior and 0 boundary and is therefore interior\n  point 7 (-60.37,-53.15,0) belongs to 12 edges, 12 interior and 0 boundary and is therefore interior\n  point 8 (-77.69,-55.82,0) belongs to 8 edges, 6 interior and 2 boundary and is therefore boundary\n  point 9 (-68.36,-43.83,0) belongs to 14 edges, 14 interior and 0 boundary and is therefore interior\n  point 10 (-41.28,-54.49,0) belongs to 8 edges, 6 interior and 2 boundary and is therefore boundary\n  point 11 (-88.34,-33.62,0) belongs to 4 edges, 2 interior and 2 boundary and is therefore boundary\n  point 12 (-66.14,-61.14,0) belongs to 6 edges, 4 interior and 2 boundary and is therefore boundary\n  point 13 (-79.02,-44.28,0) belongs to 10 edges, 10 interior and 0 boundary and is therefore interior\n  point 14 (-81.68,-32.73,0) belongs to 14 edges, 14 interior and 0 boundary and is therefore interior\n  point 15 (-63.93,-26.96,0) belongs to 14 edges, 14 interior and 0 boundary and is therefore interior\n  point 16 (-55.05,-43.39,0) belongs to 12 edges, 12 interior and 0 boundary and is therefore interior\n  point 17 (-47.5,-50.93,0) belongs to 8 edges, 8 interior and 0 boundary and is therefore interior\n  point 18 (-74.58,-50.93,0) belongs to 8 edges, 8 interior and 0 boundary and is therefore interior\n  point 19 (-68.81,-54.93,0) belongs to 10 edges, 10 interior and 0 boundary and is therefore interior\n  point 20 (-53.71,-26.07,0) belongs to 10 edges, 10 interior and 0 boundary and is therefore interior\n  point 21 (-47.06,-18.97,0) belongs to 6 edges, 4 interior and 2 boundary and is therefore boundary\n  point 22 (-49.72,-14.98,0) belongs to 4 edges, 2 interior and 2 boundary and is therefore boundary\n  point 23 (-67.03,-17.64,0) belongs to 6 edges, 4 interior and 2 boundary and is therefore boundary\n  point 24 (-74.58,-19.42,0) belongs to 6 edges, 4 interior and 2 boundary and is therefore boundary\n  point 25 (-83.46,-24.3,0) belongs to 6 edges, 4 interior and 2 boundary and is therefore boundary\n11 boundary and 15 interior points detected.\n</pre>\n<p>As far as I can tell, this works efficiently and reliably.\n\n<p>Please let me know what experiences you have with this and whether it solves the problem for you. Thank you!\n\n<p>Here is \n\n<a href=\"zip/TopoSurfacePointClassify.zip\">\nTopoSurfacePointClassify.zip</a> containing \n\nthe entire source code and Visual Studio solution implementing this add-in.\n</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p>"
  },
  {
    "original_filename": "0556_toposurf_points",
    "header_text": "Identifying Points",
    "local_header_href": "#identifying-points",
    "chunk_text": "<h4>Identifying Points</h4><p>At this point, I changed something else as well, though.\nI was initially identifying the points and edges using their coordinate values. \nBefore proceeding to the third stage, I decided to identify them by the vertex indices of the points in the list of mesh vertices instead.\nIt is obviously much more reliable and efficient to identify the points by one single integer value rather than a fuzzy comparison of three real values.\n\n<p>For example, DetermineTriangleCountForEdges is based on a helper class to represent the triangle edges \n\nwhich stores the complete XYZ start and end point data of each edge:\n\n<pre class=\"code\">\n<span class=\"blue\">public</span> <span class=\"blue\">class</span> <span class=\"teal\">MeshTriangleEdge</span>\n{\n  <span class=\"blue\">public</span> <span class=\"teal\">XYZ</span> A { <span class=\"blue\">get</span>; <span class=\"blue\">set</span>; }\n  <span class=\"blue\">public</span> <span class=\"teal\">XYZ</span> B { <span class=\"blue\">get</span>; <span class=\"blue\">set</span>; }\n \n  <span class=\"blue\">public</span> MeshTriangleEdge( <span class=\"teal\">XYZ</span> a, <span class=\"teal\">XYZ</span> b )\n  {\n    <span class=\"blue\">int</span> d = Compare( a, b );\n \n    <span class=\"teal\">Debug</span>.Assert( 0 != d, <span class=\"maroon\">\"expected non-equal edge vertices\"</span> );\n \n    A = ( 0 &lt; d ) ? a : b;\n    B = ( 0 &lt; d ) ? b : a;\n  }\n}\n</pre>\n<p>After deciding that a method storing the edges based on the mesh vertex index of their start and end points instead of the XYZ coordinates is more efficient and reliable, I switched to that representation in the third step using the following class to represent the edges:\n\n<pre class=\"code\">\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n<span class=\"gray\">///</span><span class=\"green\"> Manage a mesh triangle edge by storing the </span>\n<span class=\"gray\">///</span><span class=\"green\"> index of the mesh vertex corresponing to</span>\n<span class=\"gray\">///</span><span class=\"green\"> the edge start and end point.</span>\n<span class=\"gray\">///</span><span class=\"green\"> For reliable comparison purposes, the </span>\n<span class=\"gray\">///</span><span class=\"green\"> lower index is always stored in A and </span>\n<span class=\"gray\">///</span><span class=\"green\"> the higher in B.</span>\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n<span class=\"blue\">public</span> <span class=\"blue\">class</span> <span class=\"teal\">JtEdge</span>\n{\n  <span class=\"blue\">public</span> <span class=\"blue\">int</span> A { <span class=\"blue\">get</span>; <span class=\"blue\">set</span>; }\n  <span class=\"blue\">public</span> <span class=\"blue\">int</span> B { <span class=\"blue\">get</span>; <span class=\"blue\">set</span>; }\n \n  <span class=\"blue\">public</span> JtEdge( <span class=\"blue\">int</span> a, <span class=\"blue\">int</span> b )\n  {\n    <span class=\"teal\">Debug</span>.Assert( a != b, <span class=\"maroon\">\"expected non-equal edge vertices\"</span> );\n \n    A = ( a &lt; b ) ? a : b;\n    B = ( a &lt; b ) ? b : a;\n  }\n}\n</pre>\n<h4>Classifying Points</h4>\n<p>The third step consists in determining whether a point is interior or boundary, implemented in the method ClassifyPoints. A point is interior if all of the edges it belongs to also are. If one single edge is a boundary, then so is the point.\n\n<p>I make use of a couple of helper classes implementing dictionaries to simplify the mainline of the code. \nOne is MapEdgeToTriangles, which  maps a mesh triangle edge to a list of the indices of all the triangles it belongs to:\n\n<pre class=\"code\">\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n<span class=\"gray\">///</span><span class=\"green\"> Map mesh triangle edges to a list of the </span>\n<span class=\"gray\">///</span><span class=\"green\"> indices of all the triangles they belong to.</span>\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n<span class=\"blue\">class</span> <span class=\"teal\">MapEdgeToTriangles</span>\n  : <span class=\"teal\">Dictionary</span>&lt;<span class=\"teal\">JtEdge</span>, <span class=\"teal\">List</span>&lt;<span class=\"blue\">int</span>&gt;&gt;\n{\n  <span class=\"blue\">public</span> MapEdgeToTriangles()\n    : <span class=\"blue\">base</span>( <span class=\"blue\">new</span> <span class=\"teal\">JtEdgeEqualityComparer</span>() )\n  {\n  }\n \n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n  <span class=\"gray\">///</span><span class=\"green\"> Add a new edge.</span>\n  <span class=\"gray\">///</span><span class=\"green\"> If it is already known, append the triangle </span>\n  <span class=\"gray\">///</span><span class=\"green\"> index of the current triangle. Otherwise, </span>\n  <span class=\"gray\">///</span><span class=\"green\"> generate a new key for it.</span>\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n  <span class=\"blue\">public</span> <span class=\"blue\">void</span> AddEdge(\n    <span class=\"teal\">JtEdge</span> e,\n    <span class=\"blue\">int</span> triangleIndex )\n  {\n    <span class=\"blue\">if</span>( !ContainsKey( e ) )\n    {\n      Add( e, <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"blue\">int</span>&gt;( 2 ) );\n    }\n    ( <span class=\"blue\">this</span> )[e].Add( triangleIndex );\n  }\n}\n</pre>\n<p>Another is MapVertexToEdges, mapping a mesh vertex index to a list of the edges the vertex belongs to.\n\n<pre class=\"code\">\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n<span class=\"gray\">///</span><span class=\"green\"> Map mesh vertex index to a list of the edges </span>\n<span class=\"gray\">///</span><span class=\"green\"> the vertex belongs to.</span>\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n<span class=\"blue\">class</span> <span class=\"teal\">MapVertexToEdges</span>\n  : <span class=\"teal\">Dictionary</span>&lt;<span class=\"blue\">int</span>, <span class=\"teal\">List</span>&lt;<span class=\"teal\">JtEdge</span>&gt;&gt;\n{\n  <span class=\"blue\">public</span> MapVertexToEdges( <span class=\"blue\">int</span> capacity )\n    : <span class=\"blue\">base</span>( capacity )\n  {\n  }\n \n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n  <span class=\"gray\">///</span><span class=\"green\"> Append a new edge for a given vertex.</span>\n  <span class=\"gray\">///</span><span class=\"green\"> If the vertex is new, generate a new key for it.</span>\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n  <span class=\"blue\">public</span> <span class=\"blue\">void</span> AddVertexEdge(\n    <span class=\"blue\">int</span> vertexIndex,\n    <span class=\"teal\">JtEdge</span> e )\n  {\n    <span class=\"blue\">if</span>( !ContainsKey( vertexIndex ) )\n    {\n      Add( vertexIndex, <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">JtEdge</span>&gt;( 2 ) );\n    }\n    ( <span class=\"blue\">this</span> )[vertexIndex].Add( e );\n  }\n}\n</pre>\n<p>Both of these basically just provide an enhanced method for adding a new element to the dictionary.\n\n<p>Here is the implementation of the main algorithm:\n\n<pre class=\"code\">\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n<span class=\"gray\">///</span><span class=\"green\"> For each point of the given mesh,</span>\n<span class=\"gray\">///</span><span class=\"green\"> determine whether it is interior or boundary.</span>\n<span class=\"gray\">///</span><span class=\"green\"> The algorithm goes like this:</span>\n<span class=\"gray\">///</span><span class=\"green\"> Every triangle edge belongs to either one or two triangles,</span>\n<span class=\"gray\">///</span><span class=\"green\"> depending on whether it it boundary or interior.</span>\n<span class=\"gray\">///</span><span class=\"green\"> For each edge, determine whether it is boundary </span>\n<span class=\"gray\">///</span><span class=\"green\"> or interior. A point is interior if all of the edges it </span>\n<span class=\"gray\">///</span><span class=\"green\"> belongs to are interior.</span>\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;returns&gt;</span><span class=\"green\">A dictionary mapping each mesh vertex index </span>\n<span class=\"gray\">///</span><span class=\"green\"> to a Boolean which is true if the corresponding point </span>\n<span class=\"gray\">///</span><span class=\"green\"> is interior and false if it is on the boundary</span><span class=\"gray\">&lt;/returns&gt;</span>\n<span class=\"teal\">Dictionary</span>&lt;<span class=\"blue\">int</span>, <span class=\"blue\">bool</span>&gt; ClassifyPoints( <span class=\"teal\">Mesh</span> mesh )\n{\n  <span class=\"blue\">int</span> nv = mesh.Vertices.Count;\n  <span class=\"blue\">int</span> nt = mesh.NumTriangles;\n  <span class=\"blue\">int</span> i, n;\n \n  <span class=\"teal\">Debug</span>.Print( <span class=\"maroon\">\"\\nClassifyPoints: mesh has {0} point{1} and {2} triangle{3}:\"</span>,\n    nv, PluralSuffix( nv ), nt, PluralSuffix( nt ) );\n \n  <span class=\"green\">// set up a map to determine the vertex </span>\n  <span class=\"green\">// index of a given triangle vertex;</span>\n  <span class=\"green\">// this is needed because the </span>\n  <span class=\"green\">// MeshTriangle.get_Vertex method</span>\n  <span class=\"green\">// returns the XYZ but not the index,</span>\n  <span class=\"green\">// and we base our edges on the index:</span>\n \n  <span class=\"teal\">Dictionary</span>&lt;<span class=\"teal\">XYZ</span>, <span class=\"blue\">int</span>&gt; vertexIndex\n    = <span class=\"blue\">new</span> <span class=\"teal\">Dictionary</span>&lt;<span class=\"teal\">XYZ</span>, <span class=\"blue\">int</span>&gt;( nv, <span class=\"blue\">new</span> <span class=\"teal\">XyzEqualityComparer</span>() );\n \n  <span class=\"blue\">for</span>( i = 0; i &lt; nv; ++i )\n  {\n    <span class=\"teal\">XYZ</span> p = mesh.Vertices[i];\n    <span class=\"teal\">Debug</span>.Print( <span class=\"maroon\">\"  mesh vertex {0}: {1}\"</span>, i, PointString( p ) );\n    vertexIndex[p] = i;\n  }\n \n  <span class=\"green\">// set up a map to determine which </span>\n  <span class=\"green\">// edges a given vertex belongs to:</span>\n \n  <span class=\"teal\">MapVertexToEdges</span> vertexEdges\n    = <span class=\"blue\">new</span> <span class=\"teal\">MapVertexToEdges</span>( nv );\n \n  <span class=\"green\">// set up a map to determine which </span>\n  <span class=\"green\">// triangles a given edge belongs to;</span>\n  <span class=\"green\">// this is used to determine the edge's</span>\n  <span class=\"green\">// interior or boundary status:</span>\n \n  <span class=\"teal\">MapEdgeToTriangles</span> map\n    = <span class=\"blue\">new</span> <span class=\"teal\">MapEdgeToTriangles</span>();\n \n  <span class=\"blue\">for</span>( i = 0; i &lt; nt; ++i )\n  {\n    <span class=\"teal\">MeshTriangle</span> t = mesh.get_Triangle( i );\n \n    <span class=\"blue\">for</span>( <span class=\"blue\">int</span> j = 0; j &lt; 3; ++j )\n    {\n      <span class=\"green\">// get the start and end vertex </span>\n      <span class=\"green\">// of the current triangle edge:</span>\n \n      <span class=\"blue\">int</span> a = vertexIndex[t.get_Vertex( 0 == j ? 2 : j - 1 )];\n      <span class=\"blue\">int</span> b = vertexIndex[t.get_Vertex( j )];\n \n      <span class=\"teal\">JtEdge</span> e = <span class=\"blue\">new</span> <span class=\"teal\">JtEdge</span>( a, b );\n \n      map.AddEdge( e, i );\n \n      vertexEdges.AddVertexEdge( a, e );\n      vertexEdges.AddVertexEdge( b, e );\n    }\n  }\n \n  <span class=\"blue\">int</span> nBoundaryEdges;\n  <span class=\"blue\">int</span> nInteriorPoints = 0;\n \n  <span class=\"teal\">Dictionary</span>&lt;<span class=\"blue\">int</span>, <span class=\"blue\">bool</span>&gt; dict = <span class=\"blue\">new</span> <span class=\"teal\">Dictionary</span>&lt;<span class=\"blue\">int</span>,<span class=\"blue\">bool</span>&gt;( nv );\n \n  <span class=\"teal\">Debug</span>.Print( <span class=\"maroon\">\"Classify the {0} point{1}:\"</span>, nv, PluralSuffix( nv ) );\n \n  <span class=\"blue\">for</span>( i = 0; i &lt; nv; ++i )\n  {\n    nBoundaryEdges = 0;\n    n = vertexEdges[i].Count;\n \n    nBoundaryEdges = vertexEdges[i].Count&lt;<span class=\"teal\">JtEdge</span>&gt;( \n      e =&gt; 1 == map[e].Count );\n \n    dict[i] = ( 0 == nBoundaryEdges );\n \n    <span class=\"teal\">XYZ</span> p = mesh.Vertices[i];\n \n    <span class=\"blue\">if</span>( 0 == nBoundaryEdges )\n    {\n      ++nInteriorPoints;\n    }\n \n    <span class=\"teal\">Debug</span>.Print( <span class=\"maroon\">\"  point {0} {1} belongs to {2} edge{3}, \"</span>\n      + <span class=\"maroon\">\"{4} interior and {5} boundary and is therefore {6}\"</span>,\n      i, PointString( p ), n, PluralSuffix( n ),\n      n - nBoundaryEdges, nBoundaryEdges,\n      ( 0 == nBoundaryEdges ? <span class=\"maroon\">\"interior\"</span> : <span class=\"maroon\">\"boundary\"</span> ) );\n  }\n  <span class=\"teal\">Debug</span>.Print( <span class=\"maroon\">\"{0} boundary and {1} interior points detected.\"</span>,\n    nv - nInteriorPoints, nInteriorPoints );\n \n  <span class=\"blue\">return</span> dict;\n}\n</pre>\n<p>I tested this on the following topo surfaces of increasing complexity:\n\n<ul>\n<li>a triangle, \n<li>a quadrilateral with four boundary points, \n<li>another quadrilateral with an additional interior point, and\n<li>a larger surface with 26 points\n</li></li></li></li></ul>\n<p>They look like this in Revit:</p>\n<center>\n<img alt=\"Toposurfaces\" src=\"img/toposurfaces.png\"/>\n</center>\n<p>Here are the results (please copy to a text editor to see the full untruncated lines):\n\n<pre class=\"code\">\nTopographySurface 128701:\n\nClassifyPoints: mesh has 3 points and 1 triangle:\n  mesh vertex 0: (-14.39,11.53,0)\n  mesh vertex 1: (2.81,12.55,0)\n  mesh vertex 2: (-7.4,22.76,0)\n  triangle 0 vertex 0: (-14.39,11.53,0)\n  triangle 0 vertex 1: (2.81,12.55,0)\n  triangle 0 vertex 2: (-7.4,22.76,0)\nClassify the 3 edges:\n  edge 0-&gt;1 belongs to 1 triangle and is therefore boundary\n  edge 0-&gt;2 belongs to 1 triangle and is therefore boundary\n  edge 1-&gt;2 belongs to 1 triangle and is therefore boundary\nClassify the 3 points:\n  point 0 (-14.39,11.53,0) belongs to 2 edges, 0 interior and 2 boundary and is therefore boundary\n  point 1 (2.81,12.55,0) belongs to 2 edges, 0 interior and 2 boundary and is therefore boundary\n  point 2 (-7.4,22.76,0) belongs to 2 edges, 0 interior and 2 boundary and is therefore boundary\n3 boundary and 0 interior points detected.\n\nTopographySurface 128712:\n\nClassifyPoints: mesh has 4 points and 2 triangles:\n  mesh vertex 0: (25.45,10.77,0)\n  mesh vertex 1: (25.01,23.65,0)\n  mesh vertex 2: (38.32,11.22,0)\n  mesh vertex 3: (38.77,24.09,0)\n  triangle 0 vertex 0: (25.01,23.65,0)\n  triangle 0 vertex 1: (25.45,10.77,0)\n  triangle 0 vertex 2: (38.32,11.22,0)\n  triangle 1 vertex 0: (38.32,11.22,0)\n  triangle 1 vertex 1: (38.77,24.09,0)\n  triangle 1 vertex 2: (25.01,23.65,0)\nClassify the 5 edges:\n  edge 0-&gt;1 belongs to 1 triangle and is therefore boundary\n  edge 0-&gt;2 belongs to 1 triangle and is therefore boundary\n  edge 1-&gt;2 belongs to 2 triangles and is therefore interior\n  edge 1-&gt;3 belongs to 1 triangle and is therefore boundary\n  edge 2-&gt;3 belongs to 1 triangle and is therefore boundary\nClassify the 4 points:\n  point 0 (25.45,10.77,0) belongs to 2 edges, 0 interior and 2 boundary and is therefore boundary\n  point 1 (25.01,23.65,0) belongs to 4 edges, 2 interior and 2 boundary and is therefore boundary\n  point 2 (38.32,11.22,0) belongs to 4 edges, 2 interior and 2 boundary and is therefore boundary\n  point 3 (38.77,24.09,0) belongs to 2 edges, 0 interior and 2 boundary and is therefore boundary\n4 boundary and 0 interior points detected.\n\nTopographySurface 128718:\n\nClassifyPoints: mesh has 5 points and 4 triangles:\n  mesh vertex 0: (80.05,28.53,0)\n  mesh vertex 1: (63.18,39.63,0)\n  mesh vertex 2: (84.49,41.85,0)\n  mesh vertex 3: (75.61,52.06,0)\n  mesh vertex 4: (98.7,45.84,0)\n  triangle 0 vertex 0: (75.61,52.06,0)\n  triangle 0 vertex 1: (63.18,39.63,0)\n  triangle 0 vertex 2: (84.49,41.85,0)\n  triangle 1 vertex 0: (80.05,28.53,0)\n  triangle 1 vertex 1: (98.7,45.84,0)\n  triangle 1 vertex 2: (84.49,41.85,0)\n  triangle 2 vertex 0: (84.49,41.85,0)\n  triangle 2 vertex 1: (98.7,45.84,0)\n  triangle 2 vertex 2: (75.61,52.06,0)\n  triangle 3 vertex 0: (80.05,28.53,0)\n  triangle 3 vertex 1: (84.49,41.85,0)\n  triangle 3 vertex 2: (63.18,39.63,0)\nClassify the 8 edges:\n  edge 0-&gt;1 belongs to 1 triangle and is therefore boundary\n  edge 0-&gt;2 belongs to 2 triangles and is therefore interior\n  edge 0-&gt;4 belongs to 1 triangle and is therefore boundary\n  edge 1-&gt;2 belongs to 2 triangles and is therefore interior\n  edge 1-&gt;3 belongs to 1 triangle and is therefore boundary\n  edge 2-&gt;3 belongs to 2 triangles and is therefore interior\n  edge 2-&gt;4 belongs to 2 triangles and is therefore interior\n  edge 3-&gt;4 belongs to 1 triangle and is therefore boundary\nClassify the 5 points:\n  point 0 (80.05,28.53,0) belongs to 4 edges, 2 interior and 2 boundary and is therefore boundary\n  point 1 (63.18,39.63,0) belongs to 4 edges, 2 interior and 2 boundary and is therefore boundary\n  point 2 (84.49,41.85,0) belongs to 8 edges, 8 interior and 0 boundary and is therefore interior\n  point 3 (75.61,52.06,0) belongs to 4 edges, 2 interior and 2 boundary and is therefore boundary\n  point 4 (98.7,45.84,0) belongs to 4 edges, 2 interior and 2 boundary and is therefore boundary\n4 boundary and 1 interior points detected.\n\nTopographySurface 128725:\n\nClassifyPoints: mesh has 26 points and 39 triangles:\n  mesh vertex 0: (-87.01,-44.72,0)\n  mesh vertex 1: (-75.47,-26.96,0)\n  . . .\n  mesh vertex 25: (-83.46,-24.3,0)\n  triangle 0 vertex 0: (-87.01,-44.72,0)\n  triangle 0 vertex 1: (-77.69,-55.82,0)\n  . . .\n  triangle 38 vertex 2: (-75.47,-26.96,0)\nClassify the 64 edges:\n  edge 0-&gt;8 belongs to 1 triangle and is therefore boundary\n  edge 0-&gt;11 belongs to 1 triangle and is therefore boundary\n  . . .\n  edge 24-&gt;25 belongs to 1 triangle and is therefore boundary\nClassify the 26 points:\n  point 0 (-87.01,-44.72,0) belongs to 6 edges, 4 interior and 2 boundary and is therefore boundary\n point 1 (-75.47,-26.96,0) belongs to 10 edges, 10 interior and 0 boundary and is therefore interior\n  point 2 (-55.49,-19.86,0) belongs to 10 edges, 10 interior and 0 boundary and is therefore interior\n  point 3 (-53.71,-33.18,0) belongs to 12 edges, 12 interior and 0 boundary and is therefore interior\n  point 4 (-43.06,-26.96,0) belongs to 8 edges, 6 interior and 2 boundary and is therefore boundary\n  point 5 (-43.06,-42.5,0) belongs to 10 edges, 10 interior and 0 boundary and is therefore interior\n  point 6 (-65.26,-35.4,0) belongs to 12 edges, 12 interior and 0 boundary and is therefore interior\n  point 7 (-60.37,-53.15,0) belongs to 12 edges, 12 interior and 0 boundary and is therefore interior\n  point 8 (-77.69,-55.82,0) belongs to 8 edges, 6 interior and 2 boundary and is therefore boundary\n  point 9 (-68.36,-43.83,0) belongs to 14 edges, 14 interior and 0 boundary and is therefore interior\n  point 10 (-41.28,-54.49,0) belongs to 8 edges, 6 interior and 2 boundary and is therefore boundary\n  point 11 (-88.34,-33.62,0) belongs to 4 edges, 2 interior and 2 boundary and is therefore boundary\n  point 12 (-66.14,-61.14,0) belongs to 6 edges, 4 interior and 2 boundary and is therefore boundary\n  point 13 (-79.02,-44.28,0) belongs to 10 edges, 10 interior and 0 boundary and is therefore interior\n  point 14 (-81.68,-32.73,0) belongs to 14 edges, 14 interior and 0 boundary and is therefore interior\n  point 15 (-63.93,-26.96,0) belongs to 14 edges, 14 interior and 0 boundary and is therefore interior\n  point 16 (-55.05,-43.39,0) belongs to 12 edges, 12 interior and 0 boundary and is therefore interior\n  point 17 (-47.5,-50.93,0) belongs to 8 edges, 8 interior and 0 boundary and is therefore interior\n  point 18 (-74.58,-50.93,0) belongs to 8 edges, 8 interior and 0 boundary and is therefore interior\n  point 19 (-68.81,-54.93,0) belongs to 10 edges, 10 interior and 0 boundary and is therefore interior\n  point 20 (-53.71,-26.07,0) belongs to 10 edges, 10 interior and 0 boundary and is therefore interior\n  point 21 (-47.06,-18.97,0) belongs to 6 edges, 4 interior and 2 boundary and is therefore boundary\n  point 22 (-49.72,-14.98,0) belongs to 4 edges, 2 interior and 2 boundary and is therefore boundary\n  point 23 (-67.03,-17.64,0) belongs to 6 edges, 4 interior and 2 boundary and is therefore boundary\n  point 24 (-74.58,-19.42,0) belongs to 6 edges, 4 interior and 2 boundary and is therefore boundary\n  point 25 (-83.46,-24.3,0) belongs to 6 edges, 4 interior and 2 boundary and is therefore boundary\n11 boundary and 15 interior points detected.\n</pre>\n<p>As far as I can tell, this works efficiently and reliably.\n\n<p>Please let me know what experiences you have with this and whether it solves the problem for you. Thank you!\n\n<p>Here is \n\n<a href=\"zip/TopoSurfacePointClassify.zip\">\nTopoSurfacePointClassify.zip</a> containing \n\nthe entire source code and Visual Studio solution implementing this add-in.\n</p></p></p></p></p></p></p></p></p></p></p></p></p>"
  },
  {
    "original_filename": "0556_toposurf_points",
    "header_text": "Classifying Points",
    "local_header_href": "#classifying-points",
    "chunk_text": "<h4>Classifying Points</h4><p>The third step consists in determining whether a point is interior or boundary, implemented in the method ClassifyPoints. A point is interior if all of the edges it belongs to also are. If one single edge is a boundary, then so is the point.\n\n<p>I make use of a couple of helper classes implementing dictionaries to simplify the mainline of the code. \nOne is MapEdgeToTriangles, which  maps a mesh triangle edge to a list of the indices of all the triangles it belongs to:\n\n<pre class=\"code\">\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n<span class=\"gray\">///</span><span class=\"green\"> Map mesh triangle edges to a list of the </span>\n<span class=\"gray\">///</span><span class=\"green\"> indices of all the triangles they belong to.</span>\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n<span class=\"blue\">class</span> <span class=\"teal\">MapEdgeToTriangles</span>\n  : <span class=\"teal\">Dictionary</span>&lt;<span class=\"teal\">JtEdge</span>, <span class=\"teal\">List</span>&lt;<span class=\"blue\">int</span>&gt;&gt;\n{\n  <span class=\"blue\">public</span> MapEdgeToTriangles()\n    : <span class=\"blue\">base</span>( <span class=\"blue\">new</span> <span class=\"teal\">JtEdgeEqualityComparer</span>() )\n  {\n  }\n \n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n  <span class=\"gray\">///</span><span class=\"green\"> Add a new edge.</span>\n  <span class=\"gray\">///</span><span class=\"green\"> If it is already known, append the triangle </span>\n  <span class=\"gray\">///</span><span class=\"green\"> index of the current triangle. Otherwise, </span>\n  <span class=\"gray\">///</span><span class=\"green\"> generate a new key for it.</span>\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n  <span class=\"blue\">public</span> <span class=\"blue\">void</span> AddEdge(\n    <span class=\"teal\">JtEdge</span> e,\n    <span class=\"blue\">int</span> triangleIndex )\n  {\n    <span class=\"blue\">if</span>( !ContainsKey( e ) )\n    {\n      Add( e, <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"blue\">int</span>&gt;( 2 ) );\n    }\n    ( <span class=\"blue\">this</span> )[e].Add( triangleIndex );\n  }\n}\n</pre>\n<p>Another is MapVertexToEdges, mapping a mesh vertex index to a list of the edges the vertex belongs to.\n\n<pre class=\"code\">\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n<span class=\"gray\">///</span><span class=\"green\"> Map mesh vertex index to a list of the edges </span>\n<span class=\"gray\">///</span><span class=\"green\"> the vertex belongs to.</span>\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n<span class=\"blue\">class</span> <span class=\"teal\">MapVertexToEdges</span>\n  : <span class=\"teal\">Dictionary</span>&lt;<span class=\"blue\">int</span>, <span class=\"teal\">List</span>&lt;<span class=\"teal\">JtEdge</span>&gt;&gt;\n{\n  <span class=\"blue\">public</span> MapVertexToEdges( <span class=\"blue\">int</span> capacity )\n    : <span class=\"blue\">base</span>( capacity )\n  {\n  }\n \n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n  <span class=\"gray\">///</span><span class=\"green\"> Append a new edge for a given vertex.</span>\n  <span class=\"gray\">///</span><span class=\"green\"> If the vertex is new, generate a new key for it.</span>\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n  <span class=\"blue\">public</span> <span class=\"blue\">void</span> AddVertexEdge(\n    <span class=\"blue\">int</span> vertexIndex,\n    <span class=\"teal\">JtEdge</span> e )\n  {\n    <span class=\"blue\">if</span>( !ContainsKey( vertexIndex ) )\n    {\n      Add( vertexIndex, <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">JtEdge</span>&gt;( 2 ) );\n    }\n    ( <span class=\"blue\">this</span> )[vertexIndex].Add( e );\n  }\n}\n</pre>\n<p>Both of these basically just provide an enhanced method for adding a new element to the dictionary.\n\n<p>Here is the implementation of the main algorithm:\n\n<pre class=\"code\">\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n<span class=\"gray\">///</span><span class=\"green\"> For each point of the given mesh,</span>\n<span class=\"gray\">///</span><span class=\"green\"> determine whether it is interior or boundary.</span>\n<span class=\"gray\">///</span><span class=\"green\"> The algorithm goes like this:</span>\n<span class=\"gray\">///</span><span class=\"green\"> Every triangle edge belongs to either one or two triangles,</span>\n<span class=\"gray\">///</span><span class=\"green\"> depending on whether it it boundary or interior.</span>\n<span class=\"gray\">///</span><span class=\"green\"> For each edge, determine whether it is boundary </span>\n<span class=\"gray\">///</span><span class=\"green\"> or interior. A point is interior if all of the edges it </span>\n<span class=\"gray\">///</span><span class=\"green\"> belongs to are interior.</span>\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;returns&gt;</span><span class=\"green\">A dictionary mapping each mesh vertex index </span>\n<span class=\"gray\">///</span><span class=\"green\"> to a Boolean which is true if the corresponding point </span>\n<span class=\"gray\">///</span><span class=\"green\"> is interior and false if it is on the boundary</span><span class=\"gray\">&lt;/returns&gt;</span>\n<span class=\"teal\">Dictionary</span>&lt;<span class=\"blue\">int</span>, <span class=\"blue\">bool</span>&gt; ClassifyPoints( <span class=\"teal\">Mesh</span> mesh )\n{\n  <span class=\"blue\">int</span> nv = mesh.Vertices.Count;\n  <span class=\"blue\">int</span> nt = mesh.NumTriangles;\n  <span class=\"blue\">int</span> i, n;\n \n  <span class=\"teal\">Debug</span>.Print( <span class=\"maroon\">\"\\nClassifyPoints: mesh has {0} point{1} and {2} triangle{3}:\"</span>,\n    nv, PluralSuffix( nv ), nt, PluralSuffix( nt ) );\n \n  <span class=\"green\">// set up a map to determine the vertex </span>\n  <span class=\"green\">// index of a given triangle vertex;</span>\n  <span class=\"green\">// this is needed because the </span>\n  <span class=\"green\">// MeshTriangle.get_Vertex method</span>\n  <span class=\"green\">// returns the XYZ but not the index,</span>\n  <span class=\"green\">// and we base our edges on the index:</span>\n \n  <span class=\"teal\">Dictionary</span>&lt;<span class=\"teal\">XYZ</span>, <span class=\"blue\">int</span>&gt; vertexIndex\n    = <span class=\"blue\">new</span> <span class=\"teal\">Dictionary</span>&lt;<span class=\"teal\">XYZ</span>, <span class=\"blue\">int</span>&gt;( nv, <span class=\"blue\">new</span> <span class=\"teal\">XyzEqualityComparer</span>() );\n \n  <span class=\"blue\">for</span>( i = 0; i &lt; nv; ++i )\n  {\n    <span class=\"teal\">XYZ</span> p = mesh.Vertices[i];\n    <span class=\"teal\">Debug</span>.Print( <span class=\"maroon\">\"  mesh vertex {0}: {1}\"</span>, i, PointString( p ) );\n    vertexIndex[p] = i;\n  }\n \n  <span class=\"green\">// set up a map to determine which </span>\n  <span class=\"green\">// edges a given vertex belongs to:</span>\n \n  <span class=\"teal\">MapVertexToEdges</span> vertexEdges\n    = <span class=\"blue\">new</span> <span class=\"teal\">MapVertexToEdges</span>( nv );\n \n  <span class=\"green\">// set up a map to determine which </span>\n  <span class=\"green\">// triangles a given edge belongs to;</span>\n  <span class=\"green\">// this is used to determine the edge's</span>\n  <span class=\"green\">// interior or boundary status:</span>\n \n  <span class=\"teal\">MapEdgeToTriangles</span> map\n    = <span class=\"blue\">new</span> <span class=\"teal\">MapEdgeToTriangles</span>();\n \n  <span class=\"blue\">for</span>( i = 0; i &lt; nt; ++i )\n  {\n    <span class=\"teal\">MeshTriangle</span> t = mesh.get_Triangle( i );\n \n    <span class=\"blue\">for</span>( <span class=\"blue\">int</span> j = 0; j &lt; 3; ++j )\n    {\n      <span class=\"green\">// get the start and end vertex </span>\n      <span class=\"green\">// of the current triangle edge:</span>\n \n      <span class=\"blue\">int</span> a = vertexIndex[t.get_Vertex( 0 == j ? 2 : j - 1 )];\n      <span class=\"blue\">int</span> b = vertexIndex[t.get_Vertex( j )];\n \n      <span class=\"teal\">JtEdge</span> e = <span class=\"blue\">new</span> <span class=\"teal\">JtEdge</span>( a, b );\n \n      map.AddEdge( e, i );\n \n      vertexEdges.AddVertexEdge( a, e );\n      vertexEdges.AddVertexEdge( b, e );\n    }\n  }\n \n  <span class=\"blue\">int</span> nBoundaryEdges;\n  <span class=\"blue\">int</span> nInteriorPoints = 0;\n \n  <span class=\"teal\">Dictionary</span>&lt;<span class=\"blue\">int</span>, <span class=\"blue\">bool</span>&gt; dict = <span class=\"blue\">new</span> <span class=\"teal\">Dictionary</span>&lt;<span class=\"blue\">int</span>,<span class=\"blue\">bool</span>&gt;( nv );\n \n  <span class=\"teal\">Debug</span>.Print( <span class=\"maroon\">\"Classify the {0} point{1}:\"</span>, nv, PluralSuffix( nv ) );\n \n  <span class=\"blue\">for</span>( i = 0; i &lt; nv; ++i )\n  {\n    nBoundaryEdges = 0;\n    n = vertexEdges[i].Count;\n \n    nBoundaryEdges = vertexEdges[i].Count&lt;<span class=\"teal\">JtEdge</span>&gt;( \n      e =&gt; 1 == map[e].Count );\n \n    dict[i] = ( 0 == nBoundaryEdges );\n \n    <span class=\"teal\">XYZ</span> p = mesh.Vertices[i];\n \n    <span class=\"blue\">if</span>( 0 == nBoundaryEdges )\n    {\n      ++nInteriorPoints;\n    }\n \n    <span class=\"teal\">Debug</span>.Print( <span class=\"maroon\">\"  point {0} {1} belongs to {2} edge{3}, \"</span>\n      + <span class=\"maroon\">\"{4} interior and {5} boundary and is therefore {6}\"</span>,\n      i, PointString( p ), n, PluralSuffix( n ),\n      n - nBoundaryEdges, nBoundaryEdges,\n      ( 0 == nBoundaryEdges ? <span class=\"maroon\">\"interior\"</span> : <span class=\"maroon\">\"boundary\"</span> ) );\n  }\n  <span class=\"teal\">Debug</span>.Print( <span class=\"maroon\">\"{0} boundary and {1} interior points detected.\"</span>,\n    nv - nInteriorPoints, nInteriorPoints );\n \n  <span class=\"blue\">return</span> dict;\n}\n</pre>\n<p>I tested this on the following topo surfaces of increasing complexity:\n\n<ul>\n<li>a triangle, \n<li>a quadrilateral with four boundary points, \n<li>another quadrilateral with an additional interior point, and\n<li>a larger surface with 26 points\n</li></li></li></li></ul>\n<p>They look like this in Revit:</p>\n<center>\n<img alt=\"Toposurfaces\" src=\"img/toposurfaces.png\"/>\n</center>\n<p>Here are the results (please copy to a text editor to see the full untruncated lines):\n\n<pre class=\"code\">\nTopographySurface 128701:\n\nClassifyPoints: mesh has 3 points and 1 triangle:\n  mesh vertex 0: (-14.39,11.53,0)\n  mesh vertex 1: (2.81,12.55,0)\n  mesh vertex 2: (-7.4,22.76,0)\n  triangle 0 vertex 0: (-14.39,11.53,0)\n  triangle 0 vertex 1: (2.81,12.55,0)\n  triangle 0 vertex 2: (-7.4,22.76,0)\nClassify the 3 edges:\n  edge 0-&gt;1 belongs to 1 triangle and is therefore boundary\n  edge 0-&gt;2 belongs to 1 triangle and is therefore boundary\n  edge 1-&gt;2 belongs to 1 triangle and is therefore boundary\nClassify the 3 points:\n  point 0 (-14.39,11.53,0) belongs to 2 edges, 0 interior and 2 boundary and is therefore boundary\n  point 1 (2.81,12.55,0) belongs to 2 edges, 0 interior and 2 boundary and is therefore boundary\n  point 2 (-7.4,22.76,0) belongs to 2 edges, 0 interior and 2 boundary and is therefore boundary\n3 boundary and 0 interior points detected.\n\nTopographySurface 128712:\n\nClassifyPoints: mesh has 4 points and 2 triangles:\n  mesh vertex 0: (25.45,10.77,0)\n  mesh vertex 1: (25.01,23.65,0)\n  mesh vertex 2: (38.32,11.22,0)\n  mesh vertex 3: (38.77,24.09,0)\n  triangle 0 vertex 0: (25.01,23.65,0)\n  triangle 0 vertex 1: (25.45,10.77,0)\n  triangle 0 vertex 2: (38.32,11.22,0)\n  triangle 1 vertex 0: (38.32,11.22,0)\n  triangle 1 vertex 1: (38.77,24.09,0)\n  triangle 1 vertex 2: (25.01,23.65,0)\nClassify the 5 edges:\n  edge 0-&gt;1 belongs to 1 triangle and is therefore boundary\n  edge 0-&gt;2 belongs to 1 triangle and is therefore boundary\n  edge 1-&gt;2 belongs to 2 triangles and is therefore interior\n  edge 1-&gt;3 belongs to 1 triangle and is therefore boundary\n  edge 2-&gt;3 belongs to 1 triangle and is therefore boundary\nClassify the 4 points:\n  point 0 (25.45,10.77,0) belongs to 2 edges, 0 interior and 2 boundary and is therefore boundary\n  point 1 (25.01,23.65,0) belongs to 4 edges, 2 interior and 2 boundary and is therefore boundary\n  point 2 (38.32,11.22,0) belongs to 4 edges, 2 interior and 2 boundary and is therefore boundary\n  point 3 (38.77,24.09,0) belongs to 2 edges, 0 interior and 2 boundary and is therefore boundary\n4 boundary and 0 interior points detected.\n\nTopographySurface 128718:\n\nClassifyPoints: mesh has 5 points and 4 triangles:\n  mesh vertex 0: (80.05,28.53,0)\n  mesh vertex 1: (63.18,39.63,0)\n  mesh vertex 2: (84.49,41.85,0)\n  mesh vertex 3: (75.61,52.06,0)\n  mesh vertex 4: (98.7,45.84,0)\n  triangle 0 vertex 0: (75.61,52.06,0)\n  triangle 0 vertex 1: (63.18,39.63,0)\n  triangle 0 vertex 2: (84.49,41.85,0)\n  triangle 1 vertex 0: (80.05,28.53,0)\n  triangle 1 vertex 1: (98.7,45.84,0)\n  triangle 1 vertex 2: (84.49,41.85,0)\n  triangle 2 vertex 0: (84.49,41.85,0)\n  triangle 2 vertex 1: (98.7,45.84,0)\n  triangle 2 vertex 2: (75.61,52.06,0)\n  triangle 3 vertex 0: (80.05,28.53,0)\n  triangle 3 vertex 1: (84.49,41.85,0)\n  triangle 3 vertex 2: (63.18,39.63,0)\nClassify the 8 edges:\n  edge 0-&gt;1 belongs to 1 triangle and is therefore boundary\n  edge 0-&gt;2 belongs to 2 triangles and is therefore interior\n  edge 0-&gt;4 belongs to 1 triangle and is therefore boundary\n  edge 1-&gt;2 belongs to 2 triangles and is therefore interior\n  edge 1-&gt;3 belongs to 1 triangle and is therefore boundary\n  edge 2-&gt;3 belongs to 2 triangles and is therefore interior\n  edge 2-&gt;4 belongs to 2 triangles and is therefore interior\n  edge 3-&gt;4 belongs to 1 triangle and is therefore boundary\nClassify the 5 points:\n  point 0 (80.05,28.53,0) belongs to 4 edges, 2 interior and 2 boundary and is therefore boundary\n  point 1 (63.18,39.63,0) belongs to 4 edges, 2 interior and 2 boundary and is therefore boundary\n  point 2 (84.49,41.85,0) belongs to 8 edges, 8 interior and 0 boundary and is therefore interior\n  point 3 (75.61,52.06,0) belongs to 4 edges, 2 interior and 2 boundary and is therefore boundary\n  point 4 (98.7,45.84,0) belongs to 4 edges, 2 interior and 2 boundary and is therefore boundary\n4 boundary and 1 interior points detected.\n\nTopographySurface 128725:\n\nClassifyPoints: mesh has 26 points and 39 triangles:\n  mesh vertex 0: (-87.01,-44.72,0)\n  mesh vertex 1: (-75.47,-26.96,0)\n  . . .\n  mesh vertex 25: (-83.46,-24.3,0)\n  triangle 0 vertex 0: (-87.01,-44.72,0)\n  triangle 0 vertex 1: (-77.69,-55.82,0)\n  . . .\n  triangle 38 vertex 2: (-75.47,-26.96,0)\nClassify the 64 edges:\n  edge 0-&gt;8 belongs to 1 triangle and is therefore boundary\n  edge 0-&gt;11 belongs to 1 triangle and is therefore boundary\n  . . .\n  edge 24-&gt;25 belongs to 1 triangle and is therefore boundary\nClassify the 26 points:\n  point 0 (-87.01,-44.72,0) belongs to 6 edges, 4 interior and 2 boundary and is therefore boundary\n point 1 (-75.47,-26.96,0) belongs to 10 edges, 10 interior and 0 boundary and is therefore interior\n  point 2 (-55.49,-19.86,0) belongs to 10 edges, 10 interior and 0 boundary and is therefore interior\n  point 3 (-53.71,-33.18,0) belongs to 12 edges, 12 interior and 0 boundary and is therefore interior\n  point 4 (-43.06,-26.96,0) belongs to 8 edges, 6 interior and 2 boundary and is therefore boundary\n  point 5 (-43.06,-42.5,0) belongs to 10 edges, 10 interior and 0 boundary and is therefore interior\n  point 6 (-65.26,-35.4,0) belongs to 12 edges, 12 interior and 0 boundary and is therefore interior\n  point 7 (-60.37,-53.15,0) belongs to 12 edges, 12 interior and 0 boundary and is therefore interior\n  point 8 (-77.69,-55.82,0) belongs to 8 edges, 6 interior and 2 boundary and is therefore boundary\n  point 9 (-68.36,-43.83,0) belongs to 14 edges, 14 interior and 0 boundary and is therefore interior\n  point 10 (-41.28,-54.49,0) belongs to 8 edges, 6 interior and 2 boundary and is therefore boundary\n  point 11 (-88.34,-33.62,0) belongs to 4 edges, 2 interior and 2 boundary and is therefore boundary\n  point 12 (-66.14,-61.14,0) belongs to 6 edges, 4 interior and 2 boundary and is therefore boundary\n  point 13 (-79.02,-44.28,0) belongs to 10 edges, 10 interior and 0 boundary and is therefore interior\n  point 14 (-81.68,-32.73,0) belongs to 14 edges, 14 interior and 0 boundary and is therefore interior\n  point 15 (-63.93,-26.96,0) belongs to 14 edges, 14 interior and 0 boundary and is therefore interior\n  point 16 (-55.05,-43.39,0) belongs to 12 edges, 12 interior and 0 boundary and is therefore interior\n  point 17 (-47.5,-50.93,0) belongs to 8 edges, 8 interior and 0 boundary and is therefore interior\n  point 18 (-74.58,-50.93,0) belongs to 8 edges, 8 interior and 0 boundary and is therefore interior\n  point 19 (-68.81,-54.93,0) belongs to 10 edges, 10 interior and 0 boundary and is therefore interior\n  point 20 (-53.71,-26.07,0) belongs to 10 edges, 10 interior and 0 boundary and is therefore interior\n  point 21 (-47.06,-18.97,0) belongs to 6 edges, 4 interior and 2 boundary and is therefore boundary\n  point 22 (-49.72,-14.98,0) belongs to 4 edges, 2 interior and 2 boundary and is therefore boundary\n  point 23 (-67.03,-17.64,0) belongs to 6 edges, 4 interior and 2 boundary and is therefore boundary\n  point 24 (-74.58,-19.42,0) belongs to 6 edges, 4 interior and 2 boundary and is therefore boundary\n  point 25 (-83.46,-24.3,0) belongs to 6 edges, 4 interior and 2 boundary and is therefore boundary\n11 boundary and 15 interior points detected.\n</pre>\n<p>As far as I can tell, this works efficiently and reliably.\n\n<p>Please let me know what experiences you have with this and whether it solves the problem for you. Thank you!\n\n<p>Here is \n\n<a href=\"zip/TopoSurfacePointClassify.zip\">\nTopoSurfacePointClassify.zip</a> containing \n\nthe entire source code and Visual Studio solution implementing this add-in.\n</p></p></p></p></p></p></p></p></p></p>"
  }
]