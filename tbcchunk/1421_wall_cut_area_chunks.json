[
  {
    "original_filename": "1421_wall_cut_area",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n<link rel=\"stylesheet\" type=\"text/css\" href=\"bc.css\">\n<script src=\"run_prettify.js\" type=\"text/javascript\"></script>\n<!--\n<script src=\"https://google-code-prettify.googlecode.com/svn/loader/run_prettify.js\" type=\"text/javascript\"></script>\n-->\n</head>\n\n<!---\n\nDetermining Wall Cut Area for a Specific Room #revitAPI #3dwebcoder @AutodeskRevit #adsk #aec #bim\n\nWe looked at calculating gross and net wall areas last year, with a later enhancement to use IFCExportUtils to determine the door and window area, resulting in the two respective projects and GitHub repositories, SpatialElementGeometryCalculator and ExporterIfcUtilsWinArea. Several developers have been busy expanding on those to determine surface areas of subfaces, for instance for openings in walls spanning multiple rooms...\n\n-->"
  },
  {
    "original_filename": "1421_wall_cut_area",
    "header_text": "Determining Wall Cut Area for a Specific Room",
    "local_header_href": "#determining-wall-cut-area-for-a-specific-room",
    "chunk_text": "### Determining Wall Cut Area for a Specific Room\n\nWe looked\nat [calculating gross and net wall areas](http://thebuildingcoder.typepad.com/blog/2015/03/calculating-gross-and-net-wall-areas.html) last\nyear, with a later enhancement to\nuse [IFCExportUtils to determine the door and window area](http://thebuildingcoder.typepad.com/blog/2015/03/ifcexportutils-methods-determine-door-and-window-area.html),\nresulting in the two respective projects and GitHub repositories:\n\n- [SpatialElementGeometryCalculator](https://github.com/jeremytammik/SpatialElementGeometryCalculator)\n- [ExporterIfcUtilsWinArea](https://github.com/jeremytammik/ExporterIfcUtilsWinArea)\n\nSeveral developers have been busy expanding on those to determine surface areas of subfaces, for instance for openings in walls spanning multiple rooms.\n\nThese two project demonstrate useful and powerful starting points but obviously do not yet satisfy all needs.\n\nHere are some additional aspects brought up by [Arif](#2), [Miroslav](#3) and [Håvard](#4):"
  },
  {
    "original_filename": "1421_wall_cut_area",
    "header_text": "<a name=\"2\"></a>Arif",
    "local_header_href": "#a-name2aarif",
    "chunk_text": "#### <a name=\"2\"></a>Arif\n\nArif Hanif explored the use the spatial geometry calculator and noted in\na [comment on FindInserts retrieving openings](http://thebuildingcoder.typepad.com/blog/2015/03/findinserts-retrieves-all-openings-in-all-wall-types.html#comment-2424158731) that\nit **does** in fact return the subface linked instance element ids. You have to set the `SpatialElementBoundaryLocation = SpatialElementBoundaryLocation.Center` to close the geometry, and it does not work for Finish.\n\nMore significantly, he explored the subface issue in\na [comment on getting the wall elevation profile](http://thebuildingcoder.typepad.com/blog/2015/01/getting-the-wall-elevation-profile.html#comment-2567466439)\n([image](http://thebuildingcoder.typepad.com/blog/2015/01/getting-the-wall-elevation-profile.html#comment-2570111596)):\n\n**Question:** I am working on an interesting problem, which I have been trying to see if anyone else has been solving. I tried searching your blog and Internet (Revit API forum) but did not see it come up. I need to determine the vertices of an embedded wall returned by FindInserts part of a spatial geometry calculator return. I have the edge and curve loops of the wall in the spaces creating the bounding element. I have used `SpatialElementBoundarySubface` to return the bounding element and determined the id of the embedded wall in this case a curtain wall. The issue I am running into is that the geometry of the embedded wall spans multiple spaces and have not figured out how to determine only the portion of the embedded wall that belongs to the spatial element boundary. As I read more seems maybe the reference intersector class might be something I look at, any recommendations on your end would be greatly appreciated.\n\n<center>\n<img src=\"img/room_surface_area_02.png\" alt=\"Subfaces in different spaces\" width=\"400\">\n</center>\n\nSolve for the shaded curtain wall vertices.\n\n**Answer:** It looks to me as if one way to go would be to project all the relevant elements onto the wall plane to convert the problem to a two-dimensional one, and then use 2D Boolean operations on the partial surfaces to determine their intersections and overlap.\n\nLook at The Building Coder topic group on [2D Booleans and Adjacent Areas](http://thebuildingcoder.typepad.com/blog/about-the-author.html#5.2)."
  },
  {
    "original_filename": "1421_wall_cut_area",
    "header_text": "<a name=\"3\"></a>Miroslav",
    "local_header_href": "#a-name3amiroslav",
    "chunk_text": "#### <a name=\"3\"></a>Miroslav\n\nMiroslav Schonauer adds:\n\nI’ve been playing with `SpatialElementGeometryCalculator` and `SpatialElementGeometryResults` in order to retrieve room bounding surfaces for a project to apply finishes.\n\nI’m successfully getting subfaces which include the originating element ids (at least for the 'vertical' room faces from walls.\nMy aim is to get the *net* wall face geometries rather than *gross* which I understand is by-design in the `SpatialElementBoundary*` classes.\n\nI was hoping that `SpatialElementBoundarySubface.GetBoundingElementFace` may get me to the source element face, but unfortunately it does not and that also seems by design. The help file remarks say that 'Faces do not contain voids in room-bounding elements (such the voids in walls created by doors and windows'. It gives me the same or typically just a slightly bigger gross Face that goes a bit 'beyond' the room bounding inside shell due to the wall joints\n\nWhat would be my best bet to get the geometry of the room bounding parts of walls same as `SpatialElementBoundarySubface` but excluding the openings in the walls?\n\nIn other words, I need a combination of 'net-ness' of the original wall inside face(s) (which are net as needed, but extend beyond the room inside shell) and the 'room-belong-ness' of `SpatialElementBoundarySubface` (which are exact in terms of room inside shell, but unfortunately gross excluding the openings).\n\nAfaik, there is no built-in Revit API functionality to get what I want.\n\nA solution for *planar* faces can be implemented but requires some complex geometrical manipulation based on the full wall geometry and the subfaces obtainable via `SpatialElement*`."
  },
  {
    "original_filename": "1421_wall_cut_area",
    "header_text": "<a name=\"4\"></a>Håvard",
    "local_header_href": "#a-name4ahåvard",
    "chunk_text": "#### <a name=\"4\"></a>Håvard\n\nHåvard Dagsvik explored this issue further and implemented solutions to address several of these needs after raising the issue in\na [comment on calculating gross and net wall areas](http://thebuildingcoder.typepad.com/blog/2015/03/calculating-gross-and-net-wall-areas.html#comment-2531680684):\n\n**Question:** Right now I am getting the opening area from built-in height and width parameters.\n\nBut it's not ideal, as doors are made in different ways.\n\nIn theory the opening could be any kind of family instance. And sometimes it only partially cuts the wall, e.g. in a stacked wall.\nIt might even extend beyond the room or ceiling as an embedded curtain wall might do, or a standard window for that matter.\n\n<center>\n<img src=\"img/room_surface_area_03.png\" alt=\"Subfaces in different spaces\" width=\"400\">\n</center>\n\nSo the temporary transaction trick won't always get the correct 'spatial' opening area but I had to try anyway.\n\nWhat sometimes happens is that Revit will throw other warnings, such as 'Geometry no longer defines a plane', as a consequence.\nSometimes not always, depends on the model.\n\nWhich the user has to cancel manually, even though the function proceeds probably because we roll back.\n\nI decided not to use a temp transaction.\n\nIf you have a WallOpening or a OpeningByFace the spatial area returned already has those subtracted.\n\nStrange this doesn't happen with FamilyInstances.\n\nAnyway the opening area should be available through the EnergyAnalysis API, but then we would have to generate the energy model first.\nIf gbXML could generate areas at the room face we could do it all there.\nBut I think gbXML only calculates at the wall centreline. (Fine for opening areas though).\n\nAnother method might be to get the actual OpeningCut element in the family.\n\nSome Boolean subtraction trick using transient solids from the actual wall residing in the family document. A bit like the temp transaction only using transient family document geometry. But as I realize just now you would also have to set the correct family symbol active first.\n\n**Answer:** Yes, things are a bit complicated.\n\nIf you put in enough effort, I think you can catch and\nautomatically [handle any kind of warning message that can ever comes up](http://thebuildingcoder.typepad.com/blog/about-the-author.html#5.32).\n\nRegarding bits sticking out from the wall, you can always reduce the problem to a much simpler two-dimensional issue by projecting everything onto the wall plane.\n\nThe [ExtrusionAnalyzer class](http://thebuildingcoder.typepad.com/blog/2013/04/extrusion-analyser-and-plan-view-boundaries.html) can help with that.\n\nA [2D Boolean library](http://thebuildingcoder.typepad.com/blog/about-the-author.html#5.2) might also come in handy.\n\nI assume that the gbXML functionality does use that kind of functionality, since you say it works in the wall centre line.\n\n**Response:** I found that using solid manipulation worked better for me than temporary transactions.\n\nEspecially when the opening is an embedded curtain wall spanning multiple rooms and stories.\n\nSo I intersect a curtain wall solid with the room solid, where the intersected solid holds the opening area for that specific room.\n\nI also used more of the `IFCUtils` classes from Angel's team, and one of your methods from The Building Coder to retrieve the wall profile.\n\nModified to include non-visible objects in order\nto [get 'invisible' curtain wall geometry](http://thebuildingcoder.typepad.com/blog/2010/05/curtain-wall-geometry.html),\nalso based on one of your suggestions in another case.\n\nHere is a small example on how I achieve this:\n\n<pre class=\"code\">\n&nbsp; <span class=\"blue\">public</span> <span class=\"blue\">double</span> GetWallCutArea(\n&nbsp; &nbsp; <span class=\"teal\">Document</span> doc,\n&nbsp; &nbsp; <span class=\"teal\">FamilyInstance</span> fi,\n&nbsp; &nbsp; <span class=\"teal\">Wall</span> wall,\n&nbsp; &nbsp; <span class=\"blue\">bool</span> isStacked )\n&nbsp; {\n&nbsp; &nbsp; <span class=\"teal\">Options</span> optCompRef\n&nbsp; &nbsp; &nbsp; = doc.Application.Create.NewGeometryOptions();\n&nbsp;\n&nbsp; &nbsp; <span class=\"blue\">if</span>( <span class=\"blue\">null</span> != optCompRef )\n&nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; optCompRef.ComputeReferences = <span class=\"blue\">true</span>;\n&nbsp; &nbsp; &nbsp; optCompRef.DetailLevel = <span class=\"teal\">ViewDetailLevel</span>.Medium;\n&nbsp; &nbsp; }\n&nbsp;\n&nbsp; &nbsp; <span class=\"teal\">SolidHandler</span> solHandler = <span class=\"blue\">new</span> <span class=\"teal\">SolidHandler</span>();\n&nbsp; &nbsp; <span class=\"teal\">XYZ</span> cutDir = <span class=\"blue\">null</span>;\n&nbsp;\n&nbsp; &nbsp; <span class=\"blue\">if</span>( !isStacked )\n&nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; <span class=\"teal\">CurveLoop</span> curveLoop\n&nbsp; &nbsp; &nbsp; &nbsp; = <span class=\"teal\">ExporterIFCUtils</span>.GetInstanceCutoutFromWall(\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fi.Document, wall, fi, <span class=\"blue\">out</span> cutDir );\n&nbsp;\n&nbsp; &nbsp; &nbsp; <span class=\"teal\">IList</span>&lt;<span class=\"teal\">CurveLoop</span>&gt; loops = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">CurveLoop</span>&gt;( 1 );\n&nbsp; &nbsp; &nbsp; loops.Add( curveLoop );\n&nbsp;\n&nbsp; &nbsp; &nbsp; <span class=\"blue\">return</span> <span class=\"teal\">ExporterIFCUtils</span>.ComputeAreaOfCurveLoops(\n&nbsp; &nbsp; &nbsp; &nbsp; loops );\n&nbsp; &nbsp; }\n&nbsp;\n&nbsp; &nbsp; <span class=\"blue\">else</span> <span class=\"blue\">if</span>( isStacked )\n&nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; <span class=\"teal\">CurveLoop</span> curveLoop\n&nbsp; &nbsp; &nbsp; &nbsp; = <span class=\"teal\">ExporterIFCUtils</span>.GetInstanceCutoutFromWall(\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fi.Document, wall, fi, <span class=\"blue\">out</span> cutDir );\n&nbsp;\n&nbsp; &nbsp; &nbsp; <span class=\"teal\">IList</span>&lt;<span class=\"teal\">CurveLoop</span>&gt; loops = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">CurveLoop</span>&gt;( 1 );\n&nbsp; &nbsp; &nbsp; loops.Add( curveLoop );\n&nbsp;\n&nbsp; &nbsp; &nbsp; <span class=\"teal\">GeometryElement</span> geomElemHost = wall.get_Geometry(\n&nbsp; &nbsp; &nbsp; &nbsp; optCompRef ) <span class=\"blue\">as</span> <span class=\"teal\">GeometryElement</span>;\n&nbsp;\n&nbsp; &nbsp; &nbsp; <span class=\"teal\">Solid</span> solidOpening\n&nbsp; &nbsp; &nbsp; &nbsp; = <span class=\"teal\">GeometryCreationUtilities</span>.CreateExtrusionGeometry(\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; loops, cutDir.Negate(), .1 );\n&nbsp;\n&nbsp; &nbsp; &nbsp; <span class=\"teal\">Solid</span> solidHost = solHandler.CreateSolidFromBoundingBox(\n&nbsp; &nbsp; &nbsp; &nbsp; <span class=\"blue\">null</span>, geomElemHost.GetBoundingBox(), <span class=\"blue\">null</span> );\n&nbsp;\n&nbsp; &nbsp; &nbsp; <span class=\"blue\">if</span>( solidHost == <span class=\"blue\">null</span> )\n&nbsp; &nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; &nbsp; <span class=\"blue\">return</span> 0;\n&nbsp; &nbsp; &nbsp; }\n&nbsp;\n&nbsp; &nbsp; &nbsp; <span class=\"teal\">Solid</span> intersectSolid\n&nbsp; &nbsp; &nbsp; &nbsp; = <span class=\"teal\">BooleanOperationsUtils</span>.ExecuteBooleanOperation(\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; solidOpening, solidHost,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class=\"teal\">BooleanOperationsType</span>.Intersect );\n&nbsp;\n&nbsp; &nbsp; &nbsp; <span class=\"blue\">if</span>( intersectSolid.Faces.Size.Equals( 0 ) )\n&nbsp; &nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; &nbsp; solidOpening\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = <span class=\"teal\">GeometryCreationUtilities</span>.CreateExtrusionGeometry(\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; loops, cutDir, .1 );\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; intersectSolid\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = <span class=\"teal\">BooleanOperationsUtils</span>.ExecuteBooleanOperation(\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; solidOpening, solidHost,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class=\"teal\">BooleanOperationsType</span>.Intersect );\n&nbsp; &nbsp; &nbsp; }\n&nbsp;\n&nbsp; &nbsp; &nbsp; <span class=\"blue\">if</span>( <span class=\"teal\">DebugHandler</span>.EnableSolidUtilityVolumes )\n&nbsp; &nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; &nbsp; <span class=\"blue\">using</span>( <span class=\"teal\">Transaction</span> trans = <span class=\"blue\">new</span> <span class=\"teal\">Transaction</span>( doc ) )\n&nbsp; &nbsp; &nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; trans.Start( <span class=\"maroon\">&quot;stacked1&quot;</span> );\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class=\"teal\">ShapeCreator</span>.CreateDirectShape( doc,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intersectSolid, <span class=\"maroon\">&quot;stackedOpening&quot;</span> );\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; trans.Commit();\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; <span class=\"blue\">return</span> solHandler.GetLargestFaceArea( intersectSolid );\n&nbsp; &nbsp; }\n&nbsp; &nbsp; <span class=\"blue\">return</span> 0;\n&nbsp; }\n</pre>\n\nThere are other fall-backs implemented as well such as just getting the area from height and width parameters, and another method for handling curtain walls.\n\nNo temporary transactions are used at all :-)\n\nJeremy adds: I started adding Håvard's functionality to\nthe [SpatialElementGeometryCalculator GitHub project](https://github.com/jeremytammik/SpatialElementGeometryCalculator),\nand it is integrated into the current [release 2016.0.0.2](https://github.com/jeremytammik/SpatialElementGeometryCalculator/releases/tag/2016.0.0.2) but still not hooked up and as of yet completely untested in that project.\n\nHåvard is using is successfully in his own project, though.\n\nPlease feel free to fork, explore, enhance and issue pull requests back.\n\nMany thanks to everybody for their valuable contributions, especially Håvard for sharing this solution!\n\nHappy weekend to all!"
  }
]