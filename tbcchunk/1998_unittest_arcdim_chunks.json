[
  {
    "original_filename": "1998_unittest_arcdim",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n<link rel=\"stylesheet\" type=\"text/css\" href=\"bc.css\">\n<script src=\"https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js\" type=\"text/javascript\"></script>\n</head>\n\n<!---\n\n- xUnitRevit: a test runner for Revit\n  https://speckle.systems/blog/xunitrevit/\n\n- dimension arc endpoint references\n\n- API versus SDK\n  https://autodesk.slack.com/archives/C0PLC20PP/p1686249893898359\n  Erica Beffert\n\ntwitter:\n\n@SpeckleSystems share a new Revit add-in unit testing tool, xUnitRevit, a test runner for @AutodeskRevit #RevitAPI #BIM @DynamoBIM @AutodeskAPS https://speckle.systems/blog/xunitrevit\n\n/Users/jta/a/doc/revit/tbc/git/a/img/xunitrevit.gif\n\nAccessible Revit add-in unit testing, function and accessibility of Autodesk APIs and SDKs, a minimalist secure file sharing tool and programmatic dimensioning of circles in the @AutodeskRevit #RevitAPI #BIM @DynamoBIM @AutodeskAPS https://autode.sk/unittest_arcdim\n\nRevit add-in unit testing is becoming much more accessible, and now yet another toolkit is here.\nWe also clarify function and accessability of various Autodesk APIs and SDKs, look at programmatic dimensioning of circles in Revit and a minimalist secure file sharing tool\n&ndash; Revit add-in unit testing\n&ndash; API versus SDK\n&ndash; Arc dimensioning\n&ndash; Rotate your file...\n\nlinkedin:\n\nAccessible Revit add-in unit testing, function and accessibility of Autodesk APIs and SDKs, a minimalist secure file sharing tool and programmatic dimensioning of circles in the #RevitAPI\n\nhttps://autode.sk/unittest_arcdim\n\n- Revit add-in unit testing\n- API versus SDK\n- Arc dimensioning\n- Rotate your file...\n\n#BIM #DynamoBIM #AutodeskAPS #Revit #API #IFC #SDK #Autodesk #AEC #adsk\n\nthe [Revit API discussion forum](http://forums.autodesk.com/t5/revit-api-forum/bd-p/160) thread\n\n<center>\n<img src=\"img/\" alt=\"\" title=\"\" width=\"600\"/>\n<p style=\"font-size: 80%; font-style:italic\"></p>\n</center>\n\n-->"
  },
  {
    "original_filename": "1998_unittest_arcdim",
    "header_text": "Unit Testing and Arc Dimensioning",
    "local_header_href": "#unit-testing-and-arc-dimensioning",
    "chunk_text": "### Unit Testing and Arc Dimensioning\n\nRevit add-in unit testing is becoming much more assessible, and now yet another toolkit is here.\nWe also clarify function and accessability of various Autodesk APIs and SDKs, look at programmatic dimensioning of circles in Revit and a minimalist secure file sharing tool:\n\n- [Revit add-in unit testing](#2)\n- [API versus SDK](#3)\n- [Arc dimensioning](#4)\n- [Rotate your file](#5)"
  },
  {
    "original_filename": "1998_unittest_arcdim",
    "header_text": "Revit Add-In Unit Testing",
    "local_header_href": "#2",
    "chunk_text": "####<a name=\"2\"></a> Revit Add-In Unit Testing\n\n[Speckle](https://speckle.systems/) shared\n[xUnitRevit: a test runner for Revit](https://speckle.systems/blog/xunitrevit) that\nlooks very promising.\nCheck out other options in\nthe [unit testing topic group](https://thebuildingcoder.typepad.com/blog/about-the-author.html#5.16)."
  },
  {
    "original_filename": "1998_unittest_arcdim",
    "header_text": "API versus SDK",
    "local_header_href": "#3",
    "chunk_text": "####<a name=\"3\"></a> API versus SDK\n\nMy colleagues Mikako Harada and Kevin Vandecar answered a fundamental question comparing\nthe [API](https://en.wikipedia.org/wiki/API) or application programming interface of a product with\nits [SDK](https://en.wikipedia.org/wiki/Software_development_kit) or software development kit:\n\n**Question:** I have a question about desktop APIs and SDKs &ndash; I'm more familiar with the cloud world, so apologies if this is a really dumb question.\nFor our desktop products that offer an API, my understanding is that the API is part of the code that is downloaded, but that the SDK is downloaded separately.\nIs that correct?\nI am also assuming that I could use the API without the SDK, is that correct?\n\n**Answer 1:** It depends on the product.\nFor example, the AutoCAD C++ API ObjectARX requires a separate DLL separately, while the AutoCAD.NET API and AutoLISP are included in the product.\n\nFor some other APIs, such as OMF and ReCap, you need to be a member of ADN.\n\nOEM is completely separate offering that you need to license\nfrom [Tech Soft 3D](https://www.techsoft3d.com).\n\n**Answer 2:** It really varies a lot depending on the product.\nIn the desktop world, the SDK usually provides the \"access\" and full \"experience\" to the API.\nDocs, samples, and necessary tools to produce a plugin/addin.\nDepending on the product and development environment, it can vary.\n\nFor example, AutoCAD ObjectARX, 3ds Max SDK, and Maya DevKit, are fundamentally C++ oriented and requires minimally headers and libraries.\nIn Maya, those are included with the product, but that's it.\nThe ObjectARX and 3ds Max SDKs contain those header and libraries, plus samples, docs, etc.\nThe Maya devkit further enhances the developer experience but is not absolutely necessary.\nIn 3ds Max through 2023, for example, the SDK was included by a separate installer task; for convenience it was also posted to the developer centre and ADN extranet. In 2024, due to installer changes, it is only available through the developer center.\nThe additional benefit of including the SDK separately from the product is so developers can \"build\" without needing to fully install the product.\nFor example, if they have build machines that do not need the full product, this helps them.\n\nSo, the assumption \"I am also assuming that I could use the API without the SDK, is that correct?\" is definitely not true for C++ environments, and would be questionable for others, depending on API environment and product.\nIn Autodesk context, the .NET APIs are usually a wrapper around or interface into the internals of the product (and may \"wrap\" the C++ interfaces).\nIn AutoCAD and 3ds Max, for example, these are just wrapper DLLs and are included with the product to enable plugins/addins to actually run against it.\nBut the SDK there may include again docs, samples, and other supporting aspects.\nOne example exception is AutoCAD ACA/AMEP.\nThose are completely included (along with API reference docs and samples) within the product.\nAdditionally, the \"API reference\" in a .NET environment is not usually necessary, because it can be replaced by Reflection and Visual Studio IntelliSense.\nA \"developer's guide\" is typically helpful, but that can also vary.\nAnother contradiction is the Vault API, where they do not even have much online docs.\nSo, even though the SDK is included with the product, you must install it, to get a local CHM file for API reference docs.\n\nIn Revit, as another example, the .NET environment is still sort of a \"wrapper\" but has a more integrated approach internally for software development.\nA proprietary definition language (RIDL) is used to produce the .NET API during compilation of Revit source code.\nThe SDK includes the samples, docs, etc., so it provides a lot of useful information for anyone getting started with the API.\n\nSome desktop apps also have a COM API.\nInventor is a good example here, where the COM AP is used to develop .NET and C++ applications, and through its COM/ActiveX interfaces also allows VBA.\nVBA is included with Inventor and allows \"macro\" style development (much like the MS Office apps).\n\nAs said, OEM is a different situation altogether, where the product itself usually includes everything, including a way to stamp/brand it into the licensees' tools.\n\nThe Navisworks SDK is another example of a mixture of all the above.\n\nMany thanks to Mikako and Kevin for the helpful explanation."
  },
  {
    "original_filename": "1998_unittest_arcdim",
    "header_text": "Arc Dimensioning",
    "local_header_href": "#4",
    "chunk_text": "####<a name=\"4\"></a> Arc Dimensioning\n\nI made an interesting discovery working on a dimensioning issue that involved chain dimensioning of a circle placement within a rectangle, displaying its diameter and offsets from the four edges.\nThe circle is generated by creating two 180-degree arcs with a centre point `p` and half width and height vectors `vw2` and `vh2`:\n\n<pre class=\"prettyprint\">\n  arc = Arc.Create(p - vw2, p + vh2, p + vw2);\n  curve = doc.Create.NewModelCurve( arc, sketchPlane);\n  arc = Arc.Create(p + vw2, p - vh2, p - vw2);\n  curve = doc.Create.NewModelCurve(arc, sketchPlane);\n</pre>\n\nChain dimensioning model line segments is straightforward, simply adding all the line endpoint references to the `ReferenceArray`.\n\nI attempted a similar approach with the arcs like this:\n\n<pre class=\"prettyprint\">\n  arc = Arc.Create(p - vw2, p + vh2, p + vw2);\n  curve = doc.Create.NewModelCurve( arc, sketchPlane);\n\n  // Vertical\n\n  ra.Clear();\n  ra.Append(mc_front_left.GeometryCurve.GetEndPointReference(0));\n  ra.Append(curve.GeometryCurve.GetEndPointReference(0));\n  ra.Append(curve.GeometryCurve.GetEndPointReference(1));\n  ra.Append(mc_front_left.GeometryCurve.GetEndPointReference(1));\n  doc.Create.NewDimension(viewForDimension, Line.CreateUnbound(pVert, vz), ra);\n\n  // Horizontal\n\n  ra.Clear();\n  ra.Append(ductEdgeForDimHor.GeometryCurve.GetEndPointReference(0));\n  ra.Append(curve.GeometryCurve.GetEndPointReference(0));\n  ra.Append(curve.GeometryCurve.GetEndPointReference(1));\n  ra.Append(ductEdgeForDimHor.GeometryCurve.GetEndPointReference(1));\n  doc.Create.NewDimension(viewForDimension, Line.CreateUnbound(pHor, vHor), ra);\n</pre>\n\nTo my surprise, this code creates dimensions to one endpoint and one midpoint of the arc:\n\n<center>\n<img src=\"img/dim_180_deg_arc_end_point_a0_r01.png\" alt=\"Arc dimensioning\" title=\"Arc dimensioning\" width=\"300\"/> <!-- Pixel Height: 1,064 Pixel Width: 1,026 -->\n</center>\n\nTo obtain the other endpoint, I need to grab a reference from the second arc as well, like this:\n\n<pre class=\"prettyprint\">\n  arc = Arc.Create(p - vw2, p + vh2, p + vw2);\n  curve = doc.Create.NewModelCurve( arc, sketchPlane);\n  Reference r1 = curve.GeometryCurve.GetEndPointReference(0);\n  arc = Arc.Create(p + vw2, p - vh2, p - vw2);\n  curve = doc.Create.NewModelCurve(arc, sketchPlane);\n  Reference r2 = curve.GeometryCurve.GetEndPointReference(0);\n\n  // Vertical\n\n  ra.Clear();\n  ra.Append(mc_front_left.GeometryCurve.GetEndPointReference(0));\n  ra.Append(r1);\n  ra.Append(r2);\n  ra.Append(mc_front_left.GeometryCurve.GetEndPointReference(1));\n  doc.Create.NewDimension(viewForDimension, Line.CreateUnbound(pVert, vz), ra);\n\n  // Horizontal\n\n  ra.Clear();\n  ra.Append(ductEdgeForDimHor.GeometryCurve.GetEndPointReference(0));\n  ra.Append(r1);\n  ra.Append(r2);\n  ra.Append(ductEdgeForDimHor.GeometryCurve.GetEndPointReference(1));\n  doc.Create.NewDimension(viewForDimension, Line.CreateUnbound(pHor, vHor), ra);\n</pre>\n\nWith this code, the vertical dimension correctly dimensions the circle diameter, but the horizontal dimensioning collapses the two endpoints into one:\n\n<center>\n<img src=\"img/dim_two_180_deg_arcs_a01_r0.png\" alt=\"Arc dimensioning\" title=\"Arc dimensioning\" width=\"300\"/>\n</center>\n\nSo, finally, we arrive at the working solution with successful diameter chain dimensioning both horizontal and vertical by using both endpoint references of both arcs, specifying different endpoints for the horizontal and vertical direction:\n\n<pre class=\"prettyprint\">\n  arc = Arc.Create(p - vw2, p + vh2, p + vw2);\n  curve = doc.Create.NewModelCurve( arc, sketchPlane);\n  Reference a0r0 = curve.GeometryCurve.GetEndPointReference(0);\n  Reference a0r1 = curve.GeometryCurve.GetEndPointReference(1);\n\n  arc = Arc.Create(p + vw2, p - vh2, p - vw2);\n  curve = doc.Create.NewModelCurve(arc, sketchPlane);\n  Reference a1r0 = curve.GeometryCurve.GetEndPointReference(0);\n  Reference a1r1 = curve.GeometryCurve.GetEndPointReference(1);\n\n  // Vertical\n\n  ra.Clear();\n  ra.Append(mc_front_left.GeometryCurve.GetEndPointReference(0));\n  ra.Append(a0r0);\n  ra.Append(a1r0);\n  ra.Append(mc_front_left.GeometryCurve.GetEndPointReference(1));\n  doc.Create.NewDimension(viewForDimension, Line.CreateUnbound(pVert, vz), ra);\n\n  // Horizontal\n\n  ra.Clear();\n  ra.Append(ductEdgeForDimHor.GeometryCurve.GetEndPointReference(0));\n  ra.Append(a0r1);\n  ra.Append(a1r1);\n  ra.Append(ductEdgeForDimHor.GeometryCurve.GetEndPointReference(1));\n  doc.Create.NewDimension(viewForDimension, Line.CreateUnbound(pHor, vHor), ra);\n</pre>\n\nThe result is as desired:\n\n<center>\n<img src=\"img/dim_two_180_deg_arcs_a01_r01.png\" alt=\"Arc dimensioning\" title=\"Arc dimensioning\" width=\"300\"/>\n</center>\n\nIn summary, the tests above include:\n\n- Arc 0, references 0 + 1 &ndash; both endpioints of one single arc\n- Arc 0 + 1, reference 0 &ndash; the start points of two arcs\n- Arc 0 + 1, references 0 + 1 &ndash; start and end point of both arcs, depending on the dimensioning orientation\n\nMy interpretation is that the chain dimensioning does not use the specified endpoint reference in the way I expect.\n\nRather, the most extreme endpoint towards the start or end of the curve is dynamically determined depending on the dimension line orientation, resulting in the endpoint in one direction and the midpoint in the other."
  },
  {
    "original_filename": "1998_unittest_arcdim",
    "header_text": "Rotate Your File",
    "local_header_href": "#5",
    "chunk_text": "####<a name=\"5\"></a> Rotate Your File\n\n[Rotate Your File](https://funct.app/) provides a handy little service to safely send someone a file:\n\n- [Start here](https://funct.app/start)\n- [Frequently asked questions](https://funct.app/faq)\n\nThe FAQ is pleasantly readable and succinct, including nice descriptions of the design philosophy, GDPR, data collection, security and encryption aspects."
  }
]