[
  {
    "original_filename": "0983_space_adjacency",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<head>\n<link href=\"bc.css\" rel=\"stylesheet\" type=\"text/css\"/>\n<meta content=\"text/html; charset=utf-8\" http-equiv=\"Content-Type\"/>\n</head>"
  },
  {
    "original_filename": "0983_space_adjacency",
    "header_text": "Football and Space Adjacency for Heat Load Calculation",
    "local_header_href": "#football-and-space-adjacency-for-heat-load-calculation",
    "chunk_text": "<h3>Football and Space Adjacency for Heat Load Calculation</h3><p>Here is a summary of a discussion with Jasper Desmet, who is studying engineering and working on a research project for his master thesis concerning heat load calculation using BIM software, proving that it is possible for a novice programmer to extract the required information from the model using the Revit API.</p><a name=\"2\"></a>"
  },
  {
    "original_filename": "0983_space_adjacency",
    "header_text": "Football Tournament, Fleece and Shard",
    "local_header_href": "#football-tournament-fleece-and-shard",
    "chunk_text": "<h4>Football Tournament, Fleece and Shard</h4><p>First, though,  let me mention that I visited the UK this weekend to participate in the Autodesk European soccer tournament, which took place on Saturday at the\n\n<a href=\"http://www.rhul.ac.uk\">Royal Holloway</a> University in Egham:</p><center>\n<img alt=\"Neuchâtel Eagles at the Royal Holloway in Egham\" src=\"file:////j/photo/jeremy/2013/2013-07-14_london/1360.jpg\" width=\"300\"/>\n</center><p>Sunday I took a walk along the Thames from Waterloo to London Bridge on the way to the airport, and happened to pass by the\n\n<a href=\"http://southbanklondon.com/bargehouse\">Bargehouse</a> exhibition space, currently housing the\n\n<a href=\"http://fleeceshow.com\">Fleece</a> photography exhibition including 'Climax' by\n\n<a href=\"http://fleeceshow.com/artists/Holly_Buckle.html\">Holly Buckle</a>:</p><center>\n<img alt=\"'Climax' by Holly Buckle in the Bargehouse\" src=\"file:////j/photo/jeremy/2013/2013-07-14_london/1457.jpg\" width=\"300\"/>\n</center><p>Among the many other fascinating images, I also discovered a poem by\n\n<a href=\"http://en.wikipedia.org/wiki/Lord_Byron\">\nLord Byron</a>, from\n\n<a href=\"http://en.wikipedia.org/wiki/Childe_Harold%27s_Pilgrimage\">\nChilde Harold's Pilgrimage</a>, Canto iv, Verse 178, which reflects my opinion of nature and society quite nicely:</p><p style=\"padding-left:10%\">There is a pleasure in the pathless woods,\n<br/>There is a rapture on the lonely shore,\n<br/>There is society, where none intrudes,\n<br/>By the deep sea, and music in its roar:\n<br/>I love not man the less, but Nature more ...</p><p>Finally, here is a close-up of the 72-storey\n\n<a href=\"http://the-shard.com\">Shard</a> skyscraper,\n\ncurrently the tallest building in the European Union, from the London Bridge station platform, just before boarding the train for Gatwick:</p><center>\n<img alt=\"Shard\" src=\"file:////j/photo/jeremy/2013/2013-07-14_london/1470.jpg\" width=\"300\"/>\n</center><p>I think those are more than enough impressions from this eventful weekend, so let's return to the heat load calculation space adjacency discussion with Jasper:</p><a name=\"3\"></a>"
  },
  {
    "original_filename": "0983_space_adjacency",
    "header_text": "Space Adjacency for Heat Load Calculation",
    "local_header_href": "#space-adjacency-for-heat-load-calculation",
    "chunk_text": "<h4>Space Adjacency for Heat Load Calculation</h4><p><strong>Question:</strong> I'm doing my master thesis concerning heat load calculation using BIM-software (obviously I use Revit).\nAs a part of this thesis I'm writing an application to extract all necessary information from Revit, and calculate the heat load using Belgian standards. This is mainly to show the possibilities of automation using the Revit API.</p><p>As I am studying engineering: construction, programming is not my strong suit (although I love it very much), and your site has been invaluable for my efforts to making this application work. Thanks for all the help already (through the blog), but I write with a question:</p><p>To implement the calculation I need a lot of data about the spaces and their bounding elements.\nI use the SpatialElementGeometryCalculator to calculate the geometry, and get the SpatialBoundaryElements, as shown in the Developer Guide wiki page on\n\n<a href=\"http://wikihelp.autodesk.com/Revit/enu/2013/Help/00006-API_Developer's_Guide/0074-Revit_Ge74/0108-Geometry108/Room_and_Space_Geometry.\">\nRoom and Space Geometry</a> to\n\ncalculate a room's geometry and find its boundary faces.\nThis works great.</p><p>Apart from that I also need to know the space adjacencies, and I adapted the code you provided for determining\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2009/07/space-adjacency.html\">\nspace adjacencies</a> to\n\nretrieve the segments and the adjacent space for each segment.</p><p>What I want to do now is merge these two different data sets into a single component class MySurface.</p><p>Here is a schematic view of the data I am collecting from the model that makes it easier to understand how I defined the MyComponents class to manage the data:</p><center>\n<img alt=\"Heat load calculation data schema\" src=\"img/jd_heat_load_calculation_data_schema.jpeg\" width=\"800\"/>\n</center><p>Right now I can't find the link I need between the faces/subfaces of the SpatialElementGeometryCalculator and the segments from the BoundarySegments.</p><p>So basically my question is how to know which segment and which (sub)face go together.\nIs there a way to achieve this?\nIs there a way to get the boundary segments through the SpatialElementGeometryCalculator?</p><p><strong>Answer:</strong> Thank you for raising this interesting topic.</p><p>Some questions back:</p><ul>\n<li>What exact data have you already retrieved?</li>\n<li>2D space boundaries + adjacent spaces on each side?</li>\n<li>SpatialElementGeometryCalculator faces and sub-faces?</li>\n<li>Do the SpatialElementGeometryCalculator not tell you the originating element producing each face?</li>\n</ul><p>You can ask a space to return its 3D volume and all its bounding elements in 3D.</p><p><strong>Response:</strong> Here is some clarification on what I already have and the paths I’m considering next:</p><p>Certain assumptions are made to simplify the project:</p><ul>\n<li>All boundary curves are linear and coincident with the possible calculated segments.</li>\n<li>The floor type is defined by the level (1 level, 1 floor).</li>\n</ul><p>As said, I made use of your\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2009/07/space-adjacency.html\">\nCmdSpaceAdjacency</a> command\n\nand added the adjacent space (_adjSpace) to the Segment class, so that both the space of origin and the adjacent space (null for exterior walls) are available for each given segment, not only for the space.</p><pre class=\"code\">\n<span class=\"blue\">  #region</span> Adjacencies\n<span class=\"blue\">  #region</span> Segment Class\n  <span class=\"blue\">public</span> <span class=\"blue\">class</span> <span class=\"teal\">Segment</span>\n  {\n    <span class=\"teal\">XYZ</span> _sp;\n    <span class=\"teal\">XYZ</span> _ep;\n    <span class=\"teal\">Space</span> _space;\n    <span class=\"teal\">Space</span> _adjSpace = <span class=\"blue\">null</span>;\n    <span class=\"green\">// . . .\n</span></pre><p>So this is what I have at the moment.\nA list of segments that give me access to the adjacencies of spaces at the given 2D-boundaries, and a list of surfaces containing geometric and thermal information about the spaces.</p><p>One problem is that the adjacencies at the moment are only in 2D (on the same level). For a correct heat load calculation you would need surface division for the floors (e.g. a bathroom [at 24°C for calculation], above an entrance hall [at 20°C for calculation] will need transmission calculation, whereas two rooms at the same temperature will not need that, so that surface information is necessary =&gt; see plan views in attachment). The SpatialElementGeometryCalculator does not take the layout of spaces above or below into consideration though (this I derived from the printed info of the faces). However much I would like to puzzle out how to implement this, that would take me too far, as this application is not the main focus of my master-thesis.</p><p>What I’m considering:</p><p>Now I’m looking for how to link both data together.\nI’m considering one of two following options:</p><ul>\n<li>Using the segments (2D boundaries) to find the corresponding face edge inside a space (comparing XYZ-points). Although this might work, it doesn’t solve the fact that only adjacency on the same level is considered.</li>\n<li>Implementing a similar adjacency system using the faces instead of the 2D-boundaries, using the normal vector as direction for the testing point (as this always points outward).</li>\n</ul><p>I think the second option is the more widely usable option, as it takes adjacency directly from the same calculated data, taking away certain problems. It might not be the most performant of the two, but I have no way of knowing this.</p><p>The first option might be the fastest to implement with what I have so far.</p><p><strong>Later:</strong> I’ve been trying to get the adjacency system to work, and here’s what I got.\nIt works for the horizontal adjacencies (on the same level), but vertical adjacencies are still an issue as the SpatialElementGeometryCalculator does not divide floor/ceiling faces to reflect the adjacent level space layout (for differences in internal design temperature between different spaces).\nI have an idea on how to solve that issue later.</p><p>Here is what I do:</p><p>My method for retrieving the Space data from a given Space in Revit is implemented by the GetSpaceData method below.</p><p>For the given Space I retrieve the Geometry through the SpatialElementGeometryCalculator.\nFor each face of the Space I do the following:</p><ul>\n<li>Create a personal Surface component to store the data retrieved for later use.</li>\n<li>Retrieve the defining points of the edges of the face, for calculation of a point inside the face (if necessary).</li>\n<li>Retrieve the normal-vector of the face (which according to the information I found always points outwards of the Solid the Face is part of), for retrieval of the adjacent Space.</li>\n<li>Retrieve the adjacent Space through the method FindAdjacentSpaceFromSurface, which takes the following arguments: the considered Face, a list of XYZ points defining the polygon, and the normal-vector of the face.</li>\n<ul>\n<li>At first I tried to use a Ray Projection (ReferenceIntersector) to retrieve the adjacent space (to ‘poke’ into a certain direction), but this resulted in a failure, and my guess is that it’s because the Space element is not considered 3D-geometry and is not ‘visible’ in the 3D-view, and can thereby not be found by intersection.</li>\n<li>As an adjacent Space has a certain proximity to the other space I construct a test point from a point on the Face, using the normal and a MaxWallThickness-constant to make sure the test point surpasses the bounding Element responsible for the Space-face creation.</li>\n<li>Then I test if this point is inside a Space of the Project (using a List of spaces constructed earlier on in the application), and if it is I assign this space as the adjacent Space to the considered Space in GetSpaceData-method.</li>\n</ul>\n<li>Through the subfaces I then retrieve the necessary data for the calculations, as through these subfaces I can access the boundary element responsible for the surface creation. Floors however don’t have a boundary element (and as I have come to notice, nor has my second floor upper surface (my roof is not considered a bounding element, and I don’t see why…).\nThe method FindAdjacentSpaceFromSurface listed below to retrieve the underlying Floor, but it currently causes a fatal error and closes the Revit session as soon as it hits the second floor Spaces.</li>\n</ul><p>So, in conclusion, I successfully asses the space adjacency for horizontal adjacencies (although maybe not totally fool proof), but still have an issue with the vertical adjacencies, as to which space is adjacent for which portion of the surface. I also have an issue with determining the floor of a space, as my attempt to use Ray Projection to do so results in a fatal error. Also I don’t understand why the RoofBase-element is not a bounding element for my Spaces on the top-most floor, have you got an idea as to why this is?</p><p><strong>Answer:</strong> The issue with the SpatialElementGeometryCalculator may be due to modelling errors.\nI cannot say for sure, of course, just offer this as a wild guess.</p><p>You say that you suspect that the ReferenceIntersector does not consider the Space element as 3D-geometry and it is therefore not ‘visible’ in the 3D-view.\nYes, I agree.</p><p>The other issues you report are not surprising.\nI run into similar issues when I try new things.\nIt is often an unclear mix between imperfect modelling and rather sensitive API methods with detailed input requirements.</p><p>By the way, the new\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2013/07/graphics-pipeline-custom-exporter.html\">\nCustomExporter class</a>,\n\nfor which I just published a couple of samples, provides another completely different way to access surfaces which may be of interest to you as well.</p><p><strong>Response:</strong> Your wild (educated) guess was right.\nThe problem with the Roof not being a BoundingElement of the Space was due to a modelling error.\nThe space top constraint was ‘level 2’, which was also the level the roof was drawn on, so the space did not run totally up to the roof.\n\n<p>After fixing this, the Roof became a BoundingElement and the output was correct.</p>\n<p>Even better, because I took away this modelling error, the fatal error concerning the ReferenceIntersector was also gone, and now I’m able to implement this to determine the floor type of a Space.\nThanks a lot for this helpful input, it saved me a lot of time (and sweat :-).</p>\n<p>That fixed the most important issues.\nFor now I’ve got what I need to get my small thesis-application to work.\nAs to the issue with vertical adjacency (the only one left), I will try to look into that, but I don’t think I’ll have time to do so before the end of august (which is when my thesis is due). It’s an interesting issue though, and an important one for Energy Analysis, I think.</p>\n<p>Here is the code in its current state, and working for me in my test project:</p>\n<pre class=\"code\">\n<span class=\"blue\">public</span> <span class=\"blue\">void</span> GetSpaceData(\n  <span class=\"teal\">MySpace</span> mySpace, <span class=\"teal\">Space</span> revitSpace )\n{\n  mySpace.surfaces = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">MySurface</span>&gt;();\n \n  <span class=\"teal\">SpatialElementGeometryCalculator</span> calculator\n    = <span class=\"blue\">new</span> <span class=\"teal\">SpatialElementGeometryCalculator</span>( doc );\n \n  <span class=\"teal\">SpatialElementGeometryResults</span> results\n    = calculator.CalculateSpatialElementGeometry(\n      revitSpace );\n \n  <span class=\"teal\">Solid</span> spaceSolid = results.GetGeometry();\n \n  <span class=\"blue\">foreach</span>( <span class=\"teal\">Face</span> face <span class=\"blue\">in</span> spaceSolid.Faces )\n  {\n    <span class=\"green\">//</span>\n    <span class=\"green\">//Creating personal Surface component</span>\n    <span class=\"green\">//</span>\n    <span class=\"teal\">MySurface</span> surf = <span class=\"blue\">new</span> <span class=\"teal\">MySurface</span>();\n    surf.area = SQFeetToSQMeter( face.Area );\n    mySpace.surfaces.Add( surf );\n \n    <span class=\"green\">//</span>\n    <span class=\"green\">//Get the edgePoints of the face</span>\n    <span class=\"green\">//</span>\n    <span class=\"teal\">UV</span> px = <span class=\"blue\">null</span>;\n    <span class=\"teal\">List</span>&lt;<span class=\"teal\">XYZ</span>&gt; edgesPoints = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">XYZ</span>&gt;();\n \n    <span class=\"blue\">foreach</span>( <span class=\"teal\">EdgeArray</span> a <span class=\"blue\">in</span> face.EdgeLoops )\n    {\n      <span class=\"blue\">int</span> nEdges = a.Size;\n      <span class=\"teal\">List</span>&lt;<span class=\"teal\">Curve</span>&gt; curves = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">Curve</span>&gt;( nEdges );\n      <span class=\"teal\">XYZ</span> p = <span class=\"blue\">null</span>;\n \n      <span class=\"blue\">foreach</span>( <span class=\"teal\">Edge</span> e <span class=\"blue\">in</span> a )\n      {\n        <span class=\"teal\">Curve</span> curve = e.AsCurveFollowingFace( face );\n        curves.Add( curve );\n      }\n \n      <span class=\"blue\">foreach</span>( <span class=\"teal\">Curve</span> curve <span class=\"blue\">in</span> curves )\n      {\n        p = curve.get_EndPoint( 0 );\n        edgesPoints.Add( p );\n      }\n      px = <span class=\"blue\">new</span> <span class=\"teal\">UV</span>( p.X, p.Y );\n    }\n    surf.edges = edgesPoints;\n    surf.normal = face.ComputeNormal( px );\n    <span class=\"teal\">Space</span> adjacentSpace = FindAdjacentSpaceFromSurface(\n      face, edgesPoints, surf.normal );\n    surf.adjSpace = adjacentSpace;\n    <span class=\"blue\">if</span>( adjacentSpace != <span class=\"blue\">null</span> )\n    {\n      surf.adjSpaceTemperature = adjacentSpace\n        .get_Parameter( <span class=\"maroon\">\"BE_SpaceTemperature\"</span> )\n        .AsDouble();\n    }\n    surf.space = revitSpace;\n \n    <span class=\"green\">//</span>\n    <span class=\"green\">//Getting the subfaces to determine the BoundaryElement</span>\n    <span class=\"green\">//</span>\n    <span class=\"blue\">var</span> subfaceList = results.GetBoundaryFaceInfo( face );\n \n    <span class=\"blue\">if</span>( subfaceList.Count != 0 )\n    {\n      <span class=\"blue\">foreach</span>( <span class=\"teal\">SpatialElementBoundarySubface</span> subface\n        <span class=\"blue\">in</span> subfaceList )\n      {\n        <span class=\"teal\">ElementId</span> elemid = subface.SpatialBoundaryElement\n          .HostElementId;\n \n        <span class=\"teal\">ElementId</span> typeid = doc.GetElement(\n          subface.SpatialBoundaryElement.HostElementId )\n            .GetTypeId();\n \n        <span class=\"green\">// Determine the 'assembly' of the bounding Element</span>\n        <span class=\"blue\">if</span>( myAssemblies.ContainsKey( typeid ) )\n        {\n          surf.assembly = myAssemblies[typeid];\n        }\n \n        <span class=\"green\">// Retrieve the openings in the considered bounding element</span>\n        <span class=\"teal\">Element</span> elem = doc.GetElement( elemid );\n        <span class=\"blue\">if</span>( elem <span class=\"blue\">is</span> <span class=\"teal\">Wall</span> )\n        {\n          <span class=\"teal\">Wall</span> wall = elem <span class=\"blue\">as</span> <span class=\"teal\">Wall</span>;\n          <span class=\"teal\">IList</span>&lt;<span class=\"teal\">ElementId</span>&gt; op = wall.FindInserts(\n            <span class=\"blue\">true</span>, <span class=\"blue\">false</span>, <span class=\"blue\">true</span>, <span class=\"blue\">true</span> );\n \n          <span class=\"blue\">foreach</span>( <span class=\"teal\">ElementId</span> elid <span class=\"blue\">in</span> op )\n          {\n            <span class=\"teal\">Element</span> opening = doc.GetElement( elid );\n            <span class=\"teal\">ElementId</span> openingTypeId = opening.GetTypeId();\n \n            <span class=\"blue\">if</span>( opening <span class=\"blue\">is</span> <span class=\"teal\">FamilyInstance</span>\n              &amp;&amp; openingTypes.ContainsKey( openingTypeId ) )\n            {\n              <span class=\"teal\">FamilyInstance</span> fi = opening <span class=\"blue\">as</span> <span class=\"teal\">FamilyInstance</span>;\n              <span class=\"teal\">XYZ</span> facingDirection = fi.FacingOrientation.Normalize();\n              <span class=\"teal\">BoundingBoxXYZ</span> bb = fi.get_BoundingBox( <span class=\"blue\">null</span> );\n              <span class=\"teal\">XYZ</span> midpoint = ( bb.Min + bb.Max ) / 2;\n \n              <span class=\"teal\">XYZ</span> testPoint1 = midpoint + facingDirection\n                * MaxWallThickness;\n \n              <span class=\"teal\">XYZ</span> testpoint2 = midpoint + -facingDirection\n                * MaxWallThickness;\n \n              <span class=\"blue\">if</span>( revitSpace.IsPointInSpace( testPoint1 )\n                || revitSpace.IsPointInSpace( testpoint2 ) )\n              {\n                <span class=\"teal\">Parameter</span> height = fi.get_Parameter( <span class=\"maroon\">\"Height\"</span> );\n                <span class=\"blue\">if</span>( height == <span class=\"blue\">null</span> )\n                {\n                  height = fi.Symbol.get_Parameter( <span class=\"maroon\">\"Height\"</span> );\n                }\n                <span class=\"teal\">Parameter</span> width = fi.get_Parameter( <span class=\"maroon\">\"Width\"</span> );\n                <span class=\"blue\">if</span>( width == <span class=\"blue\">null</span> )\n                {\n                  width = fi.Symbol.get_Parameter( <span class=\"maroon\">\"Width\"</span> );\n                }\n                <span class=\"blue\">double</span> area = SQFeetToSQMeter(\n                  height.AsDouble() * width.AsDouble() );\n \n                <span class=\"teal\">MyOpeningType</span> myOpeningType\n                  = openingTypes[openingTypeId];\n \n                <span class=\"teal\">MyOpening</span> myOpening = <span class=\"blue\">new</span> <span class=\"teal\">MyOpening</span>(\n                  area, elid );\n \n                myOpening.type = myOpeningType;\n                surf.openings.Add( myOpening );\n              }\n            }\n          }\n        }\n      }\n    }\n    <span class=\"blue\">else</span>\n    {\n      <span class=\"green\">//</span>\n      <span class=\"green\">// The floor has no subfaces (and no boundary-element) </span>\n      <span class=\"green\">// from the geometrycalculator</span>\n      <span class=\"green\">// We use ray projection to determine the floortype</span>\n      <span class=\"green\">//</span>\n \n      <span class=\"green\">// Find a 3D view to use for the </span>\n      <span class=\"green\">// ReferenceIntersector constructor</span>\n      <span class=\"teal\">FilteredElementCollector</span> coll\n        = <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( doc );\n \n      <span class=\"teal\">Func</span>&lt;<span class=\"teal\">View3D</span>, <span class=\"blue\">bool</span>&gt; isNotTemplate\n        = v3 =&gt; !( v3.IsTemplate );\n \n      <span class=\"teal\">View3D</span> view3D = coll.OfClass( <span class=\"blue\">typeof</span>( <span class=\"teal\">View3D</span> ) )\n        .Cast&lt;<span class=\"teal\">View3D</span>&gt;().First&lt;<span class=\"teal\">View3D</span>&gt;( isNotTemplate );\n \n      <span class=\"green\">// set originPoint just above the floor</span>\n      <span class=\"teal\">BoundingBoxUV</span> bb = face.GetBoundingBox();\n      <span class=\"teal\">XYZ</span> startPoint = FindPointOnFace( bb, edgesPoints, face );\n      <span class=\"teal\">XYZ</span> originPoint = startPoint + -( surf.normal ) * D2mm;\n \n      <span class=\"green\">// set the filter to floor</span>\n      <span class=\"teal\">ElementClassFilter</span> filter\n        = <span class=\"blue\">new</span> <span class=\"teal\">ElementClassFilter</span>( <span class=\"blue\">typeof</span>( <span class=\"teal\">Floor</span> ) );\n \n      <span class=\"teal\">ReferenceIntersector</span> refint\n        = <span class=\"blue\">new</span> <span class=\"teal\">ReferenceIntersector</span>( filter,\n          <span class=\"teal\">FindReferenceTarget</span>.Face, view3D );\n \n      <span class=\"blue\">if</span>( refint != <span class=\"blue\">null</span> )\n      {\n        <span class=\"teal\">ReferenceWithContext</span> refwithcont\n          = refint.FindNearest( originPoint,\n            surf.normal );\n \n        <span class=\"blue\">if</span>( refwithcont != <span class=\"blue\">null</span> )\n        {\n          <span class=\"teal\">Element</span> foundElem = doc.GetElement(\n            refwithcont.GetReference().ElementId );\n \n          <span class=\"teal\">ElementId</span> typeid = foundElem.GetTypeId();\n          surf.assembly = myAssemblies[typeid];\n          <span class=\"blue\">if</span>( surf.assembly.FloorOnGround\n            &amp;&amp; foundElem.get_Parameter( <span class=\"maroon\">\"BE_B U waarde\"</span> )\n              != <span class=\"blue\">null</span> )\n          {\n            surf.Uequiv = foundElem\n              .get_Parameter( <span class=\"maroon\">\"BE_B U waarde\"</span> )\n              .AsDouble();\n          }\n        }\n      }\n    }\n  }\n}\n \n<span class=\"blue\">public</span> <span class=\"teal\">Space</span> FindAdjacentSpaceFromSurface(\n  <span class=\"teal\">Face</span> originFace,\n  <span class=\"teal\">List</span>&lt;<span class=\"teal\">XYZ</span>&gt; edgesPoints,\n  <span class=\"teal\">XYZ</span> normalVector )\n{\n  <span class=\"teal\">Space</span> foundSpace = <span class=\"blue\">null</span>;\n \n  <span class=\"green\">// Find a suitable point on the face to 'poke' into the nearby space</span>\n  <span class=\"green\">// We then propagate by direction of the normal, and poke 1,35 feet into the wall</span>\n  <span class=\"green\">// to see if the testpoint is in another space</span>\n \n  <span class=\"teal\">BoundingBoxUV</span> bb = originFace.GetBoundingBox();\n \n  <span class=\"green\">// We determine the point by bounding box or by the points of the face polygon</span>\n  <span class=\"teal\">XYZ</span> startPoint = FindPointOnFace(\n    bb, edgesPoints, originFace );\n \n  <span class=\"teal\">XYZ</span> testPoint = startPoint + ( normalVector )\n    * MaxWallThickness;\n \n  <span class=\"blue\">foreach</span>( <span class=\"teal\">Space</span> space <span class=\"blue\">in</span> revitSpaceList )\n  {\n    <span class=\"blue\">if</span>( space.IsPointInSpace( testPoint ) )\n    {\n      foundSpace = space;\n      <span class=\"blue\">break</span>;\n    }\n  }\n  <span class=\"blue\">return</span> foundSpace;\n}\n \n<span class=\"blue\">public</span> <span class=\"teal\">XYZ</span> FindPointOnFace(\n  <span class=\"teal\">BoundingBoxUV</span> bb,\n  <span class=\"teal\">List</span>&lt;<span class=\"teal\">XYZ</span>&gt; edgesPoints,\n  <span class=\"teal\">Face</span> originFace )\n{\n  <span class=\"teal\">UV</span> midPoint = ( bb.Min + bb.Max ) / 2;\n  <span class=\"teal\">IntersectionResult</span> result;\n  <span class=\"teal\">XYZ</span> startPoint = <span class=\"blue\">new</span> <span class=\"teal\">XYZ</span>();\n  <span class=\"blue\">if</span>( originFace.IsInside( midPoint, <span class=\"blue\">out</span> result ) )\n  {\n    startPoint = originFace.Evaluate( midPoint );\n  }\n  <span class=\"blue\">else</span>\n  {\n    <span class=\"blue\">bool</span> isInside = <span class=\"blue\">false</span>;\n    <span class=\"blue\">while</span>( !isInside )\n    {\n      <span class=\"green\">// This is not a fool-proof method, but it gets the work done for a simple enough case</span>\n      <span class=\"green\">// (it will have to be an intricate face-polygon for this method not to work)</span>\n      <span class=\"teal\">XYZ</span> sumPoint = <span class=\"blue\">new</span> <span class=\"teal\">XYZ</span>();\n      <span class=\"blue\">int</span> start = 0;\n \n      <span class=\"blue\">for</span>( <span class=\"blue\">int</span> i = start; i &lt; start + 3; i++ )\n      {\n        sumPoint = sumPoint.Add( edgesPoints[i] );\n      }\n \n      startPoint = <span class=\"blue\">new</span> <span class=\"teal\">XYZ</span>( sumPoint.X / 3,\n        sumPoint.Y / 3, sumPoint.Z / 3 );\n \n      <span class=\"blue\">var</span> intersect = originFace.Project( startPoint );\n      <span class=\"teal\">UV</span> startp = intersect.UVPoint;\n      <span class=\"blue\">if</span>( originFace.IsInside( startp, <span class=\"blue\">out</span> result ) )\n      {\n        isInside = <span class=\"blue\">true</span>;\n      }\n      start++;\n    }\n  }\n  <span class=\"blue\">return</span> startPoint;\n}\n</pre>\n<p>Here is the complete\n\n<a href=\"/a/rvt/jd_heat_load_calculation_space_adjacency.rvt\">\nRevit 2013 project file</a> containing\n\nthe calculation macros and simple sample model:</p>\n<center>\n<img alt=\"Sample model 3D\" src=\"img/jd_heat_load_calculation_house_3d.png\" width=\"200\"/>\n</center>\n<p>Here is a cut through the 3D model:</p>\n<center>\n<img alt=\"Sample model 3D cut\" src=\"img/jd_heat_load_calculation_house_3d_cut.png\" width=\"200\"/>\n</center>\n<p>The first level floor plan looks like this:</p>\n<center>\n<img alt=\"Sample model 2D\" src=\"img/jd_heat_load_calculation_house_2d.png\" width=\"300\"/>\n</center>\n<p>There is no Visual Studio solution, since I am working entirely in the SharpDevelop macro environment available within Revit.\nAs an inexperienced programmer (just started this year, learning it on my own) I found this made it easier to debug, and after getting it to work as a macro, I found the cleaning-up process to make it work as add-in using Visual Studio express minimal.\nSo actually the code is inside the project file, embedded as a project-level Macro:</p>\n<center>\n<img alt=\"Sample model macros\" src=\"img/jd_heat_load_calculation_macros.png\" width=\"200\"/>\n</center>\n<p>I am already working on the calculations and the export to XML and PDF, but I cleaned up the project to only reflect the data collection part.\nIf you are interested in the rest too, I can send the whole project over once it is complete.</p>\n<p>Many thanks to Jasper for this fruitful discussion, your research and hard work, and the best of luck to you with the rest of the thesis!</p>\n</p>"
  }
]