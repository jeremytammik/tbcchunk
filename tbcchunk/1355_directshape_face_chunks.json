[
  {
    "original_filename": "1355_directshape_face",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n<link rel=\"stylesheet\" type=\"text/css\" href=\"bc.css\">\n<script src=\"run_prettify.js\" type=\"text/javascript\"></script>\n<!---\n<script src=\"https://google-code-prettify.googlecode.com/svn/loader/run_prettify.js\" type=\"text/javascript\"></script>\n-->\n</head>\n\n<!---\n\n#revitapi #3dwebcoder #bim #aec #adskdevnetwrk #dotnet #csharp #geometry\n#adsk #fsharp #dynamobim\n#restapi #python\n#grevit\n#responsivedesign #typepad\n#ah8 #augi #au2015 #dotnet #dynamobim\n#stingray #adsklabs #cloud #rendering\n#3dweb #3dviewapi #html5 #threejs #webgl #3d #apis #mobile #vr #ecommerce\n#Markdown #Fusion360 #Fusion360Hackathon #revitapi #adsk #3dwebcoder #aec #bim\n\nRevit API, Jeremy Tammik, akn_include\n\nThe creation of a DirectShape element on an interactively selected existing element face requires a transformation to be applied to the face of a family instance returned by the PickObject method to convert it from the family symbol space to the family instance real world coordinates\n&ndash; Creating DirectShape from face mesh\n&ndash; Determining real world transform of a family instance face returned by PickObject\n&ndash; Iterating over element geometry to find a specific target geometry object\n&ndash; Reusing sketch planes for model curve creation...\n\n-->"
  },
  {
    "original_filename": "1355_directshape_face",
    "header_text": "DirectShape From Face and Sketch Plane Reuse",
    "local_header_href": "#directshape-from-face-and-sketch-plane-reuse",
    "chunk_text": "### DirectShape From Face and Sketch Plane Reuse\n\nFrode Tørresdal of [Norconsult Informasjonssystemer AS](https://www.nois.no) just raised an interesting issue regarding the creation of a DirectShape element on an interactively selected existing element face.\n\nAs it turned out, his specific issue was not related to the DirectShape creation at all, but rather to the transformation that needs to be applied to the face of a family instance returned by the PickObject method to convert it from the family symbol space to the family instance real world coordinates.\n\nHere is our discussion of the problem and the evolution of my\n[DirectShapeFromFace](https://github.com/jeremytammik/DirectShapeFromFace) solution that I implemented to address this.\n\nIt ends up demonstrating several interesting aspects:\n\n- [Creating a DirectShape element from a face mesh](#2)\n- [Determining the real world transform of a family instance face returned by PickObject](#3)\n- [Iterating over element geometry to find a specific target geometry object](#4)\n- [Reusing sketch planes for model curve creation](#5)\n- [Complete solution](#6)\n- [Download](#7)"
  },
  {
    "original_filename": "1355_directshape_face",
    "header_text": "<a name=\"2\"></a>Creating a DirectShape Element from a Face Mesh",
    "local_header_href": "#a-name2acreating-a-directshape-element-from-a-face-mesh",
    "chunk_text": "#### <a name=\"2\"></a>Creating a DirectShape Element from a Face Mesh\n\n**Question:**\nI have some issues when creating DirectShape elements in Revit. I attached a sample project and a Revit model:\n\n<center>\n<img src=\"img/faces_for_directshape.png\" alt=\"Faces for DirectShape\" width=\"376\"/>\n</center>\n\nThe sample project creates a DirectShape from a selected face.\n\nHere is the code:\n\n<pre class=\"code\">\n&nbsp; <span class=\"blue\">public</span> <span class=\"blue\">static</span> <span class=\"blue\">void</span> Execute1(\n&nbsp; &nbsp; <span class=\"teal\">ExternalCommandData</span> commandData )\n&nbsp; {\n&nbsp; &nbsp; <span class=\"teal\">Transaction</span> trans = <span class=\"blue\">null</span>;\n&nbsp;\n&nbsp; &nbsp; <span class=\"teal\">UIDocument</span> uidoc = commandData.Application\n&nbsp; &nbsp; &nbsp; .ActiveUIDocument;\n&nbsp;\n&nbsp; &nbsp; <span class=\"teal\">Document</span> doc = uidoc.Document;\n&nbsp;\n&nbsp; &nbsp; <span class=\"blue\">try</span>\n&nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; <span class=\"teal\">Selection</span> choices = uidoc.Selection;\n&nbsp;\n&nbsp; &nbsp; &nbsp; <span class=\"teal\">Reference</span> reference = choices.PickObject(\n&nbsp; &nbsp; &nbsp; &nbsp; <span class=\"teal\">ObjectType</span>.Face );\n&nbsp;\n&nbsp; &nbsp; &nbsp; <span class=\"teal\">Element</span> el = doc.GetElement(\n&nbsp; &nbsp; &nbsp; &nbsp; reference.ElementId );\n&nbsp;\n&nbsp; &nbsp; &nbsp; trans = <span class=\"blue\">new</span> <span class=\"teal\">Transaction</span>( doc, <span class=\"maroon\">&quot;Create elements&quot;</span> );\n&nbsp; &nbsp; &nbsp; trans.Start();\n&nbsp;\n&nbsp; &nbsp; &nbsp; <span class=\"teal\">TessellatedShapeBuilder</span> builder\n&nbsp; &nbsp; &nbsp; &nbsp; = <span class=\"blue\">new</span> <span class=\"teal\">TessellatedShapeBuilder</span>();\n&nbsp;\n&nbsp; &nbsp; &nbsp; builder.OpenConnectedFaceSet( <span class=\"blue\">false</span> );\n&nbsp;\n&nbsp; &nbsp; &nbsp; <span class=\"teal\">Face</span> face = el.GetGeometryObjectFromReference(\n&nbsp; &nbsp; &nbsp; &nbsp; reference ) <span class=\"blue\">as</span> <span class=\"teal\">Face</span>;\n&nbsp;\n&nbsp; &nbsp; &nbsp; <span class=\"teal\">Mesh</span> mesh = face.Triangulate();\n&nbsp; &nbsp; &nbsp; <span class=\"teal\">List</span>&lt;<span class=\"teal\">XYZ</span>&gt; args = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">XYZ</span>&gt;( 3 );\n&nbsp;\n&nbsp; &nbsp; &nbsp; <span class=\"teal\">XYZ</span> offset = <span class=\"blue\">new</span> <span class=\"teal\">XYZ</span>();\n&nbsp; &nbsp; &nbsp; <span class=\"blue\">if</span>( el.Location <span class=\"blue\">is</span> <span class=\"teal\">LocationPoint</span> )\n&nbsp; &nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; &nbsp; <span class=\"teal\">LocationPoint</span> locationPoint = el.Location\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class=\"blue\">as</span> <span class=\"teal\">LocationPoint</span>;\n&nbsp; &nbsp; &nbsp; &nbsp; offset = locationPoint.Point;\n&nbsp; &nbsp; &nbsp; }\n&nbsp;\n&nbsp; &nbsp; &nbsp; <span class=\"blue\">for</span>( <span class=\"blue\">int</span> i = 0; i &lt; mesh.NumTriangles; i++ )\n&nbsp; &nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; &nbsp; <span class=\"teal\">MeshTriangle</span> triangle = mesh.get_Triangle(\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i );\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; <span class=\"teal\">XYZ</span> p1 = triangle.get_Vertex( 0 );\n&nbsp; &nbsp; &nbsp; &nbsp; <span class=\"teal\">XYZ</span> p2 = triangle.get_Vertex( 1 );\n&nbsp; &nbsp; &nbsp; &nbsp; <span class=\"teal\">XYZ</span> p3 = triangle.get_Vertex( 2 );\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; p1 = p1.Add( offset );\n&nbsp; &nbsp; &nbsp; &nbsp; p2 = p2.Add( offset );\n&nbsp; &nbsp; &nbsp; &nbsp; p3 = p3.Add( offset );\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; args.Clear();\n&nbsp; &nbsp; &nbsp; &nbsp; args.Add( p1 );\n&nbsp; &nbsp; &nbsp; &nbsp; args.Add( p2 );\n&nbsp; &nbsp; &nbsp; &nbsp; args.Add( p3 );\n&nbsp; &nbsp; &nbsp; &nbsp; <span class=\"teal\">TessellatedFace</span> tesseFace\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = <span class=\"blue\">new</span> <span class=\"teal\">TessellatedFace</span>( args,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class=\"teal\">ElementId</span>.InvalidElementId );\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; <span class=\"blue\">if</span>( builder.DoesFaceHaveEnoughLoopsAndVertices(\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tesseFace ) )\n&nbsp; &nbsp; &nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; builder.AddFace( tesseFace );\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; }\n&nbsp;\n&nbsp; &nbsp; &nbsp; builder.CloseConnectedFaceSet();\n&nbsp;\n&nbsp; &nbsp; &nbsp; <span class=\"teal\">TessellatedShapeBuilderResult</span> result\n&nbsp; &nbsp; &nbsp; &nbsp; = builder.Build(\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class=\"teal\">TessellatedShapeBuilderTarget</span>.AnyGeometry,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class=\"teal\">TessellatedShapeBuilderFallback</span>.Mesh,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class=\"teal\">ElementId</span>.InvalidElementId );\n&nbsp;\n&nbsp; &nbsp; &nbsp; <span class=\"teal\">ElementId</span> categoryId = <span class=\"blue\">new</span> <span class=\"teal\">ElementId</span>(\n&nbsp; &nbsp; &nbsp; &nbsp; <span class=\"teal\">BuiltInCategory</span>.OST_GenericModel );\n&nbsp;\n&nbsp; &nbsp; &nbsp; <span class=\"teal\">DirectShape</span> ds = <span class=\"teal\">DirectShape</span>.CreateElement(\n&nbsp; &nbsp; &nbsp; &nbsp; doc, categoryId,\n&nbsp; &nbsp; &nbsp; &nbsp; <span class=\"teal\">Assembly</span>.GetExecutingAssembly().GetType()\n&nbsp; &nbsp; &nbsp; &nbsp; .GUID.ToString(), <span class=\"teal\">Guid</span>.NewGuid().ToString() );\n&nbsp;\n&nbsp; &nbsp; &nbsp; ds.SetShape( result.GetGeometricalObjects() );\n&nbsp;\n&nbsp; &nbsp; &nbsp; ds.Name = <span class=\"maroon\">&quot;MyShape&quot;</span>;\n&nbsp;\n&nbsp; &nbsp; &nbsp; trans.Commit();\n&nbsp; &nbsp; }\n&nbsp; &nbsp; <span class=\"blue\">catch</span>( <span class=\"teal\">Exception</span> ex )\n&nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; <span class=\"blue\">if</span>( trans != <span class=\"blue\">null</span> )\n&nbsp; &nbsp; &nbsp; &nbsp; trans.RollBack();\n&nbsp;\n&nbsp; &nbsp; &nbsp; <span class=\"teal\">Debug</span>.Print( ex.Message );\n&nbsp; &nbsp; }\n&nbsp; }\n</pre>\n\nThe code works fine on the columns. I managed this by calculating an offset from the LocationPoint. But this unfortunately affects the big Generic Model. This Generic Model element has been moved and when I run the code on this object, the DirectShape is created in the wrong location. If I remove the lines that get the offset from the location point this works fine on the generic model, but not on the columns. How do I know when to use the offset? Is there a way to write code that works on both cases?\n\nAlso in this model there are two columns. The code works fine on one of them, but not the other. Why is that?\n\nI really hope you can help me with this!"
  },
  {
    "original_filename": "1355_directshape_face",
    "header_text": "<a name=\"3\"></a>Determining the Real World Transform of a Family Instance Face returned by PickObject",
    "local_header_href": "#a-name3adetermining-the-real-world-transform-of-a-family-instance-face-returned-by-pickobject",
    "chunk_text": "#### <a name=\"3\"></a>Determining the Real World Transform of a Family Instance Face returned by PickObject\n\n**Answer:**\nThank you for your interesting query and sample material.\n\nI compiled the add-in and can reproduce the behaviour you describe.\n\nIt looks to me as if you are not taking the translation of the selected element properly into account.\n\nJust like you, I would have expected the GetGeometryObjectFromReference method to do that automatically for me.\n\nMaybe it will work better and work for all types of elements if you use a different approach to retrieve the geometry.\n\nFor family instances, there is a difference between symbol geometry and the translated family instance geometry.\n\nI have made good experiences using the GeometryElement.GetTransformed method and passing in an identity transform to retrieve element geometry in its real world location.\n\nYou can possibly use the geometry reference returned by the pick operation to select the same face from the element geometry with the option ComputeReferences turned on.\n\nAnother, more pertinent question:\n\nAre you sure this is an issue with the DirectShape?\n\nI would have thought that it is more an issue of the geometry retrieval, and has nothing to do with the DirectShape creation.\n\nTherefore, I would suggest the following test of the intermediate results:\n\n1. Retrieve the three MeshTriangle vertices.\n2. Create a plane containing all three, and a sketch plane. For efficiency, we can cache and reuse already existing sketch planes.\n3. Draw three model lines representing the mesh triangle.\n\nThen you can see exactly what geometry is being returned.\n\nI cleaned up your sample a little bit to test that myself.\n\nI created the [DirectShapeFromFace GitHub repository](https://github.com/jeremytammik/DirectShapeFromFace) for it to keep track of my modifications.\n\nYou might want to take a look at that in its current state, and maybe synchronise your sample with mine.\n\nI have not finished yet, though, and am still working on it.\n\nI am sure we will find a perfect resolution for this.\n\n**Update:**\nI updated my sample code to create model lines displaying the original triangles obtained from the element geometry via the GetGeometryObjectFromReference method.\n\nLook at the new [release 2016.0.0.1](https://github.com/jeremytammik/DirectShapeFromFace/releases/tag/2016.0.0.1).\n\nI can confirm that the mesh triangles are located in a different place than the original element.\n\nThere is certainly a really simple solution to this.\n\nIn any case, the problem has nothing to do with the DirectShape creation, just with the geometry retrieval.\n\nI have seen and handled similar issues in the past, when traversing element geometry for various export processes.\n\nIn those cases, I was using geometry retrieved from the `Element.get_Geometry` property instead of the `GetGeometryObjectFromReference` method.\n\nI therefore know how this issue can be handled.\n\nI would still like to learn what the optimal, simplest and most efficient approach really is.\n\nThe Revit API often moves in mysterious ways...\n\n**Question simplified:**\nThe following geometry retrieval returns a face in a different project location that the original selected element:\n\n<pre class=\"code\">\n&nbsp; <span class=\"teal\">Selection</span> choices = uidoc.Selection;\n&nbsp;\n&nbsp; <span class=\"teal\">Reference</span> reference = choices.PickObject(\n&nbsp; &nbsp; <span class=\"teal\">ObjectType</span>.Face );\n&nbsp;\n&nbsp; <span class=\"teal\">Element</span> el = doc.GetElement(\n&nbsp; &nbsp; reference.ElementId );\n&nbsp;\n&nbsp; <span class=\"teal\">Face</span> face = el.GetGeometryObjectFromReference(\n&nbsp; &nbsp; reference ) <span class=\"blue\">as</span> <span class=\"teal\">Face</span>;\n</pre>\n\nWhat is the proper and efficient way to obtain the face in the same location as the original selected element?\n\nThe face obtained as shown above is in an unexpected location, often far away from the selected element.\n\nApparently, the problem is that `PickObject` returns a reference to a face, and that face may be in the symbol geometry, not the instance geometry.\n\nHow can I find the correct transformation to the instance geometry location?\n\nI tried applying `FamilyInstance.GetTransform` to it, to no avail.\n\nI also tried iterating through all the (possibly nested) element geometry instances to calculate the appropriate transform, but I cannot find any way to identify the face returned by PickObject.\n\nBoth the equality operator `==` and a comparison using the `Face.Reference` property always return false for all the faces that I find.\n\nVery mystifying.\n\n**Answer:**\nIt is possible that some families (and their representative geometry) are nested several levels deep, and you need all the transforms.\n\nYou should be able to compare references by the strings returned by the `ConvertToStableRepresentation` method.\n\nIt would be a nice enhancement to make `Reference.Equals` work in this manner.  Unfortunately, it does not currently do so.\n\n**Response:**\nThat really sounds quite bad.\n\n`FamilyInstance.GetTransform` works for some family instances and not for others.\n\nI would love that to work, then the problem would be almost resolved.\n\nOtherwise I have to resort to determining the transform myself.\n\nWhen a user calls `PickObject( ObjectType.Face )`, nothing is known except the resulting element id and reference to the face.\n\nAre you really telling me that at this point I have to:\n\n1. Check whether the element happens to be a family instance.\n2. If so, determine the selected face's ConvertToStableRepresentation string, iterate through all the geometry, possibly through several levels of nested family instances, keep track of all the transforms, find and identify the picked face by checking and comparing the ConvertToStableRepresentation string, use the result of that to decide at which point I need to stop traversing the geometry, exit the traversal when the target is found, put together the list of nested transforms in the proper manner, and finally apply the resulting total transform to the selected face?\n\nI think that should be packaged and provided by the API.\n\nCould you provide example code that implements this in the correct manner?\n\nI have tried to achieve this and not succeeded so far, e.g., like this:\n\n<pre class=\"code\">\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n<span class=\"gray\">///</span><span class=\"green\"> Determine the stack of transforms to apply to</span>\n<span class=\"gray\">///</span><span class=\"green\"> the given target geometry object to bring it</span>\n<span class=\"gray\">///</span><span class=\"green\"> to the proper location in the project coordinates.</span>\n<span class=\"gray\">///</span><span class=\"green\"> Unfortunetely, we have not found any way at all</span>\n<span class=\"gray\">///</span><span class=\"green\"> yet to identify the target object we are after.</span>\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n<span class=\"blue\">static</span> <span class=\"blue\">bool</span> GetTransformStackForObject(\n&nbsp; <span class=\"teal\">Stack</span>&lt;<span class=\"teal\">Transform</span>&gt; tstack,\n&nbsp; <span class=\"teal\">GeometryElement</span> geo,\n&nbsp; <span class=\"teal\">GeometryObject</span> targetObj,\n&nbsp; <span class=\"teal\">Reference</span> targetRef )\n{\n&nbsp; <span class=\"blue\">foreach</span>( <span class=\"teal\">GeometryObject</span> obj <span class=\"blue\">in</span> geo )\n&nbsp; {\n&nbsp; &nbsp; <span class=\"blue\">if</span>( obj == targetObj )\n&nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; <span class=\"blue\">return</span> <span class=\"blue\">true</span>;\n&nbsp; &nbsp; }\n&nbsp;\n&nbsp; &nbsp; <span class=\"teal\">GeometryInstance</span> gi = obj <span class=\"blue\">as</span> <span class=\"teal\">GeometryInstance</span>;\n&nbsp;\n&nbsp; &nbsp; <span class=\"blue\">if</span>( <span class=\"blue\">null</span> != gi )\n&nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; tstack.Push( gi.Transform );\n&nbsp; &nbsp; &nbsp; <span class=\"blue\">return</span> GetTransformStackForObject( tstack,\n&nbsp; &nbsp; &nbsp; &nbsp; gi.GetInstanceGeometry(), targetObj, targetRef );\n&nbsp; &nbsp; }\n&nbsp;\n&nbsp; &nbsp; <span class=\"teal\">Solid</span> solid = obj <span class=\"blue\">as</span> <span class=\"teal\">Solid</span>;\n&nbsp; &nbsp; <span class=\"blue\">if</span>( <span class=\"blue\">null</span> != solid )\n&nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; <span class=\"blue\">if</span>( 0 &lt; solid.Faces.Size )\n&nbsp; &nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; &nbsp; <span class=\"blue\">foreach</span>( <span class=\"teal\">Face</span> face <span class=\"blue\">in</span> solid.Faces )\n&nbsp; &nbsp; &nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class=\"blue\">if</span>( face == targetObj )\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class=\"blue\">return</span> <span class=\"blue\">true</span>;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class=\"blue\">if</span>( face.Reference == targetRef )\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class=\"blue\">return</span> <span class=\"blue\">true</span>;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; <span class=\"blue\">if</span>( 0 &lt; solid.Edges.Size )\n&nbsp; &nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; &nbsp; <span class=\"blue\">foreach</span>( <span class=\"teal\">Edge</span> edge <span class=\"blue\">in</span> solid.Edges )\n&nbsp; &nbsp; &nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class=\"blue\">if</span>( edge == targetObj )\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class=\"blue\">return</span> <span class=\"blue\">true</span>;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class=\"blue\">if</span>( edge.Reference == targetRef )\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class=\"blue\">return</span> <span class=\"blue\">true</span>;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n&nbsp; }\n&nbsp; <span class=\"blue\">return</span> <span class=\"blue\">false</span>;\n}\n</pre>\n\nThis code never found the target.\n\nMaybe it will if I use `ConvertToStableRepresentation`.\n\nStill, I would appreciate further input and confirmation before I continue in these struggles.\n\nI think 'PickObject( ObjectType.Face )' is pretty hard to use out of the box if it requires all these additional calculations...\n\n\n**Response 2:**\nAfter further testing, I still cannot identify the picked face within the element geometry in the manner suggested.\n\nHere are the relevant code snippets:\n\n<pre class=\"code\">\n&nbsp; <span class=\"teal\">Selection</span> choices = uidoc.Selection;\n&nbsp;\n&nbsp; <span class=\"teal\">Reference</span> faceref = choices.PickObject(\n&nbsp; &nbsp; <span class=\"teal\">ObjectType</span>.Face );\n&nbsp;\n&nbsp; <span class=\"blue\">string</span> rep = faceref\n&nbsp; &nbsp; .ConvertToStableRepresentation( doc );\n&nbsp;\n&nbsp; <span class=\"teal\">Debug</span>.Print( <span class=\"maroon\">&quot;Face reference picked: &quot;</span>\n&nbsp; &nbsp; + rep );\n&nbsp;\n&nbsp; <span class=\"teal\">Element</span> el = doc.GetElement(\n&nbsp; &nbsp; faceref.ElementId );\n\n...\n\n&nbsp; <span class=\"teal\">Transform</span> t = <span class=\"blue\">null</span>;\n&nbsp;\n&nbsp; <span class=\"teal\">Options</span> opt = <span class=\"blue\">new</span> <span class=\"teal\">Options</span>();\n&nbsp; opt.ComputeReferences = <span class=\"blue\">true</span>;\n&nbsp; <span class=\"teal\">GeometryElement</span> geo = el.get_Geometry( opt );\n&nbsp; <span class=\"teal\">Stack</span>&lt;<span class=\"teal\">Transform</span>&gt; tstack = <span class=\"blue\">new</span> <span class=\"teal\">Stack</span>&lt;<span class=\"teal\">Transform</span>&gt;();\n&nbsp;\n&nbsp; <span class=\"blue\">if</span>( GetTransformStackForObject( tstack, geo, doc, rep )\n&nbsp; &nbsp; &amp;&amp; 0 &lt; tstack.Count )\n&nbsp; {\n&nbsp; &nbsp; t = <span class=\"teal\">Transform</span>.Identity;\n&nbsp;\n&nbsp; &nbsp; <span class=\"blue\">while</span>( 0 &lt; tstack.Count )\n&nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; t *= tstack.Pop();\n&nbsp; &nbsp; }\n&nbsp; }\n\n...\n\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n<span class=\"gray\">///</span><span class=\"green\"> Determine the stack of transforms to apply to</span>\n<span class=\"gray\">///</span><span class=\"green\"> the given target geometry object to bring it</span>\n<span class=\"gray\">///</span><span class=\"green\"> to the proper location in the project coordinates.</span>\n<span class=\"gray\">///</span><span class=\"green\"> Unfortunetely, we have not found any way at all</span>\n<span class=\"gray\">///</span><span class=\"green\"> yet to identify the target object we are after.</span>\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n<span class=\"blue\">static</span> <span class=\"blue\">bool</span> GetTransformStackForObject(\n&nbsp; <span class=\"teal\">Stack</span>&lt;<span class=\"teal\">Transform</span>&gt; tstack,\n&nbsp; <span class=\"teal\">GeometryElement</span> geo,\n&nbsp; <span class=\"teal\">Document</span> doc,\n&nbsp; <span class=\"blue\">string</span> stable_representation )\n{\n&nbsp; <span class=\"blue\">foreach</span>( <span class=\"teal\">GeometryObject</span> obj <span class=\"blue\">in</span> geo )\n&nbsp; {\n&nbsp; &nbsp; <span class=\"teal\">GeometryInstance</span> gi = obj <span class=\"blue\">as</span> <span class=\"teal\">GeometryInstance</span>;\n&nbsp;\n&nbsp; &nbsp; <span class=\"blue\">if</span>( <span class=\"blue\">null</span> != gi )\n&nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; tstack.Push( gi.Transform );\n&nbsp;\n&nbsp; &nbsp; &nbsp; <span class=\"blue\">return</span> GetTransformStackForObject( tstack,\n&nbsp; &nbsp; &nbsp; &nbsp; gi.GetInstanceGeometry(), doc,\n&nbsp; &nbsp; &nbsp; &nbsp; stable_representation );\n&nbsp; &nbsp; }\n&nbsp;\n&nbsp; &nbsp; <span class=\"teal\">Solid</span> solid = obj <span class=\"blue\">as</span> <span class=\"teal\">Solid</span>;\n&nbsp;\n&nbsp; &nbsp; <span class=\"blue\">if</span>( <span class=\"blue\">null</span> != solid )\n&nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; <span class=\"blue\">string</span> rep;\n&nbsp;\n&nbsp; &nbsp; &nbsp; <span class=\"blue\">if</span>( 0 &lt; solid.Faces.Size )\n&nbsp; &nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; &nbsp; <span class=\"blue\">foreach</span>( <span class=\"teal\">Face</span> face <span class=\"blue\">in</span> solid.Faces )\n&nbsp; &nbsp; &nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rep = face.Reference\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .ConvertToStableRepresentation( doc );\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class=\"blue\">if</span>( rep.Equals( stable_representation ) )\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class=\"blue\">return</span> <span class=\"blue\">true</span>;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; <span class=\"blue\">if</span>( 0 &lt; solid.Edges.Size )\n&nbsp; &nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; &nbsp; <span class=\"blue\">foreach</span>( <span class=\"teal\">Edge</span> edge <span class=\"blue\">in</span> solid.Edges )\n&nbsp; &nbsp; &nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rep = edge.Reference\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .ConvertToStableRepresentation( doc );\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class=\"blue\">if</span>( rep.Equals( stable_representation ) )\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class=\"blue\">return</span> <span class=\"blue\">true</span>;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n&nbsp; }\n&nbsp; <span class=\"blue\">return</span> <span class=\"blue\">false</span>;\n}\n</pre>\n\nI tested this with a structural concrete rectangular column.\n\nAll the faces were visited, and none of them returned a `ConvertToStableRepresentation` string that matched the picked face's one."
  },
  {
    "original_filename": "1355_directshape_face",
    "header_text": "<a name=\"4\"></a>Iterating over Element Geometry to Find a Specific Target Geometry Object",
    "local_header_href": "#a-name4aiterating-over-element-geometry-to-find-a-specific-target-geometry-object",
    "chunk_text": "#### <a name=\"4\"></a>Iterating over Element Geometry to Find a Specific Target Geometry Object\n\n**Answer:**\nShort answer:\n\n`GetInstanceGeometry` is incorrect in extracting usable references &ndash; you must call `GetSymbolGeometry` with no arguments instead.\n\nThis should result in comparable stable references.\n\nMore details of instance transforms etc. are available in Scott Conover's AU courses and have been rolled into material that is in the Developer’s Guide in the Revit online help.\n\n**Response:**\nThank you!\n\nThat helped.\n\nIt seems to be working now, in [DirectShapeFromFace release 2016.0.0.5](https://github.com/jeremytammik/DirectShapeFromFace/releases/tag/2016.0.0.5):\n\n<center>\n<img src=\"img/direct_shape_from_face.png\" alt=\"DirectShape from face\" width=\"320\"/>\n</center>\n\nI am surprised it is so hard.\n\nThe sequence of prior attempts and tests is described by the preceding [release messages](https://github.com/jeremytammik/DirectShapeFromFace/releases).\n\nIt still needs to be tested with more samples, especially with faces nested several levels deep within nested families."
  },
  {
    "original_filename": "1355_directshape_face",
    "header_text": "<a name=\"5\"></a>Reusing Sketch Planes for Model Curve Creation",
    "local_header_href": "#a-name5areusing-sketch-planes-for-model-curve-creation",
    "chunk_text": "#### <a name=\"5\"></a>Reusing Sketch Planes for Model Curve Creation\n\nOne final cool implementation details to note:\n\nFor testing purposes, I create model lines representing the original face mesh triangles as well the final direct shape.\n\nThe model lines require a sketch plane to host them.\n\nTo avoid recreating hundreds and thousands of identical sketch planes for this purpose, I try to reuse the existing ones as much as possible.\n\nIn tried to limit the reuse to my own sketch planes and mark them by specifying their element name, but that does not work.\n\nThe always end up named \"&lt;not associated&gt;\".\n\nSo I modified my reusage algorithm to reuse only such sketch planes, and it seems to work fine, cf. the `SketchPlaneMatches` and `GetSketchPlane` methods below."
  },
  {
    "original_filename": "1355_directshape_face",
    "header_text": "<a name=\"6\"></a>Complete Solution",
    "local_header_href": "#a-name6acomplete-solution",
    "chunk_text": "#### <a name=\"6\"></a>Complete Solution\n\nTo wrap up, here is the complete code implementing this:\n\n<pre class=\"code\">\n<span class=\"blue\">class</span> <span class=\"teal\">CreateDirectShape</span>\n{\n&nbsp; <span class=\"blue\">const</span> <span class=\"blue\">string</span> _sketch_plane_name_prefix\n&nbsp; &nbsp; = <span class=\"maroon\">&quot;The Building Coder&quot;</span>;\n&nbsp;\n&nbsp; <span class=\"blue\">const</span> <span class=\"blue\">string</span> _sketch_plane_name_prefix2\n&nbsp; &nbsp; = <span class=\"maroon\">&quot;&lt;not associated&gt;&quot;</span>;\n&nbsp;\n<span class=\"blue\">&nbsp; #region</span> Geometrical Comparison\n&nbsp; <span class=\"blue\">const</span> <span class=\"blue\">double</span> _eps = 1.0e-9;\n&nbsp;\n&nbsp; <span class=\"blue\">public</span> <span class=\"blue\">static</span> <span class=\"blue\">bool</span> IsAlmostZero(\n&nbsp; &nbsp; <span class=\"blue\">double</span> a,\n&nbsp; &nbsp; <span class=\"blue\">double</span> tolerance )\n&nbsp; {\n&nbsp; &nbsp; <span class=\"blue\">return</span> tolerance &gt; <span class=\"teal\">Math</span>.Abs( a );\n&nbsp; }\n&nbsp;\n&nbsp; <span class=\"blue\">public</span> <span class=\"blue\">static</span> <span class=\"blue\">bool</span> IsAlmostZero( <span class=\"blue\">double</span> a )\n&nbsp; {\n&nbsp; &nbsp; <span class=\"blue\">return</span> IsAlmostZero( a, _eps );\n&nbsp; }\n&nbsp;\n&nbsp; <span class=\"blue\">public</span> <span class=\"blue\">static</span> <span class=\"blue\">bool</span> IsAlmostEqual( <span class=\"blue\">double</span> a, <span class=\"blue\">double</span> b )\n&nbsp; {\n&nbsp; &nbsp; <span class=\"blue\">return</span> IsAlmostZero( b - a );\n&nbsp; }\n<span class=\"blue\">&nbsp; #endregion</span> <span class=\"green\">// Geometrical Comparison</span>\n&nbsp;\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> Return the normal of a plane&nbsp; </span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> spanned by the two given vectors.</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n&nbsp; <span class=\"blue\">static</span> <span class=\"teal\">XYZ</span> GetNormal( <span class=\"teal\">XYZ</span> v1, <span class=\"teal\">XYZ</span> v2 )\n&nbsp; {\n&nbsp; &nbsp; <span class=\"blue\">return</span> v1\n&nbsp; &nbsp; &nbsp; .CrossProduct( v2 )\n&nbsp; &nbsp; &nbsp; .Normalize();\n&nbsp; }\n&nbsp;\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> Return the normal of a plane spanned by the</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> three given triangle corner points.</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n&nbsp; <span class=\"blue\">static</span> <span class=\"teal\">XYZ</span> GetNormal( <span class=\"teal\">XYZ</span>[] triangleCorners )\n&nbsp; {\n&nbsp; &nbsp; <span class=\"blue\">return</span> GetNormal(\n&nbsp; &nbsp; &nbsp; triangleCorners[1] - triangleCorners[0],\n&nbsp; &nbsp; &nbsp; triangleCorners[2] - triangleCorners[0] );\n&nbsp; }\n&nbsp;\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> Return signed distance from plane to a given point.</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n&nbsp; <span class=\"blue\">public</span> <span class=\"blue\">static</span> <span class=\"blue\">double</span> SignedDistanceTo(\n&nbsp; &nbsp; <span class=\"teal\">Plane</span> plane,\n&nbsp; &nbsp; <span class=\"teal\">XYZ</span> p )\n&nbsp; {\n&nbsp; &nbsp; <span class=\"teal\">Debug</span>.Assert(\n&nbsp; &nbsp; &nbsp; IsAlmostEqual( plane.Normal.GetLength(), 1 ),\n&nbsp; &nbsp; &nbsp; &nbsp; <span class=\"maroon\">&quot;expected normalised plane normal&quot;</span> );\n&nbsp;\n&nbsp; &nbsp; <span class=\"teal\">XYZ</span> v = p - plane.Origin;\n&nbsp;\n&nbsp; &nbsp; <span class=\"blue\">return</span> plane.Normal.DotProduct( v );\n&nbsp; }\n&nbsp;\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> Return true if the sketch plane belongs to us</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> and its origin and normal vector match the </span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> given targets.</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> Nope, we are unable to set the sketch plane </span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> name. However, Revit throws an exception if </span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> we try to draw on the skatch plane named</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> 'Level 1', so lets ensure we use '</span><span class=\"gray\">&lt;not </span>\n&nbsp; <span class=\"gray\">/// associated&gt;</span><span class=\"green\">'.</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n&nbsp; <span class=\"blue\">static</span> <span class=\"blue\">bool</span> SketchPlaneMatches(\n&nbsp; &nbsp; <span class=\"teal\">SketchPlane</span> sketchPlane,\n&nbsp; &nbsp; <span class=\"teal\">XYZ</span> origin,\n&nbsp; &nbsp; <span class=\"teal\">XYZ</span> normal )\n&nbsp; {\n&nbsp; &nbsp; <span class=\"green\">//bool rc = sketchPlane.Name.StartsWith(</span>\n&nbsp; &nbsp; <span class=\"green\">//&nbsp; _sketch_plane_name_prefix );</span>\n&nbsp;\n&nbsp; &nbsp; <span class=\"blue\">bool</span> rc = sketchPlane.Name.Equals(\n&nbsp; &nbsp; &nbsp; _sketch_plane_name_prefix2 );\n&nbsp;\n&nbsp; &nbsp; <span class=\"blue\">if</span>( rc )\n&nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; <span class=\"teal\">Plane</span> plane = sketchPlane.GetPlane();\n&nbsp;\n&nbsp; &nbsp; &nbsp; rc = plane.Normal.IsAlmostEqualTo( normal )\n&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; IsAlmostZero( SignedDistanceTo(\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plane, origin ) );\n&nbsp; &nbsp; }\n&nbsp; &nbsp; <span class=\"blue\">return</span> rc;\n&nbsp; }\n&nbsp;\n&nbsp; <span class=\"blue\">static</span> <span class=\"blue\">int</span> _sketch_plane_creation_counter = 0;\n&nbsp;\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> Return a sketch plane through the given origin</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> point with the given normal, either by creating</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> a new one or reusing an existing one.</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n&nbsp; <span class=\"blue\">static</span> <span class=\"teal\">SketchPlane</span> GetSketchPlane(\n&nbsp; &nbsp; <span class=\"teal\">Document</span> doc,\n&nbsp; &nbsp; <span class=\"teal\">XYZ</span> origin,\n&nbsp; &nbsp; <span class=\"teal\">XYZ</span> normal )\n&nbsp; {\n&nbsp; &nbsp; <span class=\"blue\">string</span> s = <span class=\"maroon\">&quot;reusing&quot;</span>;\n&nbsp;\n&nbsp; &nbsp; <span class=\"green\">// If we could reliably set the sketch plane Name</span>\n&nbsp; &nbsp; <span class=\"green\">// property or find some other relaible marker </span>\n&nbsp; &nbsp; <span class=\"green\">// that is reflected in a parameter, we could </span>\n&nbsp; &nbsp; <span class=\"green\">// replace the sketchPlane.Name.Equals check in</span>\n&nbsp; &nbsp; <span class=\"green\">// SketchPlaneMatches by a parameter filter in</span>\n&nbsp; &nbsp; <span class=\"green\">// the filtered element collector framework</span>\n&nbsp; &nbsp; <span class=\"green\">// to move the test into native Revit code </span>\n&nbsp; &nbsp; <span class=\"green\">// instead of post-processing in .NET, which</span>\n&nbsp; &nbsp; <span class=\"green\">// would give a 50% performance enhancement.</span>\n&nbsp;\n&nbsp; &nbsp; <span class=\"teal\">SketchPlane</span> sketchPlane\n&nbsp; &nbsp; &nbsp; = <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( doc )\n&nbsp; &nbsp; &nbsp; &nbsp; .OfClass( <span class=\"blue\">typeof</span>( <span class=\"teal\">SketchPlane</span> ) )\n&nbsp; &nbsp; &nbsp; &nbsp; .Cast&lt;<span class=\"teal\">SketchPlane</span>&gt;()\n&nbsp; &nbsp; &nbsp; &nbsp; .FirstOrDefault&lt;<span class=\"teal\">SketchPlane</span>&gt;( x =&gt;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SketchPlaneMatches( x, origin, normal ) );\n&nbsp;\n&nbsp; &nbsp; <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == sketchPlane )\n&nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; <span class=\"teal\">Plane</span> plane = <span class=\"blue\">new</span> <span class=\"teal\">Plane</span>( normal, origin );\n&nbsp;\n&nbsp; &nbsp; &nbsp; sketchPlane = <span class=\"teal\">SketchPlane</span>.Create( doc, plane );\n&nbsp;\n&nbsp; &nbsp; &nbsp; <span class=\"green\">//sketchPlane.Name = string.Format(</span>\n&nbsp; &nbsp; &nbsp; <span class=\"green\">//&nbsp; &quot;{0} {1}&quot;, _sketch_plane_name_prefix,</span>\n&nbsp; &nbsp; &nbsp; <span class=\"green\">//&nbsp; _sketch_plane_creation_counter++ );</span>\n&nbsp;\n&nbsp; &nbsp; &nbsp; ++_sketch_plane_creation_counter;\n&nbsp;\n&nbsp; &nbsp; &nbsp; s = <span class=\"maroon\">&quot;created&quot;</span>;\n&nbsp; &nbsp; }\n&nbsp; &nbsp; <span class=\"teal\">Debug</span>.Print( <span class=\"maroon\">&quot;GetSketchPlane: {0} '{1}' ({2})&quot;</span>,\n&nbsp; &nbsp; &nbsp; s, sketchPlane.Name,\n&nbsp; &nbsp; &nbsp; _sketch_plane_creation_counter );\n&nbsp;\n&nbsp; &nbsp; <span class=\"blue\">return</span> sketchPlane;\n&nbsp; }\n&nbsp;\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> Create model lines representing a closed </span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> planar loop in the given sketch plane.</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n&nbsp; <span class=\"blue\">static</span> <span class=\"blue\">void</span> DrawModelLineLoop(\n&nbsp; &nbsp; <span class=\"teal\">SketchPlane</span> sketchPlane,\n&nbsp; &nbsp; <span class=\"teal\">XYZ</span>[] corners )\n&nbsp; {\n&nbsp; &nbsp; Autodesk.Revit.Creation.<span class=\"teal\">Document</span> factory\n&nbsp; &nbsp; &nbsp; = sketchPlane.Document.Create;\n&nbsp;\n&nbsp; &nbsp; <span class=\"blue\">int</span> n = corners.GetLength( 0 );\n&nbsp;\n&nbsp; &nbsp; <span class=\"blue\">for</span>( <span class=\"blue\">int</span> i = 0; i &lt; n; ++i )\n&nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; <span class=\"blue\">int</span> j = 0 == i ? n - 1 : i - 1;\n&nbsp;\n&nbsp; &nbsp; &nbsp; factory.NewModelCurve( <span class=\"teal\">Line</span>.CreateBound(\n&nbsp; &nbsp; &nbsp; &nbsp; corners[j], corners[i] ), sketchPlane );\n&nbsp; &nbsp; }\n&nbsp; }\n&nbsp;\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> Determine the stack of transforms to apply to </span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> the given target geometry object to bring it </span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> to the proper location in the project coordinates.</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> Unfortunetely, we have not found any way at all </span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> yet to identify the target object we are after.</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n&nbsp; <span class=\"blue\">static</span> <span class=\"blue\">bool</span> GetTransformStackForObject(\n&nbsp; &nbsp; <span class=\"teal\">Stack</span>&lt;<span class=\"teal\">Transform</span>&gt; tstack,\n&nbsp; &nbsp; <span class=\"teal\">GeometryElement</span> geo,\n&nbsp; &nbsp; <span class=\"teal\">Document</span> doc,\n&nbsp; &nbsp; <span class=\"blue\">string</span> stable_representation )\n&nbsp; {\n&nbsp; &nbsp; <span class=\"teal\">Debug</span>.Print( <span class=\"maroon\">&quot;enter GetTransformStackForObject &quot;</span>\n&nbsp; &nbsp; &nbsp; + <span class=\"maroon\">&quot;with tstack count {0}&quot;</span>, tstack.Count );\n&nbsp;\n&nbsp; &nbsp; <span class=\"blue\">bool</span> found = <span class=\"blue\">false</span>;\n&nbsp;\n&nbsp; &nbsp; <span class=\"blue\">foreach</span>( <span class=\"teal\">GeometryObject</span> obj <span class=\"blue\">in</span> geo )\n&nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; <span class=\"teal\">GeometryInstance</span> gi = obj <span class=\"blue\">as</span> <span class=\"teal\">GeometryInstance</span>;\n&nbsp;\n&nbsp; &nbsp; &nbsp; <span class=\"blue\">if</span>( <span class=\"blue\">null</span> != gi )\n&nbsp; &nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; &nbsp; tstack.Push( gi.Transform );\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; found = GetTransformStackForObject( tstack,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gi.GetSymbolGeometry(), doc,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stable_representation );\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; <span class=\"blue\">if</span>( found ) { <span class=\"blue\">return</span> found; }\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; tstack.Pop();\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; <span class=\"blue\">continue</span>;\n&nbsp; &nbsp; &nbsp; }\n&nbsp;\n&nbsp; &nbsp; &nbsp; <span class=\"teal\">Solid</span> solid = obj <span class=\"blue\">as</span> <span class=\"teal\">Solid</span>;\n&nbsp;\n&nbsp; &nbsp; &nbsp; <span class=\"blue\">if</span>( <span class=\"blue\">null</span> != solid )\n&nbsp; &nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; &nbsp; <span class=\"blue\">string</span> rep;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; <span class=\"blue\">bool</span> isFace = stable_representation.EndsWith(\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class=\"maroon\">&quot;SURFACE&quot;</span> );\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; <span class=\"blue\">bool</span> isEdge = stable_representation.EndsWith(\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class=\"maroon\">&quot;LINEAR&quot;</span> );\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; <span class=\"teal\">Debug</span>.Assert( isFace || isEdge,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class=\"maroon\">&quot;GetTransformStackForObject currently only supports faces and edges&quot;</span> );\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; <span class=\"blue\">if</span>( isFace &amp;&amp; 0 &lt; solid.Faces.Size )\n&nbsp; &nbsp; &nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class=\"blue\">foreach</span>( <span class=\"teal\">Face</span> face <span class=\"blue\">in</span> solid.Faces )\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rep = face.Reference\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .ConvertToStableRepresentation( doc );\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class=\"blue\">if</span>( rep.Equals( stable_representation ) )\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class=\"blue\">return</span> <span class=\"blue\">true</span>;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; <span class=\"blue\">if</span>( isEdge &amp;&amp; 0 &lt; solid.Edges.Size )\n&nbsp; &nbsp; &nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class=\"blue\">foreach</span>( <span class=\"teal\">Edge</span> edge <span class=\"blue\">in</span> solid.Edges )\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rep = edge.Reference\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .ConvertToStableRepresentation( doc );\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class=\"blue\">if</span>( rep.Equals( stable_representation ) )\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class=\"blue\">return</span> <span class=\"blue\">true</span>;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n&nbsp; &nbsp; <span class=\"blue\">return</span> <span class=\"blue\">false</span>;\n&nbsp; }\n&nbsp;\n&nbsp; <span class=\"blue\">public</span> <span class=\"blue\">static</span> <span class=\"blue\">void</span> Execute(\n&nbsp; &nbsp; <span class=\"teal\">ExternalCommandData</span> commandData )\n&nbsp; {\n&nbsp; &nbsp; <span class=\"teal\">Transaction</span> trans = <span class=\"blue\">null</span>;\n&nbsp;\n&nbsp; &nbsp; <span class=\"teal\">UIApplication</span> uiapp = commandData.Application;\n&nbsp; &nbsp; <span class=\"teal\">UIDocument</span> uidoc = uiapp.ActiveUIDocument;\n&nbsp; &nbsp; <span class=\"teal\">Document</span> doc = uidoc.Document;\n&nbsp;\n&nbsp; &nbsp; <span class=\"blue\">try</span>\n&nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; <span class=\"teal\">Selection</span> choices = uidoc.Selection;\n&nbsp;\n&nbsp; &nbsp; &nbsp; <span class=\"teal\">Reference</span> faceref = choices.PickObject(\n&nbsp; &nbsp; &nbsp; &nbsp; <span class=\"teal\">ObjectType</span>.Face );\n&nbsp;\n&nbsp; &nbsp; &nbsp; <span class=\"blue\">string</span> rep = faceref\n&nbsp; &nbsp; &nbsp; &nbsp; .ConvertToStableRepresentation( doc );\n&nbsp;\n&nbsp; &nbsp; &nbsp; <span class=\"teal\">Debug</span>.Assert( rep.EndsWith( <span class=\"maroon\">&quot;:SURFACE&quot;</span> ),\n&nbsp; &nbsp; &nbsp; &nbsp; <span class=\"maroon\">&quot;expected stable representation to end with SURFACE&quot;</span> );\n&nbsp;\n&nbsp; &nbsp; &nbsp; <span class=\"teal\">Debug</span>.Print( <span class=\"maroon\">&quot;Face reference picked: &quot;</span>\n&nbsp; &nbsp; &nbsp; &nbsp; + rep );\n&nbsp;\n&nbsp; &nbsp; &nbsp; <span class=\"teal\">Element</span> el = doc.GetElement(\n&nbsp; &nbsp; &nbsp; &nbsp; faceref.ElementId );\n&nbsp;\n&nbsp; &nbsp; &nbsp; <span class=\"blue\">using</span>( trans = <span class=\"blue\">new</span> <span class=\"teal\">Transaction</span>( doc ) )\n&nbsp; &nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; &nbsp; trans.Start( <span class=\"maroon\">&quot;Create elements&quot;</span> );\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; <span class=\"teal\">TessellatedShapeBuilder</span> builder\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = <span class=\"blue\">new</span> <span class=\"teal\">TessellatedShapeBuilder</span>();\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; builder.OpenConnectedFaceSet( <span class=\"blue\">false</span> );\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; <span class=\"green\">// This may return a face in the family </span>\n&nbsp; &nbsp; &nbsp; &nbsp; <span class=\"green\">// symbol definition with no family instance </span>\n&nbsp; &nbsp; &nbsp; &nbsp; <span class=\"green\">// transform applied. Use the GeometryElement</span>\n&nbsp; &nbsp; &nbsp; &nbsp; <span class=\"green\">// GetTransformed method to retrieve the face </span>\n&nbsp; &nbsp; &nbsp; &nbsp; <span class=\"green\">// with the instance transformation applied.</span>\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; <span class=\"teal\">Face</span> face = el.GetGeometryObjectFromReference(\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; faceref ) <span class=\"blue\">as</span> <span class=\"teal\">Face</span>;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; <span class=\"teal\">Debug</span>.Print( <span class=\"maroon\">&quot;Face reference property: &quot;</span>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; + ( ( <span class=\"blue\">null</span> == face.Reference )\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ? <span class=\"maroon\">&quot;&lt;nil&gt;&quot;</span>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; : face.Reference.ConvertToStableRepresentation( doc ) ) );\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; <span class=\"teal\">Transform</span> t = <span class=\"blue\">null</span>;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; <span class=\"teal\">FamilyInstance</span> fi = el <span class=\"blue\">as</span> <span class=\"teal\">FamilyInstance</span>;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; <span class=\"blue\">if</span>( <span class=\"blue\">null</span> != fi )\n&nbsp; &nbsp; &nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class=\"green\">// Will this handle a face selected</span>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class=\"green\">// in a nested family instance?</span>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class=\"green\">// Some, yes, but not all.</span>\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class=\"green\">//t = fi.GetTransform();</span>\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class=\"green\">// This also works for some instances</span>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class=\"green\">// but not all.</span>\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class=\"green\">//Transform t1 = fi.GetTotalTransform();</span>\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class=\"teal\">Options</span> opt = <span class=\"blue\">new</span> <span class=\"teal\">Options</span>();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opt.ComputeReferences = <span class=\"blue\">true</span>;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class=\"teal\">GeometryElement</span> geo = el.get_Geometry( opt );\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class=\"teal\">GeometryElement</span> geo2 = geo.GetTransformed(\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class=\"teal\">Transform</span>.Identity );\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class=\"teal\">Stack</span>&lt;<span class=\"teal\">Transform</span>&gt; tstack\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = <span class=\"blue\">new</span> <span class=\"teal\">Stack</span>&lt;<span class=\"teal\">Transform</span>&gt;();\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class=\"blue\">if</span>( GetTransformStackForObject( tstack,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; geo, doc, rep ) &amp;&amp; 0 &lt; tstack.Count )\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class=\"teal\">Debug</span>.Print( <span class=\"maroon\">&quot;GetTransformStackForObject &quot;</span>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; + <span class=\"maroon\">&quot;returned true with tstack count {0}&quot;</span>,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tstack.Count );\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; t = <span class=\"teal\">Transform</span>.Identity;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class=\"blue\">while</span>( 0 &lt; tstack.Count )\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; t *= tstack.Pop();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; <span class=\"teal\">Mesh</span> mesh = face.Triangulate();\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; <span class=\"blue\">if</span>( <span class=\"blue\">null</span> != t )\n&nbsp; &nbsp; &nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mesh = mesh.get_Transformed( t );\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; <span class=\"teal\">XYZ</span>[] triangleCorners = <span class=\"blue\">new</span> <span class=\"teal\">XYZ</span>[3];\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; <span class=\"blue\">for</span>( <span class=\"blue\">int</span> i = 0; i &lt; mesh.NumTriangles; i++ )\n&nbsp; &nbsp; &nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class=\"teal\">MeshTriangle</span> triangle = mesh.get_Triangle( i );\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; triangleCorners[0] = triangle.get_Vertex( 0 );\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; triangleCorners[1] = triangle.get_Vertex( 1 );\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; triangleCorners[2] = triangle.get_Vertex( 2 );\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class=\"teal\">XYZ</span> normal = GetNormal( triangleCorners );\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class=\"teal\">SketchPlane</span> sketchPlane = GetSketchPlane(\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; doc, triangleCorners[0], normal );\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DrawModelLineLoop( sketchPlane, triangleCorners );\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class=\"teal\">TessellatedFace</span> tesseFace\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = <span class=\"blue\">new</span> <span class=\"teal\">TessellatedFace</span>( triangleCorners,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class=\"teal\">ElementId</span>.InvalidElementId );\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class=\"blue\">if</span>( builder.DoesFaceHaveEnoughLoopsAndVertices(\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tesseFace ) )\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; builder.AddFace( tesseFace );\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; builder.CloseConnectedFaceSet();\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; <span class=\"teal\">TessellatedShapeBuilderResult</span> result\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = builder.Build(\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class=\"teal\">TessellatedShapeBuilderTarget</span>.AnyGeometry,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class=\"teal\">TessellatedShapeBuilderFallback</span>.Mesh,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class=\"teal\">ElementId</span>.InvalidElementId );\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; <span class=\"teal\">ElementId</span> categoryId = <span class=\"blue\">new</span> <span class=\"teal\">ElementId</span>(\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class=\"teal\">BuiltInCategory</span>.OST_GenericModel );\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; <span class=\"teal\">DirectShape</span> ds = <span class=\"teal\">DirectShape</span>.CreateElement(\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; doc, categoryId,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class=\"teal\">Assembly</span>.GetExecutingAssembly().GetType().GUID.ToString(),\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class=\"teal\">Guid</span>.NewGuid().ToString() );\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; ds.SetShape( result.GetGeometricalObjects() );\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; ds.Name = <span class=\"maroon\">&quot;MyShape&quot;</span>;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; trans.Commit();\n&nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n&nbsp; &nbsp; <span class=\"blue\">catch</span>( <span class=\"teal\">Exception</span> ex )\n&nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; <span class=\"teal\">TaskDialog</span>.Show( <span class=\"maroon\">&quot;Error&quot;</span>, ex.Message );\n&nbsp; &nbsp; }\n&nbsp; }\n}\n</pre>"
  },
  {
    "original_filename": "1355_directshape_face",
    "header_text": "<a name=\"7\"></a>Download",
    "local_header_href": "#a-name7adownload",
    "chunk_text": "#### <a name=\"7\"></a>Download\n\nThe most up-to-date version, complete Visual Studio solution and add-in manifest is provided by the\n[DirectShapeFromFace GitHub repository](https://github.com/jeremytammik/DirectShapeFromFace).\n\nThe version discussed here is\n[release 2016.0.0.9](https://github.com/jeremytammik/DirectShapeFromFace/releases/tag/2016.0.0.9)\n\nI hope you find this as interesting and useful as I do.\n\nMany thanks to Frode for raising the issue and providing the original code to create the DirectShape element."
  }
]