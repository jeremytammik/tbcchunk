[
  {
    "original_filename": "0098_booleans_on_polygons",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<style>\n.blue { color: blue; }\n.teal { color: teal; }\n.maroon { color: maroon; }\n.green { color: green; }\n</style>"
  },
  {
    "original_filename": "0098_booleans_on_polygons",
    "header_text": "Boolean Operations for 2D Polygons",
    "local_header_href": "#boolean-operations-for-2d-polygons",
    "chunk_text": "<h3>Boolean Operations for 2D Polygons</h3><p>Friday the thirteenth! What has gone wrong so far today? Keeping my fingers crossed ...</p><p>We recently discussed the issue of determining the\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2009/01/room-and-wall-adjacent-area.html\">\nwall area adjacent to a room</a>\n\nand mentioned the fact that the simplest way to calculate such an overlapping area might be the use of a free-standing library for performing Boolean set operations on two-dimensional polygons.\nAs said, there are many such libraries available, as you can see by googling for \"polygon boolean\" or by looking at the Wikipedia article on\n\n<a href=\"http://en.wikipedia.org/wiki/Boolean_operations_on_polygons\">\nBoolean operations on polygons</a>.\n\nI suggested possibly using the\n\n<a href=\"http://www.cs.man.ac.uk/~toby/alan/software\">\nGeneric Polygon Clipper (gpc)</a>\n\nand its C# wrapper GpcWrapper.\nNow my colleague Adam Nagy\n– the\n\n<a href=\"http://www.geocities.com/nagy_name/nagy-name-pronunciations.html\">\npronunciation</a>\n\nis 'nadj', according to Adam, and an interesting topic in itself –\n\nwent ahead and wrote a sample application demonstrating the use of this tool in a Revit add-in.\n\n<p>Adam's sample application is named GpcNET.\nIt defines an external command within the namespace GpcNET.\nIt also includes the GpcWrapper code in the same namespace, so that all its classes are immediately available to the command class.</p>\n<p>You need to select two floors before running the command.\nIf not, it will prompt you to do so and abort.\nThe two floors are used to define a two-dimensional polygon each.\nThe intersection of the two polygons is computed.\nIf the result is a valid polygon, a new third floor is created.\nIt uses the intersection result to define its profile CurveArray, and the same floor type and level as the first selected floor.</p>\n<p>Here is the code that extracts the profile from a selected floor and creates a GPC polygon object from it:</p>\n<pre class=\"code\">\n<span class=\"teal\">Polygon</span> getPolygon( <span class=\"teal\">Floor</span> floor )\n{\n  <span class=\"teal\">Options</span> geomOptions\n    = app.Create.NewGeometryOptions();\n \n  <span class=\"teal\">GeoElement</span> elem\n    = floor.get_Geometry( geomOptions );\n \n  <span class=\"teal\">List</span>&lt;<span class=\"teal\">Vertex</span>&gt; vertices = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">Vertex</span>&gt;();\n \n  <span class=\"blue\">foreach</span>( <span class=\"blue\">object</span> obj <span class=\"blue\">in</span> elem.Objects )\n  {\n    <span class=\"teal\">Solid</span> solid = obj <span class=\"blue\">as</span> <span class=\"teal\">Solid</span>;\n    <span class=\"blue\">if</span>( <span class=\"blue\">null</span> != solid )\n    {\n      <span class=\"teal\">Face</span> face = solid.Faces.get_Item( 0 );\n      <span class=\"teal\">EdgeArray</span> loop = face.EdgeLoops.get_Item( 0 );\n      <span class=\"blue\">foreach</span>( <span class=\"teal\">Edge</span> edge <span class=\"blue\">in</span> loop )\n      {\n        <span class=\"teal\">XYZArray</span> edgePts = edge.Tessellate();\n        <span class=\"blue\">int</span> n = edgePts.Size;\n        <span class=\"blue\">for</span>( <span class=\"blue\">int</span> i = 0; i &lt; n - 1; ++i )\n        {\n          <span class=\"teal\">XYZ</span> p = edgePts.get_Item( i );\n          vertices.Add( <span class=\"blue\">new</span> <span class=\"teal\">Vertex</span>( p.X, p.Y ) );\n        }\n      }\n      <span class=\"blue\">break</span>;\n    }\n  }\n  <span class=\"teal\">VertexList</span> vertexList = <span class=\"blue\">new</span> <span class=\"teal\">VertexList</span>();\n  vertexList.NofVertices = vertices.Count;\n  vertexList.Vertex = vertices.ToArray();\n  <span class=\"teal\">Polygon</span> poly = <span class=\"blue\">new</span> <span class=\"teal\">Polygon</span>();\n  poly.AddContour( vertexList, <span class=\"blue\">false</span> );\n  <span class=\"blue\">return</span> poly;\n}\n</pre>\n<p>Here is the code for the Execute method of the command, i.e. the command mainline:</p>\n<pre class=\"code\">\n<span class=\"teal\">CmdResult</span> rc = <span class=\"teal\">CmdResult</span>.Failed;\napp = commandData.Application;\ndoc = app.ActiveDocument;\n \n<span class=\"teal\">Floor</span>[] floors = <span class=\"blue\">new</span> <span class=\"teal\">Floor</span>[2] { <span class=\"blue\">null</span>, <span class=\"blue\">null</span> };\n \n<span class=\"green\">// get the first 2 floors of the selection</span>\n<span class=\"blue\">foreach</span>( <span class=\"teal\">RvtElement</span> e <span class=\"blue\">in</span> doc.Selection.Elements )\n{\n  <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == floors[0] )\n  {\n    floors[0] = e <span class=\"blue\">as</span> <span class=\"teal\">Floor</span>;\n  }\n  <span class=\"blue\">else</span> <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == floors[1] )\n  {\n    floors[1] = e <span class=\"blue\">as</span> <span class=\"teal\">Floor</span>;\n  }\n  <span class=\"blue\">else</span>\n  {\n    <span class=\"blue\">break</span>;\n  }\n}\n \n<span class=\"green\">// if the selction did not contain two floors, return</span>\n<span class=\"blue\">if</span>( <span class=\"blue\">null</span> == floors[0] || <span class=\"blue\">null</span> == floors[1] )\n{\n  <span class=\"teal\">MessageBox</span>.Show(\n    <span class=\"maroon\">\"Please select two floors before\"</span>\n    + <span class=\"maroon\">\" running this command.\"</span>,\n    <span class=\"maroon\">\"GpcNET\"</span> );\n}\n<span class=\"blue\">else</span>\n{\n  <span class=\"green\">// get the intersection</span>\n  <span class=\"teal\">Polygon</span> poly1 = getPolygon( floors[0] );\n \n  <span class=\"teal\">Polygon</span> poly2 = getPolygon( floors[1] );\n \n  <span class=\"teal\">Polygon</span> poly3 = poly1.Clip(\n    <span class=\"teal\">GpcOperation</span>.Intersection,\n    poly2 );\n \n  <span class=\"green\">// if it looks like a valid polygon, create a new floor</span>\n  <span class=\"blue\">if</span>( 0 &lt; poly3.NofContours )\n  {\n    <span class=\"teal\">CurveArray</span> curves = app.Create.NewCurveArray();\n    <span class=\"teal\">VertexList</span> v = poly3.Contour[0];\n    <span class=\"blue\">int</span> i, j, n = v.NofVertices;\n    <span class=\"blue\">for</span>( i = 0; i &lt; n; ++i )\n    {\n      j = ( i + 1 ) % n;\n      <span class=\"teal\">Vertex</span> p = v.Vertex[i];\n      <span class=\"teal\">Vertex</span> q = v.Vertex[j];\n \n      curves.Append( app.Create.NewLineBound(\n        app.Create.NewXYZ( p.X, p.Y, 0 ),\n        app.Create.NewXYZ( q.X, q.Y, 0 ) ) );\n    }\n    doc.Create.NewFloor( curves,\n      floors[0].FloorType,\n      floors[0].Level, <span class=\"blue\">false</span> );\n \n    rc = <span class=\"teal\">CmdResult</span>.Succeeded;\n  }\n}\n<span class=\"blue\">return</span> rc;\n</pre>\n<p>A short readme file and sample Revit.ini snippet are included with the project.\nHere are the steps to rebuild and install it:</p>\n<ol>\n<li>In the Visual Studio project, adjust the Properties &gt; Build &gt; Output Path to point to the Revit.exe folder, e.g. \"C:\\Program Files\\Revit Architecture 2009\\Program\".</li>\n<li>Compile the project.</li>\n<li>Copy the gpc.dll file from the project folder to the Revit.exe folder.</li>\n<li>Adjust your Revit.ini file, for instance using the text in the sample Revit.ini file provided.</li>\n</ol>\n<p>Please note that the GPC library is only free to use for non-commercial use. Please contact the vendor if you are thinking of using it in a commercial product.</p>\n<p>The zip file includes a sample project named floors.rvt containing two floors.\nHere is what they look like before running the command:</p>\n<img alt=\"Two floors before calculating intersection\" src=\"img/floors_intersect_before.png\"/>\n<p>Here is the third floor created using the profile resulting from the intersection of the two, which have been temporarily half-toned:</p>\n<img alt=\"New floor created using intersection result\" src=\"img/floors_intersect_after.png\"/>\n<p>To apply these results to the problem we started the discussion with, the wall area adjacent to a given room, we would need to transform the vertical wall and room faces into 2D, as described in the discussion on\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2008/12/polygon-transformation.html\">\npolygon transformation</a>.\n\n<p>Here is the complete Visual Studio\n\n<a href=\"zip/gpcnet.zip\">\nGpcNET solution</a>.</p>\n</p></p>"
  }
]