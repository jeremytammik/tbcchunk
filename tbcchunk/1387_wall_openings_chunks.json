[
  {
    "original_filename": "1387_wall_openings",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n<link rel=\"stylesheet\" type=\"text/css\" href=\"bc.css\">\n<script src=\"run_prettify.js\" type=\"text/javascript\"></script>\n<!---\n<script src=\"https://google-code-prettify.googlecode.com/svn/loader/run_prettify.js\" type=\"text/javascript\"></script>\n-->\n</head>\n\n<!---\n\n- http://forums.autodesk.com/t5/revit-api/get-wall-openings/m-p/5955467\n\n#dotnet #csharp\n#fsharp #python\n#grevit\n#responsivedesign #typepad\n#ah8 #augi #dotnet\n#stingray #rendering\n#3dweb #3dviewapi #html5 #threejs #webgl #3d #mobile #vr #ecommerce\n#Markdown #Fusion360 #Fusion360Hackathon\n#javascript\n#RestSharp #restapi\n#mongoosejs #mongodb #nodejs\n#rtceur\n#xaml\n\nRevit API, Jeremy Tammik, akn_include\n\nRetrieving Wall Openings and Sorting Points #revitapi #bim #aec #3dwebcoder #adsk #geometry #3d #apis\n\n\nI continue my rather active involvement in the Revit API discussion forum. Lets look at one of them, and an associated point or two\n&ndash; Retrieving wall openings\n&ndash; Ray shooting solution\n&ndash; CmdWallOpenings implementation\n&ndash; Faster lexicographical point sorting...\n\n- [Retrieving wall openings](#2)\n- [Ray shooting solution](#2.1)\n- [CmdWallOpenings implementation](#3)\n- [Faster lexicographical point sorting](#4)\n\n-->"
  },
  {
    "original_filename": "1387_wall_openings",
    "header_text": "Retrieving Wall Openings and Sorting Points",
    "local_header_href": "#retrieving-wall-openings-and-sorting-points",
    "chunk_text": "### Retrieving Wall Openings and Sorting Points\n\nI continue my rather active involvement in the [Revit API discussion forum](http://forums.autodesk.com/t5/revit-api/bd-p/160).\n\nLets look at one of them, and an associated point or two:\n\n- [Retrieving wall openings](#2)\n- [Ray shooting solution](#2.1)\n- [CmdWallOpenings implementation](#3)\n- [Addendum](#3.1)\n- [Faster lexicographical point sorting](#4)"
  },
  {
    "original_filename": "1387_wall_openings",
    "header_text": "<a name=\"2\"></a>Retrieving Wall Openings",
    "local_header_href": "#a-name2aretrieving-wall-openings",
    "chunk_text": "#### <a name=\"2\"></a>Retrieving Wall Openings\n\nA very nice geometric issue was raised yesterday by Eirik Aasved Holst concerning the [determination of wall openings](http://forums.autodesk.com/t5/revit-api/get-wall-openings/m-p/5955539):\n\n**Question:** I'm struggling to get wall openings using the API. What I'm interested in is the coordinates of a rectangular wall opening:\n\n<center>\n<img src=\"img/wall_openings_01.jpeg\" alt=\"Wall opening points\" width=\"412\">\n</center>\n\nI've tried FindInserts(), but it's not given that anything is inserted in the opening (cf. the [addendum below](#3.1)).\n\nDoes anyone have a solution for this?\n\n\n**Answer:** This is an interesting question, and therefore has many answers.\n\nYou can determine the elements inserted in the wall (incl. openings) by temporarily deleting the wall. That gives you a list of all the dependent objects that also got deleted. Then you have the elements you are after.\n\nYou could look at the wall geometry before and after deleting the inserted elements and determine the differences.\n\nYou could query the wall for its geometry and determine all the holes in the elevation view.\n\nMy personal favourite candidate right now, off the hip, would be to shoot a ray along the wall centre line and determine all the faces that it hits.\n\nThat only works if you know one specific height or elevation (or several) at which all the openings really are open, so that they really have side faces that the ray intersection will hit.\n\nThis technique is demonstrated to find columns intersecting a wall by the FindReferencesByDirection / FindColumns SDK sample.\n\nHave fun exploring, and please let us know what you end up with."
  },
  {
    "original_filename": "1387_wall_openings",
    "header_text": "<a name=\"2.1\"></a>Ray Shooting Solution",
    "local_header_href": "#a-name21aray-shooting-solution",
    "chunk_text": "#### <a name=\"2.1\"></a>Ray Shooting Solution\n\n**Response:** Wonderful! The ray shooting solution works perfectly.\n\nI use the function for a planar view and set the ray elevation equal to view elevation.\n\nFor anyone else interested in using the same technique to locate wall openings, remember to set the ray origin a step outside the wall to determine if the wall starts with an opening or not:\n\n<center>\n<img src=\"img/wall_openings_03.jpeg\" alt=\"Wall openings at wall ends\" width=\"407\">\n</center>\n\nPseudo-code for my solution:\n\n<pre class=\"code\">\n  WallOpening2D - a simple class with two\n    coordinates and some other basic info.\n\n  List&lt;WallOpening2D&gt; GetWallOpenings(\n    Wall wall,\n    ViewPlan view )\n  {\n    var rayStart = new XYZ(\n      wallOrigin.X - wallDirection.X,\n      wallOrigin.Y - wallDirection.Y,\n      GetElevation(view));\n\n    pointList = (from reference in\n      new ReferenceIntersector(view)\n        .Find(rayStart, wallDirection)\n        .where(IsSurface)\n        .where(ref => ref.Proximity\n          < wallLength + \"step outside\"))\n        select reference.GetReference.GlobalPoint)\n\n    if(!pointList.First().IsAlmostEqualTo(wallOrigin) //CHECK IF FIRST POINT IS NOT AT WALL START\n      pointList.Insert(0, wallOrigin);\n    else\n      pointList.remove(pointList(First));\n\n    if(!IsEven(pointList.Count)  //IF NOT EVEN POINTCOUNT - WALL ENDS WITH OPENING\n      pointList.Add(wallEndPoint);\n\n    var wallOpenings = new List<WallOpening2d>();\n    for(i = 0; i &lt; pointList.Count -1; i += 2)\n      wallOpenings.Add(new WallOpening2d(pointList[i], pointList[i+1]);\n\n    return wallOpenings;\n  }\n</pre>\n\n\n**Answer:** I am very glad it helped.\n\nThank you for sharing the pseudo code.\n\nI started implementing the real thing based on that and ran into one single little snag:\n\n- error CS1502: The best overloaded method match for 'Autodesk.Revit.DB.ReferenceIntersector.ReferenceIntersector(Autodesk.Revit.DB.View3D)' has some invalid arguments\n- error CS1503: Argument 1: cannot convert from 'Autodesk.Revit.DB.ViewPlan' to 'Autodesk.Revit.DB.View3D'\n\nHere is my implementation so far:\n\n<pre class=\"code\">\nList<WallOpening2d> GetWallOpenings(\n  Wall wall,\n  ViewPlan view )\n{\n  Document doc = wall.Document;\n  Level level = doc.GetElement( view.LevelId ) as Level;\n  double elevation = level.Elevation;\n  Curve c = (wall.Location as LocationCurve).Curve;\n  XYZ wallOrigin = c.GetEndPoint(0);\n  XYZ wallEndPoint = c.GetEndPoint(1);\n  XYZ wallDirection =wallEndPoint - wallOrigin;\n  double wallLength = wallDirection.GetLength();\n  wallDirection = wallDirection.Normalize();\n  UV offset = new UV( wallDirection.X, wallDirection.Y );\n  double step_outside = offset.GetLength();\n\n  XYZ rayStart = new XYZ( wallOrigin.X - offset.U,\n    wallOrigin.Y - offset.V, elevation );\n\n  ReferenceIntersector intersector = new ReferenceIntersector( view ); // *** error here ***\n\n  IList<ReferenceWithContext> refs = intersector.Find( rayStart, wallDirection );\n  List<XYZ> pointList = new List<XYZ>( refs\n    .Where<ReferenceWithContext>( r => IsSurface(r.GetReference()))\n    .Where<ReferenceWithContext>( r => r.Proximity < wallLength + step_outside)\n    .Select<ReferenceWithContext,XYZ>( r => r.GetReference().GlobalPoint) );\n\n  // Check if first point is not at wall start.\n  // If so, the wall begins with an opening, so\n  // add its start point.\n\n  if(!pointList.First().IsAlmostEqualTo(wallOrigin))\n  {\n    pointList.Insert(0, wallOrigin);\n  }\n  else\n  {\n    pointList.Remove(pointList.First());\n  }\n\n  // If the point count in not even, the wall\n  // ends  with an opening, so add its end as\n  // a new last point.\n\n  if(!IsEven(pointList.Count))\n  {\n    pointList.Add(wallEndPoint);\n  }\n\n  int n = pointList.Count;\n  var wallOpenings = new List<WallOpening2d>( n / 2 );\n  for( int i = 0; i < n; i += 2 )\n  {\n    wallOpenings.Add( new WallOpening2d {\n      Start = pointList[i],\n      End = pointList[i + 1] } );\n  }\n  return wallOpenings;\n}\n</pre>\n\nI obviously have to provide a 3D view, not a plan one.\n\nI also get a pretty weird point list from my sample wall with four openings, none of them at either end of the wall, all in the middle.\n\nThe wall start point appears twice, the wall end point does not appear at all, and the points are not sorted by proximity:\n\n<center>\n<img src=\"img/wall_openings_04.png\" alt=\"Intersection points returned by ReferenceIntersector.Find\" width=\"327\">\n</center>\n\nI have to add some clean-up and fool-proofing to get a reliable result.\n\nI implemented a working command\nin [The Building Coder samples](https://github.com/jeremytammik/the_building_coder_samples)\n[release 2016.0.124.0](https://github.com/jeremytammik/the_building_coder_samples/releases/tag/2016.0.124.0).\n\nThe external command name\nis [CmdWallOpenings](https://github.com/jeremytammik/the_building_coder_samples/blob/master/BuildingCoder/BuildingCoder/CmdWallOpenings.cs).\n\n\n**Response:** Some corrections to my pseudocode:\n\n- You are right about the view3D. I'm using the 2D view to get the elevation of the view range cut plane. For the ReferenceIntersector, I'm using the standard 3D view (just make sure it does not have an active section box and that all relevant elements are visible).\n\n<pre class=\"code\">\n  var default3DView\n    = new FilteredElementCollector(doc)\n      .OfClass(typeof (View3D))\n      .ToElements()\n      .Cast<View3D>()\n      .FirstOrDefault( v\n        => v != null\n        && !v.IsTemplate\n        && v.Name.Equals(\"{3D}\"));\n</pre>\n\nOf course one may create a new 3D view if that works better.\n\n- I forgot to specify that the reference intersector should only return Faces belonging to the relevant wall.\n\n<pre class=\"code\">\n  var referenceIntersector\n    = new ReferenceIntersector( wall.Id,\n      FindReferenceTarget.Face, default3DView);\n</pre>\n\n- \"The wall start point appears twice, the wall end point does not appear at all, and the points are not sorted by proximity:\"\n\nThe points will get sorted by proximity when the wall.id is specified to the ReferenceIntersector.\n\nYour points are sorted by element, then by proximity.\n\nTo get the wall end point, it is important to set the \"step_outside\" sufficiently large in the clause\n\n<pre class=\"code\">\n  .Where<ReferenceWithContext>( r => r.Proximity < wallLength + step_outside)\n</pre>\n\nThe first point appears twice probably because `!pointList.First().IsAlmostEqualTo(wallOrigin)` in\n\n<pre class=\"code\">\n  if(!pointList.First().IsAlmostEqualTo(wallOrigin))\n  {\n    pointList.Insert(0, wallOrigin);\n  }\n</pre>\n\nwill always return true (or !false) and therefore the start point gets inserted.\n\nThis is because the wall origin Z coordinate is not necessarily the same as the ray start Z coordinate.\n\nI changed the code to:\n\n<pre class=\"code\">\n  Curve c = (wall.Location as LocationCurve).Curve;\n\n  var wallStartPoint = new XYZ( c.GetEndPoint(0).X,\n    c.GetEndPoint(0).Y, elevation);\n\n  var rayStart = new XYZ(\n    wallStartPoint.X - wallLine.Direction.X,\n    wallStartPoint.Y - wallLine.Direction.Y,\n    wallStartPoint.Z);\n\n  ...\n\n  if (!pointList.First().IsAlmostEqualTo(wallStartPoint))\n    pointList.Insert(0, wallStartPoint);\n</pre>\n\nMy code works quite well now; thank you for the suggestion to use a shooting ray &nbsp; :-)\n\n\n**Answer:** Thank you for picking up my questions.\n\nAs you can see from my later post and GitHub submission, I also found and solved all the issues you mention my own way.\n\n1. I just use the currently active user selected 3D view.\n\n2. Yes, I noticed and added that as well.\n\n3. Nope. The points I list above are the exact results of the call to Find, with nothing added or removed. I think my problems were caused by using elevation zero, so the ray was passing through the bottom edges of the wall faces. That way, it is hit or miss whether an intersection is found or not. I raised it off the floor and extend it beyond the wall at each end by 0.1 feet, and then I get reliable results. I am surprised that is not causing problems for you.\n\n4. My code works well too. Check it out on GitHub. If you see any further possible improvements, please let me know.\n\n\n**Suggestion 1:** One addition concerning the default 3D view.\nIn a workshared environment, there is no \"{3D}\".\nInstead of this, if a user creates a new default 3D view, this will be named like \"{3d - username}\".\nNote the username suffix and the lowercase \"d\".\n\n**Suggestion 2:** Instead of just elevating the one and single ray, what about using multiple rays, like a comb?\n\n**Answer:** I totally agree.\n\nDefine a parameter specifying the minimum opening size, and then fan a comb up the entire wall side.\n\nRetrieve all the resulting intersection points, sort them by proximity, eliminate duplicates, and Bob's your uncle."
  },
  {
    "original_filename": "1387_wall_openings",
    "header_text": "<a name=\"3\"></a>CmdWallOpenings Implementation",
    "local_header_href": "#a-name3acmdwallopenings-implementation",
    "chunk_text": "#### <a name=\"3\"></a>CmdWallOpenings Implementation\n\nAs said, I implemented and tested this algorithm in a new [external command CmdWallOpenings](https://github.com/jeremytammik/the_building_coder_samples/blob/master/BuildingCoder/BuildingCoder/CmdWallOpenings.cs)\nin [The Building Coder samples](https://github.com/jeremytammik/the_building_coder_samples).\n\nI cleaned it up a bit more, and the version presented below is\n[release 2016.0.125.1](https://github.com/jeremytammik/the_building_coder_samples/releases/tag/2016.0.125.1).\n\nI performed minimal testing of it on these three different walls:\n\n<center>\n<img src=\"img/wall_openings_05.png\" alt=\"Three walls with openings\" width=\"430\">\n</center>\n\nEach of them has four openings.\nRunning the CmdWallOpenings command once for each wall reports the four openings like this:\n\n<pre>\n  4 openings found:\n  ((-0.42,18.27,0.1)-(2.59,18.27,0.1))\n  ((5.49,18.27,0.1)-(8.49,18.27,0.1))\n  ((9.43,18.27,0.1)-(12.43,18.27,0.1))\n  ((13.36,18.27,0.1)-(16.37,18.27,0.1))\n  4 openings found:\n  ((0.78,4.77,0)-(2.73,5.68,0.1))\n  ((4.47,6.5,0.1)-(7.19,7.76,0.1))\n  ((8.93,8.58,0.1)-(11.66,9.84,0.1))\n  ((13.1,10.52,0.1)-(15.82,11.79,0.1))\n  4 openings found:\n  ((2.23,-3.24,0.1)-(5.12,-2.41,0.1))\n  ((6.96,-1.88,0.1)-(9.85,-1.06,0.1))\n  ((12.32,-0.35,0.1)-(15.21,0.48,0.1))\n  ((15.79,0.65,0.1)-(17.24,1.06,0))\n</pre>\n\n<center>\n<img src=\"img/wall_openings_06_msg.png\" alt=\"Wall opening coordinates\" width=\"366\">\n</center>\n\nThe wall opening data currently just includes the opening start and end points:\n\n<pre class=\"code\">\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> A simple class with two coordinates </span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> and some other basic info.</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n&nbsp; <span class=\"blue\">class</span> <span class=\"teal\">WallOpening2d</span>\n&nbsp; {\n&nbsp; &nbsp; <span class=\"green\">//public ElementId Id { get; set; }</span>\n&nbsp; &nbsp; <span class=\"blue\">public</span> <span class=\"teal\">XYZ</span> Start { <span class=\"blue\">get</span>; <span class=\"blue\">set</span>; }\n&nbsp; &nbsp; <span class=\"blue\">public</span> <span class=\"teal\">XYZ</span> End { <span class=\"blue\">get</span>; <span class=\"blue\">set</span>; }\n&nbsp; &nbsp; <span class=\"blue\">override</span> <span class=\"blue\">public</span> <span class=\"blue\">string</span> ToString()\n&nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; <span class=\"blue\">return</span> <span class=\"maroon\">&quot;(&quot;</span>\n&nbsp; &nbsp; &nbsp; &nbsp; <span class=\"green\">//+ Id.ToString() + &quot;@&quot;</span>\n&nbsp; &nbsp; &nbsp; &nbsp; + <span class=\"teal\">Util</span>.PointString( Start ) + <span class=\"maroon\">&quot;-&quot;</span>\n&nbsp; &nbsp; &nbsp; &nbsp; + <span class=\"teal\">Util</span>.PointString( End ) + <span class=\"maroon\">&quot;)&quot;</span>;\n&nbsp; &nbsp; }\n&nbsp; }\n</pre>\n\nI use an offset to raise the ray above the floor level and thus avoid intersecting the bottom edge of the wall faces:\n\nThis offset is also applied to lengthen the ray beyond the wall extents at both ends.\n\n<pre class=\"code\">\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> Move out of wall and up from floor a bit</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n&nbsp; <span class=\"blue\">const</span> <span class=\"blue\">double</span> _offset = 0.1; <span class=\"green\">// feet</span>\n</pre>\n\nThe following two predicate methods determine whether a number is even and whether a reference applies to a surface:\n\n<pre class=\"code\">\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> Predicate: is the given number even?</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n&nbsp; <span class=\"blue\">static</span> <span class=\"blue\">bool</span> IsEven( <span class=\"blue\">int</span> i )\n&nbsp; {\n&nbsp; &nbsp; <span class=\"blue\">return</span> 0 == i % 2;\n&nbsp; }\n&nbsp;\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> Predicate: does the given reference refer to a surface?</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n&nbsp; <span class=\"blue\">static</span> <span class=\"blue\">bool</span> IsSurface( <span class=\"teal\">Reference</span> r )\n&nbsp; {\n&nbsp; &nbsp; <span class=\"blue\">return</span> <span class=\"teal\">ElementReferenceType</span>.REFERENCE_TYPE_SURFACE\n&nbsp; &nbsp; &nbsp; == r.ElementReferenceType;\n&nbsp; }\n</pre>\n\nThe latter could probably be eliminated, since we now specify that we are only interested in surfaces when calling the `ReferenceIntersector` `Find` method.\n\nI ensure that distinct points are retained and processed by implementing this XYZ equality comparer and passing it into the LINQ `Distinct` method:\n\n<pre class=\"code\">\n&nbsp; <span class=\"blue\">class</span> <span class=\"teal\">XyzEqualityComparer</span> : <span class=\"teal\">IEqualityComparer</span>&lt;<span class=\"teal\">XYZ</span>&gt;\n&nbsp; {\n&nbsp; &nbsp; <span class=\"blue\">public</span> <span class=\"blue\">bool</span> Equals( <span class=\"teal\">XYZ</span> a, <span class=\"teal\">XYZ</span> b )\n&nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; <span class=\"blue\">return</span> <span class=\"teal\">Util</span>.IsEqual( a, b );\n&nbsp; &nbsp; }\n&nbsp;\n&nbsp; &nbsp; <span class=\"blue\">public</span> <span class=\"blue\">int</span> GetHashCode( <span class=\"teal\">XYZ</span> a )\n&nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; <span class=\"blue\">return</span> <span class=\"teal\">Util</span>.PointString( a ).GetHashCode();\n&nbsp; &nbsp; }\n&nbsp; }\n</pre>\n\nWith those helper methods in place, the main `GetWallOpenings` method can be implemented as follows:\n\n<pre class=\"code\">\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n<span class=\"gray\">///</span><span class=\"green\"> Retrieve all wall openings, </span>\n<span class=\"gray\">///</span><span class=\"green\"> including at start and end of wall.</span>\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n<span class=\"teal\">List</span>&lt;<span class=\"teal\">WallOpening2d</span>&gt; GetWallOpenings(\n&nbsp; <span class=\"teal\">Wall</span> wall,\n&nbsp; <span class=\"teal\">View3D</span> view )\n{\n&nbsp; <span class=\"teal\">Document</span> doc = wall.Document;\n&nbsp; <span class=\"teal\">Level</span> level = doc.GetElement( wall.LevelId ) <span class=\"blue\">as</span> <span class=\"teal\">Level</span>;\n&nbsp; <span class=\"blue\">double</span> elevation = level.Elevation;\n&nbsp; <span class=\"teal\">Curve</span> c = ( wall.Location <span class=\"blue\">as</span> <span class=\"teal\">LocationCurve</span> ).Curve;\n&nbsp; <span class=\"teal\">XYZ</span> wallOrigin = c.GetEndPoint( 0 );\n&nbsp; <span class=\"teal\">XYZ</span> wallEndPoint = c.GetEndPoint( 1 );\n&nbsp; <span class=\"teal\">XYZ</span> wallDirection = wallEndPoint - wallOrigin;\n&nbsp; <span class=\"blue\">double</span> wallLength = wallDirection.GetLength();\n&nbsp; wallDirection = wallDirection.Normalize();\n&nbsp; <span class=\"teal\">UV</span> offsetOut = _offset * <span class=\"blue\">new</span> <span class=\"teal\">UV</span>( wallDirection.X, wallDirection.Y );\n&nbsp;\n&nbsp; <span class=\"teal\">XYZ</span> rayStart = <span class=\"blue\">new</span> <span class=\"teal\">XYZ</span>( wallOrigin.X - offsetOut.U,\n&nbsp; &nbsp; wallOrigin.Y - offsetOut.V, elevation + _offset );\n&nbsp;\n&nbsp; <span class=\"teal\">ReferenceIntersector</span> intersector\n&nbsp; &nbsp; = <span class=\"blue\">new</span> <span class=\"teal\">ReferenceIntersector</span>( wall.Id,\n&nbsp; &nbsp; &nbsp; <span class=\"teal\">FindReferenceTarget</span>.Face, view );\n&nbsp;\n&nbsp; <span class=\"teal\">IList</span>&lt;<span class=\"teal\">ReferenceWithContext</span>&gt; refs\n&nbsp; &nbsp; = intersector.Find( rayStart, wallDirection );\n&nbsp;\n&nbsp; <span class=\"green\">// Extract the intersection points:</span>\n&nbsp; <span class=\"green\">// - only surfaces</span>\n&nbsp; <span class=\"green\">// - within wall length plus offset at each end</span>\n&nbsp; <span class=\"green\">// - sorted by proximity</span>\n&nbsp; <span class=\"green\">// - eliminating duplicates</span>\n&nbsp;\n&nbsp; <span class=\"teal\">List</span>&lt;<span class=\"teal\">XYZ</span>&gt; pointList = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">XYZ</span>&gt;( refs\n&nbsp; &nbsp; .Where&lt;<span class=\"teal\">ReferenceWithContext</span>&gt;( r =&gt; IsSurface(\n&nbsp; &nbsp; &nbsp; r.GetReference() ) )\n&nbsp; &nbsp; .Where&lt;<span class=\"teal\">ReferenceWithContext</span>&gt;( r =&gt; r.Proximity\n&nbsp; &nbsp; &nbsp; &lt; wallLength + _offset + _offset )\n&nbsp; &nbsp; .OrderBy&lt;<span class=\"teal\">ReferenceWithContext</span>, <span class=\"blue\">double</span>&gt;(\n&nbsp; &nbsp; &nbsp; r =&gt; r.Proximity )\n&nbsp; &nbsp; .Select&lt;<span class=\"teal\">ReferenceWithContext</span>, <span class=\"teal\">XYZ</span>&gt;( r\n&nbsp; &nbsp; &nbsp; =&gt; r.GetReference().GlobalPoint )\n&nbsp; &nbsp; .Distinct&lt;<span class=\"teal\">XYZ</span>&gt;( <span class=\"blue\">new</span> <span class=\"teal\">XyzEqualityComparer</span>() ) );\n&nbsp;\n&nbsp; <span class=\"green\">// Check if first point is at the wall start.</span>\n&nbsp; <span class=\"green\">// If so, the wall does not begin with an opening,</span>\n&nbsp; <span class=\"green\">// so that point can be removed. Else, add it.</span>\n&nbsp;\n&nbsp; <span class=\"teal\">XYZ</span> q = wallOrigin + _offset * <span class=\"teal\">XYZ</span>.BasisZ;\n&nbsp;\n&nbsp; <span class=\"blue\">bool</span> wallHasFaceAtStart = <span class=\"teal\">Util</span>.IsEqual(\n&nbsp; &nbsp; pointList[0], q );\n&nbsp;\n&nbsp; <span class=\"blue\">if</span>( wallHasFaceAtStart )\n&nbsp; {\n&nbsp; &nbsp; pointList.RemoveAll( p\n&nbsp; &nbsp; &nbsp; =&gt; <span class=\"teal\">Util</span>.IsEqual( p, q ) );\n&nbsp; }\n&nbsp; <span class=\"blue\">else</span>\n&nbsp; {\n&nbsp; &nbsp; pointList.Insert( 0, wallOrigin );\n&nbsp; }\n&nbsp;\n&nbsp; <span class=\"green\">// Check if last point is at the wall end.</span>\n&nbsp; <span class=\"green\">// If so, the wall does not end with an opening, </span>\n&nbsp; <span class=\"green\">// so that point can be removed. Else, add it.</span>\n&nbsp;\n&nbsp; q = wallEndPoint + _offset * <span class=\"teal\">XYZ</span>.BasisZ;\n&nbsp;\n&nbsp; <span class=\"blue\">bool</span> wallHasFaceAtEnd = <span class=\"teal\">Util</span>.IsEqual(\n&nbsp; &nbsp; pointList.Last(), q );\n&nbsp;\n&nbsp; <span class=\"blue\">if</span>( wallHasFaceAtEnd )\n&nbsp; {\n&nbsp; &nbsp; pointList.RemoveAll( p\n&nbsp; &nbsp; &nbsp; =&gt; <span class=\"teal\">Util</span>.IsEqual( p, q ) );\n&nbsp; }\n&nbsp; <span class=\"blue\">else</span>\n&nbsp; {\n&nbsp; &nbsp; pointList.Add( wallEndPoint );\n&nbsp; }\n&nbsp;\n&nbsp; <span class=\"blue\">int</span> n = pointList.Count;\n&nbsp;\n&nbsp; <span class=\"teal\">Debug</span>.Assert( IsEven( n ),\n&nbsp; &nbsp; <span class=\"maroon\">&quot;expected an even number of opening sides&quot;</span> );\n&nbsp;\n&nbsp; <span class=\"blue\">var</span> wallOpenings = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">WallOpening2d</span>&gt;(\n&nbsp; &nbsp; n / 2 );\n&nbsp;\n&nbsp; <span class=\"blue\">for</span>( <span class=\"blue\">int</span> i = 0; i &lt; n; i += 2 )\n&nbsp; {\n&nbsp; &nbsp; wallOpenings.Add( <span class=\"blue\">new</span> <span class=\"teal\">WallOpening2d</span>\n&nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; Start = pointList[i],\n&nbsp; &nbsp; &nbsp; End = pointList[i + 1]\n&nbsp; &nbsp; } );\n&nbsp; }\n&nbsp; <span class=\"blue\">return</span> wallOpenings;\n}\n</pre>\n\nThe external command mainline Execute method drives it like this to achieve the following:\n\n- Ensure we are running in a valid context.\n- Select a wall, or retrieve the pre-selected one.\n- Retrieve the wall openings.\n- Report the result.\n\n<pre class=\"code\">\n<span class=\"blue\">public</span> <span class=\"teal\">Result</span> Execute(\n&nbsp; <span class=\"teal\">ExternalCommandData</span> commandData,\n&nbsp; <span class=\"blue\">ref</span> <span class=\"blue\">string</span> message,\n&nbsp; <span class=\"teal\">ElementSet</span> elements )\n{\n&nbsp; <span class=\"teal\">UIApplication</span> uiapp = commandData.Application;\n&nbsp; <span class=\"teal\">UIDocument</span> uidoc = uiapp.ActiveUIDocument;\n&nbsp; <span class=\"teal\">Document</span> doc = uidoc.Document;\n&nbsp;\n&nbsp; <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == doc )\n&nbsp; {\n&nbsp; &nbsp; message = <span class=\"maroon\">&quot;Please run this command in a valid document.&quot;</span>;\n&nbsp; &nbsp; <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n&nbsp; }\n&nbsp;\n&nbsp; <span class=\"teal\">View3D</span> view = doc.ActiveView <span class=\"blue\">as</span> <span class=\"teal\">View3D</span>;\n&nbsp;\n&nbsp; <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == view )\n&nbsp; {\n&nbsp; &nbsp; message = <span class=\"maroon\">&quot;Please run this command in a 3D view.&quot;</span>;\n&nbsp; &nbsp; <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n&nbsp; }\n&nbsp;\n&nbsp; <span class=\"teal\">Element</span> e = <span class=\"teal\">Util</span>.SelectSingleElementOfType(\n&nbsp; &nbsp; uidoc, <span class=\"blue\">typeof</span>( <span class=\"teal\">Wall</span> ), <span class=\"maroon\">&quot;wall&quot;</span>, <span class=\"blue\">true</span> );\n&nbsp;\n&nbsp; <span class=\"teal\">List</span>&lt;<span class=\"teal\">WallOpening2d</span>&gt; openings = GetWallOpenings(\n&nbsp; &nbsp; e <span class=\"blue\">as</span> <span class=\"teal\">Wall</span>, view );\n&nbsp;\n&nbsp; <span class=\"blue\">int</span> n = openings.Count;\n&nbsp;\n&nbsp; <span class=\"blue\">string</span> msg = <span class=\"blue\">string</span>.Format(\n&nbsp; &nbsp; <span class=\"maroon\">&quot;{0} opening{1} found{2}&quot;</span>,\n&nbsp; &nbsp; n, <span class=\"teal\">Util</span>.PluralSuffix( n ),\n&nbsp; &nbsp; <span class=\"teal\">Util</span>.DotOrColon( n ) );\n&nbsp;\n&nbsp; <span class=\"teal\">Util</span>.InfoMsg2( msg, <span class=\"blue\">string</span>.Join(\n&nbsp; &nbsp; <span class=\"maroon\">&quot;\\r\\n&quot;</span>, openings ) );\n&nbsp;\n&nbsp; <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Succeeded;\n}\n</pre>"
  },
  {
    "original_filename": "1387_wall_openings",
    "header_text": "<a name=\"3.1\"></a>Addendum",
    "local_header_href": "#a-name31aaddendum",
    "chunk_text": "#### <a name=\"3.1\"></a>Addendum\n\nEirik's statement in the initial query implies that `FindInserts` does not return wall openings that do not host any insert, w.g., a door or window family instance.\n\nThis is not true, as Scott Wilson later pointed out. Scott also provided an alternative implementation determining and\ndisplaying [wall opening profiles using FindInserts](http://thebuildingcoder.typepad.com/blog/2015/12/wall-opening-profiles-and-happy-holidays.html), which you might want to have a look at as well."
  },
  {
    "original_filename": "1387_wall_openings",
    "header_text": "<a name=\"4\"></a>Faster Lexicographical Point Sorting",
    "local_header_href": "#a-name4afaster-lexicographical-point-sorting",
    "chunk_text": "#### <a name=\"4\"></a>Faster Lexicographical Point Sorting\n\nWhile evaluating different methods for sorting and comparing points, I also implemented the following `XyzProximityComparer`:\n\n<pre class=\"code\">\n&nbsp; <span class=\"blue\">class</span> <span class=\"teal\">XyzProximityComparer</span> : <span class=\"teal\">IComparer</span>&lt;<span class=\"teal\">XYZ</span>&gt;\n&nbsp; {\n&nbsp; &nbsp; <span class=\"teal\">XYZ</span> _p;\n&nbsp;\n&nbsp; &nbsp; <span class=\"blue\">public</span> XyzProximityComparer( <span class=\"teal\">XYZ</span> p )\n&nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; _p = p;\n&nbsp; &nbsp; }\n&nbsp;\n&nbsp; &nbsp; <span class=\"blue\">public</span> <span class=\"blue\">int</span> Compare( <span class=\"teal\">XYZ</span> x, <span class=\"teal\">XYZ</span> y )\n&nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; <span class=\"blue\">double</span> dx = x.DistanceTo( _p );\n&nbsp; &nbsp; &nbsp; <span class=\"blue\">double</span> dy = y.DistanceTo( _p );\n&nbsp; &nbsp; &nbsp; <span class=\"blue\">return</span> <span class=\"teal\">Util</span>.IsEqual( dx, dy ) ? 0\n&nbsp; &nbsp; &nbsp; &nbsp; : ( dx &lt; dy ? -1 : 1 );\n&nbsp; &nbsp; }\n&nbsp; }\n</pre>\n\nI ended up not using it, for two reasons:\n\n- The `ReferenceIntersector` already returns the points sorted by proximity.\n- I can use a LINQ `OrderBy` clause instead.\n\nAnyway, while researching this, I discovered the StackOverflow question\non [using IComparer for sorting](http://stackoverflow.com/questions/14336416/using-icomparer-for-sorting).\n\nIt discusses a point comparison class similar to `XyzEqualityComparer` presented above, only to continue with the following extremely interesting information:\n\n> Note that if you target a .NET 3.5+ application you can use LINQ which is easier and even faster with sorting.\n\n> LINQ version can be something like:\n\n>     var orderedList = Points.OrderBy(point => point.x)\n>        .ThenBy(point => point.y)\n>        .ToList();\n\nThis is definitely something to keep in mind next time you are thinking about sorting a collection of points!"
  }
]