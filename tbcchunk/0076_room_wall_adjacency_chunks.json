[
  {
    "original_filename": "0076_room_wall_adjacency",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<style>\n.blue { color: blue; }\n.teal { color: teal; }\n.maroon { color: maroon; }\n.green { color: green; }\n</style>"
  },
  {
    "original_filename": "0076_room_wall_adjacency",
    "header_text": "Room and Wall Adjacency",
    "local_header_href": "#room-and-wall-adjacency",
    "chunk_text": "<h3>Room and Wall Adjacency</h3><p><strong>Question:</strong>\nHow can I obtain the part of a wall that touches a room, especially its face area?\nThe wall can be adjacent to more than one room.</p><p><strong>Answer:</strong>\nYou will probably find the Room object's Boundary property useful.\nIt returns the boundary of the room in a BoundarySegmentArrayArray object, i.e. an array of boundaries or loops.\nA room may have more than one boundary loop if its floor surface contains holes, which is why this returns an array of arrays.\nEach boundary consists of a BoundarySegmentArray item, which is a list of BoundarySegment elements.\nEach such element represents a segment of a room boundary and has a property Element, which provides access to the element that is responsible for producing this boundary segment.\nThat means that from the room, you can figure out what part of its boundary is generated by which wall.\nIf you then go to each of these bounding walls, you can ask it for further information to discover the surface area that it generates adjacent to the given room.</p><p>The use and analysis of the Room Boundary property is demonstrated by the RoomViewer SDK sample.</p><p>I implemented a new external command class CmdRoomWallAdjacency to demonstrate the principle.\nIt analyses the currently selected rooms in the model, or all rooms if none have been selected.\nFor each room, it iterates over all its boundary segments and lists the bounding elements and their adjacent length, i.e. the length of the curve that they generate which forms part of the room boundary.\nThis may well be less than the total length of the element.\nFor all wall elements, its total length and its total area are also listed.\nThe total area of a wall is queried from the built-in parameter HOST_AREA_COMPUTED, as discussed in our early post on\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2008/09/selecting-all-w.html\">\nselecting all walls</a>.</p><p>We have already discussed more complex ways of calculating areas for\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2008/12/2d-polygon-areas-and-outer-loop.html\">\n2D</a>\n\nand\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2008/12/3d-polygon-areas.html\">\n3D</a>\n\npolygons and their\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2008/12/polygon-transformation.html\">\ntransformations</a>\n\ndirectly from the underlying wall geometry, instead of relying on the black box result provided by the built-in parameter.\n\nThe\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2009/01/plantopology-class.html\">\nplan topology</a>\n\nobject provided by the Revit API may also be useful in this context.</p><p>Here is the implementation of the command mainline:</p><pre class=\"code\">\n<span class=\"teal\">Application</span> app = commandData.Application;\n<span class=\"teal\">Document</span> doc = app.ActiveDocument;\n \n<span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt; rooms = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt;();\n<span class=\"blue\">if</span>( !<span class=\"teal\">Util</span>.GetSelectedElementsOrAll(\n  rooms, doc, <span class=\"blue\">typeof</span>( <span class=\"teal\">Room</span> ) ) )\n{\n  <span class=\"teal\">Selection</span> sel = doc.Selection;\n  message = ( 0 &lt; sel.Elements.Size )\n    ? <span class=\"maroon\">\"Please select some room elements.\"</span>\n    : <span class=\"maroon\">\"No room elements found.\"</span>;\n  <span class=\"blue\">return</span> <span class=\"teal\">CmdResult</span>.Failed;\n}\n<span class=\"blue\">foreach</span>( <span class=\"teal\">Room</span> room <span class=\"blue\">in</span> rooms )\n{\n  DetermineAdjacentElementLengthsAndWallAreas(\n    room );\n}\n<span class=\"blue\">return</span> <span class=\"teal\">CmdResult</span>.Failed;\n</pre><p>It retrieves the currently selected rooms in the model, or all rooms if none have been selected, using the utility method GetSelectedElementsOrAll, and then iterates over each wall, applying the worker method DetermineAdjacentElementLengthsAndWallAreas to it.\nHere is the implementation of the worker method:</p><pre class=\"code\">\n<span class=\"blue\">void</span> DetermineAdjacentElementLengthsAndWallAreas(\n  <span class=\"teal\">Room</span> room )\n{\n  <span class=\"teal\">BoundarySegmentArrayArray</span> boundaries\n    = room.Boundary;\n \n  <span class=\"blue\">int</span> n = boundaries.Size;\n \n  <span class=\"teal\">Debug</span>.Print(\n    <span class=\"maroon\">\"{0} has {1} boundar{2}{3}\"</span>,\n    <span class=\"teal\">Util</span>.ElementDescription( room ),\n    n, <span class=\"teal\">Util</span>.PluralSuffixY( n ),\n    <span class=\"teal\">Util</span>.DotOrColon( n ) );\n \n  <span class=\"blue\">int</span> iBoundary = 0, iSegment;\n \n  <span class=\"blue\">foreach</span>( <span class=\"teal\">BoundarySegmentArray</span> b <span class=\"blue\">in</span> boundaries )\n  {\n    ++iBoundary;\n    iSegment = 0;\n    <span class=\"blue\">foreach</span>( <span class=\"teal\">BoundarySegment</span> s <span class=\"blue\">in</span> b )\n    {\n      ++iSegment;\n      <span class=\"teal\">Element</span> neighbour = s.Element;\n      <span class=\"teal\">Curve</span> curve = s.Curve;\n      <span class=\"blue\">double</span> length = curve.Length;\n \n      <span class=\"teal\">Debug</span>.Print(\n        <span class=\"maroon\">\"  Neighbour {0}:{1} {2} has {3}\"</span>\n        + <span class=\"maroon\">\" feet adjacent to room.\"</span>,\n        iBoundary, iSegment,\n        <span class=\"teal\">Util</span>.ElementDescription( neighbour ),\n        <span class=\"teal\">Util</span>.RealString( length ) );\n \n      <span class=\"blue\">if</span>( neighbour <span class=\"blue\">is</span> <span class=\"teal\">Wall</span> )\n      {\n        <span class=\"teal\">Wall</span> wall = neighbour <span class=\"blue\">as</span> <span class=\"teal\">Wall</span>;\n \n        <span class=\"teal\">Parameter</span> p = wall.get_Parameter(\n          <span class=\"teal\">BuiltInParameter</span>.HOST_AREA_COMPUTED );\n \n        <span class=\"blue\">double</span> area = p.AsDouble();\n \n        <span class=\"teal\">LocationCurve</span> lc\n          = wall.Location <span class=\"blue\">as</span> <span class=\"teal\">LocationCurve</span>;\n \n        <span class=\"blue\">double</span> wallLength = lc.Curve.Length;\n \n        <span class=\"teal\">Debug</span>.Print(\n          <span class=\"maroon\">\"    This wall has a total length\"</span>\n          + <span class=\"maroon\">\" and area of {0} feet and {1}\"</span>\n          + <span class=\"maroon\">\" square feet.\"</span>,\n          <span class=\"teal\">Util</span>.RealString( wallLength ),\n          <span class=\"teal\">Util</span>.RealString( area ) );\n      }\n    }\n  }\n}\n</pre><p>It retrieves the room boundaries, prints a report on their number and the room identity, iterates over the boundaries and their segments, and checks each segment for the adjacent generating elements.\nIf the neighbouring element is a wall, its total length and area are also listed.</p><p>Here is the result of running this command on a simple square house containing one single room:</p><pre>\nRooms &lt;127284 Room 1&gt; has 1 boundary:\n  Neighbour 1:1 Walls &lt;127248 Generic - 200mm&gt; has 22.31 feet adjacent to room.\n    This wall has a total length and area of 22.97 feet and 283.65 square feet.\n  Neighbour 1:2 Walls &lt;127249 Generic - 200mm&gt; has 12.47 feet adjacent to room.\n    This wall has a total length and area of 13.12 feet and 172.22 square feet.\n  Neighbour 1:3 Walls &lt;127250 Generic - 200mm&gt; has 22.31 feet adjacent to room.\n    This wall has a total length and area of 22.97 feet and 301.39 square feet.\n  Neighbour 1:4 Walls &lt;127251 Generic - 200mm&gt; has 12.47 feet adjacent to room.\n    This wall has a total length and area of 13.12 feet and 163.61 square feet.\n</pre><p>The reason for the varying surfaces reported for the walls is due to the way their connections and intersections in the corners of the house have been generated by Revit.</p><p>Here is the output when a room is bounded by some walls that extend out beyond the room, so that only part of them are actually adjacent to it:</p><pre>\nRooms &lt;128358 Room 2&gt; has 1 boundary:\n  Neighbour 1:1 Walls &lt;128146 Generic - 200mm&gt; has 5.91 feet adjacent to room.\n    This wall has a total length and area of 42.65 feet and 1119.45 square feet.\n  Neighbour 1:2 Walls &lt;128348 Generic - 200mm&gt; has 4.27 feet adjacent to room.\n    This wall has a total length and area of 4.92 feet and 111.94 square feet.\n  Neighbour 1:3 Walls &lt;128302 Generic - 200mm&gt; has 5.91 feet adjacent to room.\n    This wall has a total length and area of 19.69 feet and 499.45 square feet.\n  Neighbour 1:4 Walls &lt;128256 Generic - 200mm&gt; has 4.27 feet adjacent to room.\n    This wall has a total length and area of 9.84 feet and 241.11 square feet.\n</pre><p>As you can see, the room boundary curve only reports the adjacent length, whereas the total wall length for some of the walls is much larger.</p><p>To determine the adjacent surface area is trivial if the wall has a constant height, since in that case it is a constant factor multiplied by the wall length. If the height varies, it becomes more complex.</p><p>Many thanks to Massimiliano Revelli of \n\n<a href=\"http://www.infosys.it\">\nInformatica System srl</a>\n\nfor raising this issue.</p>"
  }
]