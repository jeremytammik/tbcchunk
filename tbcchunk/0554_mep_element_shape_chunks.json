[
  {
    "original_filename": "0554_mep_element_shape",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<head>\n<link href=\"bc.css\" rel=\"stylesheet\" type=\"text/css\"/>\n</head>"
  },
  {
    "original_filename": "0554_mep_element_shape",
    "header_text": "Distinguishing MEP Element Shape",
    "local_header_href": "#distinguishing-mep-element-shape",
    "chunk_text": "<h3>Distinguishing MEP Element Shape</h3><p>Normally, when given a family instance, you can access the family name to obtain some information about it.\nFor Revit MEP ducts, however, the duct shape is determined by an internal system family whose name is visible in the user interface but is not accessible through the API.\n\n<p>For instance, with ducts, you cannot access the family of a round duct.\nIn the user interface, it appears to belong to a family named \"Round Duct\", but in fact this built-in system family and its name are not accessible through the API.\n\n<p>Fittings are represented by normal standard families, so this problem does not apply to them, only to ducts with the BuiltInCategory OST_DuctCurves\n.\n\n<p>Several people have asked for and probably implemented workarounds for this. \nHere is one solution by Max, <a href=\"http://maciejszlek.pl\">Maciej Szlek</a>, based on an analysis of the string value of the duct's Size parameter.\nHe starts off by asking:\n\n<p><strong>Question:</strong> I wonder if there is some way to clearly determine the part type of a ductwork element, i.e. round, oval or rectangular. \nHow to distinguish this? \nI can do it by regular expression matching for size parameter, but there must be a better way.\n\n<p><strong>Answer:</strong> Unfortunately, I am not aware of any good solution for this.\nWhat does your solution look like?\n\n<p><strong>Response:</strong> I assumed that if the family name like \"round duct\" is shown in Revit it would also be accessible through the API. As I see, that was a hasty assumption :)\n\n<p>To my work around: I simply noticed that the size parameter is displayed in a manner sufficient to clearly identify most duct elements. \nHere is a code snippet to explain exactly what I mean:\n\n<pre class=\"code\">\n  <span class=\"blue\">if</span>( size.Split( <span class=\"maroon\">'x'</span> ).Length == 3 ) <span class=\"green\">// could use a regex \"[0-9]x[0-9]+-[0-9]+/[0-9]+\" but splitting is less costly</span>\n    <span class=\"blue\">return</span> <span class=\"maroon\">\"rectangular2rectangular\"</span>;\n  <span class=\"blue\">else</span> <span class=\"blue\">if</span>( size.Split( <span class=\"maroon\">'/'</span> ).Length == 3 )\n    <span class=\"blue\">return</span> <span class=\"maroon\">\"oval2oval\"</span>;\n  <span class=\"blue\">else</span> <span class=\"blue\">if</span>( \n    <span class=\"blue\">new</span> <span class=\"teal\">Regex</span>( <span class=\"maroon\">@\"[0-9]+x[0-9]+-[0-9]+/[0-9]+\"</span> )\n      .IsMatch( size ) )\n        <span class=\"blue\">return</span> <span class=\"maroon\">\"rectangular2oval\"</span>;\n  <span class=\"blue\">else</span> <span class=\"blue\">if</span>( \n    <span class=\"blue\">new</span> <span class=\"teal\">Regex</span>( <span class=\"maroon\">@\"[0-9]+/[0-9]+-[0-9]+x[0-9]+\"</span> )\n      .IsMatch( size ) )\n        <span class=\"blue\">return</span> <span class=\"maroon\">\"oval2rectangular\"</span>;\n  <span class=\"blue\">else</span> <span class=\"blue\">if</span>( \n    <span class=\"blue\">new</span> <span class=\"teal\">Regex</span>( <span class=\"maroon\">@\"[0-9]+[^0-9]-[0-9]+x[0-9]+\"</span> )\n      .IsMatch( size ) )\n        <span class=\"blue\">return</span> <span class=\"maroon\">\"round2rectangular\"</span>;\n  <span class=\"blue\">else</span> <span class=\"blue\">if</span>( \n    <span class=\"blue\">new</span> <span class=\"teal\">Regex</span>( <span class=\"maroon\">@\"[0-9]+x[0-9]+-[0-9]+[^0-9]\"</span> )\n      .IsMatch( size ) )\n        <span class=\"blue\">return</span> <span class=\"maroon\">\"rectangular2round\"</span>;\n  <span class=\"blue\">else</span> <span class=\"blue\">if</span>( \n    <span class=\"blue\">new</span> <span class=\"teal\">Regex</span>( <span class=\"maroon\">@\"[0-9]+[^0-9]-[0-9]+/[0-9]+\"</span> )\n      .IsMatch( size ) )\n        <span class=\"blue\">return</span> <span class=\"maroon\">\"round2oval\"</span>;\n  <span class=\"blue\">else</span> <span class=\"blue\">if</span>( \n    <span class=\"blue\">new</span> <span class=\"teal\">Regex</span>( <span class=\"maroon\">@\"[0-9]+/[0-9]+-[0-9]+[^0-9]\"</span> )\n      .IsMatch( size ) )\n        <span class=\"blue\">return</span> <span class=\"maroon\">\"oval2round\"</span>;\n  <span class=\"blue\">else</span> <span class=\"blue\">if</span>( \n    <span class=\"blue\">new</span> <span class=\"teal\">Regex</span>( <span class=\"maroon\">@\"[0-9]+[^0-9]-[0-9]+[^0-9]\"</span> )\n      .IsMatch( size ) )\n        <span class=\"blue\">return</span> <span class=\"maroon\">\"round2round\"</span>;\n  <span class=\"blue\">else</span> { <span class=\"blue\">return</span> <span class=\"maroon\">\"other case\"</span>; }\n</pre>\n<p>By the way, is there any convenient way to check if some parameter exists? \nElement.get_Parameter(\"some_param\") throws an exception if parameter doesn't exist. \nThere is a method Element.Parameters.Contains, but I don't know how to use it for a given parameter name.\nI want to check if an element has my shared parameter attached.\n\n<p><strong>Answer:</strong> Thank you for your interesting sample code. \nNow I see what you mean by regular expressions, of course. \n\n<p>I have one possible enhancement suggestion to make: if you call this method many times, I would suggest compiling the regular expressions and caching the compiled version instead of re-instantiating them all on each call.\n\n<p>Regarding checking whether a parameter exists, I always suggest using built-in parameters as much as possible. \nIf you call Element.get_Parameter( BuiltInParameter ) with an enum value that does not exist on the given element, it simply returns null without throwing an exception, I believe. \nOf course that will not work for family parameters with no corresponding built-in parameter enum value. You could also try finding the Definition class instance representing the named parameter and calling Element.get_Parameter( Definition ). \nThat might return null as well instead of throwing an exception, but I don't know for sure.\n\n<p>By the way, your code includes the following expression:\n\n<!--\n\n<pre class=\"code\">\n  return ( e.Category.Id.Equals( \n    e.Document.Settings.Categories.get_Item( c ).Id ) ) \n      ? true \n      : false;\n</pre>\n\n<p>This is exactly equivalent to the following less verbose statement:\n\n-->\n<pre class=\"code\">\n  <span class=\"blue\">return</span> e.Category.Id.Equals(\n    e.Document.Settings.Categories.get_Item(\n      c ).Id );\n</pre>\n<p>This can be significantly shortened and also implemented more effectively by using the \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2009/06/category-comparison-and-model-element-selection-revisited.html\">\ncategory comparison casting the built-in category to an integer</a>:\n\n<pre class=\"code\">\n  <span class=\"blue\">return</span> e.Category.Id.IntegerValue.Equals( \n    (<span class=\"blue\">int</span>) c );\n</pre>\n<p>I implemented a new Building Coder sample command CmdMepElementShape to test your method, and included the regular expression caching that I suggested.\nIt fails for imperial units, though.\n\n<p><strong>Response:</strong> Hmm, I didn't think about imperial units. \nI work with the metric unit system and the regular expressions in my function are compatible with this. \nI extended it to work with imperial units as well, for some selected part types.\nThere was not that much to modify, actually.\n\n<p>There are quite a lot part types, though, and many are not handled yet. \n\n<p>I think it would be sufficient to make this function work fully correctly only for transitions and elbows, to start with.\nThat will demonstrate the main principle. \nIf someone needs to handle other part types, it can be done analogously.\n\n<p>I couldn't switch my Revit to imperial units, so I'm not 100% sure if my regular expressions will work correctly. \nI could switch parameters like Length in Manage &gt; Project Units, but I couldn't switch Size.\nI read that I can choose units system during Revit installation, so I tried to do this with a fresh installation, but I couldn't switch units in \"Configure\" because the option was blocked – maybe because it saw that country was Poland, I don't know.\nI even downloaded the newest update especially, and both metric and imperial templates – with no result.\n\n<p>Therefore, I don't know how Size parameter can be displayed by Revit in other than metric units – as \"fractional inches\" or \"decimal inches\" or else... and I had to write these regular expressions blindly.\nIn metric units, for example, the Size parameter is always rounded to millimetres. \n\n<p>I would be grateful if you check them again and where possible improve them, because that would be useful information for me as well. \nThe regular expressions for metric units, as previously, work fine. \nThe important thing is that the principles be clear for everyone.\n\n<p>Thinking further about it, I noticed two disadvantages of this solution.\n\n<p>The first one is that it has to contain regular expressions handling all Size parameter display cases due to the different units (optimistically only two: metric/imperial, pessimistically: many cases from \"project units\" formats – I don't know Revit well enough yet to be sure how it looks like but looking at metric example I think that would be the optimistic one).\n\n<p>Secondly, it returns the element shape well, but if one needs information about shape changes in the flow direction (like me), additional information about at least the preceding element is needed.\n\n<p>Here is a screen snapshot from a fragment of a sample project to show what I mean:\n\n<center>\n<img alt=\"Duct shape sequence\" src=\"img/duct_shape_sequence.png\"/>\n</center>\n<p>At first I assumed optimistically that the Size parameter value is dependent on the sequence in the flow direction, but it isn't. \nThe shape is returned from the family definition. \nI tried to find some other parameter responsible for storing information about element's rotation in relation to flow direction or even the preceding path element but I only found parameters storing rotation/facing orientation/hand orientation in relation to absolute coordinates. \nActually, this doesn't have to be a disadvantage at all – it depends on the application. :)\n\n<p>You told me that the Element.get_Parameter method doesn't throw an exception for BuiltInParameters. This could be good solution for the first disadvantage (elements of different part types has different set of parameters), because it is independent on units system but it has its own weakness: we lose information about element shapes sequence completely.\n\n<p>I think the best solution would be using mix of the two above methods: checking existence of specific parameters for specified part type/category and the Size parameter analysis.\n\n<p><strong>Answer:</strong> Some additional information on flow direction is available from the element connectors.\n\n<p>Actually, come to think of it, the shape of the duct is available from the connectors as well.\nThat might be a much more reliable and effective method to address this issue.\nSorry for thinking of this so late.\n\n<p>Anyway, here is the complete code of the CmdMepElementShape sample command in its current state.\nFirst, we have the regular expression cache implementation that I mentioned above:\n\n<pre class=\"code\">\n<span class=\"blue\">class</span> <span class=\"teal\">RegexCache</span> : <span class=\"teal\">Dictionary</span>&lt;<span class=\"blue\">string</span>, <span class=\"teal\">Regex</span>&gt;\n{\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n  <span class=\"gray\">///</span><span class=\"green\"> Apply regular expression pattern matching </span>\n  <span class=\"gray\">///</span><span class=\"green\"> to a given input string. The compiled </span>\n  <span class=\"gray\">///</span><span class=\"green\"> regular expression is cached for efficient </span>\n  <span class=\"gray\">///</span><span class=\"green\"> future reuse.</span>\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;param name=\"pattern\"&gt;</span><span class=\"green\">Regular expression pattern</span><span class=\"gray\">&lt;/param&gt;</span>\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;param name=\"input\"&gt;</span><span class=\"green\">Input string</span><span class=\"gray\">&lt;/param&gt;</span>\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;returns&gt;</span><span class=\"green\">True if input matches pattern, else false</span><span class=\"gray\">&lt;/returns&gt;</span>\n  <span class=\"blue\">public</span> <span class=\"blue\">bool</span> Match( <span class=\"blue\">string</span> pattern, <span class=\"blue\">string</span> input )\n  {\n    <span class=\"blue\">if</span>( !ContainsKey( pattern ) )\n    {\n      Add( pattern, <span class=\"blue\">new</span> <span class=\"teal\">Regex</span>( pattern ) );\n    }\n    <span class=\"blue\">return</span> <span class=\"blue\">this</span>[pattern].IsMatch( input );\n  }\n}\n</pre>\n<p>Then the predicate method to determine whether an element has a given built-in category:\n\n<pre class=\"code\">\n<span class=\"blue\">static</span> <span class=\"blue\">bool</span> is_element_of_category( \n  <span class=\"teal\">Element</span> e, \n  <span class=\"teal\">BuiltInCategory</span> c )\n{\n  <span class=\"green\">//return e.Category.Id.Equals( </span>\n  <span class=\"green\">//  e.Document.Settings.Categories.get_Item( </span>\n  <span class=\"green\">//    c ).Id );</span>\n \n  <span class=\"blue\">return</span> e.Category.Id.IntegerValue.Equals( \n    (<span class=\"blue\">int</span>) c );\n}\n</pre>\n<p>Here is the main method we have been discussing, to determine a ductwork element's shape from its MEP PartType and Size parameter:\n\n<pre class=\"code\">\n<span class=\"blue\">static</span> <span class=\"blue\">string</span> GetElementShape( <span class=\"teal\">Element</span> e )\n{\n  <span class=\"blue\">if</span>( is_element_of_category( e, \n    <span class=\"teal\">BuiltInCategory</span>.OST_DuctCurves ) )\n  {\n    <span class=\"green\">// simple case, no need to use regular expression</span>\n \n    <span class=\"blue\">string</span> size = e.get_Parameter( <span class=\"maroon\">\"Size\"</span> )\n      .AsString();\n \n    <span class=\"blue\">if</span>( size.Split( <span class=\"maroon\">'x'</span> ).Length == 2 )\n      <span class=\"blue\">return</span> <span class=\"maroon\">\"rectangular\"</span>;\n    <span class=\"blue\">else</span> <span class=\"blue\">if</span>( size.Split( <span class=\"maroon\">'/'</span> ).Length == 2 )\n      <span class=\"blue\">return</span> <span class=\"maroon\">\"oval\"</span>;\n    <span class=\"blue\">else</span>\n      <span class=\"blue\">return</span> <span class=\"maroon\">\"round\"</span>;\n  }\n  <span class=\"blue\">else</span> <span class=\"blue\">if</span>( is_element_of_category( e, \n    <span class=\"teal\">BuiltInCategory</span>.OST_DuctFitting ) )\n  {\n    <span class=\"teal\">FamilyInstance</span> fi = e <span class=\"blue\">as</span> <span class=\"teal\">FamilyInstance</span>;\n \n    <span class=\"blue\">if</span>( fi != <span class=\"blue\">null</span> &amp;&amp; fi.MEPModel <span class=\"blue\">is</span> <span class=\"teal\">MechanicalFitting</span> )\n    {\n      <span class=\"blue\">string</span> size = e.get_Parameter( <span class=\"maroon\">\"Size\"</span> )\n        .AsString();\n \n      <span class=\"teal\">PartType</span> partType = ( fi.MEPModel <span class=\"blue\">as</span> \n        <span class=\"teal\">MechanicalFitting</span> ).PartType;\n \n      <span class=\"blue\">if</span>( <span class=\"teal\">PartType</span>.Elbow == partType\n        || <span class=\"teal\">PartType</span>.Transition == partType )\n      {\n        <span class=\"green\">// more complex case</span>\n \n        <span class=\"blue\">if</span>( size.Split( <span class=\"maroon\">'x'</span> ).Length == 3 ) <span class=\"green\">// or use Regex(\"[0-9]x[0-9]+-[0-9]+/[0-9]+\") but splitting is less costly</span>\n          <span class=\"blue\">return</span> <span class=\"maroon\">\"rectangular2rectangular\"</span>;\n        <span class=\"blue\">else</span> <span class=\"blue\">if</span>( size.Split( <span class=\"maroon\">'/'</span> ).Length == 3 ) <span class=\"green\">// but if in imperial units size is in fractional inches format it has to be replaced by another regular expression</span>\n          <span class=\"blue\">return</span> <span class=\"maroon\">\"oval2oval\"</span>;\n        <span class=\"blue\">else</span> <span class=\"blue\">if</span>( _regexCache.Match( \n          <span class=\"maroon\">\"[0-9]+\\\"?x[0-9]+\\\"?-[0-9]+\\\"?/[0-9]+\\\"?\"</span>, size ) )\n            <span class=\"blue\">return</span> <span class=\"maroon\">\"rectangular2oval\"</span>;\n        <span class=\"blue\">else</span> <span class=\"blue\">if</span>( _regexCache.Match( \n          <span class=\"maroon\">\"[0-9]+\\\"?/[0-9]+\\\"?-[0-9]+\\\"?x[0-9]+\\\"?\"</span>, size ) )\n            <span class=\"blue\">return</span> <span class=\"maroon\">\"oval2rectangular\"</span>;\n        <span class=\"blue\">else</span> <span class=\"blue\">if</span>( _regexCache.Match( \n          <span class=\"maroon\">\"[0-9]+\\\"?[^0-9]-[0-9]+\\\"?x[0-9]+\\\"?\"</span>, size ) )\n            <span class=\"blue\">return</span> <span class=\"maroon\">\"round2rectangular\"</span>;\n        <span class=\"blue\">else</span> <span class=\"blue\">if</span>( _regexCache.Match( \n          <span class=\"maroon\">\"[0-9]+\\\"?x[0-9]+\\\"?-[0-9]+\\\"?[^0-9]\"</span>, size ) )\n            <span class=\"blue\">return</span> <span class=\"maroon\">\"rectangular2round\"</span>;\n        <span class=\"blue\">else</span> <span class=\"blue\">if</span>( _regexCache.Match( \n          <span class=\"maroon\">\"[0-9]+\\\"?[^0-9]-[0-9]+\\\"?/[0-9]+\\\"?\"</span>, size ) )\n            <span class=\"blue\">return</span> <span class=\"maroon\">\"round2oval\"</span>;\n        <span class=\"blue\">else</span> <span class=\"blue\">if</span>( _regexCache.Match( \n          <span class=\"maroon\">\"[0-9]+\\\"?/[0-9]+\\\"?-[0-9]+\\\"?[^0-9]\"</span>, size ) )\n            <span class=\"blue\">return</span> <span class=\"maroon\">\"oval2round\"</span>;\n        <span class=\"blue\">else</span> <span class=\"blue\">if</span>( _regexCache.Match( \n          <span class=\"maroon\">\"[0-9]+\\\"?[^0-9]-[0-9]+\\\"?[^0-9]\"</span>, size ) )\n            <span class=\"blue\">return</span> <span class=\"maroon\">\"round2round\"</span>;\n        <span class=\"blue\">else</span> { <span class=\"blue\">return</span> <span class=\"maroon\">\"other case\"</span>; }\n      }\n      <span class=\"green\">// etc (for other part types)</span>\n      <span class=\"blue\">else</span> \n      { \n      }\n    }\n    <span class=\"green\">// etc (for other categories)</span>\n    <span class=\"blue\">else</span> \n    { \n    }\n  }\n  <span class=\"blue\">return</span> <span class=\"maroon\">\"unknown\"</span>;\n}\n</pre>\n<p>Finally, here is the external command class implementation and its Execute method, which ties it all together, prompts the user to select a test element, and displays the result:\n\n<pre class=\"code\">\n[<span class=\"teal\">Transaction</span>( <span class=\"teal\">TransactionMode</span>.ReadOnly )]\n[<span class=\"teal\">Regeneration</span>( <span class=\"teal\">RegenerationOption</span>.Manual )]\n<span class=\"blue\">class</span> <span class=\"teal\">CmdMepElementShape</span> : <span class=\"teal\">IExternalCommand</span>\n{\n  <span class=\"blue\">public</span> <span class=\"teal\">Result</span> Execute(\n    <span class=\"teal\">ExternalCommandData</span> commandData,\n    <span class=\"blue\">ref</span> <span class=\"blue\">string</span> message,\n    <span class=\"teal\">ElementSet</span> elements )\n  {\n    <span class=\"teal\">UIApplication</span> uiapp = commandData.Application;\n    <span class=\"teal\">UIDocument</span> uidoc = uiapp.ActiveUIDocument;\n    <span class=\"teal\">Application</span> app = uiapp.Application;\n    <span class=\"teal\">Document</span> doc = uidoc.Document;\n \n    <span class=\"teal\">Element</span> e = <span class=\"blue\">null</span>;\n \n    <span class=\"blue\">try</span>\n    {\n      e = <span class=\"teal\">Util</span>.SelectSingleElementOfType(\n       uidoc, <span class=\"blue\">typeof</span>( <span class=\"teal\">Element</span> ), <span class=\"maroon\">\"an element\"</span>, <span class=\"blue\">true</span> );\n    }\n    <span class=\"blue\">catch</span>( <span class=\"teal\">OperationCanceledException</span> )\n    {\n      message = <span class=\"maroon\">\"No element selected\"</span>;\n      <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n    }\n \n    <span class=\"teal\">Util</span>.InfoMsg( <span class=\"blue\">string</span>.Format(\n      <span class=\"maroon\">\"{0} is {1}\"</span>,\n      <span class=\"teal\">Util</span>.ElementDescription( e ),\n      GetElementShape( e ) ) );\n \n    <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Succeeded;\n  }\n}\n</pre>\n<p>Here is\n\n<!-- C:\\a\\doc\\revit\\blog\\zip\\bc_11_87.zip -->\n<a href=\"zip/bc_11_87.zip\">\nversion 2011.0.87.0</a>\n\nof The Building Coder samples including the complete source code and Visual Studio solution with the new command.\n\n<p>Many thanks to Max for his research, in-depth explanation and useful sample solution.\nBy the way, if you have suggestions for other ways to solve this, they will be more than welcome.\nPlease let us know.\nThank you!\n\n\n<p>***\n<p>The advantage of this is that it works in any flavour of Revit, even without RME, since it does not use the connector manager, which is only available in RME.\n</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p>"
  }
]