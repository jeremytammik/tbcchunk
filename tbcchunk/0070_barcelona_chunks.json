[
  {
    "original_filename": "0070_barcelona",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<style>\n.blue { color: blue; }\n.teal { color: teal; }\n.maroon { color: maroon; }\n.green { color: green; }\n</style>"
  },
  {
    "original_filename": "0070_barcelona",
    "header_text": "Barcelona Questions",
    "local_header_href": "#barcelona-questions",
    "chunk_text": "<h3>Barcelona Questions</h3><p>Thanks to Alex Vila Ortega of Autodesk Spain, I spent the last couple of days here in Barcelona giving a training class on the Revit API, with lots of professional and enthusiastic participants.\nHere are some of the questions that we explored.</p><a name=\"retrieve_windows_hosted_by_a_wall\"></a><p><strong>Question:</strong>\nHow can I retrieve all the windows hosted by a specific given wall?\n</p><p><strong>Answer:</strong>\nWell, one possibility is to make use of the\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2008/10/relationship-in.html\">\nrelationship inverter</a>\n\nthat we already discussed.\nThis will provide a global dictionary mapping each wall in the entire model to a list of all the windows it hosts.\nHere is an idea for a more direct and localised approach using API filtering:</p><p>We can make use of the fact that each window's host id is available not only from the FamilyInstance Host property, but also through the built-in parameter HOST_ID_PARAM.\nThis means that we can build a filter checking for the following combination of properties:</p><ul>\n<li>Category Windows.</li>\n<li>Type FamilyInstance.</li>\n<li>Built-in parameter value for HOST_ID_PARAM equal to the given wall element id.</li>\n</ul><p>The resulting Boolean 'and' combination should return all the windows hosted by a specific wall.</p><p><strong>Question:</strong>\nI create new levels through the API and that works fine.\nHowever, no views are generated for these levels.\nHow can I generate views for the new levels?</p><p><strong>Answer:</strong>\nYou might get some ideas by searching globally in the SDKSamples2009 solution for the NewLevel method, which is used to create a new level.\nOne of the places it is used is the FrameBuilder SDK sample, in FrameData.cs:</p><pre class=\"code\">\n  <span class=\"teal\">Level</span> newLevel\n    = createDoc.NewLevel( elevation );\n\n  createDoc.NewViewPlan( newLevel.Name,\n    newLevel, <span class=\"teal\">ViewType</span>.FloorPlan );\n</pre><p>This appears to be creating a level and immediately creating a new plan view for it as well, which seems to be just what you are looking for.</p><a name=\"open_transaction_in_event_handler\"></a><p><strong>Question:</strong>\nWe need to update some parameter values on certain elements from the document closed and saved events on the application object.\nTo do so, we implemented an external application class App in order to hook up automatic synchronisation to document save and close events.\nWe created a method SynchroniseAreaParameters to update the appropriate element parameters, which is registered as an event handler for the OnDocumentClosed, OnDocumentSaved and OnDocumentSavedAs events:</p><pre class=\"code\">\n<span class=\"blue\">public</span> <span class=\"blue\">class</span> <span class=\"teal\">App</span> : <span class=\"teal\">IExternalApplication</span>\n{\n  <span class=\"blue\">void</span> SynchroniseAreaParameters(\n    <span class=\"teal\">Document</span> doc )\n  {\n    <span class=\"teal\">ElementIterator</span> i = doc.get_Elements(\n      <span class=\"blue\">typeof</span>( <span class=\"teal\">Room</span> ) );\n \n    <span class=\"blue\">while</span>( i.MoveNext() )\n    {\n      <span class=\"teal\">Command</span>.UpdateAreaParameter(\n        i.Current <span class=\"blue\">as</span> <span class=\"teal\">Room</span> );\n    }\n  }\n \n  <span class=\"blue\">public</span> <span class=\"teal\">IExternalApplication</span>.<span class=\"teal\">Result</span> OnStartup(\n    <span class=\"teal\">ControlledApplication</span> app )\n  {\n    app.OnDocumentClosed\n      += <span class=\"blue\">new</span> <span class=\"teal\">DocumentClosedEventHandler</span>(\n        SynchroniseAreaParameters );\n \n    app.OnDocumentSaved\n      += <span class=\"blue\">new</span> <span class=\"teal\">DocumentSavedEventHandler</span>(\n        SynchroniseAreaParameters );\n \n    app.OnDocumentSavedAs\n      += <span class=\"blue\">new</span> <span class=\"teal\">DocumentSavedAsEventHandler</span>(\n        SynchroniseAreaParameters );\n \n    <span class=\"blue\">return</span> <span class=\"teal\">IExternalApplication</span>.<span class=\"teal\">Result</span>.Succeeded;\n  }\n \n  <span class=\"blue\">public</span> <span class=\"teal\">IExternalApplication</span>.<span class=\"teal\">Result</span> OnShutdown( <span class=\"teal\">ControlledApplication</span> app )\n  {\n    app.OnDocumentClosed\n      -= <span class=\"blue\">new</span> <span class=\"teal\">DocumentClosedEventHandler</span>(\n        SynchroniseAreaParameters );\n \n    app.OnDocumentSaved\n      -= <span class=\"blue\">new</span> <span class=\"teal\">DocumentSavedEventHandler</span>(\n        SynchroniseAreaParameters );\n \n    app.OnDocumentSavedAs\n      -= <span class=\"blue\">new</span> <span class=\"teal\">DocumentSavedAsEventHandler</span>(\n        SynchroniseAreaParameters );\n \n    <span class=\"blue\">return</span> <span class=\"teal\">IExternalApplication</span>.<span class=\"teal\">Result</span>.Succeeded;\n  }\n}\n</pre><p>Unfortunately, this does not work, although we can see in the debugger that the notifications are dispatched as expected and each step executes correctly with no error.\nWhy are the parameters not updated accordingly?</p><p><strong>Answer:</strong>\nThe reason why no changes are applied to the document is that you need to encapsulate the modification in a transaction.\nIn the context of an external command, the Revit API will automatically begin a transaction for you.\nDepending on the IExternalCommand.Result value returned from the external command's Execute method, the transaction will be either closed or aborted.\nWithin the context of an event handler, however, no such transaction will be automatically opened for you, so you are responsible for doing so yourself.\nAdding two lines to SynchroniseAreaParameters to begin and end a transaction solved the problem:</p><pre class=\"code\">\n  <span class=\"blue\">void</span> SynchroniseAreaParameters(\n    <span class=\"teal\">Document</span> doc )\n  {\n    <span class=\"blue\">if</span>( doc.BeginTransaction() )\n    {\n      <span class=\"teal\">ElementIterator</span> i = doc.get_Elements(\n        <span class=\"blue\">typeof</span>( <span class=\"teal\">Room</span> ) );\n \n      <span class=\"blue\">while</span>( i.MoveNext() )\n      {\n        <span class=\"teal\">Command</span>.UpdateAreaParameter(\n          i.Current <span class=\"blue\">as</span> <span class=\"teal\">Room</span> );\n      }\n      doc.EndTransaction();\n    }\n  }\n</pre><p>I am looking forward to more exciting topics to explore and things to learn in our remaining day together.</p>"
  }
]