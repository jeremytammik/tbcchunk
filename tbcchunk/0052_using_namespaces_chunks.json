[
  {
    "original_filename": "0052_using_namespaces",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<style>\n.blue { color: blue; }\n.teal { color: teal; }\n.maroon { color: maroon; }\n.green { color: green; }\n</style>"
  },
  {
    "original_filename": "0052_using_namespaces",
    "header_text": "Using Namespaces",
    "local_header_href": "#using-namespaces",
    "chunk_text": "<h3>Using Namespaces</h3><p>Autodesk University is done and finished, but no rest for the wicked ... I am now on the Western European stage of the\n\n<a href=\"http://www.autodesknews.de/2008_developer_days\">\nDevdays</a>\n\nconference tour, with a first stop in London.\n\nOn the trip here from Las Vegas, I started to write about polygon area calculation and determining the outer boundary loop for floor slabs and walls for the next post or two,\nand ran into another little issue that I thought might be worth discussing first.\nLike many other aspects of life, it has to do with the principle of KISS ... keep it simple, stupid.\nThis is mostly very sound advice for every human being, and especially applicable to programming.\nThe temptation to introduce complexity in software development is huge and mostly detrimental.\nThe best solution is mostly the simplest.\nOne important starting point is keeping source code minimal and easy to read,\nand one aspect related to readability in .NET is namespace handling.</p><p>In .NET programming, every class has a name, which is defined within a namespace.\nThe fully qualified class name is the class name itself together with the namespace prefix, using the dot '.' as a separator.\nFor instance, the entire Revit API is encapsulated in the Autodesk.Revit namespace.\nThat namespace defines some classes and interfaces directly, such as the CommandData class and the IExternalCommand interface.\nIt also defines additional nested namespaces, for instance the Geometry one, and so on.\nOne class inside the Autodesk.Revit.Geometry namespace is the class XYZ, whose fully qualified class name is Autodesk.Revit.Geometry.XYZ.</p><p>You may have noticed that I avoid explicitly using fully qualified class names in the code.\nInstead, I make use of <code>using</code> statements in the module header, enabling me to make local use of the unqualified class names from those namespaces.\nIn some cases, we need to make use of a class that has an ambiguous name, i.e. two classes with the same name occur in different namespaces, and we would like to make use of both namespaces at the same time.\nIn this case, we can disambiguate the two classes by defining different aliases for them.\nFor instance, we have done this for the Element classes residing in the Autodesk.Revit and Autodesk.Revit.Geometry namespaces in the CmdWallProfile.cs module:</p><pre class=\"code\">\n<span class=\"blue\">using</span> <span class=\"teal\">RvtElement</span> = Autodesk.Revit.<span class=\"teal\">Element</span>;\n<span class=\"blue\">using</span> <span class=\"teal\">GeoElement</span> = Autodesk.Revit.Geometry.<span class=\"teal\">Element</span>;\n</pre><p>We could avoid the need for this disambiguation by avoiding making simultaneous global use of both these namespaces.\nThat is the approach we used so far in the Util.cs module, which currently has the following namespace header:</p><pre class=\"code\">\n<span class=\"blue\">using</span> System;\n<span class=\"blue\">using</span> System.Collections.Generic;\n<span class=\"blue\">using</span> System.Diagnostics;\n<span class=\"blue\">using</span> Autodesk.Revit;\n<span class=\"blue\">using</span> Autodesk.Revit.Elements;\n<span class=\"blue\">using</span> <span class=\"teal\">Curve</span> = Autodesk.Revit.Geometry.<span class=\"teal\">Curve</span>;\n<span class=\"blue\">using</span> <span class=\"teal\">CylindricalFace</span> = Autodesk.Revit.Geometry.<span class=\"teal\">CylindricalFace</span>;\n<span class=\"blue\">using</span> <span class=\"teal\">Edge</span> = Autodesk.Revit.Geometry.<span class=\"teal\">Edge</span>;\n<span class=\"blue\">using</span> <span class=\"teal\">PlanarFace</span> = Autodesk.Revit.Geometry.<span class=\"teal\">PlanarFace</span>;\n<span class=\"blue\">using</span> <span class=\"teal\">Transform</span> = Autodesk.Revit.Geometry.<span class=\"teal\">Transform</span>;\n<span class=\"blue\">using</span> <span class=\"teal\">XYZ</span> = Autodesk.Revit.Geometry.<span class=\"teal\">XYZ</span>;\n<span class=\"blue\">using</span> <span class=\"teal\">XYZArray</span> = Autodesk.Revit.Geometry.<span class=\"teal\">XYZArray</span>;\n</pre><p>Instead of including the entire Geometry namespace and disambiguating the duplicate Element class,\nwe defined individual aliases for each single geometry class that we make use of.\nTo begin with, there were just one or two of these required, but the list started growing and has now reached a size\nat which I prefer to eliminate it, include the entire Geometry namespace instead, which introduces the Element class ambiguity,\nand add the same disambiguation aliases for that instead, so I am replacing the lines above by</p><pre class=\"code\">\n<span class=\"blue\">using</span> System;\n<span class=\"blue\">using</span> System.Collections.Generic;\n<span class=\"blue\">using</span> System.Diagnostics;\n<span class=\"blue\">using</span> Autodesk.Revit;\n<span class=\"blue\">using</span> Autodesk.Revit.Elements;\n<span class=\"blue\">using</span> Autodesk.Revit.Geometry;\n<span class=\"blue\">using</span> <span class=\"teal\">RvtElement</span> = Autodesk.Revit.<span class=\"teal\">Element</span>;\n</pre><p>Quite a bit shorter than the list above. This initially produces an error message</p><p style=\"background-color:lightgrey; font-family:courier new; font-size : 90%; line-height : 120%\">\n'Element' is an ambiguous reference between 'Autodesk.Revit.Element' and 'Autodesk.Revit.Geometry.Element'\n</p><p>This expected error is obviously fixed by replacing the occurrences of Element by RvtElement.</p><p>So much for that.\nAs said, I am working on an area calculation algorithm for the floor slab and wall boundary loops.\nInitially, we thought that the outer loop was always listed first in the Revit Face class EdgeLoops property, followed by the inner loops representing holes, i.e. openings such as shafts, doors or windows.\nWe now have a case where this is not true, so we will calculate each boundary loop polygon's area in order to determine which is the largest one.\nStay tuned and walk in beauty.</p>"
  }
]