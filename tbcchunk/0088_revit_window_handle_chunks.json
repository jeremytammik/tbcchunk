[
  {
    "original_filename": "0088_revit_window_handle",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<style>\n.blue { color: blue; }\n.teal { color: teal; }\n.maroon { color: maroon; }\n.green { color: green; }\n</style>"
  },
  {
    "original_filename": "0088_revit_window_handle",
    "header_text": "Revit Window Handle and Modeless Dialogues",
    "local_header_href": "#revit-window-handle-and-modeless-dialogues",
    "chunk_text": "<h3>Revit Window Handle and Modeless Dialogues</h3><p>Even though we cannot make use of the Revit API unless we are inside a Revit external command context, which is a modal state, there is still a lot of very useful functionality that can be provided with the help of modeless dialogue boxes.\nModeless dialogues require knowledge of the Revit main window handle.</p><p>As an example of a modeless dialogue, we will implement a form which is displayed in parallel with the Revit user interaction for selecting elements on the graphic screen.\nOur implementation of this dialogue simply reports the current contents of the Revit selection set.\nObviously, it could be adapted to prompt the user to select only specific elements, or a very specific combination of them.</p><p>In order to host a modeless dialogue box, one needs to supply a parent window handle.\nThis ensures that the modeless form is displayed on top of the parent window.</p><p>In .NET, a modeless dialogue is displayed to the user through the Form.Show method.\nIt has two overloads.\nOne of them takes an IWin32Window argument, which is defined by the System.Windows.Forms namespace to encapsulate a windows handle.\nIn that case, the specified window becomes the top-level owner of the form being displayed.\nThe other overload takes no arguments, in which case the owner is unspecified.\nIf so, Windows has no knowledge that the modeless dialogue belongs to Revit, thus there is no guarantee that it will appear on top of the Revit window.\nIn fact, to the contrary, as soon as the Revit window is activated, it will hide the modeless form.\nThis will sabotage our intention of using the modeless form to display information to the Revit user.</p><p>Our first discussion on\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2008/12/driving-revit-from-outside.html\">\ndriving Revit from outside</a>\n\ndiscussed and demonstrated the use of FindWindow.\nIt requires either the window class name or the full window caption.\nThe window class name depends on the exact version of Revit, and also changes depending on the state of the application.\nFor instance, the Revit window class name is different depending on whether a document is currently opened or not.\nThe window caption is also variable, again depending on the flavour and state of Revit and the name of the current document.</p><p>Another way to obtain a window handle makes use of the .NET framework Process class.\nThis has two advantages:</p><ul>\n<li>This is pure .NET, no need make use of Win32 API calls.</li>\n<li>The process name is invariant, always \"Revit\".</li>\n</ul><p>This means we do not need to understand or import any methods from Win32 DLLs, and the code will work regardless of the Revit version number or flavour, i.e. Architecture, MEP, or Structure.</p><p>To retrieve all processes named \"Revit\", we can simply call Process.GetProcessesByName( \"Revit\" ).\nThat returns a list with zero or more entries of instances of the Process class.\nThe Process class provides a property MainWindowHandle to return its top level window handle.</p><p>As explained above, the Form.Show method takes an IWin32Window argument.\nThe value returned by the MainWindowHandle is an IntPtr, so we have to somehow convert it.\nOne way of doing so is to implement our own class implementing the IWin32Window interface.\nThe only required method is Handle, so our minimal window handle wrapper class implementation can look like this:</p><pre class=\"code\">\n<span class=\"blue\">public</span> <span class=\"blue\">class</span> <span class=\"teal\">WindowHandle</span> : <span class=\"teal\">IWin32Window</span>\n{\n  <span class=\"teal\">IntPtr</span> _hwnd;\n \n  <span class=\"blue\">public</span> WindowHandle( <span class=\"teal\">IntPtr</span> h )\n  {\n    <span class=\"teal\">Debug</span>.Assert( <span class=\"teal\">IntPtr</span>.Zero != h,\n      <span class=\"maroon\">\"expected non-null window handle\"</span> );\n \n    _hwnd = h;\n  }\n \n  <span class=\"blue\">public</span> <span class=\"teal\">IntPtr</span> Handle\n  {\n    <span class=\"blue\">get</span>\n    {\n      <span class=\"blue\">return</span> _hwnd;\n    }\n  }\n}\n</pre><p>The rest is quite easy and straightforward, actually.\nWe have implemented an external command CmdWindowHandle which encapsulates the following steps:</p><ul>\n<li>Determine the Revit top level window handle.</li>\n<li>Display a modeless form listing the current contents of the Revit selection set and prompting the user to continue the selection process.</li>\n<li>Drive the continued selection using the Revit API PickOne method.</li>\n</ul><p>Since we do not expect the Revit main window handle to change from one call of our external command to the next, we can determine it once and for all and store it in a static class variable _hWndRevit.\nWe initialise _hWndRevit to null, and set it on the first call to the command using the .NET GetProcessesByName and MainWindowHandle methods.</p><p>The form CmdWindowHandleForm is used to display the current contents of the Revit selection set.\nIt is simply a resizable form hosting one single label element, whose text can be set through a property LabelText:</p><pre class=\"code\">\n<span class=\"blue\">public</span> <span class=\"blue\">partial</span> <span class=\"blue\">class</span> <span class=\"teal\">CmdWindowHandleForm</span> : <span class=\"teal\">Form</span>\n{\n  <span class=\"blue\">public</span> CmdWindowHandleForm()\n  {\n    InitializeComponent();\n  }\n \n  <span class=\"blue\">public</span> <span class=\"blue\">string</span> LabelText\n  {\n    <span class=\"blue\">get</span>\n    {\n      <span class=\"blue\">return</span> label1.Text;\n    }\n    <span class=\"blue\">set</span>\n    {\n      label1.Text = <span class=\"blue\">value</span>;\n    }\n  }\n}\n</pre><p>We define two class variables for the default prompt and the Revit window handle:</p><pre class=\"code\">\n<span class=\"blue\">const</span> <span class=\"blue\">string</span> _prompt\n  = <span class=\"maroon\">\"Please select some elements.\"</span>;\n \n<span class=\"blue\">static</span> <span class=\"teal\">WindowHandle</span> _hWndRevit = <span class=\"blue\">null</span>;\n</pre><p>The rest is the implementation of the main command line, which realises the three steps listed above:</p><pre class=\"code\">\n<span class=\"blue\">if</span>( <span class=\"blue\">null</span> == _hWndRevit )\n{\n  <span class=\"teal\">Process</span>[] processes\n    = <span class=\"teal\">Process</span>.GetProcessesByName( <span class=\"maroon\">\"Revit\"</span> );\n \n  <span class=\"blue\">if</span>( 0 &lt; processes.Length )\n  {\n    <span class=\"teal\">IntPtr</span> h = processes[0].MainWindowHandle;\n    _hWndRevit = <span class=\"blue\">new</span> <span class=\"teal\">WindowHandle</span>( h );\n  }\n}\n \n<span class=\"teal\">Application</span> app = commandData.Application;\n<span class=\"teal\">Document</span> doc = app.ActiveDocument;\n<span class=\"teal\">Selection</span> sel = doc.Selection;\n \n<span class=\"blue\">using</span>( <span class=\"teal\">CmdWindowHandleForm</span> f\n  = <span class=\"blue\">new</span> <span class=\"teal\">CmdWindowHandleForm</span>() )\n{\n  f.Show( _hWndRevit );\n  <span class=\"blue\">bool</span> go = <span class=\"blue\">true</span>;\n  <span class=\"blue\">while</span>( go )\n  {\n    <span class=\"teal\">SelElementSet</span> ss = sel.Elements;\n    <span class=\"blue\">int</span> n = ss.Size;\n \n    <span class=\"blue\">string</span> s = <span class=\"blue\">string</span>.Format(\n      <span class=\"maroon\">\"{0} element{1} selected{2}\"</span>,\n      n, <span class=\"teal\">Util</span>.PluralSuffix( n ),\n      ((0 == n)\n        ? <span class=\"maroon\">\";\\n\"</span> + _prompt\n        : <span class=\"maroon\">\":\"</span> ) );\n \n    <span class=\"blue\">foreach</span>( <span class=\"teal\">Element</span> e <span class=\"blue\">in</span> ss )\n    {\n      s += <span class=\"maroon\">\"\\n\"</span>;\n      s += <span class=\"teal\">Util</span>.ElementDescription( e );\n    }\n    f.LabelText = s;\n    sel.StatusbarTip = _prompt;\n    go = sel.PickOne();\n  }\n}\n<span class=\"blue\">return</span> <span class=\"teal\">CmdResult</span>.Failed;\n</pre><p>Note that we can initialise the variable 'sel' for the document selection outside the loop.\nHowever, we cannot do the same for the currently selected elements stored in 'ss', because the sel.Elements property just returns a snapshot of the current state.\nTherefore, we need to reinitialise that variable on each loop iteration.</p><p>In real life, the application looks like this; if the Revit selection set is initially empty, it prompts us to select some elements:</p><img alt=\"Modeless form displaying prompt and empty selection set\" src=\"img/window_handle_none.png\"/><p>Every time a new pick is made, the contents of the dialogue update to reflect the new state:</p><img alt=\"Modeless form displaying some selected elements\" src=\"img/window_handle_some.png\"/><p>At any point, the application can determine that a valid selection has been made and terminate the interaction to process the elements, or the user can make an empty pick to cause PickOne to return false and terminate the loop.</p><p>Here is\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/files/bc10021.zip\">\nversion 1.0.0.21</a>\n\nof the complete Visual Studio solution with the new command CmdWindowHandle discussed here, as well as the\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2009/01/room-and-wall-adjacency.html\">\nroom and wall adjacency</a>\n\ncommand that we presented a few days ago, and an additional secret command that we have not presented in detail yet.\nBy the way, we are still working on the room and wall adjacency and will have something more to say about that and the Boolean operations for 2D polygons sometime soon.</p><p>As suggested below by Guy, I have updated the code to use GetCurrentProcess instead of GetProcessesByName.\nThis has several advantages:</p><ul>\n<li>It completely removes any dependency whatsoever on the Revit executable name.</li>\n<li>When running multiple Revit sessions, it ensures you get the one with no additional logic.</li>\n<li>It siplifies the code above, and removes the need for an array of processes.</li>\n</ul><p>Here is the simplified code snippet for the first step using GetCurrentProcess:</p><pre class=\"code\">\n<span class=\"blue\">if</span>( <span class=\"blue\">null</span> == _hWndRevit )\n{\n  <span class=\"teal\">Process</span> process\n    = <span class=\"teal\">Process</span>.GetCurrentProcess();\n \n  <span class=\"teal\">IntPtr</span> h = process.MainWindowHandle;\n  _hWndRevit = <span class=\"blue\">new</span> <span class=\"teal\">WindowHandle</span>( h );\n}\n</pre>"
  },
  {
    "original_filename": "0088_revit_window_handle",
    "header_text": "Various Places",
    "local_header_href": "#various-places",
    "chunk_text": "<h4>Various Places</h4><p>I originally started working on this topic during the Revit API training in Barcelona, then started writing this specific post in Terni in Italy.\nAsking for the single most important local sight of Terni, I was told there are none, this is an industrial town.\nOn second thoughts, the waterfall of Marmore was mentioned,\n\n<a href=\"http://www.marmore.it\">\nCascata delle Marmore</a>,\n\nwhich unfortunately closed before I got there.\nApparently, it is the highest waterfall in Europe.\nHard to believe, coming from Switzerland.\nFrom Terni I continued to the beautiful towns and cities of Perugia, Firenze, and Bologna.\nIn Perugia, I met Gaetano, with whom I spent a wonderful evening together practicing amateur philosophy and very basic Italian.\nIn Firenze and Bologna, I was impressed with the size of the cathedrals.\nI had originally thought of staying longer in Firenze, but my tourist allergy forced me to leave quickly.\nMassive tourism polarises the entire population to a degree that I simply cannot stand.\nI arrived in Verona in the north of Italy, which is much colder and where it has been raining incessantly.\nI learned the word settiornio, for the north part of somthing, etymologically derived from seven, for the seven stars of the Ursa minor or major or something.</p><p>By the time I finally get to post this, much more has happened.\nThe world's first Revit API training in Italian in Verona is complete.\nI met several extremely nice people and discovered that I like Italy very much indeed.\nI performed some research on tiramisu and discovered a simple dessert of mascarpone con caffee which I liked even better.\nI had two nice dinners with Stefano and Giovanna, and in the last one we had some pizza by the meter.</p>"
  }
]