[
  {
    "original_filename": "1076_framing_xsec_analyse",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<head>\n<link href=\"bc.css\" rel=\"stylesheet\" type=\"text/css\"/>\n<meta content=\"text/html; charset=utf-8\" http-equiv=\"Content-Type\"/>\n</head>"
  },
  {
    "original_filename": "1076_framing_xsec_analyse",
    "header_text": "Security, Framing Cross Section Analyser and REX",
    "local_header_href": "#security-framing-cross-section-analyser-and-rex",
    "chunk_text": "<h3>Security, Framing Cross Section Analyser and REX</h3><p>My topic for today is structural cross section analysis, i.e. determination of the cross section profile of beam, columns, braces, etc., and the various completely different approaches one can take to achieve this.</p><p>I also demonstrate how to make use of some of the powerful functionality provided by the REX toolkit without building my entire application on top of the REX framework.</p><p>Before getting to that, though, let me mention where we are with the DevDays conference tour:\n\n<ul>\n<li><a href=\"#2\">DevDays in Milano and security heads-up</a></li>\n<li><a href=\"#3\">Five structural framing cross section analysis approaches</a></li>\n<li><a href=\"#4\">Sample FramingXsecAnalyzer implementation for Revit 2012</a></li>\n<li><a href=\"#5\">Pure Revit API approach</a></li>\n<li><a href=\"#6\">Using REX without the REX framework</a></li>\n<li><a href=\"#7\">Cross section analysis using REX</a></li>\n<li><a href=\"#8\">Migrating from Revit 2012 to Revit 2014</a></li>\n<li><a href=\"#9\">Obsolete GeoSnoop</a></li>\n<li><a href=\"#10\">Download</a></li>\n</ul>\n<a name=\"2\"></a>\n<h4>DevDays in Milano and Security</h4>\n<p>We held our second West European Devday in Milano on Tuesday.</p>\n<p>Here is Jim Quanci entertaining his enthralled audience:</p>\n<center>\n<img alt=\"Jim Quanci at the ADN DevDays Conference in Milano\" src=\"file:///j/photo/jeremy/2013/2013-12-10_milano/devday_cropped.jpeg\" width=\"400\"/>\n</center>\n<p>One piece of Jim's presentation deals with security.\nThis is an important topic in its own right, of course, and always has been, but the cloud and mobile discussion brings it to people's attention again, so this also discusses the Autodesk trust center and security in the 360 environment.\nMost of all, though, it highlights the fact that you and your customers need to have a basic understanding of the issue, and somebody in your organisation needs to know a bit more than just the basics.</p>\n<p>I think it is so important and Jim's ten-minute overview so effective and refreshing I decided to publish it right here and now:</p>\n<ul>\n<li><a href=\"http://thebuildingcoder.typepad.com/devday/2013/security_jim_quanci.pdf\">Slide deck</a></li>\n<li><a href=\"http://thebuildingcoder.typepad.com/devday/2013/security_jim_quanci.mp3\">Audio</a></li>\n</ul>\n<p>Something else happened after the conference, travelling...</p>\n<p>On Monday, Jim and I were joking that I arrive at the airport gate at the last minute, and it was about time I get burned.</p>\n<p>The retribution for that hubris was immediate: I missed the plane from Milano to London, mistaking the gate closing time for the opening time.</p>\n<p>I arrived three minutes late, the gate was adamantly closed, and there was nothing I could do – in spite of this being Italy, after all.</p>\n<p>A long taxi ride from Linate to Malpensa and a hefty cancellation fee later, I am now gratefully sitting on a different plane, thanking the powers that be for not being harsher to me.</p>\n<p>Back to the topic at hand...</p>\n<a name=\"3\"></a>\n<h4>Five Structural Framing Cross Section Analysis Approaches</h4>\n<p>This is actually a topic I have been wanting to write about for a long time now – how to determine the cross section of a structural framing member.</p>\n<p>In fact, I implemented a solution (two solutions!) addressing this several years ago, and never got around to publishing.</p>\n<p>There are quite a number of different possible approaches to take.</p>\n<p>Here is one of several developer queries that prompted this exploration:</p>\n<p><strong>Question:</strong> A Structural Framing or Structural Column object can be open shape such as T Shape, I Shape or L Shape, or an enclosed shape such as Rectangular Shape, Square Shape or Round Shape.</p>\n<p>Does the Revit API provide a way to find out whether a shape is open or enclosed, and what kind of shape it is?</p>\n<p><strong>Answer:</strong> The Revit API does not provide any direct API method to tell whether a cross section of a structural column or beam is open or closed, or extract its profile.</p>\n<p>There are, however, several reliable approaches you can implement yourself based on the functionality provided both by the Revit API itself and the Revit Extensions REX.</p>\n<p>You can always access the basic element geometry.\nThe FamilyInstance.GetOriginalGeometry method returns the member geometry before joins, cuts, etc. are applied.\nThere are various ways to calculate the cross section contour of the structural element from that and analyse it to find the best match according to pre-determined internal definitions.\nIn some cases, it may be pretty simple, since you can check for rectangular and round shapes, existence of inner loops, etc.</p>\n<p>Here are a few different approaches that come to mind:</p>\n<p><b>1.</b> For structural extrusions, the REX content generator includes a cross section analysis tool providing automatic section recognition functionality:</p>\n<ul>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2011/04/the-rex-sdk.html\">\nThe REX SDK</a></li>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2011/06/extensions-for-revit-2012.html\">\nExtensions for Revit 2012</a></li>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2011/12/rex-content-generator.html\">\nREX Content Generator</a></li>\n</ul>\n<p><b>2.</b> Some families such as gutter, fascia, slab edge, railings, etc., are based on profiles consisting of 2D elements, e.g., lines, arcs, circles, etc.\nYou might be able to use some\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2011/11/undocumented-elementid-relationships.html\">\nunofficial element id relationships</a> to\n\naccess those elements knowing the element id of the family symbol or its profile.\nThey can be used, for example, to determine the relationship between a\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/05/curtain-wall-geometry.html\">\ncurtain wall and its panels</a> or\n\nbetween a stacked wall and it basic wall components.</p>\n<p><b>3.</b> From the element, you can retrieve its solid geometry and location line.\nThe profile lines can be determined by intersecting a plane that is perpendicular to the element location line with its solid.\nI can imagine that the REX content generator does something like this internally, as well.</p>\n<p><b>4.</b> You can set up a section view cutting the framing element perpendicularly using a\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2012/06/create-section-view-parallel-to-wall.html\">\nview perpendicular to the element location line</a> and\n\nask the element for its view-specific geometry, the\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2011/08/section-view-geometry.html\">\nsection view geometry</a> in\n\nthat specific view.\nThen, just ignore all lines that are not lying on the view plane and analyse the face loops in the cut plane.</p>\n<p><b>5.</b> Use the\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/about-the-author.html#5.29\">\nExtrusionAnalyzer</a> –\n\nto do so, grab the FamilyInstance GetOriginalGeometry that returns the member geometry before joins, cuts, etc. are applied.\nFor a linear member, using this and then an ExtrusionAnalyzer in the direction of the beam curve yields a reasonably accurate picture of the beam cross-section.\nAn ExtrusionAnalyzer instance is a single-time use object that should be supplied a solid geometry, a plane, and a direction.\nBased on that input, it calculates a base boundary parallel to the input plane representing the outer boundary of the shadow cast by the solid onto the input plane along the extrusion direction.\nNote that only the outer boundary is calculated, so any cavities in the cross section will be ignored.</p>\n<a name=\"4\"></a>\n<h4>Sample FramingXsecAnalyzer Implementation for Revit 2012</h4>\n<p>I implemented a sample application named FramingXsecAnalyzer based on Revit 2012 that demonstrates how to achieve the suggestions 1 and 3 above.</p>\n<p>As an example of a really simple analysis, it just determines whether a selected beam or column is hollow or not.</p>\n<p>The REX cross section analysis tool providing automatic section recognition functionality can be accessed from a 'pure' Revit add-in, in spite of the fact that it is not built on top of the REX framework.</p>\n<p>The direct analysis of the element geometry is quite simple, in this case: we simply grab the first best face we find that is perpendicular to the element extrusion direction, i.e. the framing element curve or location line, and check the number of curve edge loops it contains.\nIf it has more than one, we assume it is hollow.\nObviously, more complex test might be required, depending on your exact needs.</p>\n<a name=\"5\"></a>\n<h4>Pure Revit API Approach</h4>\n<p>The cross section analysis based on the pure naked Revit API basically requires two steps:</p>\n<ol>\n<li>Set up a section view cutting the element in question.</li>\n<li>Retrieve the cut plane faces of the element geometry.</li>\n</ol>\n<p>This will give you a number of edge loops. As far as I understand your definition of 'open' and 'closed', all 'open' cross section shapes have one single loop, and 'closed' ones have more, since they consist of an outer and one or more inner loops.</p>\n<p>Here is a more detailed description of the steps and source code:</p>\n<p><b>1.</b> Set up a section view cutting the element in question.</p>\n<p>How this can be achieved is demonstrated by our venerable CreateViewSection SDK sample.\nIt shows how to generate a section view through the mid point of a linear structural element such as a wall, floor or beam.</p>\n<p>Here is a hollow beam that I used to test it on:</p>\n<center>\n<img alt=\"HSS hollow beam 3D view\" src=\"img/hss_hollow_beam_3d.png\"/>\n</center>\n<p>It is horizontal and oriented parallel to the Y axis:</p>\n<center>\n<img alt=\"HSS hollow beam plan view\" src=\"img/hss_hollow_beam_plan.png\"/>\n</center>\n<p>The CreateViewSection creates the a section view for it:</p>\n<center>\n<img alt=\"HSS hollow beam section view\" src=\"img/hss_hollow_beam_section.png\"/>\n</center>\n<p>The section view displays its geometry including the internal loop for the hollow cavity:</p>\n<center>\n<img alt=\"HSS hollow beam geometry with inner loop\" src=\"img/hss_hollow_beam_section2.png\"/>\n</center>\n<p><b>2.</b> Retrieve and analyse the cut plane faces of the element geometry.</p>\n<p>Here is some code that demonstrates this, assuming the section view cutting the element is set up as described above:</p>\n<pre class=\"code\">\n  <span class=\"teal\">UIApplication</span> uiapp = commandData.Application;\n  <span class=\"teal\">UIDocument</span> uidoc = uiapp.ActiveUIDocument;\n  <span class=\"teal\">Application</span> app = uiapp.Application;\n \n  <span class=\"teal\">Document</span> doc = <span class=\"teal\">Util</span>.GetActiveDocument(\n    uidoc, <span class=\"blue\">false</span> );\n \n  <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == doc )\n  {\n    <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n  }\n \n  <span class=\"green\">// Retrieve pre-selected or </span>\n  <span class=\"green\">// interactively select element </span>\n \n  <span class=\"teal\">Selection</span> sel = uidoc.Selection;\n \n  <span class=\"blue\">int</span> n = sel.Elements.Size;\n \n  <span class=\"blue\">if</span>( 1 &lt; n )\n  {\n    <span class=\"teal\">Util</span>.InfoMessage( <span class=\"blue\">string</span>.Format(\n      <span class=\"maroon\">\"{0} element{1} selected. Please select one \"</span>\n      + <span class=\"maroon\">\"single framing element for cross section \"</span>\n      + <span class=\"maroon\">\"analysis.\"</span>,\n      n, <span class=\"teal\">Util</span>.PluralSuffix( n ) ) );\n \n    <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n  }\n \n  <span class=\"teal\">Element</span> e = <span class=\"blue\">null</span>;\n \n  <span class=\"blue\">if</span>( 0 &lt; n )\n  {\n    <span class=\"teal\">Debug</span>.Assert( 1 == n,\n      <span class=\"maroon\">\"we already checked for 1 &lt; n above\"</span> );\n \n    <span class=\"blue\">foreach</span>( <span class=\"teal\">Element</span> e2 <span class=\"blue\">in</span> sel.Elements )\n    {\n      e = e2;\n    }\n  }\n  <span class=\"blue\">else</span>\n  {\n    <span class=\"blue\">try</span>\n    {\n      <span class=\"teal\">Reference</span> r = sel.PickObject(\n        <span class=\"teal\">ObjectType</span>.Element,\n        <span class=\"maroon\">\"Please pick a framing element \"</span>\n        + <span class=\"maroon\">\"for cross section analysis.\"</span> );\n \n      e = doc.GetElement( r.ElementId );\n    }\n    <span class=\"blue\">catch</span>( <span class=\"teal\">RvtOperationCanceledException</span> )\n    {\n      <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Cancelled;\n    }\n  }\n \n  <span class=\"green\">// Set up section view</span>\n \n  <span class=\"green\">//ViewSection viewSection = GetFrontView( e );</span>\n \n  <span class=\"green\">// Retrieve element solid</span>\n \n  <span class=\"teal\">Options</span> opt = app.Create.NewGeometryOptions();\n \n  <span class=\"green\">//opt.IncludeNonVisibleObjects = true;</span>\n \n  <span class=\"green\">// Cannot set both detail level and view:</span>\n  <span class=\"green\">// Autodesk.Revit.Exceptions.InvalidOperationException</span>\n  <span class=\"green\">// DetailLevel is already set. When DetailLevel is set </span>\n  <span class=\"green\">// view-specific geometry can't be extracted.</span>\n \n  <span class=\"green\">//opt.DetailLevel = DetailLevels.MAX;</span>\n \n  <span class=\"teal\">View</span> view = doc.ActiveView;\n  opt.View = view;\n \n  <span class=\"green\">//opt.View = viewSection;</span>\n \n  <span class=\"teal\">GeometryElement</span> geo = e.get_Geometry( opt );\n  <span class=\"teal\">GeometryInstance</span> inst = <span class=\"blue\">null</span>;\n \n  <span class=\"blue\">foreach</span>( <span class=\"teal\">GeometryObject</span> obj <span class=\"blue\">in</span> geo )\n  {\n    inst = obj <span class=\"blue\">as</span> <span class=\"teal\">GeometryInstance</span>;\n    <span class=\"blue\">if</span>( <span class=\"blue\">null</span> != inst )\n    {\n      <span class=\"blue\">break</span>;\n    }\n  }\n  <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == inst )\n  {\n    <span class=\"teal\">Util</span>.InfoMessage( <span class=\"maroon\">\"Sorry, I am unable to retrieve \"</span>\n      + <span class=\"maroon\">\"the structural framing geometry instance \"</span>\n      + <span class=\"maroon\">\"from the selected element.\"</span> );\n \n    <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n  }\n  <span class=\"teal\">Solid</span> solid = <span class=\"blue\">null</span>;\n \n  <span class=\"green\">//geo = inst.SymbolGeometry;</span>\n  geo = inst.GetInstanceGeometry();\n \n  <span class=\"blue\">foreach</span>( <span class=\"teal\">GeometryObject</span> obj <span class=\"blue\">in</span> geo )\n  {\n    solid = obj <span class=\"blue\">as</span> <span class=\"teal\">Solid</span>;\n \n    <span class=\"blue\">if</span>( <span class=\"blue\">null</span> != solid\n      &amp;&amp; 0 != solid.Faces.Size )\n    {\n      <span class=\"blue\">break</span>;\n    }\n  }\n \n  <span class=\"green\">// Select the first planar face which is </span>\n  <span class=\"green\">// perpendicular to view direction, i.e. has</span>\n  <span class=\"green\">// same normal vector as the view plane.</span>\n  <span class=\"green\">// Assuming the cross section is constant,</span>\n  <span class=\"green\">// any one will do. We expect two of them.</span>\n \n  <span class=\"teal\">XYZ</span> viewDir = view.ViewDirection;\n \n  <span class=\"teal\">PlanarFace</span> crossSection = <span class=\"blue\">null</span>;\n \n  <span class=\"blue\">foreach</span>( <span class=\"teal\">Face</span> f <span class=\"blue\">in</span> solid.Faces )\n  {\n    <span class=\"blue\">if</span>( f <span class=\"blue\">is</span> <span class=\"teal\">PlanarFace</span>\n      &amp;&amp; <span class=\"teal\">Util</span>.IsParallel( viewDir,\n        ( f <span class=\"blue\">as</span> <span class=\"teal\">PlanarFace</span> ).Normal ) )\n    {\n      crossSection = f <span class=\"blue\">as</span> <span class=\"teal\">PlanarFace</span>;\n \n      <span class=\"blue\">break</span>;\n    }\n  }\n \n  <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == crossSection )\n  {\n    <span class=\"teal\">Util</span>.InfoMessage( <span class=\"maroon\">\"Sorry, I am unable to retrieve \"</span>\n      + <span class=\"maroon\">\"the structural framing cross section.\"</span> );\n \n    <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n  }\n \n  <span class=\"teal\">EdgeArrayArray</span> eaa = crossSection.EdgeLoops;\n \n  n = eaa.Size;\n \n  <span class=\"teal\">Debug</span>.Print(\n    <span class=\"maroon\">\"The selected structural framing element \"</span>\n    + <span class=\"maroon\">\"cross section section view cut plane \"</span>\n    + <span class=\"maroon\">\"face has {0} loop{1} and is thus '{2}'.\"</span>,\n    n, <span class=\"teal\">Util</span>.PluralSuffix( n ),\n    ( 1 == n ? <span class=\"maroon\">\"open\"</span> : <span class=\"maroon\">\"closed\"</span> ) );\n \n  <span class=\"teal\">GeoSnoop</span>.ShowCurve( <span class=\"maroon\">\"Solid face directly\"</span>,\n    eaa, <span class=\"teal\">AnalyticalDirection</span>.Y );\n</pre>\n<p>It performs the following steps:</p>\n<ul>\n<li>Retrieve a pre-selected element or prompt one to be selected.</li>\n<li>Retrieve its geometry and drill down to a non-empty solid.</li>\n<li>Pick the first best face whose normal is parallel to the view direction.</li>\n</ul>\n<p>The selected face represents the element cross section.</p>\n<p>The number of loops indicates its topology, as explained above.</p>\n<p>Here is a result of displaying the retrieved geometry in a custom 2D picture box using the GeoSnoop.ShowCurve method:</p>\n<center>\n<img alt=\"Cross section geometry snooping\" src=\"img/hss_hollow_beam_xsec_snoop.png\" width=\"250\"/>\n</center>\n<p>Here is the output from the add-in in the Visual Studio debug output window:</p>\n<p><code>The selected structural framing element cross section section view cut plane face has 2 loops and is thus 'closed'.</code></p>\n<a name=\"6\"></a>\n<h4>Cross Section Analysis Using REX without the REX Framework</h4>\n<p>The REX content generator analysis is based on faces taken directly from the geometry, not the ExtrusionAnalyzer.\nIt takes the GeometryElement and gathers all PlanarFaces according to a specific normal vector, taking the origin into consideration.\nThat determines all loops.\nNext, the relations between them are determined.</p>\n<p>The 'normal' way to use REX is to create a new Revit REX add-in from scratch using the REX add-in wizard.</p>\n<p>I chose a different approach, because I wished to add the method to the add-in I already had.</p>\n<p>Some additional steps are required to use this functionality independently of the REX module.\nIn REX modules, they are performed automatically.</p>\n<p>The REX.ContentGenerator component is not placed in the GAC or Revit directory, so .NET doesn’t know from where it should be loaded.\nThere are several solutions:</p>\n<ul>\n<li>Provide REX.ContentGenerator.LT.dll in the same directory as your ExternalCommand, e.g. by using CopyLocal = true – not recommended.</li>\n<li>Load REX.ContentGenerator.LT at the beginning of ExternalCommand Execution – doable, but you have to know the correct path, which may be problematic.</li>\n<li>Use the Autodesk.Revit.Framework component to resolve assembly – this is a GAC assembly so .NET has no problem finding it.</li>\n</ul>\n<p>The third solution is the most welcomed.\nHere what you should do:</p>\n<ol>\n<li>Add a reference to Autodesk.Revit.Framework.dll to your project (you can take it from GAC or from \"\\Program Files\\Common Files\\Autodesk Shared\\Extensions 2014\\Framework\\Engine\\AssemblyCache\\Autodesk.REX.Framework.dll\").\n\n<li>Set copy local to False.</li>\n<li>Add the code which resolves the assembly, e.g. in the external command Execute method:</li>\n</li></ol>\n<pre class=\"code\">\n  <span class=\"teal\">AppDomain</span>.CurrentDomain.AssemblyResolve\n    += <span class=\"blue\">new</span> <span class=\"teal\">ResolveEventHandler</span>( OnAssemblyResolve );\n</pre>\n<p>Here is the method definition:</p>\n<pre class=\"code\">\n  <span class=\"blue\">static</span> System.Reflection.<span class=\"teal\">Assembly</span> OnAssemblyResolve(\n    <span class=\"blue\">object</span> sender,\n    <span class=\"teal\">ResolveEventArgs</span> args )\n  {\n    <span class=\"teal\">Assembly</span> a = <span class=\"teal\">Assembly</span>.GetExecutingAssembly();\n \n    <span class=\"blue\">return</span> Autodesk.REX.Framework.<span class=\"teal\">REXAssemblies</span>\n      .Resolve( sender, args, <span class=\"maroon\">\"2014\"</span>, a );\n  }\n</pre>\n<p>Note that the converter initialisation must reside in a different method than the subscription to the assembly resolver OnAssemblyResolve, because .NET investigates all methods before execution and will try to resolve the assembly before you register the resolving mechanism, which will cause a crash.\nThe best way to avoid that is to create an additional method and call it separately, so you can register the resolve mechanism first.</p>\n<a name=\"7\"></a>\n<h4>Cross Section Analysis Using REX</h4>\n<p>Once REX is up and running, you have access to its functionality, and you know what classes and properties to query, there is hardly anything at all left to do.</p>\n<p>Here is the entire RexXsecAnalyis method that identifies the framing member cross section type:</p>\n<pre class=\"code\">\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n  <span class=\"gray\">///</span><span class=\"green\"> Use REX to analyse element cross section.</span>\n  <span class=\"gray\">///</span><span class=\"green\"> This requires a reference to </span>\n  <span class=\"gray\">///</span><span class=\"green\"> REX.ContentGeneratorLT.dll and prior</span>\n  <span class=\"gray\">///</span><span class=\"green\"> initialisation of the REX framework.</span>\n  <span class=\"gray\">///</span><span class=\"green\"> The converter initialisation must reside in</span>\n  <span class=\"gray\">///</span><span class=\"green\"> a different method than the subscription to</span>\n  <span class=\"gray\">///</span><span class=\"green\"> the assembly resolver OnAssemblyResolve.</span>\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n  <span class=\"blue\">void</span> RexXsecAnalyis(\n    <span class=\"teal\">ExternalCommandData</span> commandData,\n    <span class=\"teal\">Element</span> e )\n  {\n    <span class=\"green\">// Initialise converter</span>\n \n    <span class=\"teal\">RVTFamilyConverter</span> rvt = <span class=\"blue\">new</span> <span class=\"teal\">RVTFamilyConverter</span>(\n      commandData, <span class=\"blue\">true</span> );\n \n    <span class=\"green\">// Retrieve family type</span>\n \n    <span class=\"teal\">REXFamilyType</span> fam = rvt.GetFamily( e,\n      <span class=\"teal\">ECategoryType</span>.SECTION_PARAM );\n \n    <span class=\"green\">// Retrieve section data</span>\n \n    <span class=\"teal\">REXFamilyType_ParamSection</span> paramSection = fam\n      <span class=\"blue\">as</span> <span class=\"teal\">REXFamilyType_ParamSection</span>;\n \n    <span class=\"teal\">REXSectionParamDescription</span> parameters\n      = paramSection.Parameters;\n \n    <span class=\"green\">// Extract dimensions, section type, tapered</span>\n    <span class=\"green\">// predicate, etc.</span>\n    <span class=\"green\">// If different start and end sections are </span>\n    <span class=\"green\">// required, use DimensionsEnd as well.</span>\n \n    <span class=\"teal\">REXSectionParamDimensions</span> dimensions = parameters\n      .Dimensions;\n \n    <span class=\"teal\">ESectionType</span> sectionType = parameters\n      .SectionType;\n \n    <span class=\"blue\">bool</span> tapered = parameters.Tapered;\n \n    <span class=\"blue\">bool</span> start = <span class=\"blue\">true</span>;\n \n    <span class=\"teal\">Contour_Section</span> contour = parameters.GetContour(\n      start );\n \n    <span class=\"teal\">List</span>&lt;<span class=\"teal\">ContourCont</span>&gt; shape = contour.Shape;\n \n    <span class=\"teal\">Debug</span>.Print(\n      <span class=\"maroon\">\"The selected structural framing element \"</span>\n      + <span class=\"maroon\">\"cross section REX section type is \"</span>\n      + <span class=\"maroon\">\"{0}.\"</span>, sectionType );\n  }\n</pre>\n<p>In this case, it prints the following message to the Visual Studio debug output window:</p>\n<p><code>The selected structural framing element cross section REX section type is RECT_HOLLOW.</code></p>\n<p>The REX documentation provides more information, e.g. on how to retrieve instance characteristics like area or moment of inertia.\nHere is a table of the supported sections with dimensions:</p>\n<center>\n<img alt=\"REX cross section table\" src=\"img/pawel_xsec_table.png\" width=\"400\"/>\n</center>\n<p>Note: In case of UNKNOWN, please use the contour directly, since no dimensions will be determined.</p>\n<a name=\"9\"></a>\n<h4>Migrating from Revit 2012 to Revit 2014</h4>\n<p>As said, all of my initial exploration of this was based on Revit 2012.</p>\n<p>I easily migrated it to Revit 2014, though, and verified that it still works.</p>\n<p>Here are all the code differences required for the migration:</p>\n<pre>\nCommand.cs:\n\n&lt;   e = doc.get_Element( r.ElementId );\n&gt;   e = doc.GetElement( r.ElementId );\n\n&lt;   GeometryObjectArray objects = geo.Objects;\n&gt;   //GeometryObjectArray objects = geo.Objects;\n\n&lt;   foreach( GeometryObject obj in objects )\n&gt;   foreach( GeometryObject obj in geo )\n\n&lt;   objects = geo.Objects;\n&gt;   //objects = geo.Objects;\n\n&lt;   foreach( GeometryObject obj in objects )\n&gt;   foreach( GeometryObject obj in geo )\n\nGeoSnoop.cs:\n\n&lt;   XYZ p = e.AsCurve().get_EndPoint( 0 );\n&lt;   XYZ p = e.AsCurve().GetEndPoint( 0 );\n</pre>\n<p>Not that much, is it?</p>\n<p>The harder part was to browse to the REX .NET assemblies that I need to reference.</p>\n<p>Here are all the Revit and REX .NET assembly references required for Revit 2014:</p>\n<ul>\n<li>Program Files\\Autodesk\\Revit 2014\\RevitAPI.dll</li>\n<li>Program Files\\Autodesk\\Revit 2014\\RevitAPIUI.dll</li>\n<li>Program Files\\Common Files\\Autodesk Shared\\Extensions 2014\\Framework\\Components\\AREXContentGenerator\\REX.ContentGeneratorLT.dll</li>\n<li>Program Files\\Common Files\\Autodesk Shared\\Extensions 2014\\Framework\\Engine\\AssemblyCache\\Autodesk.REX.Framework.dll</li>\n</ul>\n<p>They can easily be listed by searching the C# project file for the DLL file name extension or the HintPath tag:</p>\n<pre>\n  grep -i DLL FramingXsecAnalyzer.csproj\n</pre>\n<p>The initial test run threw an exception saying \"Could not load file or assembly 'REX.ContentGeneratorLT, Version=2014.0.0.2608, Culture=neutral, PublicKeyToken=null' or one of its dependencies. The system cannot find the file specified.\"</p>\n<p>That was resolved when I updated the crucial OnAssemblyResolve method, bumping the version number from 2012 to 2014:</p>\n<pre class=\"code\">\n  <span class=\"blue\">static</span> System.Reflection.<span class=\"teal\">Assembly</span> OnAssemblyResolve(\n    <span class=\"blue\">object</span> sender,\n    <span class=\"teal\">ResolveEventArgs</span> args )\n  {\n    <span class=\"teal\">Assembly</span> a = <span class=\"teal\">Assembly</span>.GetExecutingAssembly();\n \n    <span class=\"blue\">return</span> Autodesk.REX.Framework.<span class=\"teal\">REXAssemblies</span>\n      .Resolve( sender, args, <span class=\"maroon\">\"2014\"</span>, a );\n  }\n</pre>\n<p>I tested it on the following tubular column in Revit 2014 instead of a beam:</p>\n<center>\n<img alt=\"Hollow column\" src=\"img/framing_xsec_hollow_column.png\" width=\"325\"/>\n</center>\n<p>Here are the two resulting report messages from the pure Revit API and REX analysis, respectively:</p>\n<p><code>The selected structural framing element cross section section view cut plane face has 2 loops and is thus 'closed'.</code></p>\n<p><code>The selected structural framing element cross section REX section type is TUBE.</code></p>\n<a name=\"9\"></a>\n<h4>Obsolete GeoSnoop</h4>\n<p>This is actually the origin of the\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2013/04/geosnoop-net-boundary-curve-loop-visualisation.html\">\nGeoSnoop .NET boundary curve loop visualisation</a>,\n\nlater\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2013/04/room-and-furniture-loops-using-symbols.html\">\nupdated for use with family symbols</a>,\n\nthat I make use of in the RoomEditorApp add-in for the simplified cloud-based 2D Revit model editing.</p>\n<p>The RoomEditorApp version is significantly cleaned up, though, so please make sure to ignore the obsolete one provided here.</p>\n<a name=\"10\"></a>\n<h4>Download</h4>\n<p>I created a new\n\n<a href=\"https://github.com/jeremytammik/FramingXsecAnalyzer\">FramingXsecAnalyzer GitHub repository</a> to\n\nhost this project, and published the following releases so far:\n<ul>\n<li><a href=\"https://github.com/jeremytammik/FramingXsecAnalyzer/releases/tag/2012.0.0.0\">2012.0.0.0</a> –\ninitial commit for Revit 2012</li>\n<li><a href=\"https://github.com/jeremytammik/FramingXsecAnalyzer/releases/tag/2014.0.0.0\">2014.0.0.0</a> –\ninitial untested migration from Revit 2012 to Revit 2014</li>\n<li><a href=\"https://github.com/jeremytammik/FramingXsecAnalyzer/releases/tag/2014.0.0.1\">2014.0.0.1</a> –\nverified working functionality in Revit 2014</li>\n</ul>\n</p></p>"
  },
  {
    "original_filename": "1076_framing_xsec_analyse",
    "header_text": "DevDays in Milano and Security",
    "local_header_href": "#devdays-in-milano-and-security",
    "chunk_text": "<h4>DevDays in Milano and Security</h4><p>We held our second West European Devday in Milano on Tuesday.</p><p>Here is Jim Quanci entertaining his enthralled audience:</p><center>\n<img alt=\"Jim Quanci at the ADN DevDays Conference in Milano\" src=\"file:///j/photo/jeremy/2013/2013-12-10_milano/devday_cropped.jpeg\" width=\"400\"/>\n</center><p>One piece of Jim's presentation deals with security.\nThis is an important topic in its own right, of course, and always has been, but the cloud and mobile discussion brings it to people's attention again, so this also discusses the Autodesk trust center and security in the 360 environment.\nMost of all, though, it highlights the fact that you and your customers need to have a basic understanding of the issue, and somebody in your organisation needs to know a bit more than just the basics.</p><p>I think it is so important and Jim's ten-minute overview so effective and refreshing I decided to publish it right here and now:</p><ul>\n<li><a href=\"http://thebuildingcoder.typepad.com/devday/2013/security_jim_quanci.pdf\">Slide deck</a></li>\n<li><a href=\"http://thebuildingcoder.typepad.com/devday/2013/security_jim_quanci.mp3\">Audio</a></li>\n</ul><p>Something else happened after the conference, travelling...</p><p>On Monday, Jim and I were joking that I arrive at the airport gate at the last minute, and it was about time I get burned.</p><p>The retribution for that hubris was immediate: I missed the plane from Milano to London, mistaking the gate closing time for the opening time.</p><p>I arrived three minutes late, the gate was adamantly closed, and there was nothing I could do – in spite of this being Italy, after all.</p><p>A long taxi ride from Linate to Malpensa and a hefty cancellation fee later, I am now gratefully sitting on a different plane, thanking the powers that be for not being harsher to me.</p><p>Back to the topic at hand...</p><a name=\"3\"></a>"
  },
  {
    "original_filename": "1076_framing_xsec_analyse",
    "header_text": "Five Structural Framing Cross Section Analysis Approaches",
    "local_header_href": "#five-structural-framing-cross-section-analysis-approaches",
    "chunk_text": "<h4>Five Structural Framing Cross Section Analysis Approaches</h4><p>This is actually a topic I have been wanting to write about for a long time now – how to determine the cross section of a structural framing member.</p><p>In fact, I implemented a solution (two solutions!) addressing this several years ago, and never got around to publishing.</p><p>There are quite a number of different possible approaches to take.</p><p>Here is one of several developer queries that prompted this exploration:</p><p><strong>Question:</strong> A Structural Framing or Structural Column object can be open shape such as T Shape, I Shape or L Shape, or an enclosed shape such as Rectangular Shape, Square Shape or Round Shape.</p><p>Does the Revit API provide a way to find out whether a shape is open or enclosed, and what kind of shape it is?</p><p><strong>Answer:</strong> The Revit API does not provide any direct API method to tell whether a cross section of a structural column or beam is open or closed, or extract its profile.</p><p>There are, however, several reliable approaches you can implement yourself based on the functionality provided both by the Revit API itself and the Revit Extensions REX.</p><p>You can always access the basic element geometry.\nThe FamilyInstance.GetOriginalGeometry method returns the member geometry before joins, cuts, etc. are applied.\nThere are various ways to calculate the cross section contour of the structural element from that and analyse it to find the best match according to pre-determined internal definitions.\nIn some cases, it may be pretty simple, since you can check for rectangular and round shapes, existence of inner loops, etc.</p><p>Here are a few different approaches that come to mind:</p><p><b>1.</b> For structural extrusions, the REX content generator includes a cross section analysis tool providing automatic section recognition functionality:</p><ul>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2011/04/the-rex-sdk.html\">\nThe REX SDK</a></li>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2011/06/extensions-for-revit-2012.html\">\nExtensions for Revit 2012</a></li>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2011/12/rex-content-generator.html\">\nREX Content Generator</a></li>\n</ul><p><b>2.</b> Some families such as gutter, fascia, slab edge, railings, etc., are based on profiles consisting of 2D elements, e.g., lines, arcs, circles, etc.\nYou might be able to use some\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2011/11/undocumented-elementid-relationships.html\">\nunofficial element id relationships</a> to\n\naccess those elements knowing the element id of the family symbol or its profile.\nThey can be used, for example, to determine the relationship between a\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/05/curtain-wall-geometry.html\">\ncurtain wall and its panels</a> or\n\nbetween a stacked wall and it basic wall components.</p><p><b>3.</b> From the element, you can retrieve its solid geometry and location line.\nThe profile lines can be determined by intersecting a plane that is perpendicular to the element location line with its solid.\nI can imagine that the REX content generator does something like this internally, as well.</p><p><b>4.</b> You can set up a section view cutting the framing element perpendicularly using a\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2012/06/create-section-view-parallel-to-wall.html\">\nview perpendicular to the element location line</a> and\n\nask the element for its view-specific geometry, the\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2011/08/section-view-geometry.html\">\nsection view geometry</a> in\n\nthat specific view.\nThen, just ignore all lines that are not lying on the view plane and analyse the face loops in the cut plane.</p><p><b>5.</b> Use the\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/about-the-author.html#5.29\">\nExtrusionAnalyzer</a> –\n\nto do so, grab the FamilyInstance GetOriginalGeometry that returns the member geometry before joins, cuts, etc. are applied.\nFor a linear member, using this and then an ExtrusionAnalyzer in the direction of the beam curve yields a reasonably accurate picture of the beam cross-section.\nAn ExtrusionAnalyzer instance is a single-time use object that should be supplied a solid geometry, a plane, and a direction.\nBased on that input, it calculates a base boundary parallel to the input plane representing the outer boundary of the shadow cast by the solid onto the input plane along the extrusion direction.\nNote that only the outer boundary is calculated, so any cavities in the cross section will be ignored.</p><a name=\"4\"></a>"
  },
  {
    "original_filename": "1076_framing_xsec_analyse",
    "header_text": "Sample FramingXsecAnalyzer Implementation for Revit 2012",
    "local_header_href": "#sample-framingxsecanalyzer-implementation-for-revit-2012",
    "chunk_text": "<h4>Sample FramingXsecAnalyzer Implementation for Revit 2012</h4><p>I implemented a sample application named FramingXsecAnalyzer based on Revit 2012 that demonstrates how to achieve the suggestions 1 and 3 above.</p><p>As an example of a really simple analysis, it just determines whether a selected beam or column is hollow or not.</p><p>The REX cross section analysis tool providing automatic section recognition functionality can be accessed from a 'pure' Revit add-in, in spite of the fact that it is not built on top of the REX framework.</p><p>The direct analysis of the element geometry is quite simple, in this case: we simply grab the first best face we find that is perpendicular to the element extrusion direction, i.e. the framing element curve or location line, and check the number of curve edge loops it contains.\nIf it has more than one, we assume it is hollow.\nObviously, more complex test might be required, depending on your exact needs.</p><a name=\"5\"></a>"
  },
  {
    "original_filename": "1076_framing_xsec_analyse",
    "header_text": "Pure Revit API Approach",
    "local_header_href": "#pure-revit-api-approach",
    "chunk_text": "<h4>Pure Revit API Approach</h4><p>The cross section analysis based on the pure naked Revit API basically requires two steps:</p><ol>\n<li>Set up a section view cutting the element in question.</li>\n<li>Retrieve the cut plane faces of the element geometry.</li>\n</ol><p>This will give you a number of edge loops. As far as I understand your definition of 'open' and 'closed', all 'open' cross section shapes have one single loop, and 'closed' ones have more, since they consist of an outer and one or more inner loops.</p><p>Here is a more detailed description of the steps and source code:</p><p><b>1.</b> Set up a section view cutting the element in question.</p><p>How this can be achieved is demonstrated by our venerable CreateViewSection SDK sample.\nIt shows how to generate a section view through the mid point of a linear structural element such as a wall, floor or beam.</p><p>Here is a hollow beam that I used to test it on:</p><center>\n<img alt=\"HSS hollow beam 3D view\" src=\"img/hss_hollow_beam_3d.png\"/>\n</center><p>It is horizontal and oriented parallel to the Y axis:</p><center>\n<img alt=\"HSS hollow beam plan view\" src=\"img/hss_hollow_beam_plan.png\"/>\n</center><p>The CreateViewSection creates the a section view for it:</p><center>\n<img alt=\"HSS hollow beam section view\" src=\"img/hss_hollow_beam_section.png\"/>\n</center><p>The section view displays its geometry including the internal loop for the hollow cavity:</p><center>\n<img alt=\"HSS hollow beam geometry with inner loop\" src=\"img/hss_hollow_beam_section2.png\"/>\n</center><p><b>2.</b> Retrieve and analyse the cut plane faces of the element geometry.</p><p>Here is some code that demonstrates this, assuming the section view cutting the element is set up as described above:</p><pre class=\"code\">\n  <span class=\"teal\">UIApplication</span> uiapp = commandData.Application;\n  <span class=\"teal\">UIDocument</span> uidoc = uiapp.ActiveUIDocument;\n  <span class=\"teal\">Application</span> app = uiapp.Application;\n \n  <span class=\"teal\">Document</span> doc = <span class=\"teal\">Util</span>.GetActiveDocument(\n    uidoc, <span class=\"blue\">false</span> );\n \n  <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == doc )\n  {\n    <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n  }\n \n  <span class=\"green\">// Retrieve pre-selected or </span>\n  <span class=\"green\">// interactively select element </span>\n \n  <span class=\"teal\">Selection</span> sel = uidoc.Selection;\n \n  <span class=\"blue\">int</span> n = sel.Elements.Size;\n \n  <span class=\"blue\">if</span>( 1 &lt; n )\n  {\n    <span class=\"teal\">Util</span>.InfoMessage( <span class=\"blue\">string</span>.Format(\n      <span class=\"maroon\">\"{0} element{1} selected. Please select one \"</span>\n      + <span class=\"maroon\">\"single framing element for cross section \"</span>\n      + <span class=\"maroon\">\"analysis.\"</span>,\n      n, <span class=\"teal\">Util</span>.PluralSuffix( n ) ) );\n \n    <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n  }\n \n  <span class=\"teal\">Element</span> e = <span class=\"blue\">null</span>;\n \n  <span class=\"blue\">if</span>( 0 &lt; n )\n  {\n    <span class=\"teal\">Debug</span>.Assert( 1 == n,\n      <span class=\"maroon\">\"we already checked for 1 &lt; n above\"</span> );\n \n    <span class=\"blue\">foreach</span>( <span class=\"teal\">Element</span> e2 <span class=\"blue\">in</span> sel.Elements )\n    {\n      e = e2;\n    }\n  }\n  <span class=\"blue\">else</span>\n  {\n    <span class=\"blue\">try</span>\n    {\n      <span class=\"teal\">Reference</span> r = sel.PickObject(\n        <span class=\"teal\">ObjectType</span>.Element,\n        <span class=\"maroon\">\"Please pick a framing element \"</span>\n        + <span class=\"maroon\">\"for cross section analysis.\"</span> );\n \n      e = doc.GetElement( r.ElementId );\n    }\n    <span class=\"blue\">catch</span>( <span class=\"teal\">RvtOperationCanceledException</span> )\n    {\n      <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Cancelled;\n    }\n  }\n \n  <span class=\"green\">// Set up section view</span>\n \n  <span class=\"green\">//ViewSection viewSection = GetFrontView( e );</span>\n \n  <span class=\"green\">// Retrieve element solid</span>\n \n  <span class=\"teal\">Options</span> opt = app.Create.NewGeometryOptions();\n \n  <span class=\"green\">//opt.IncludeNonVisibleObjects = true;</span>\n \n  <span class=\"green\">// Cannot set both detail level and view:</span>\n  <span class=\"green\">// Autodesk.Revit.Exceptions.InvalidOperationException</span>\n  <span class=\"green\">// DetailLevel is already set. When DetailLevel is set </span>\n  <span class=\"green\">// view-specific geometry can't be extracted.</span>\n \n  <span class=\"green\">//opt.DetailLevel = DetailLevels.MAX;</span>\n \n  <span class=\"teal\">View</span> view = doc.ActiveView;\n  opt.View = view;\n \n  <span class=\"green\">//opt.View = viewSection;</span>\n \n  <span class=\"teal\">GeometryElement</span> geo = e.get_Geometry( opt );\n  <span class=\"teal\">GeometryInstance</span> inst = <span class=\"blue\">null</span>;\n \n  <span class=\"blue\">foreach</span>( <span class=\"teal\">GeometryObject</span> obj <span class=\"blue\">in</span> geo )\n  {\n    inst = obj <span class=\"blue\">as</span> <span class=\"teal\">GeometryInstance</span>;\n    <span class=\"blue\">if</span>( <span class=\"blue\">null</span> != inst )\n    {\n      <span class=\"blue\">break</span>;\n    }\n  }\n  <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == inst )\n  {\n    <span class=\"teal\">Util</span>.InfoMessage( <span class=\"maroon\">\"Sorry, I am unable to retrieve \"</span>\n      + <span class=\"maroon\">\"the structural framing geometry instance \"</span>\n      + <span class=\"maroon\">\"from the selected element.\"</span> );\n \n    <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n  }\n  <span class=\"teal\">Solid</span> solid = <span class=\"blue\">null</span>;\n \n  <span class=\"green\">//geo = inst.SymbolGeometry;</span>\n  geo = inst.GetInstanceGeometry();\n \n  <span class=\"blue\">foreach</span>( <span class=\"teal\">GeometryObject</span> obj <span class=\"blue\">in</span> geo )\n  {\n    solid = obj <span class=\"blue\">as</span> <span class=\"teal\">Solid</span>;\n \n    <span class=\"blue\">if</span>( <span class=\"blue\">null</span> != solid\n      &amp;&amp; 0 != solid.Faces.Size )\n    {\n      <span class=\"blue\">break</span>;\n    }\n  }\n \n  <span class=\"green\">// Select the first planar face which is </span>\n  <span class=\"green\">// perpendicular to view direction, i.e. has</span>\n  <span class=\"green\">// same normal vector as the view plane.</span>\n  <span class=\"green\">// Assuming the cross section is constant,</span>\n  <span class=\"green\">// any one will do. We expect two of them.</span>\n \n  <span class=\"teal\">XYZ</span> viewDir = view.ViewDirection;\n \n  <span class=\"teal\">PlanarFace</span> crossSection = <span class=\"blue\">null</span>;\n \n  <span class=\"blue\">foreach</span>( <span class=\"teal\">Face</span> f <span class=\"blue\">in</span> solid.Faces )\n  {\n    <span class=\"blue\">if</span>( f <span class=\"blue\">is</span> <span class=\"teal\">PlanarFace</span>\n      &amp;&amp; <span class=\"teal\">Util</span>.IsParallel( viewDir,\n        ( f <span class=\"blue\">as</span> <span class=\"teal\">PlanarFace</span> ).Normal ) )\n    {\n      crossSection = f <span class=\"blue\">as</span> <span class=\"teal\">PlanarFace</span>;\n \n      <span class=\"blue\">break</span>;\n    }\n  }\n \n  <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == crossSection )\n  {\n    <span class=\"teal\">Util</span>.InfoMessage( <span class=\"maroon\">\"Sorry, I am unable to retrieve \"</span>\n      + <span class=\"maroon\">\"the structural framing cross section.\"</span> );\n \n    <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n  }\n \n  <span class=\"teal\">EdgeArrayArray</span> eaa = crossSection.EdgeLoops;\n \n  n = eaa.Size;\n \n  <span class=\"teal\">Debug</span>.Print(\n    <span class=\"maroon\">\"The selected structural framing element \"</span>\n    + <span class=\"maroon\">\"cross section section view cut plane \"</span>\n    + <span class=\"maroon\">\"face has {0} loop{1} and is thus '{2}'.\"</span>,\n    n, <span class=\"teal\">Util</span>.PluralSuffix( n ),\n    ( 1 == n ? <span class=\"maroon\">\"open\"</span> : <span class=\"maroon\">\"closed\"</span> ) );\n \n  <span class=\"teal\">GeoSnoop</span>.ShowCurve( <span class=\"maroon\">\"Solid face directly\"</span>,\n    eaa, <span class=\"teal\">AnalyticalDirection</span>.Y );\n</pre><p>It performs the following steps:</p><ul>\n<li>Retrieve a pre-selected element or prompt one to be selected.</li>\n<li>Retrieve its geometry and drill down to a non-empty solid.</li>\n<li>Pick the first best face whose normal is parallel to the view direction.</li>\n</ul><p>The selected face represents the element cross section.</p><p>The number of loops indicates its topology, as explained above.</p><p>Here is a result of displaying the retrieved geometry in a custom 2D picture box using the GeoSnoop.ShowCurve method:</p><center>\n<img alt=\"Cross section geometry snooping\" src=\"img/hss_hollow_beam_xsec_snoop.png\" width=\"250\"/>\n</center><p>Here is the output from the add-in in the Visual Studio debug output window:</p><p><code>The selected structural framing element cross section section view cut plane face has 2 loops and is thus 'closed'.</code></p><a name=\"6\"></a>"
  },
  {
    "original_filename": "1076_framing_xsec_analyse",
    "header_text": "Cross Section Analysis Using REX without the REX Framework",
    "local_header_href": "#cross-section-analysis-using-rex-without-the-rex-framework",
    "chunk_text": "<h4>Cross Section Analysis Using REX without the REX Framework</h4><p>The REX content generator analysis is based on faces taken directly from the geometry, not the ExtrusionAnalyzer.\nIt takes the GeometryElement and gathers all PlanarFaces according to a specific normal vector, taking the origin into consideration.\nThat determines all loops.\nNext, the relations between them are determined.</p><p>The 'normal' way to use REX is to create a new Revit REX add-in from scratch using the REX add-in wizard.</p><p>I chose a different approach, because I wished to add the method to the add-in I already had.</p><p>Some additional steps are required to use this functionality independently of the REX module.\nIn REX modules, they are performed automatically.</p><p>The REX.ContentGenerator component is not placed in the GAC or Revit directory, so .NET doesn’t know from where it should be loaded.\nThere are several solutions:</p><ul>\n<li>Provide REX.ContentGenerator.LT.dll in the same directory as your ExternalCommand, e.g. by using CopyLocal = true – not recommended.</li>\n<li>Load REX.ContentGenerator.LT at the beginning of ExternalCommand Execution – doable, but you have to know the correct path, which may be problematic.</li>\n<li>Use the Autodesk.Revit.Framework component to resolve assembly – this is a GAC assembly so .NET has no problem finding it.</li>\n</ul><p>The third solution is the most welcomed.\nHere what you should do:</p><ol>\n<li>Add a reference to Autodesk.Revit.Framework.dll to your project (you can take it from GAC or from \"\\Program Files\\Common Files\\Autodesk Shared\\Extensions 2014\\Framework\\Engine\\AssemblyCache\\Autodesk.REX.Framework.dll\").\n\n<li>Set copy local to False.</li>\n<li>Add the code which resolves the assembly, e.g. in the external command Execute method:</li>\n</li></ol><pre class=\"code\">\n  <span class=\"teal\">AppDomain</span>.CurrentDomain.AssemblyResolve\n    += <span class=\"blue\">new</span> <span class=\"teal\">ResolveEventHandler</span>( OnAssemblyResolve );\n</pre><p>Here is the method definition:</p><pre class=\"code\">\n  <span class=\"blue\">static</span> System.Reflection.<span class=\"teal\">Assembly</span> OnAssemblyResolve(\n    <span class=\"blue\">object</span> sender,\n    <span class=\"teal\">ResolveEventArgs</span> args )\n  {\n    <span class=\"teal\">Assembly</span> a = <span class=\"teal\">Assembly</span>.GetExecutingAssembly();\n \n    <span class=\"blue\">return</span> Autodesk.REX.Framework.<span class=\"teal\">REXAssemblies</span>\n      .Resolve( sender, args, <span class=\"maroon\">\"2014\"</span>, a );\n  }\n</pre><p>Note that the converter initialisation must reside in a different method than the subscription to the assembly resolver OnAssemblyResolve, because .NET investigates all methods before execution and will try to resolve the assembly before you register the resolving mechanism, which will cause a crash.\nThe best way to avoid that is to create an additional method and call it separately, so you can register the resolve mechanism first.</p><a name=\"7\"></a>"
  },
  {
    "original_filename": "1076_framing_xsec_analyse",
    "header_text": "Cross Section Analysis Using REX",
    "local_header_href": "#cross-section-analysis-using-rex",
    "chunk_text": "<h4>Cross Section Analysis Using REX</h4><p>Once REX is up and running, you have access to its functionality, and you know what classes and properties to query, there is hardly anything at all left to do.</p><p>Here is the entire RexXsecAnalyis method that identifies the framing member cross section type:</p><pre class=\"code\">\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n  <span class=\"gray\">///</span><span class=\"green\"> Use REX to analyse element cross section.</span>\n  <span class=\"gray\">///</span><span class=\"green\"> This requires a reference to </span>\n  <span class=\"gray\">///</span><span class=\"green\"> REX.ContentGeneratorLT.dll and prior</span>\n  <span class=\"gray\">///</span><span class=\"green\"> initialisation of the REX framework.</span>\n  <span class=\"gray\">///</span><span class=\"green\"> The converter initialisation must reside in</span>\n  <span class=\"gray\">///</span><span class=\"green\"> a different method than the subscription to</span>\n  <span class=\"gray\">///</span><span class=\"green\"> the assembly resolver OnAssemblyResolve.</span>\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n  <span class=\"blue\">void</span> RexXsecAnalyis(\n    <span class=\"teal\">ExternalCommandData</span> commandData,\n    <span class=\"teal\">Element</span> e )\n  {\n    <span class=\"green\">// Initialise converter</span>\n \n    <span class=\"teal\">RVTFamilyConverter</span> rvt = <span class=\"blue\">new</span> <span class=\"teal\">RVTFamilyConverter</span>(\n      commandData, <span class=\"blue\">true</span> );\n \n    <span class=\"green\">// Retrieve family type</span>\n \n    <span class=\"teal\">REXFamilyType</span> fam = rvt.GetFamily( e,\n      <span class=\"teal\">ECategoryType</span>.SECTION_PARAM );\n \n    <span class=\"green\">// Retrieve section data</span>\n \n    <span class=\"teal\">REXFamilyType_ParamSection</span> paramSection = fam\n      <span class=\"blue\">as</span> <span class=\"teal\">REXFamilyType_ParamSection</span>;\n \n    <span class=\"teal\">REXSectionParamDescription</span> parameters\n      = paramSection.Parameters;\n \n    <span class=\"green\">// Extract dimensions, section type, tapered</span>\n    <span class=\"green\">// predicate, etc.</span>\n    <span class=\"green\">// If different start and end sections are </span>\n    <span class=\"green\">// required, use DimensionsEnd as well.</span>\n \n    <span class=\"teal\">REXSectionParamDimensions</span> dimensions = parameters\n      .Dimensions;\n \n    <span class=\"teal\">ESectionType</span> sectionType = parameters\n      .SectionType;\n \n    <span class=\"blue\">bool</span> tapered = parameters.Tapered;\n \n    <span class=\"blue\">bool</span> start = <span class=\"blue\">true</span>;\n \n    <span class=\"teal\">Contour_Section</span> contour = parameters.GetContour(\n      start );\n \n    <span class=\"teal\">List</span>&lt;<span class=\"teal\">ContourCont</span>&gt; shape = contour.Shape;\n \n    <span class=\"teal\">Debug</span>.Print(\n      <span class=\"maroon\">\"The selected structural framing element \"</span>\n      + <span class=\"maroon\">\"cross section REX section type is \"</span>\n      + <span class=\"maroon\">\"{0}.\"</span>, sectionType );\n  }\n</pre><p>In this case, it prints the following message to the Visual Studio debug output window:</p><p><code>The selected structural framing element cross section REX section type is RECT_HOLLOW.</code></p><p>The REX documentation provides more information, e.g. on how to retrieve instance characteristics like area or moment of inertia.\nHere is a table of the supported sections with dimensions:</p><center>\n<img alt=\"REX cross section table\" src=\"img/pawel_xsec_table.png\" width=\"400\"/>\n</center><p>Note: In case of UNKNOWN, please use the contour directly, since no dimensions will be determined.</p><a name=\"9\"></a>"
  },
  {
    "original_filename": "1076_framing_xsec_analyse",
    "header_text": "Migrating from Revit 2012 to Revit 2014",
    "local_header_href": "#migrating-from-revit-2012-to-revit-2014",
    "chunk_text": "<h4>Migrating from Revit 2012 to Revit 2014</h4><p>As said, all of my initial exploration of this was based on Revit 2012.</p><p>I easily migrated it to Revit 2014, though, and verified that it still works.</p><p>Here are all the code differences required for the migration:</p><pre>\nCommand.cs:\n\n&lt;   e = doc.get_Element( r.ElementId );\n&gt;   e = doc.GetElement( r.ElementId );\n\n&lt;   GeometryObjectArray objects = geo.Objects;\n&gt;   //GeometryObjectArray objects = geo.Objects;\n\n&lt;   foreach( GeometryObject obj in objects )\n&gt;   foreach( GeometryObject obj in geo )\n\n&lt;   objects = geo.Objects;\n&gt;   //objects = geo.Objects;\n\n&lt;   foreach( GeometryObject obj in objects )\n&gt;   foreach( GeometryObject obj in geo )\n\nGeoSnoop.cs:\n\n&lt;   XYZ p = e.AsCurve().get_EndPoint( 0 );\n&lt;   XYZ p = e.AsCurve().GetEndPoint( 0 );\n</pre><p>Not that much, is it?</p><p>The harder part was to browse to the REX .NET assemblies that I need to reference.</p><p>Here are all the Revit and REX .NET assembly references required for Revit 2014:</p><ul>\n<li>Program Files\\Autodesk\\Revit 2014\\RevitAPI.dll</li>\n<li>Program Files\\Autodesk\\Revit 2014\\RevitAPIUI.dll</li>\n<li>Program Files\\Common Files\\Autodesk Shared\\Extensions 2014\\Framework\\Components\\AREXContentGenerator\\REX.ContentGeneratorLT.dll</li>\n<li>Program Files\\Common Files\\Autodesk Shared\\Extensions 2014\\Framework\\Engine\\AssemblyCache\\Autodesk.REX.Framework.dll</li>\n</ul><p>They can easily be listed by searching the C# project file for the DLL file name extension or the HintPath tag:</p><pre>\n  grep -i DLL FramingXsecAnalyzer.csproj\n</pre><p>The initial test run threw an exception saying \"Could not load file or assembly 'REX.ContentGeneratorLT, Version=2014.0.0.2608, Culture=neutral, PublicKeyToken=null' or one of its dependencies. The system cannot find the file specified.\"</p><p>That was resolved when I updated the crucial OnAssemblyResolve method, bumping the version number from 2012 to 2014:</p><pre class=\"code\">\n  <span class=\"blue\">static</span> System.Reflection.<span class=\"teal\">Assembly</span> OnAssemblyResolve(\n    <span class=\"blue\">object</span> sender,\n    <span class=\"teal\">ResolveEventArgs</span> args )\n  {\n    <span class=\"teal\">Assembly</span> a = <span class=\"teal\">Assembly</span>.GetExecutingAssembly();\n \n    <span class=\"blue\">return</span> Autodesk.REX.Framework.<span class=\"teal\">REXAssemblies</span>\n      .Resolve( sender, args, <span class=\"maroon\">\"2014\"</span>, a );\n  }\n</pre><p>I tested it on the following tubular column in Revit 2014 instead of a beam:</p><center>\n<img alt=\"Hollow column\" src=\"img/framing_xsec_hollow_column.png\" width=\"325\"/>\n</center><p>Here are the two resulting report messages from the pure Revit API and REX analysis, respectively:</p><p><code>The selected structural framing element cross section section view cut plane face has 2 loops and is thus 'closed'.</code></p><p><code>The selected structural framing element cross section REX section type is TUBE.</code></p><a name=\"9\"></a>"
  },
  {
    "original_filename": "1076_framing_xsec_analyse",
    "header_text": "Obsolete GeoSnoop",
    "local_header_href": "#obsolete-geosnoop",
    "chunk_text": "<h4>Obsolete GeoSnoop</h4><p>This is actually the origin of the\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2013/04/geosnoop-net-boundary-curve-loop-visualisation.html\">\nGeoSnoop .NET boundary curve loop visualisation</a>,\n\nlater\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2013/04/room-and-furniture-loops-using-symbols.html\">\nupdated for use with family symbols</a>,\n\nthat I make use of in the RoomEditorApp add-in for the simplified cloud-based 2D Revit model editing.</p><p>The RoomEditorApp version is significantly cleaned up, though, so please make sure to ignore the obsolete one provided here.</p><a name=\"10\"></a>"
  },
  {
    "original_filename": "1076_framing_xsec_analyse",
    "header_text": "Download",
    "local_header_href": "#download",
    "chunk_text": "<h4>Download</h4><p>I created a new\n\n<a href=\"https://github.com/jeremytammik/FramingXsecAnalyzer\">FramingXsecAnalyzer GitHub repository</a> to\n\nhost this project, and published the following releases so far:\n<ul>\n<li><a href=\"https://github.com/jeremytammik/FramingXsecAnalyzer/releases/tag/2012.0.0.0\">2012.0.0.0</a> –\ninitial commit for Revit 2012</li>\n<li><a href=\"https://github.com/jeremytammik/FramingXsecAnalyzer/releases/tag/2014.0.0.0\">2014.0.0.0</a> –\ninitial untested migration from Revit 2012 to Revit 2014</li>\n<li><a href=\"https://github.com/jeremytammik/FramingXsecAnalyzer/releases/tag/2014.0.0.1\">2014.0.0.1</a> –\nverified working functionality in Revit 2014</li>\n</ul>\n</p>"
  }
]