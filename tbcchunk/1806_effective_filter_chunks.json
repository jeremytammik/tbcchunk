[
  {
    "original_filename": "1806_effective_filter",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n<link rel=\"stylesheet\" type=\"text/css\" href=\"bc.css\">\n<script src=\"https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js\" type=\"text/javascript\"></script>\n<script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n</head>\n\n<!---\n\n- DA4R\n  New RVT->SVF Model Derivative parameter generates additional content, including rooms and spaces\n  https://forge.autodesk.com/blog/new-rvt-svf-model-derivative-parameter-generates-additional-content-including-rooms-and-spaces\n\nRun additional programs inside a WorkItem\nGet number of BIM 360 projects per user\nWorking with 2D and 3D scenes and geometry in Forge Viewer\nFast track your cross-platform React native Forge app with the Expo SDK\nHow to convert your plugin to work with Design Automation API for AutoCAD\nGo semantic with Viewer-custom web component for Forge Viewer\nNew RVT->SVF Model Derivative parameter generates additional content, including rooms and spaces\nCombining PointClouds and Revit models in Forge Viewer\nSwitch to orthographic corner view\nCustom BIM 360 search with Elasticsearch\nGet volume and surface area in the Viewer\nRun command from an AutoCAD AppBundle\nRun iLogic Rule without AppBundle\n\n[View all samples](https://forge.autodesk.com/categories/code-samples)\n\ntwitter:\n\nSupport for rooms and spaces in the Forge model derivative API and effective filtered element collectors in the #RevitAPI #DynamoBim @AutodeskForge @AutodeskRevit #bim #ForgeDevCon http://bit.ly/effectivecollector\n\nI successfully made it from Switzerland to Paris and the Forge accelerator in spite of the French strikes.\nMy only worry is how to get back again tomorrow.\nAgain, the train I have booked has been cancelled.\nMeanwhile, let's take a look at\n&ndash; DA4R room support and new samples\n&ndash; Effective filtered element collection...\n\nlinkedin:\n\nSupport for rooms and spaces in the Forge model derivative API and effective filtered element collectors in the #RevitAPI\n\nhttp://bit.ly/effectivecollector\n\nI successfully made it from Switzerland to Paris and the Forge accelerator in spite of the French strikes.\n\nMy only worry is how to get back again tomorrow.\n\nAgain, the train I have booked has been cancelled.\n\nMeanwhile, let's take a look at:\n\n- DA4R room support and new samples\n- Effective filtered element collection...\n\n#bim #DynamoBim #ForgeDevCon #Revit #API #IFC #SDK #AI #VisualStudio #Autodesk #AEC #adsk\n\nthe [Revit API discussion forum](http://forums.autodesk.com/t5/revit-api-forum/bd-p/160) thread\n\n<p style=\"font-size: 80%; font-style:italic\"></p>\n\n-->"
  },
  {
    "original_filename": "1806_effective_filter",
    "header_text": "Forge Rooms, Effective Filtered Element Collectors",
    "local_header_href": "#forge-rooms-effective-filtered-element-collectors",
    "chunk_text": "### Forge Rooms, Effective Filtered Element Collectors\n\nI successfully made it from Switzerland to Paris by train yesterday, in spite of the strikes here.\n\nNow I am happily occupied with the Forge accelerator in the Autodesk office.\n\nMy only worry is how to get back again tomorrow.\nThis time again, the train I had originally booked has been cancelled.\n\nWe'll see how it goes.\n\nMeanwhile, let's take a look at:\n\n- [DA4R room support and new samples](#2)\n- [Effective filtered element collection](#3)\n- [Don't waste time optimising prematurely](#4)"
  },
  {
    "original_filename": "1806_effective_filter",
    "header_text": "DA4R Room Support and New Samples",
    "local_header_href": "#2",
    "chunk_text": "####<a name=\"2\"></a> DA4R Room Support and New Samples\n\nSome recent [Forge Design Automation for Revit or DA4R](https://thebuildingcoder.typepad.com/blog/about-the-author.html#5.55) news\nand samples:\n\nMost importantly,\na [new RVT to SVF model derivative parameter generates additional content, including rooms and spaces](https://forge.autodesk.com/blog/new-rvt-svf-model-derivative-parameter-generates-additional-content-including-rooms-and-spaces).\n\nLots of other exciting [new samples](https://forge.autodesk.com/categories/code-samples) are available, including:\n\n- Run additional programs inside a WorkItem\n- Get number of BIM 360 projects per user\n- Working with 2D and 3D scenes and geometry in Forge Viewer\n- Fast track your cross-platform React native Forge app with the Expo SDK\n- How to convert your plugin to work with Design Automation API for AutoCAD\n- Go semantic with Viewer-custom web component for Forge Viewer\n- New RVT->SVF Model Derivative parameter generates additional content, including rooms and spaces\n- Combining PointClouds and Revit models in Forge Viewer\n- Switch to orthographic corner view\n- Custom BIM 360 search with Elasticsearch\n- Get volume and surface area in the Viewer\n- Run command from an AutoCAD AppBundle\n- Run iLogic Rule without AppBundle\n\nHere is a [link to view all samples](https://forge.autodesk.com/categories/code-samples)."
  },
  {
    "original_filename": "1806_effective_filter",
    "header_text": "Effective Filtered Element Collection",
    "local_header_href": "#3",
    "chunk_text": "####<a name=\"3\"></a> Effective Filtered Element Collection\n\nBack to the desktop Revit API, one issue that almost every Revit add-in developer faces is the efficiency of filtered element collectors.\n\nSeveral interesting aspects are pointed out (and repeated) in the thread on \nan [efficient way to check if an element exists in a view](https://forums.autodesk.com/t5/revit-api-forum/efficient-way-to-check-if-an-element-exists-in-a-view/m-p/9187613):\n\n**Question:** I'm creating a list of views that contain .dwg ImportInstance(s).\nFor each view in the document, I'm using a `FilteredElementCollector` to get a list of elements meeting the criteria; if this list is not empty, the view is added to the list:\n\n<pre class=\"code\">\n&nbsp;&nbsp;<span style=\"color:blue;\">foreach</span>(&nbsp;<span style=\"color:#2b91af;\">Element</span>&nbsp;e&nbsp;<span style=\"color:blue;\">in</span>&nbsp;viewElements&nbsp;)\n&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:#2b91af;\">View</span>&nbsp;view&nbsp;=&nbsp;(<span style=\"color:#2b91af;\">View</span>)&nbsp;e;\n \n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">var</span>&nbsp;stopwatch&nbsp;=&nbsp;<span style=\"color:blue;\">new</span>&nbsp;<span style=\"color:#2b91af;\">Stopwatch</span>();\n&nbsp;&nbsp;&nbsp;&nbsp;stopwatch.Start();\n \n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:#2b91af;\">List</span>&lt;<span style=\"color:#2b91af;\">Element</span>&gt;&nbsp;elementsInView\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;<span style=\"color:blue;\">new</span>&nbsp;<span style=\"color:#2b91af;\">FilteredElementCollector</span>(&nbsp;doc,&nbsp;view.Id&nbsp;)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.OfClass(&nbsp;<span style=\"color:blue;\">typeof</span>(&nbsp;<span style=\"color:#2b91af;\">ImportInstance</span>&nbsp;)&nbsp;)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Where(&nbsp;e&nbsp;=&gt;&nbsp;e.Category.Name.EndsWith(&nbsp;<span style=\"color:#a31515;\">&quot;.dwg&quot;</span>&nbsp;)&nbsp;)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.OfType&lt;<span style=\"color:#2b91af;\">Element</span>&gt;()\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.ToList();\n \n&nbsp;&nbsp;&nbsp;&nbsp;stopwatch.Stop();\n \n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:#2b91af;\">Debug</span>.WriteLine(&nbsp;view.Name&nbsp;+&nbsp;<span style=\"color:#a31515;\">&quot;:&nbsp;&quot;</span>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+&nbsp;stopwatch.ElapsedMilliseconds&nbsp;+&nbsp;<span style=\"color:#a31515;\">&quot;ms&quot;</span>&nbsp;);\n \n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:green;\">//&nbsp;if&nbsp;the&nbsp;current&nbsp;view&nbsp;contains&nbsp;at&nbsp;least&nbsp;1&nbsp;DWG</span>\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:green;\">//&nbsp;ImportInstance,&nbsp;add&nbsp;the&nbsp;view&nbsp;to&nbsp;the&nbsp;list</span>\n \n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">if</span>(&nbsp;elementsInView.Count&nbsp;&gt;&nbsp;0&nbsp;)\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;viewsWithCAD.Add(&nbsp;view&nbsp;);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">continue</span>;\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;}\n</pre>\n\nThe FilteredElementCollector can understandably take more than 4000 ms to collect elements from a view containing many elements.\n\nMy goal is only to see if a single element exists in a view &ndash; not to collect all of the elements meeting the criteria; if I could make the FilteredElementCollector stop immediately after finding an element meeting the criteria, that would be helpful. \n\nI would appreciate any advice on how to achieve this more efficiently.\n\nThank you.\n\n**Answer by Fair59**, [Frank Aarssen](https://forums.autodesk.com/t5/user/viewprofilepage/user-id/2083518):\nStopping the collector at the first element:\n\n<pre class=\"code\">\n&nbsp;&nbsp;<span style=\"color:#2b91af;\">Element</span>&nbsp;e1\n&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;<span style=\"color:blue;\">new</span>&nbsp;<span style=\"color:#2b91af;\">FilteredElementCollector</span>(&nbsp;doc,&nbsp;view.Id&nbsp;)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.OfClass(&nbsp;<span style=\"color:blue;\">typeof</span>(&nbsp;<span style=\"color:#2b91af;\">ImportInstance</span>&nbsp;)&nbsp;)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.FirstElement();\n</pre>\n\nPossible further speed improvement:\n\n- Select all `ImportInstance` elements\n- If it is not a DWG: exclude from collector in view-loop &rarr; no need for `category.Name` check\n- Else: if DWG is ViewSpecific, i.e., is \"2D annotation\" in view &rarr; `ownerview` contains DWG, can be added to `viewsWithCAD`, and can be excluded from view-loop\n \n<pre class=\"code\">\n&nbsp;&nbsp;<span style=\"color:#2b91af;\">IEnumerable</span>&lt;<span style=\"color:#2b91af;\">ImportInstance</span>&gt;&nbsp;instances\n&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;<span style=\"color:blue;\">new</span>&nbsp;<span style=\"color:#2b91af;\">FilteredElementCollector</span>(&nbsp;doc&nbsp;)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.OfClass(&nbsp;<span style=\"color:blue;\">typeof</span>(&nbsp;<span style=\"color:#2b91af;\">ImportInstance</span>&nbsp;)&nbsp;)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Cast&lt;<span style=\"color:#2b91af;\">ImportInstance</span>&gt;();\n \n&nbsp;&nbsp;<span style=\"color:#2b91af;\">List</span>&lt;<span style=\"color:#2b91af;\">ElementId</span>&gt;&nbsp;toExclude&nbsp;=&nbsp;<span style=\"color:blue;\">new</span>&nbsp;<span style=\"color:#2b91af;\">List</span>&lt;<span style=\"color:#2b91af;\">ElementId</span>&gt;();\n&nbsp;&nbsp;<span style=\"color:blue;\">foreach</span>(&nbsp;<span style=\"color:#2b91af;\">ImportInstance</span>&nbsp;instance&nbsp;<span style=\"color:blue;\">in</span>&nbsp;instances&nbsp;)\n&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">if</span>(&nbsp;!instance.Category.Name.EndsWith(&nbsp;<span style=\"color:#a31515;\">&quot;.dwg&quot;</span>&nbsp;)&nbsp;)\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;toExclude.Add(&nbsp;instance.Id&nbsp;);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">continue</span>;\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">if</span>(&nbsp;instance.ViewSpecific&nbsp;)&nbsp;<span style=\"color:green;\">//&nbsp;dwg&nbsp;only&nbsp;exists&nbsp;in&nbsp;ownerview</span>\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:#2b91af;\">View</span>&nbsp;ownerview&nbsp;=&nbsp;doc.GetElement(&nbsp;instance.OwnerViewId&nbsp;)&nbsp;<span style=\"color:blue;\">as</span>&nbsp;<span style=\"color:#2b91af;\">View</span>;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;viewsWithCAD.Add(&nbsp;ownerview&nbsp;);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">if</span>(&nbsp;viewElements.Contains(&nbsp;ownerview&nbsp;)&nbsp;)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;viewElements.Remove(&nbsp;ownerview&nbsp;);\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;}\n \n&nbsp;&nbsp;<span style=\"color:blue;\">foreach</span>(&nbsp;<span style=\"color:#2b91af;\">Element</span>&nbsp;e&nbsp;<span style=\"color:blue;\">in</span>&nbsp;viewElements&nbsp;)\n&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:#2b91af;\">View</span>&nbsp;view&nbsp;=&nbsp;(<span style=\"color:#2b91af;\">View</span>)&nbsp;e;\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">var</span>&nbsp;stopwatch&nbsp;=&nbsp;<span style=\"color:blue;\">new</span>&nbsp;<span style=\"color:#2b91af;\">Stopwatch</span>();\n&nbsp;&nbsp;&nbsp;&nbsp;stopwatch.Start();\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:#2b91af;\">Element</span>&nbsp;e1&nbsp;=&nbsp;<span style=\"color:blue;\">null</span>;\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">if</span>(&nbsp;toExclude.Count&nbsp;&gt;&nbsp;0&nbsp;)\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e1&nbsp;=&nbsp;<span style=\"color:blue;\">new</span>&nbsp;<span style=\"color:#2b91af;\">FilteredElementCollector</span>(&nbsp;doc,&nbsp;view.Id&nbsp;)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Excluding(&nbsp;toExclude&nbsp;)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.OfClass(&nbsp;<span style=\"color:blue;\">typeof</span>(&nbsp;<span style=\"color:#2b91af;\">ImportInstance</span>&nbsp;)&nbsp;)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.FirstElement();\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">else</span>\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e1&nbsp;=&nbsp;<span style=\"color:blue;\">new</span>&nbsp;<span style=\"color:#2b91af;\">FilteredElementCollector</span>(&nbsp;doc,&nbsp;view.Id&nbsp;)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.OfClass(&nbsp;<span style=\"color:blue;\">typeof</span>(&nbsp;<span style=\"color:#2b91af;\">ImportInstance</span>&nbsp;)&nbsp;)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.FirstElement();\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;stopwatch.Stop();\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:#2b91af;\">Debug</span>.WriteLine(&nbsp;view.Name&nbsp;+&nbsp;<span style=\"color:#a31515;\">&quot;:&nbsp;&quot;</span>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+&nbsp;stopwatch.ElapsedMilliseconds&nbsp;+&nbsp;<span style=\"color:#a31515;\">&quot;ms&quot;</span>&nbsp;);\n \n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:green;\">//&nbsp;if&nbsp;the&nbsp;current&nbsp;view&nbsp;contains&nbsp;at&nbsp;least&nbsp;1&nbsp;DWG</span>\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:green;\">//&nbsp;ImportInstance,&nbsp;add&nbsp;the&nbsp;view&nbsp;to&nbsp;the&nbsp;list</span>\n \n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">if</span>(&nbsp;e1&nbsp;!=&nbsp;<span style=\"color:blue;\">null</span>&nbsp;)\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;viewsWithCAD.Add(&nbsp;view&nbsp;);\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;}\n</pre>\n\nMany thanks for the interesting question, and many thanks to Fair59 for yet another extremely knowledgeable and helpful solution!\n\n**Notes:** I do keep pointing out that converting a filtered element collector to a List is an inefficient thing to do, if you can avoid it.\n\nIt forces the collector to retrieve all the data, convert it to the .NET memory space, duplicate it, costing time and space.\n\nFor the same reasons, it is much more efficient to test and apply as many filters as possible within the Revit memory space before passing any data across to .NET.\n\nIn this case, you can test the parameter values using a parameter filter instead of the LINQ post-processing that you are applying in you sample code snippet.\n\nAs Fair59 points out and we have discussed in the past, you can cancel a collector as soon as your target has been reached:\n\n- [Aborting filtered element collection](https://thebuildingcoder.typepad.com/blog/2019/02/cancelling-filtered-element-collection.html)\n\nSo, you can save time and space in several ways:\n\n- Use a parameter filter instead of LINQ or .NET post-processing\n- Do not convert to a `List`\n\nBoth of these force the filtered element collector to retrieve and return all results.\n\nHere is an explanation of the various types of filters versus post-processing in .NET:\n\n- [Slow, slower still and faster filtering](https://thebuildingcoder.typepad.com/blog/2019/04/slow-slower-still-and-faster-filtering.html)\n\nHere are some discussions and a benchmark of the results of using a parameter filter versus LINQ and .NET post-processing:\n\n- [Filtering for a specific parameter value](https://thebuildingcoder.typepad.com/blog/2018/06/forge-tutorials-and-filtering-for-a-parameter-value.html#3)\n- [Filtered element collector benchmark](https://thebuildingcoder.typepad.com/blog/2019/05/filtered-element-collector-benchmark.html#3)\n\nWe also discussed the issue of finding all views displaying an element a couple of times in the past:\n\n- [Views displaying given element](https://thebuildingcoder.typepad.com/blog/2014/05/views-displaying-given-element-svg-and-nosql.html#6)\n- [Determining views showing an element](https://thebuildingcoder.typepad.com/blog/2016/12/determining-views-showing-an-element.html)\n- [Retrieving elements visible in view](https://thebuildingcoder.typepad.com/blog/2017/05/retrieving-elements-visible-in-view.html)\n- [Can you avoid generating graphics?](https://thebuildingcoder.typepad.com/blog/2019/10/generating-graphics-and-collecting-assets.html#2)\n\n<center>\n<img src=\"img/harvester.png\" alt=\"Harvester\" width=\"321\"> <!--642-->\n</center>"
  },
  {
    "original_filename": "1806_effective_filter",
    "header_text": "Don't Waste Time Optimising Prematurely",
    "local_header_href": "#4",
    "chunk_text": "####<a name=\"4\"></a> Don't Waste Time Optimising Prematurely\n\n[Mastjaso](https://forums.autodesk.com/t5/user/viewprofilepage/user-id/1058186) adds\nsome important professional advice in\nhis [comment below](https://thebuildingcoder.typepad.com/blog/2019/12/forge-rooms-effective-filtered-element-collectors.html#comment-4719321388):\n\n> Interesting discussion on filtered element collectors, though I have to say that I have personally spend far too much time worrying about the efficiencies of those collectors when it has turned out to be inconsequential.\n\n> For new developers starting out, or ones tackling a new project for the first time, I'd remember the adage that premature optimization is the death of software.\nI start basically all my projects with super basic `OfClass` filtered element collectors and then cast and convert them to the .NET memory space so that I can use LINQ which produces shorter, more readable, and easier to debug code than the filtered element collection API.\nIt's only near the end of a project, once features are settled that I'll start swapping out LINQ for more nuanced uses of the FEC, but even then I'll only do it *if* I need the performance boost somewhere.\n\nBefore optimising anything at all, benchmark or profile to find out where and whether there are any serious performance issues at all."
  }
]