[
  {
    "original_filename": "0453_model_elements",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<head>\n<link href=\"bc.css\" rel=\"stylesheet\" type=\"text/css\"/>\n</head>"
  },
  {
    "original_filename": "0453_model_elements",
    "header_text": "Selecting Model Elements",
    "local_header_href": "#selecting-model-elements",
    "chunk_text": "<h3>Selecting Model Elements</h3><p>We repeatedly looked at the \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2009/11/select-model-elements-2.html\">\nselection of model elements</a>,\n\nand in the discussion on \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/02/material-quantity-extraction.html\">\nmaterial quantity extraction</a> I \n\nmentioned the idea that one possible additional improvement might be to make use of the Category.HasMaterialQuantities property.\n\n<p>The topic keeps returning, and now it arose again in a question from Konstanty Seniut.\nI have updated the answer after the initial posting to add some \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/10/model-elements-revisited.html\">\nlater notes</a> by <!-- add link -->\n\nScott Conover, so that they are not missed.\nTo see Scott's notes and explanations in full, please refer to the \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/10/model-elements-revisited.html\">\nfollow-up post</a>. <!-- add link -->\n<p><strong>Question:</strong> I would like to retrieve all elements from the model, for example floors, walls, windows, lines, but ignoring all views, levels and etc. \nFor now my solution is simply to make list of all the categories of the things that I don't want to retrieve. \nIs there any easier way to achieve this? \n\n<p>Currently, the following approach is working for me:\n\n<pre class=\"code\">\n<span class=\"teal\">Dictionary</span>&lt;<span class=\"blue\">string</span>, <span class=\"teal\">Category</span>&gt; GetAllCategories( \n  <span class=\"teal\">List</span>&lt;<span class=\"teal\">Document</span>&gt; allDocuments )\n{\n  <span class=\"teal\">Dictionary</span>&lt;<span class=\"blue\">string</span>, <span class=\"teal\">Category</span>&gt; categories \n    = <span class=\"blue\">new</span> <span class=\"teal\">Dictionary</span>&lt;<span class=\"blue\">string</span>, <span class=\"teal\">Category</span>&gt;();\n \n  <span class=\"teal\">Dictionary</span>&lt;<span class=\"blue\">int</span>, <span class=\"teal\">Element</span>&gt; elemnts \n    = <span class=\"blue\">new</span> <span class=\"teal\">Dictionary</span>&lt;<span class=\"blue\">int</span>, <span class=\"teal\">Element</span>&gt;();\n \n  <span class=\"blue\">foreach</span>( <span class=\"teal\">Document</span> doc <span class=\"blue\">in</span> allDocuments )\n  {\n    <span class=\"teal\">FilteredElementCollector</span> collector \n      = <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( doc );\n \n    <span class=\"teal\">IList</span>&lt;Autodesk.Revit.DB.<span class=\"teal\">Element</span>&gt; found \n      = collector\n        .WhereElementIsNotElementType()\n        .WhereElementIsViewIndependent()\n        .WherePasses( <span class=\"blue\">new</span> <span class=\"teal\">LogicalOrFilter</span>( \n          <span class=\"blue\">new</span> <span class=\"teal\">ElementIsElementTypeFilter</span>( <span class=\"blue\">false</span> ), \n          <span class=\"blue\">new</span> <span class=\"teal\">ElementIsElementTypeFilter</span>( <span class=\"blue\">true</span> ) ) )\n        .ToElements();\n \n    <span class=\"blue\">var</span> disElems = (<span class=\"blue\">from</span> elem <span class=\"blue\">in</span> found <span class=\"blue\">select</span> elem)\n      .Distinct();\n \n    <span class=\"blue\">foreach</span>( <span class=\"teal\">Element</span> element <span class=\"blue\">in</span> disElems )\n    {\n      <span class=\"blue\">if</span>( element.Category != <span class=\"blue\">null</span> )\n      {\n        <span class=\"blue\">if</span>( element.Parameters.Size &gt; 0 )\n        {\n          <span class=\"blue\">if</span>( element.PhaseCreated != <span class=\"blue\">null</span> )\n          {\n            <span class=\"blue\">if</span>( !categories.ContainsKey( \n              element.Category.Name ) )\n            {\n              categories.Add( \n                element.Category.Name, \n                element.Category );\n \n              elemnts.Add( \n                element.Category.Id.IntegerValue, \n                element );\n            }\n          }\n          <span class=\"blue\">else</span> <span class=\"blue\">if</span>( element.Location != <span class=\"blue\">null</span> )\n          {\n            <span class=\"teal\">LocationPoint</span> point = <span class=\"blue\">null</span>;\n            <span class=\"teal\">LocationCurve</span> curve = <span class=\"blue\">null</span>;\n            <span class=\"blue\">try</span>\n            {\n              point = element.Location \n                <span class=\"blue\">as</span> <span class=\"teal\">LocationPoint</span>;\n            }\n            <span class=\"blue\">catch</span> { }\n \n            <span class=\"blue\">try</span>\n            {\n              curve = element.Location \n                <span class=\"blue\">as</span> <span class=\"teal\">LocationCurve</span>;\n            }\n            <span class=\"blue\">catch</span> { }\n \n            <span class=\"blue\">if</span>( curve != <span class=\"blue\">null</span> || point != <span class=\"blue\">null</span> )\n            {\n              <span class=\"blue\">if</span>( !categories.ContainsKey( \n                element.Category.Name ) )\n              {\n                categories.Add( \n                  element.Category.Name, \n                  element.Category );\n \n                elemnts.Add( \n                  element.Category.Id.IntegerValue, \n                  element );\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  <span class=\"blue\">return</span> categories;\n}\n</pre>\n<p>Is this a good solution? \nWhat do you think?\n\n<p><strong>Answer:</strong> As said, I presented one approach in the \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2009/11/select-model-elements-2.html\">\nselection of model elements</a>.\n\nScott \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/10/model-elements-revisited.html\">\nlater pointed out</a> <!-- add link -->\n\nthat that solution appends filters to each other one at a time. \nThe new Revit 2011 LogicalOrFilters support more than two inputs, so it should actually be updated to make more efficient use of 2011 filtering.\n\n<p>The other approach I mentioned, based on the Category.HasMaterialQuantities property, allows a much shorter implementation like this:\n\n<pre class=\"code\">\n[<span class=\"teal\">Transaction</span>( <span class=\"teal\">TransactionMode</span>.ReadOnly )]\n[<span class=\"teal\">Regeneration</span>( <span class=\"teal\">RegenerationOption</span>.Manual )]\n<span class=\"blue\">public</span> <span class=\"blue\">class</span> <span class=\"teal\">Lab2_2_ModelElements</span> : <span class=\"teal\">IExternalCommand</span>\n{\n  <span class=\"blue\">public</span> <span class=\"teal\">Result</span> Execute(\n    <span class=\"teal\">ExternalCommandData</span> commandData,\n    <span class=\"blue\">ref</span> <span class=\"blue\">string</span> message,\n    <span class=\"teal\">ElementSet</span> elements )\n  {\n    <span class=\"teal\">UIApplication</span> app = commandData.Application;\n    <span class=\"teal\">Document</span> doc = app.ActiveUIDocument.Document;\n \n    <span class=\"teal\">FilteredElementCollector</span> collector\n      = <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( doc )\n        .WhereElementIsNotElementType();\n \n    <span class=\"teal\">List</span>&lt;<span class=\"blue\">string</span>&gt; a = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"blue\">string</span>&gt;();\n \n    <span class=\"blue\">foreach</span>( <span class=\"teal\">Element</span> e <span class=\"blue\">in</span> collector )\n    {\n      <span class=\"green\">//  &amp;&amp; null != e.Materials</span>\n      <span class=\"green\">//  &amp;&amp; 0 &lt; e.Materials.Size</span>\n \n      <span class=\"blue\">if</span>( <span class=\"blue\">null</span> != e.Category\n        &amp;&amp; e.Category.HasMaterialQuantities )\n      {\n        a.Add( <span class=\"blue\">string</span>.Format(\n          <span class=\"maroon\">\"Category={0}; Name={1}; Id={2}\"</span>,\n          e.Category.Name, e.Name, \n          e.Id.IntegerValue ) );\n      }\n    }\n \n    <span class=\"teal\">LabUtils</span>.InfoMsg( \n      <span class=\"maroon\">\"Project contains {0} model element{1}{2}\"</span>, a );\n \n    <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n  }\n}\n</pre>\n<p>Note that this approach may not retrieve all desired elements, as Scott explains in his \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/10/model-elements-revisited.html\">\nupdate notes</a>.  <!-- add link -->\n<p>Which approach to use, or how to combine them, depends on your exact needs, obviously.\n\n<p>Some notes on your implementation:\n\n<ul>\n<li>I find the check for parameters interesting, and also checking the PhaseCreated and Location properties.\n\n<li>I would recommend you never to use an \n\n<a href=\"http://en.wikipedia.org/wiki/Exception_handling\">\nexception handler</a> to \n\ncheck for a valid condition, if you can avoid it.\n\n<a href=\"http://www.jacopretorius.net/2009/10/exceptions-should-be-exceptional.html\">\nExceptions should always be exceptional</a>, \n\nfor handling unexpected errors.\n\n<li>Scott \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/10/model-elements-revisited.html\">\nlater pointed out</a> <!-- add link -->\n\nthat the use of the WherePasses clause is totally unnecessary and should be removed.\n</li></li></li></ul>\n<p><strong>Response:</strong> The additional check for Category.HasMaterialQuantities suits me well for now. \nThank you very much!\n\n<p>The first approach you suggested in the blog is very good; in the beginning of solving this problem I had a similar idea to make list of redundant categories, but I wanted a simpler approach.\n\n<p>My final solution for now is:\n\n<pre class=\"code\">\n<span class=\"blue\">private</span> <span class=\"blue\">void</span> GetAllCategories( \n  <span class=\"teal\">List</span>&lt;<span class=\"teal\">Document</span>&gt; allDocuments )\n{\n  <span class=\"teal\">Dictionary</span>&lt;<span class=\"blue\">string</span>, <span class=\"teal\">Category</span>&gt; categories \n    = <span class=\"blue\">new</span> <span class=\"teal\">Dictionary</span>&lt;<span class=\"blue\">string</span>, <span class=\"teal\">Category</span>&gt;();\n \n  <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt; elements = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt;();\n \n  <span class=\"blue\">foreach</span>( <span class=\"teal\">Document</span> doc <span class=\"blue\">in</span> allDocuments )\n  {\n    <span class=\"teal\">FilteredElementCollector</span> collector \n      = <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( doc );\n \n    collector\n      .WhereElementIsNotElementType()\n      .WhereElementIsViewIndependent()\n      .ToElements();\n \n    <span class=\"blue\">foreach</span>( <span class=\"teal\">Element</span> element <span class=\"blue\">in</span> collector )\n    {\n      <span class=\"blue\">if</span>( <span class=\"blue\">null</span> != element.Category\n        &amp;&amp; 0 &lt; element.Parameters.Size\n        &amp;&amp; (element.Category.HasMaterialQuantities \n          || <span class=\"blue\">null</span> != element.PhaseCreated) )\n      {\n        <span class=\"blue\">if</span>( !categories.ContainsKey( \n          element.Category.Name ) )\n        {\n          categories.Add( \n            element.Category.Name, \n            element.Category );\n        }\n        elements.Add( element );\n      }\n    }\n  }\n}\n</pre>\n<p>If in future there will be any need to retrieve some specific categories, I can use a list of specific categories in addition to this approach. \n\n<p>For now I do not know how to eliminate the try catch when needing to check the Location property, because I had situations when an element had a Location, but trying to access it threw an exception.\nAt the moment I can avoid checking that property completely, though.\n\n<p>I think it is good idea to share :) maybe someone like me will have a similar problem also :)\n\n<p><strong>Answer:</strong> The call to ToElements in this code is completely redundant, as Scott explains in his \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/10/model-elements-revisited.html\">\nupdate notes</a>,  <!-- add link -->\n\nso it should simply be removed.\n\n<p><strong>Response:</strong> Interesting things. I will try to improve them. \nThe HasMaterialQuantities property is not set in every element I am interested in, just as Scott said.\nThis is why I used the Location property to populate the dictionary with all specific elements  :)\n</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p>"
  }
]