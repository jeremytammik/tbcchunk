[
  {
    "original_filename": "0656_unofficial_param",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<head>\n<link href=\"bc.css\" rel=\"stylesheet\" type=\"text/css\"/>\n</head>"
  },
  {
    "original_filename": "0656_unofficial_param",
    "header_text": "Unofficial Parameters and BipChecker",
    "local_header_href": "#unofficial-parameters-and-bipchecker",
    "chunk_text": "<h3>Unofficial Parameters and BipChecker</h3><p>I climbed the \n\n<a href=\"http://www.mountwiki.com/wiki/view/Nadelhorn\">\nNadelhorn</a> last \n\nweekend, the highest point in Switzerland for me so far, and the second highest point I have ever been, actually, 4387 m.\nExcept for airplanes, of course.\nHere is a picture of the panorama from the Nadehorn summit with Monte Rosa, Dom, Matterhorn, Mont Blanc, etc.</p><center>\n<img alt=\"Nadelhorn summit panorama\" src=\"file:////j/photo/jeremy/2011/2011-09-23_nadelhorn/56.jpg\" width=\"800\"/>\n</center><p>Here are some\n\n<a href=\"https://picasaweb.google.com/104316998805199988071/Nadelhorn4327mSaisonabschlussMitJeremy?authuser=0&amp;authkey=Gv1sRgCJnTodeiktKZ4wE\">\nmore pictures</a> of\n\nour tour.\n\n<p>Meanwhile, on the Revit API side, Victor Chekalin, or Виктор Чекалин, raised a number of pertinent issues lately. \nOne of them is this question in the\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2008/11/exploring-element-parameters.html?cid=6a00e553e168978833015391c90d6e970b#comment-6a00e553e168978833015391c90d6e970b\">\ncomment</a> on\n\nparameters:\n\n<p><strong>Question:</strong> In my project I find parameters on a particular element that do not appear in the Element.Parameters collection. \nIn \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2008/11/exploring-element-parameters.html\">\nexploring element parameters</a>, \n\nyou wrote: \"Sometimes an element will have other parameters attached to it as well, which are not listed in the 'official' collection returned by the Parameters property. \nTo explore all parameters attached to an element, one can make use of the built-in parameter checker.\" \nAnd nothing more. \nCan you explain the meaning of these parameters? \nIn my case I need to get the length of any element if length exists. \nI wrote the \n\n<a href=\"http://pastebin.com/GgKFmxdD\">\nfollowing code</a> for it: \n\n<pre class=\"code\">\n<span class=\"blue\">private</span> <span class=\"teal\">Double</span>? GetElementLength( <span class=\"teal\">Element</span> element )\n{\n  <span class=\"blue\">var</span> lengthParam \n    = <span class=\"teal\">Enum</span>.GetValues( <span class=\"blue\">typeof</span>( <span class=\"teal\">BuiltInParameter</span> ) )\n      .OfType&lt;<span class=\"teal\">BuiltInParameter</span>&gt;()\n      .Where( p =&gt; p.ToString().Contains( <span class=\"maroon\">\"LENGTH\"</span> ) )\n      .Select( param =&gt; element.get_Parameter( param ) )\n      .Where( param =&gt; param != <span class=\"blue\">null</span> )\n      .FirstOrDefault();\n \n  <span class=\"blue\">if</span>( lengthParam != <span class=\"blue\">null</span> )\n  {\n    <span class=\"blue\">var</span> lengthValue = lengthParam.AsDouble();\n    <span class=\"blue\">return</span> lengthValue;\n  }\n \n  <span class=\"blue\">return</span> <span class=\"blue\">null</span>;\n}\n</pre>\n<p>At first in BuiltInParameters I find all parameters whose name contains the word \"LENGTH\". \nThen I check for each if this BuiltInParameter exists in element. \nIf it exists, return the value of this parameter. \nThe problem: there are sometimes no length parameters in Element.Parameters, but I can still retrieve such a parameter via Element.get_Parameter. \nOf course I can get the length of the element by enumerating all parameters and checking the parameter name for length, but I'm curious about these \"strange invisible\" parameters. \n\n<p><strong>Answer:</strong> Yes, there may be lots of parameters attached to elements that do not appear in the 'official' Element.Parameters collection.\n\n<p>You can retrieve them using any of the standard Element.Parameter property overloads. \n\n<h4>The Element.Parameter Property</h4>\n<p>While we are at it, here are a few observations of strangeness on the Parameter property itself:\n\n<ul>\n<li>Yes, it is a property, and still, yes, it takes an argument.\n<li>Yes, it does not exist in C# per se, because it is called get_Parameter there instead. \n<li>Yes, these two observations may be connected, even mutually dependent.\n</li></li></li></ul>\n<p>The complete list of arguments accepted by the overloads of the Parameter property or get_Parameter method is:\n\n<ul>\n<li>BuiltInParameter: Retrieves a parameter from the element given a parameter id. \n\n<li>Definition: Retrieves a parameter from the element based on its definition. \n\n<li>Guid: Retrieves a parameter from the element given a GUID for a shared parameter. \n\n<li>String: Retrieves a parameter from the element given its name. \n</li></li></li></li></ul>The Definition and name string can be provided and used for any parameter. \nThe BuiltInParameter enumeration value or 'parameter id' as it is called above only works for built-in parameters, and the GUID only for shared ones, so they work for mutually exclusive situations.\n\n<p>So if the parameter you are looking for is named \"Length\", you can retrieve it using that name.\n\n<p>I would recommend you <b>not to do so</b>, however, because this makes you code language dependent.\n\n<p>Better is to determine exactly which built-in parameter corresponds to it and use that instead.\n\n<p>Another issue with the approach you describe above is that for a complex element, there may be several different built-in parameters whose enumeration name contains the substring \"LENGTH\", and they may have completely different meanings. \nIt is even not completely clear what you yourself mean by 'length' of an element.\n\n<h4>Snooping and the Built-in Parameter Checker</h4>\n<p>Here is a code snippet with a loop that shows how to retrieve all parameters from an element. Actually, it may not retrieve all, but it mostly retrieves more than the official Parameters collection contains:\n\n<pre class=\"code\">\nArray bips = Enum.GetValues(typeof(BuiltInParameter));\nParameter p;\nforeach (BuiltInParameter a in bips)\n{\n  try\n  {\n    p = elem.get_Parameter(a);\n  }\n  catch { }\n}\n</pre>\n<p>This kind of loop to retrieve a value for each and every built-in parameter enumeration value is also used by the RevitLookup 'Built-In Enum Snoop' in the Snoop Parameters dialogue and my own built-in parameter checker.\nHere are some explorations I made in the past in which I discussed the use of these tools and provided the source code for my built-in parameter checker:\n\n<!--\n042_exploring_param.htm:and now we will recapitulate some basic\n099_locked_dimension.htm:built-in parameter checker.\n118_deeper_param_exploration.htm:<p>Looking at the element inst\n220_door_marks.htm:built-in parameter checker</a> to\n246_room_occupancy.htm:built-in parameter checker</a>.\n247_title_block_of_sheet.htm:built-in parameter checker</a> can\n364_pre_post_pick_select.htm:<a href=\"http://thebuildingcoder.t\n371_sheet_size.htm:<p>I analysed a sample project using the Rev\n512_lang_indep_subcat.htm:<p><strong>Answer:</strong> Have you\n\nExploring Element Parameters\nLocked Dimensioning\nDeeper Parameter Exploration\nDoor Marks\nRoom Occupancy\nTitle Block of Sheet\nPre-, Post- and Pick Select\nDetermine Sheet Size\n-->\n<ul>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2008/11/exploring-element-parameters.html\">Exploring element parameters</a>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2009/02/locked-dimensioning.html\">Locked dimensioning</a>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2009/04/deeper-parameter-exploration.html\">Deeper parameter exploration</a>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2009/09/door-marks.html\">Door marks</a>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2009/11/room-occupancy.html\">Room occupancy</a>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2009/11/title-block-of-sheet.html\">Title block of sheet</a>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2010/05/pre-post-and-pick-select.html\">Pre-, post- and pick selection</a>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2010/05/determine-sheet-size.html\">Determining sheet size</a>\n</li></li></li></li></li></li></li></li></ul>\n<p>Since I do find my built-in parameter checker a very handy tool I decided to simplify access to and installation of it by extracting the code from the obsolete Revit API Introduction Labs.\n\n<p>Besides simply displaying the list of 'unofficial' element parameter values, like the RevitLookup 'Built-In Enum Snoop' functionality, this tool provides the following additional advantages:\n\n<ul>\n<li>For elements than cannot be selected on the screen, prompt to enter the element id to select them instead.\n<li>For elements with a type, prompt whether to display type or instance parameter data.\n<li>List the results in a data grid view.\n<li>Display the built-in parameter enumeration value and the user visible parameter name side by side.\n<li>Display both the internal database value and the user visible string value of real-valued data.\n<li>Sort the results by the values of any column.\n<li>Copy the entire list of data to the clipboard.\n</li></li></li></li></li></li></li></ul>\n<p>The ability to sort by any column makes it much easier to find the records you are interested in, since you can sort by and then locate by either built-in parameter enumeration value, user visibly name, type, string or database value, or even read-write status.\n\n<p>Extracting and cleaning up this code also provided a welcome opportunity to make use of the generic CanHaveTypeAssigned and GetTypeId element methods.\nPreviously, the tool only supported displaying the type parameters for family instances.\nNow, this functionality should work for all elements that can have a type.\nThe updated code of the external command Execute mainline below includes both the old family instance code and the implementation of the new generic functionality:\n\n<pre class=\"code\">\n<span class=\"blue\">public</span> <span class=\"teal\">Result</span> Execute(\n  <span class=\"teal\">ExternalCommandData</span> commandData,\n  <span class=\"blue\">ref</span> <span class=\"blue\">string</span> message,\n  <span class=\"teal\">ElementSet</span> elements )\n{\n  <span class=\"teal\">UIApplication</span> uiapp = commandData.Application;\n  <span class=\"teal\">UIDocument</span> uidoc = uiapp.ActiveUIDocument;\n  <span class=\"teal\">Document</span> doc = uidoc.Document;\n \n  <span class=\"green\">// Select element:</span>\n \n  <span class=\"teal\">Element</span> e \n    = <span class=\"teal\">Util</span>.GetSingleSelectedElementOrPrompt( \n      uidoc );\n \n  <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == e )\n  {\n    <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Cancelled;\n  }\n  <span class=\"blue\">bool</span> isSymbol = <span class=\"blue\">false</span>;\n  <span class=\"blue\">string</span> family_name = <span class=\"blue\">string</span>.Empty;\n \n  <span class=\"green\">// For a family instance, ask user whether to </span>\n  <span class=\"green\">// display instance or type parameters; in a </span>\n  <span class=\"green\">// similar manner, we could add dedicated </span>\n  <span class=\"green\">// switches for Wall --&gt; WallType, </span>\n  <span class=\"green\">// Floor --&gt; FloorType etc. ...</span>\n \n  <span class=\"blue\">if</span>( e <span class=\"blue\">is</span> <span class=\"teal\">FamilyInstance</span> )\n  {\n    <span class=\"teal\">FamilyInstance</span> inst = e <span class=\"blue\">as</span> <span class=\"teal\">FamilyInstance</span>;\n    <span class=\"blue\">if</span>( <span class=\"blue\">null</span> != inst.Symbol )\n    {\n      <span class=\"blue\">string</span> symbol_name = <span class=\"teal\">Util</span>.ElementDescription( \n        inst.Symbol, <span class=\"blue\">true</span> );\n \n      family_name = <span class=\"teal\">Util</span>.ElementDescription( \n        inst.Symbol.Family, <span class=\"blue\">true</span> );\n \n      <span class=\"blue\">string</span> msg = <span class=\"blue\">string</span>.Format( _type_prompt,\n        <span class=\"maroon\">\"is a family instance\"</span> );\n \n      <span class=\"blue\">if</span>( !<span class=\"teal\">Util</span>.QuestionMsg( msg ) )\n      {\n        e = inst.Symbol;\n        isSymbol = <span class=\"blue\">true</span>;\n      }\n    }\n  }\n  <span class=\"blue\">else</span> <span class=\"blue\">if</span>( e.CanHaveTypeAssigned() )\n  {\n    <span class=\"teal\">ElementId</span> typeId = e.GetTypeId();\n    <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == typeId )\n    {\n      <span class=\"teal\">Util</span>.InfoMsg( <span class=\"maroon\">\"Element can have a type,\"</span>\n        + <span class=\"maroon\">\" but the current type is null.\"</span> );\n    }\n    <span class=\"blue\">else</span> <span class=\"blue\">if</span>( <span class=\"teal\">ElementId</span>.InvalidElementId == typeId )\n    {\n      <span class=\"teal\">Util</span>.InfoMsg( <span class=\"maroon\">\"Element can have a type,\"</span>\n        + <span class=\"maroon\">\" but the current type id is the\"</span>\n        + <span class=\"maroon\">\" invalid element id.\"</span> );\n    }\n    <span class=\"blue\">else</span>\n \n    {\n      <span class=\"teal\">Element</span> type = doc.get_Element( typeId );\n \n      <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == type )\n      {\n        <span class=\"teal\">Util</span>.InfoMsg( <span class=\"maroon\">\"Element has a type,\"</span>\n          + <span class=\"maroon\">\" but it cannot be accessed.\"</span> );\n      }\n      <span class=\"blue\">else</span>\n      {\n        <span class=\"blue\">string</span> msg = <span class=\"blue\">string</span>.Format( _type_prompt,\n          <span class=\"maroon\">\"has an element type\"</span> );\n \n        <span class=\"blue\">if</span>( !<span class=\"teal\">Util</span>.QuestionMsg( msg ) )\n        {\n          e = type;\n          isSymbol = <span class=\"blue\">true</span>;\n        }\n      }\n    }\n  }\n \n  <span class=\"green\">// Retrieve parameter data:</span>\n \n  <span class=\"teal\">SortableBindingList</span>&lt;<span class=\"teal\">ParameterData</span>&gt; data \n    = <span class=\"blue\">new</span> <span class=\"teal\">SortableBindingList</span>&lt;<span class=\"teal\">ParameterData</span>&gt;();\n \n  {\n    <span class=\"teal\">WaitCursor</span> waitCursor = <span class=\"blue\">new</span> <span class=\"teal\">WaitCursor</span>();\n \n    <span class=\"teal\">Array</span> bips = <span class=\"teal\">Enum</span>.GetValues( \n      <span class=\"blue\">typeof</span>( <span class=\"teal\">BuiltInParameter</span> ) );\n \n    <span class=\"blue\">int</span> n = bips.Length;\n    <span class=\"teal\">Parameter</span> p;\n \n    <span class=\"blue\">foreach</span>( <span class=\"teal\">BuiltInParameter</span> a <span class=\"blue\">in</span> bips )\n    {\n      <span class=\"blue\">try</span>\n      {\n        p = e.get_Parameter( a );\n \n        <span class=\"blue\">if</span>( <span class=\"blue\">null</span> != p )\n        {\n          <span class=\"blue\">string</span> valueString = \n            (<span class=\"teal\">StorageType</span>.ElementId == p.StorageType)\n              ? <span class=\"teal\">Util</span>.GetParameterValue2( p, doc )\n              : p.AsValueString();\n \n          data.Add( <span class=\"blue\">new</span> <span class=\"teal\">ParameterData</span>( a, p, \n            valueString ) );\n        }\n      }\n      <span class=\"blue\">catch</span>( <span class=\"teal\">Exception</span> ex )\n      {\n        <span class=\"teal\">Debug</span>.Print( \n          <span class=\"maroon\">\"Exception retrieving built-in parameter {0}: {1}\"</span>,\n          a, ex );\n      }\n    }\n  }\n \n  <span class=\"green\">// Display form:</span>\n \n  <span class=\"blue\">string</span> description \n    = <span class=\"teal\">Util</span>.ElementDescription( e, <span class=\"blue\">true</span> ) \n    + ( isSymbol \n      ? <span class=\"maroon\">\" Type\"</span> \n      : <span class=\"maroon\">\" Instance\"</span> );\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">BuiltInParamsCheckerForm</span> form \n    = <span class=\"blue\">new</span> <span class=\"teal\">BuiltInParamsCheckerForm</span>( \n      description, data ) )\n  {\n    form.ShowDialog();\n  }\n  <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Succeeded;\n}\n</pre>\n<p>For the rest of the implementation, please refer to\n\n<a href=\"zip/BipChecker01.zip\">BipChecker01.zip</a> containing \n\nthe full source code, add-in manifest, and Visual Studio solution for BipChecker version 2012.0.1.0.\n\n<p><strong>Response:</strong> I understood that parameters may not appear in the Element.Parameters collection, and also how to get them via the Element.get_Parameter method.  I still do not understand why Autodesk developers make some parameters hidden from user. \nI guess that these hidden parameters are system related and used in system methods. \nIs that it?  \n\n<p>I find it difficult to know whether parameter is present in the Element.Parameters collection or not. \nI've found only one way to check it:\n\n<pre class=\"code\">\n<span class=\"blue\">bool</span> IsParameterInCollection( <span class=\"teal\">Parameter</span> parameter )\n{\n  <span class=\"blue\">foreach</span>( <span class=\"teal\">Parameter</span> p \n    <span class=\"blue\">in</span> parameter.Element.Parameters )\n  {\n    <span class=\"blue\">if</span>( p.IsShared \n      != _parameter.IsShared )\n    {\n      <span class=\"blue\">return</span> <span class=\"blue\">false</span>;\n    }\n \n    <span class=\"blue\">if</span>( ( p.Definition <span class=\"blue\">as</span> \n        <span class=\"teal\">InternalDefinition</span> ).BuiltInParameter \n      == ( _parameter.Definition <span class=\"blue\">as</span> \n        <span class=\"teal\">InternalDefinition</span> ).BuiltInParameter )\n    {\n      _parameterInElementParametersCollection = <span class=\"blue\">true</span>;\n      <span class=\"blue\">return</span> <span class=\"blue\">true</span>;\n    }\n  }\n  <span class=\"blue\">return</span> <span class=\"blue\">false</span>;\n}\n</pre>\n<p>Regarding the second question on how to get the length of any element:\n\n<p>I agree with you that looking for parameter whose name contains 'Length' is a bad approach.\n\n<p>You say 'Better is to determine exactly which built-in parameter corresponds to it and use that instead'.\nBut how I can do it if I don't know anything about the element I am analysing? \nIn my case it may be absolutely any element.\n\n<p>I've found some parameters among BuiltInParameters that contains word 'LENGTH' but named not 'length'. \nSo, my other approach is not good either.\n\n<p>Now I think apply next algorithm to find length:\n\n<ul>\n<li>Get all visible parameters of element. It's easy – Element.Parameters.\n<li>Check if (Parameter.Definition as InternalDefinition).BuiltInParameter contains 'LENGTH' substring.\n<li>Check if Parameter.Definition.ParameterGroup == PG_GEOMETRY.\n<li>Profit if parameter exists :-)\n</li></li></li></li></ul>\n<p>I looked at your useful BipChecker tool and made some little changes. \n\n<p>I added a ParameterGroup field to the ParameterData class, and added a different parameter form with grouping using a ListView instead of DataGridView. Now you can see which parameters are provided by the Element.Parameters collection and which are retrieved via BuiltInParameter. \nIt seems more user friendly than in DataGridView. \n\n<p>I hope you like these changes.\n\n<p>Here is \n\n<a href=\"zip/BipCheckerVc.zip\">BipCheckerVc.zip</a> containing \n\nVictor's version using the list view display.\n\n<p><strong>Answer:</strong> Great, I love the addition of the new properties for the parameter group, group name, and whether or not a parameter is included in the Element.Parameters collection or not.\n\n<p>Since the ParameterData class is getting a bit heavy now, I moved it out into a new module of its own.\n\n<p>I do not like the list view all that much, because it segregates the parameters into separate groups and prevents me from sorting them all in one collection by any one of the properties.\nI therefore re-implemented the data grid view as well. \nYou can switch back and forth between the two views by setting a compile time pragma and rebuilding:\n\n<pre class=\"code\">\n<span class=\"blue\">#if</span> USE_LIST_VIEW\n<span class=\"gray\">  using( BuiltInParamsCheckerFormListView form</span>\n<span class=\"gray\">    = new BuiltInParamsCheckerFormListView(</span>\n<span class=\"gray\">      description, data ) )</span>\n<span class=\"blue\">#else</span>\n  <span class=\"blue\">using</span> (<span class=\"teal\">BuiltInParamsCheckerForm</span> form\n    = <span class=\"blue\">new</span> <span class=\"teal\">BuiltInParamsCheckerForm</span>(\n      description, data))\n<span class=\"blue\">#endif</span> <span class=\"green\">// USE_LIST_VIEW</span>\n  {\n    form.ShowDialog();\n  }\n</pre>\n<p>I have not defined USE_LIST_VIEW in my code, and therefore the data grid view is used.\nIf you want to use the list view instead, simply add the following as the first line of the file:\n\n<pre class=\"code\">\n<span class=\"blue\">#define</span> USE_LIST_VIEW\n</pre>\n<h4>Determining Whether a Parameter is Contained in Element.Parameters</h4>\n<p>Yes, I see that it is indeed unexpectedly difficult to determine whether a given parameter retrieved from an element using the Parameter property is contained in the official Element.Parameters collection.\n\n<p>The ParameterSet returned by Element.Parameters does provide a Contains method, but it does not return the expected result.\n\n<p>For example, for a wall, which has a parameter named \"Length\" with the built-in parameter id CURVE_ELEM_LENGTH, the following code snippet will still return false:\n\n<pre class=\"code\">\n  wall.Parameters.Contains( \n    wall.get_Parameter( \n      <span class=\"teal\">BuiltInParameter</span>.CURVE_ELEM_LENGTH ) )\n</pre>\n<p>I used your code as a basis for implementing the following workaround:\n\n<pre class=\"code\">\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n<span class=\"gray\">///</span><span class=\"green\"> Return BuiltInParameter id for a given parameter,</span>\n<span class=\"gray\">///</span><span class=\"green\"> assuming it is a built-in parameter.</span>\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n<span class=\"blue\">static</span> <span class=\"teal\">BuiltInParameter</span> BipOf( <span class=\"teal\">Parameter</span> p )\n{\n  <span class=\"blue\">return</span> ( p.Definition <span class=\"blue\">as</span> <span class=\"teal\">InternalDefinition</span> )\n    .BuiltInParameter;\n}\n \n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n<span class=\"gray\">///</span><span class=\"green\"> Check whether two given parameters represent</span>\n<span class=\"gray\">///</span><span class=\"green\"> the same parameter, i.e. shared parameters</span>\n<span class=\"gray\">///</span><span class=\"green\"> have the same GUID, others the same built-in</span>\n<span class=\"gray\">///</span><span class=\"green\"> parameter id.</span>\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n<span class=\"blue\">static</span> <span class=\"blue\">bool</span> IsSameParameter( <span class=\"teal\">Parameter</span> p, <span class=\"teal\">Parameter</span> q )\n{\n  <span class=\"blue\">return</span>( p.IsShared == q.IsShared )\n    &amp;&amp; ( p.IsShared\n      ? p.GUID.Equals( q.GUID )\n      : BipOf( p ) == BipOf( q ) );\n}\n \n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n<span class=\"gray\">///</span><span class=\"green\"> Return true if the given element parameter </span>\n<span class=\"gray\">///</span><span class=\"green\"> retrieved by  get_parameter( BuiltInParameter ) </span>\n<span class=\"gray\">///</span><span class=\"green\"> is contained in the element Parameters collection.</span>\n<span class=\"gray\">///</span><span class=\"green\"> Workaround to replace ParameterSet.Contains.</span>\n<span class=\"gray\">///</span><span class=\"green\"> Why does this not work?</span>\n<span class=\"gray\">///</span><span class=\"green\"> return _parameter.Element.Parameters.Contains(_parameter);</span>\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n<span class=\"blue\">bool</span> ContainedInCollection( <span class=\"teal\">Parameter</span> p, <span class=\"teal\">ParameterSet</span> set )\n{\n  <span class=\"blue\">bool</span> rc = <span class=\"blue\">false</span>;\n \n  <span class=\"blue\">foreach</span>( <span class=\"teal\">Parameter</span> q <span class=\"blue\">in</span> set )\n  {\n    rc = IsSameParameter( p, q );\n \n    <span class=\"blue\">if</span>( rc )\n    {\n      <span class=\"blue\">break</span>;\n    }\n  }\n  <span class=\"blue\">return</span> rc;\n}\n</pre>\n<p>Of course, as Victor pointed out, in the current context, one of the parameters will always be a built-in one obtained from the iteration over the BuiltInParameter enumeration, so the situation that both parameters are shared will never arise.\n\n<p>Furthermore, the comparison above can be vastly simplified by using the parameters Id property instead of the GUID or the built-in parameter id.\n\n<p>Making use of the Id property and letting LINQ perform the list processing operations for us in a generic fashion, all three methods above can be condensed into\n\n<pre class=\"code\">\n  <span class=\"blue\">bool</span> ContainedInCollection( \n    <span class=\"teal\">Parameter</span> p, \n    <span class=\"teal\">ParameterSet</span> set )\n  {\n    <span class=\"blue\">return</span> set\n      .OfType&lt;<span class=\"teal\">Parameter</span>&gt;()\n      .Any( x =&gt; x.Id == p.Id );\n  }\n</pre>\n<p>Here is \n\n<a href=\"zip/BipChecker03.zip\">BipChecker03.zip</a> containing \n\nthe source code, add-in manifest, and Visual Studio solution for the updated BipChecker version 2012.0.3.0.\n\n<p>Here is what it looks like now displaying the parameters of a standard wall:</p>\n<center>\n<img alt=\"BipChecker\" src=\"img/BipChecker.png\"/>\n</center>\n<p>I hope you find this as useful as I do!\n\n<p>P.S. One thing that is possibly still missing here is support for shared parameters.\nIf you need that, add it, and let us know, please.\n</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p>"
  },
  {
    "original_filename": "0656_unofficial_param",
    "header_text": "The Element.Parameter Property",
    "local_header_href": "#the-elementparameter-property",
    "chunk_text": "<h4>The Element.Parameter Property</h4><p>While we are at it, here are a few observations of strangeness on the Parameter property itself:\n\n<ul>\n<li>Yes, it is a property, and still, yes, it takes an argument.\n<li>Yes, it does not exist in C# per se, because it is called get_Parameter there instead. \n<li>Yes, these two observations may be connected, even mutually dependent.\n</li></li></li></ul>\n<p>The complete list of arguments accepted by the overloads of the Parameter property or get_Parameter method is:\n\n<ul>\n<li>BuiltInParameter: Retrieves a parameter from the element given a parameter id. \n\n<li>Definition: Retrieves a parameter from the element based on its definition. \n\n<li>Guid: Retrieves a parameter from the element given a GUID for a shared parameter. \n\n<li>String: Retrieves a parameter from the element given its name. \n</li></li></li></li></ul>The Definition and name string can be provided and used for any parameter. \nThe BuiltInParameter enumeration value or 'parameter id' as it is called above only works for built-in parameters, and the GUID only for shared ones, so they work for mutually exclusive situations.\n\n<p>So if the parameter you are looking for is named \"Length\", you can retrieve it using that name.\n\n<p>I would recommend you <b>not to do so</b>, however, because this makes you code language dependent.\n\n<p>Better is to determine exactly which built-in parameter corresponds to it and use that instead.\n\n<p>Another issue with the approach you describe above is that for a complex element, there may be several different built-in parameters whose enumeration name contains the substring \"LENGTH\", and they may have completely different meanings. \nIt is even not completely clear what you yourself mean by 'length' of an element.\n\n<h4>Snooping and the Built-in Parameter Checker</h4>\n<p>Here is a code snippet with a loop that shows how to retrieve all parameters from an element. Actually, it may not retrieve all, but it mostly retrieves more than the official Parameters collection contains:\n\n<pre class=\"code\">\nArray bips = Enum.GetValues(typeof(BuiltInParameter));\nParameter p;\nforeach (BuiltInParameter a in bips)\n{\n  try\n  {\n    p = elem.get_Parameter(a);\n  }\n  catch { }\n}\n</pre>\n<p>This kind of loop to retrieve a value for each and every built-in parameter enumeration value is also used by the RevitLookup 'Built-In Enum Snoop' in the Snoop Parameters dialogue and my own built-in parameter checker.\nHere are some explorations I made in the past in which I discussed the use of these tools and provided the source code for my built-in parameter checker:\n\n<!--\n042_exploring_param.htm:and now we will recapitulate some basic\n099_locked_dimension.htm:built-in parameter checker.\n118_deeper_param_exploration.htm:<p>Looking at the element inst\n220_door_marks.htm:built-in parameter checker</a> to\n246_room_occupancy.htm:built-in parameter checker</a>.\n247_title_block_of_sheet.htm:built-in parameter checker</a> can\n364_pre_post_pick_select.htm:<a href=\"http://thebuildingcoder.t\n371_sheet_size.htm:<p>I analysed a sample project using the Rev\n512_lang_indep_subcat.htm:<p><strong>Answer:</strong> Have you\n\nExploring Element Parameters\nLocked Dimensioning\nDeeper Parameter Exploration\nDoor Marks\nRoom Occupancy\nTitle Block of Sheet\nPre-, Post- and Pick Select\nDetermine Sheet Size\n-->\n<ul>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2008/11/exploring-element-parameters.html\">Exploring element parameters</a>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2009/02/locked-dimensioning.html\">Locked dimensioning</a>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2009/04/deeper-parameter-exploration.html\">Deeper parameter exploration</a>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2009/09/door-marks.html\">Door marks</a>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2009/11/room-occupancy.html\">Room occupancy</a>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2009/11/title-block-of-sheet.html\">Title block of sheet</a>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2010/05/pre-post-and-pick-select.html\">Pre-, post- and pick selection</a>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2010/05/determine-sheet-size.html\">Determining sheet size</a>\n</li></li></li></li></li></li></li></li></ul>\n<p>Since I do find my built-in parameter checker a very handy tool I decided to simplify access to and installation of it by extracting the code from the obsolete Revit API Introduction Labs.\n\n<p>Besides simply displaying the list of 'unofficial' element parameter values, like the RevitLookup 'Built-In Enum Snoop' functionality, this tool provides the following additional advantages:\n\n<ul>\n<li>For elements than cannot be selected on the screen, prompt to enter the element id to select them instead.\n<li>For elements with a type, prompt whether to display type or instance parameter data.\n<li>List the results in a data grid view.\n<li>Display the built-in parameter enumeration value and the user visible parameter name side by side.\n<li>Display both the internal database value and the user visible string value of real-valued data.\n<li>Sort the results by the values of any column.\n<li>Copy the entire list of data to the clipboard.\n</li></li></li></li></li></li></li></ul>\n<p>The ability to sort by any column makes it much easier to find the records you are interested in, since you can sort by and then locate by either built-in parameter enumeration value, user visibly name, type, string or database value, or even read-write status.\n\n<p>Extracting and cleaning up this code also provided a welcome opportunity to make use of the generic CanHaveTypeAssigned and GetTypeId element methods.\nPreviously, the tool only supported displaying the type parameters for family instances.\nNow, this functionality should work for all elements that can have a type.\nThe updated code of the external command Execute mainline below includes both the old family instance code and the implementation of the new generic functionality:\n\n<pre class=\"code\">\n<span class=\"blue\">public</span> <span class=\"teal\">Result</span> Execute(\n  <span class=\"teal\">ExternalCommandData</span> commandData,\n  <span class=\"blue\">ref</span> <span class=\"blue\">string</span> message,\n  <span class=\"teal\">ElementSet</span> elements )\n{\n  <span class=\"teal\">UIApplication</span> uiapp = commandData.Application;\n  <span class=\"teal\">UIDocument</span> uidoc = uiapp.ActiveUIDocument;\n  <span class=\"teal\">Document</span> doc = uidoc.Document;\n \n  <span class=\"green\">// Select element:</span>\n \n  <span class=\"teal\">Element</span> e \n    = <span class=\"teal\">Util</span>.GetSingleSelectedElementOrPrompt( \n      uidoc );\n \n  <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == e )\n  {\n    <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Cancelled;\n  }\n  <span class=\"blue\">bool</span> isSymbol = <span class=\"blue\">false</span>;\n  <span class=\"blue\">string</span> family_name = <span class=\"blue\">string</span>.Empty;\n \n  <span class=\"green\">// For a family instance, ask user whether to </span>\n  <span class=\"green\">// display instance or type parameters; in a </span>\n  <span class=\"green\">// similar manner, we could add dedicated </span>\n  <span class=\"green\">// switches for Wall --&gt; WallType, </span>\n  <span class=\"green\">// Floor --&gt; FloorType etc. ...</span>\n \n  <span class=\"blue\">if</span>( e <span class=\"blue\">is</span> <span class=\"teal\">FamilyInstance</span> )\n  {\n    <span class=\"teal\">FamilyInstance</span> inst = e <span class=\"blue\">as</span> <span class=\"teal\">FamilyInstance</span>;\n    <span class=\"blue\">if</span>( <span class=\"blue\">null</span> != inst.Symbol )\n    {\n      <span class=\"blue\">string</span> symbol_name = <span class=\"teal\">Util</span>.ElementDescription( \n        inst.Symbol, <span class=\"blue\">true</span> );\n \n      family_name = <span class=\"teal\">Util</span>.ElementDescription( \n        inst.Symbol.Family, <span class=\"blue\">true</span> );\n \n      <span class=\"blue\">string</span> msg = <span class=\"blue\">string</span>.Format( _type_prompt,\n        <span class=\"maroon\">\"is a family instance\"</span> );\n \n      <span class=\"blue\">if</span>( !<span class=\"teal\">Util</span>.QuestionMsg( msg ) )\n      {\n        e = inst.Symbol;\n        isSymbol = <span class=\"blue\">true</span>;\n      }\n    }\n  }\n  <span class=\"blue\">else</span> <span class=\"blue\">if</span>( e.CanHaveTypeAssigned() )\n  {\n    <span class=\"teal\">ElementId</span> typeId = e.GetTypeId();\n    <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == typeId )\n    {\n      <span class=\"teal\">Util</span>.InfoMsg( <span class=\"maroon\">\"Element can have a type,\"</span>\n        + <span class=\"maroon\">\" but the current type is null.\"</span> );\n    }\n    <span class=\"blue\">else</span> <span class=\"blue\">if</span>( <span class=\"teal\">ElementId</span>.InvalidElementId == typeId )\n    {\n      <span class=\"teal\">Util</span>.InfoMsg( <span class=\"maroon\">\"Element can have a type,\"</span>\n        + <span class=\"maroon\">\" but the current type id is the\"</span>\n        + <span class=\"maroon\">\" invalid element id.\"</span> );\n    }\n    <span class=\"blue\">else</span>\n \n    {\n      <span class=\"teal\">Element</span> type = doc.get_Element( typeId );\n \n      <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == type )\n      {\n        <span class=\"teal\">Util</span>.InfoMsg( <span class=\"maroon\">\"Element has a type,\"</span>\n          + <span class=\"maroon\">\" but it cannot be accessed.\"</span> );\n      }\n      <span class=\"blue\">else</span>\n      {\n        <span class=\"blue\">string</span> msg = <span class=\"blue\">string</span>.Format( _type_prompt,\n          <span class=\"maroon\">\"has an element type\"</span> );\n \n        <span class=\"blue\">if</span>( !<span class=\"teal\">Util</span>.QuestionMsg( msg ) )\n        {\n          e = type;\n          isSymbol = <span class=\"blue\">true</span>;\n        }\n      }\n    }\n  }\n \n  <span class=\"green\">// Retrieve parameter data:</span>\n \n  <span class=\"teal\">SortableBindingList</span>&lt;<span class=\"teal\">ParameterData</span>&gt; data \n    = <span class=\"blue\">new</span> <span class=\"teal\">SortableBindingList</span>&lt;<span class=\"teal\">ParameterData</span>&gt;();\n \n  {\n    <span class=\"teal\">WaitCursor</span> waitCursor = <span class=\"blue\">new</span> <span class=\"teal\">WaitCursor</span>();\n \n    <span class=\"teal\">Array</span> bips = <span class=\"teal\">Enum</span>.GetValues( \n      <span class=\"blue\">typeof</span>( <span class=\"teal\">BuiltInParameter</span> ) );\n \n    <span class=\"blue\">int</span> n = bips.Length;\n    <span class=\"teal\">Parameter</span> p;\n \n    <span class=\"blue\">foreach</span>( <span class=\"teal\">BuiltInParameter</span> a <span class=\"blue\">in</span> bips )\n    {\n      <span class=\"blue\">try</span>\n      {\n        p = e.get_Parameter( a );\n \n        <span class=\"blue\">if</span>( <span class=\"blue\">null</span> != p )\n        {\n          <span class=\"blue\">string</span> valueString = \n            (<span class=\"teal\">StorageType</span>.ElementId == p.StorageType)\n              ? <span class=\"teal\">Util</span>.GetParameterValue2( p, doc )\n              : p.AsValueString();\n \n          data.Add( <span class=\"blue\">new</span> <span class=\"teal\">ParameterData</span>( a, p, \n            valueString ) );\n        }\n      }\n      <span class=\"blue\">catch</span>( <span class=\"teal\">Exception</span> ex )\n      {\n        <span class=\"teal\">Debug</span>.Print( \n          <span class=\"maroon\">\"Exception retrieving built-in parameter {0}: {1}\"</span>,\n          a, ex );\n      }\n    }\n  }\n \n  <span class=\"green\">// Display form:</span>\n \n  <span class=\"blue\">string</span> description \n    = <span class=\"teal\">Util</span>.ElementDescription( e, <span class=\"blue\">true</span> ) \n    + ( isSymbol \n      ? <span class=\"maroon\">\" Type\"</span> \n      : <span class=\"maroon\">\" Instance\"</span> );\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">BuiltInParamsCheckerForm</span> form \n    = <span class=\"blue\">new</span> <span class=\"teal\">BuiltInParamsCheckerForm</span>( \n      description, data ) )\n  {\n    form.ShowDialog();\n  }\n  <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Succeeded;\n}\n</pre>\n<p>For the rest of the implementation, please refer to\n\n<a href=\"zip/BipChecker01.zip\">BipChecker01.zip</a> containing \n\nthe full source code, add-in manifest, and Visual Studio solution for BipChecker version 2012.0.1.0.\n\n<p><strong>Response:</strong> I understood that parameters may not appear in the Element.Parameters collection, and also how to get them via the Element.get_Parameter method.  I still do not understand why Autodesk developers make some parameters hidden from user. \nI guess that these hidden parameters are system related and used in system methods. \nIs that it?  \n\n<p>I find it difficult to know whether parameter is present in the Element.Parameters collection or not. \nI've found only one way to check it:\n\n<pre class=\"code\">\n<span class=\"blue\">bool</span> IsParameterInCollection( <span class=\"teal\">Parameter</span> parameter )\n{\n  <span class=\"blue\">foreach</span>( <span class=\"teal\">Parameter</span> p \n    <span class=\"blue\">in</span> parameter.Element.Parameters )\n  {\n    <span class=\"blue\">if</span>( p.IsShared \n      != _parameter.IsShared )\n    {\n      <span class=\"blue\">return</span> <span class=\"blue\">false</span>;\n    }\n \n    <span class=\"blue\">if</span>( ( p.Definition <span class=\"blue\">as</span> \n        <span class=\"teal\">InternalDefinition</span> ).BuiltInParameter \n      == ( _parameter.Definition <span class=\"blue\">as</span> \n        <span class=\"teal\">InternalDefinition</span> ).BuiltInParameter )\n    {\n      _parameterInElementParametersCollection = <span class=\"blue\">true</span>;\n      <span class=\"blue\">return</span> <span class=\"blue\">true</span>;\n    }\n  }\n  <span class=\"blue\">return</span> <span class=\"blue\">false</span>;\n}\n</pre>\n<p>Regarding the second question on how to get the length of any element:\n\n<p>I agree with you that looking for parameter whose name contains 'Length' is a bad approach.\n\n<p>You say 'Better is to determine exactly which built-in parameter corresponds to it and use that instead'.\nBut how I can do it if I don't know anything about the element I am analysing? \nIn my case it may be absolutely any element.\n\n<p>I've found some parameters among BuiltInParameters that contains word 'LENGTH' but named not 'length'. \nSo, my other approach is not good either.\n\n<p>Now I think apply next algorithm to find length:\n\n<ul>\n<li>Get all visible parameters of element. It's easy – Element.Parameters.\n<li>Check if (Parameter.Definition as InternalDefinition).BuiltInParameter contains 'LENGTH' substring.\n<li>Check if Parameter.Definition.ParameterGroup == PG_GEOMETRY.\n<li>Profit if parameter exists :-)\n</li></li></li></li></ul>\n<p>I looked at your useful BipChecker tool and made some little changes. \n\n<p>I added a ParameterGroup field to the ParameterData class, and added a different parameter form with grouping using a ListView instead of DataGridView. Now you can see which parameters are provided by the Element.Parameters collection and which are retrieved via BuiltInParameter. \nIt seems more user friendly than in DataGridView. \n\n<p>I hope you like these changes.\n\n<p>Here is \n\n<a href=\"zip/BipCheckerVc.zip\">BipCheckerVc.zip</a> containing \n\nVictor's version using the list view display.\n\n<p><strong>Answer:</strong> Great, I love the addition of the new properties for the parameter group, group name, and whether or not a parameter is included in the Element.Parameters collection or not.\n\n<p>Since the ParameterData class is getting a bit heavy now, I moved it out into a new module of its own.\n\n<p>I do not like the list view all that much, because it segregates the parameters into separate groups and prevents me from sorting them all in one collection by any one of the properties.\nI therefore re-implemented the data grid view as well. \nYou can switch back and forth between the two views by setting a compile time pragma and rebuilding:\n\n<pre class=\"code\">\n<span class=\"blue\">#if</span> USE_LIST_VIEW\n<span class=\"gray\">  using( BuiltInParamsCheckerFormListView form</span>\n<span class=\"gray\">    = new BuiltInParamsCheckerFormListView(</span>\n<span class=\"gray\">      description, data ) )</span>\n<span class=\"blue\">#else</span>\n  <span class=\"blue\">using</span> (<span class=\"teal\">BuiltInParamsCheckerForm</span> form\n    = <span class=\"blue\">new</span> <span class=\"teal\">BuiltInParamsCheckerForm</span>(\n      description, data))\n<span class=\"blue\">#endif</span> <span class=\"green\">// USE_LIST_VIEW</span>\n  {\n    form.ShowDialog();\n  }\n</pre>\n<p>I have not defined USE_LIST_VIEW in my code, and therefore the data grid view is used.\nIf you want to use the list view instead, simply add the following as the first line of the file:\n\n<pre class=\"code\">\n<span class=\"blue\">#define</span> USE_LIST_VIEW\n</pre>\n<h4>Determining Whether a Parameter is Contained in Element.Parameters</h4>\n<p>Yes, I see that it is indeed unexpectedly difficult to determine whether a given parameter retrieved from an element using the Parameter property is contained in the official Element.Parameters collection.\n\n<p>The ParameterSet returned by Element.Parameters does provide a Contains method, but it does not return the expected result.\n\n<p>For example, for a wall, which has a parameter named \"Length\" with the built-in parameter id CURVE_ELEM_LENGTH, the following code snippet will still return false:\n\n<pre class=\"code\">\n  wall.Parameters.Contains( \n    wall.get_Parameter( \n      <span class=\"teal\">BuiltInParameter</span>.CURVE_ELEM_LENGTH ) )\n</pre>\n<p>I used your code as a basis for implementing the following workaround:\n\n<pre class=\"code\">\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n<span class=\"gray\">///</span><span class=\"green\"> Return BuiltInParameter id for a given parameter,</span>\n<span class=\"gray\">///</span><span class=\"green\"> assuming it is a built-in parameter.</span>\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n<span class=\"blue\">static</span> <span class=\"teal\">BuiltInParameter</span> BipOf( <span class=\"teal\">Parameter</span> p )\n{\n  <span class=\"blue\">return</span> ( p.Definition <span class=\"blue\">as</span> <span class=\"teal\">InternalDefinition</span> )\n    .BuiltInParameter;\n}\n \n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n<span class=\"gray\">///</span><span class=\"green\"> Check whether two given parameters represent</span>\n<span class=\"gray\">///</span><span class=\"green\"> the same parameter, i.e. shared parameters</span>\n<span class=\"gray\">///</span><span class=\"green\"> have the same GUID, others the same built-in</span>\n<span class=\"gray\">///</span><span class=\"green\"> parameter id.</span>\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n<span class=\"blue\">static</span> <span class=\"blue\">bool</span> IsSameParameter( <span class=\"teal\">Parameter</span> p, <span class=\"teal\">Parameter</span> q )\n{\n  <span class=\"blue\">return</span>( p.IsShared == q.IsShared )\n    &amp;&amp; ( p.IsShared\n      ? p.GUID.Equals( q.GUID )\n      : BipOf( p ) == BipOf( q ) );\n}\n \n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n<span class=\"gray\">///</span><span class=\"green\"> Return true if the given element parameter </span>\n<span class=\"gray\">///</span><span class=\"green\"> retrieved by  get_parameter( BuiltInParameter ) </span>\n<span class=\"gray\">///</span><span class=\"green\"> is contained in the element Parameters collection.</span>\n<span class=\"gray\">///</span><span class=\"green\"> Workaround to replace ParameterSet.Contains.</span>\n<span class=\"gray\">///</span><span class=\"green\"> Why does this not work?</span>\n<span class=\"gray\">///</span><span class=\"green\"> return _parameter.Element.Parameters.Contains(_parameter);</span>\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n<span class=\"blue\">bool</span> ContainedInCollection( <span class=\"teal\">Parameter</span> p, <span class=\"teal\">ParameterSet</span> set )\n{\n  <span class=\"blue\">bool</span> rc = <span class=\"blue\">false</span>;\n \n  <span class=\"blue\">foreach</span>( <span class=\"teal\">Parameter</span> q <span class=\"blue\">in</span> set )\n  {\n    rc = IsSameParameter( p, q );\n \n    <span class=\"blue\">if</span>( rc )\n    {\n      <span class=\"blue\">break</span>;\n    }\n  }\n  <span class=\"blue\">return</span> rc;\n}\n</pre>\n<p>Of course, as Victor pointed out, in the current context, one of the parameters will always be a built-in one obtained from the iteration over the BuiltInParameter enumeration, so the situation that both parameters are shared will never arise.\n\n<p>Furthermore, the comparison above can be vastly simplified by using the parameters Id property instead of the GUID or the built-in parameter id.\n\n<p>Making use of the Id property and letting LINQ perform the list processing operations for us in a generic fashion, all three methods above can be condensed into\n\n<pre class=\"code\">\n  <span class=\"blue\">bool</span> ContainedInCollection( \n    <span class=\"teal\">Parameter</span> p, \n    <span class=\"teal\">ParameterSet</span> set )\n  {\n    <span class=\"blue\">return</span> set\n      .OfType&lt;<span class=\"teal\">Parameter</span>&gt;()\n      .Any( x =&gt; x.Id == p.Id );\n  }\n</pre>\n<p>Here is \n\n<a href=\"zip/BipChecker03.zip\">BipChecker03.zip</a> containing \n\nthe source code, add-in manifest, and Visual Studio solution for the updated BipChecker version 2012.0.3.0.\n\n<p>Here is what it looks like now displaying the parameters of a standard wall:</p>\n<center>\n<img alt=\"BipChecker\" src=\"img/BipChecker.png\"/>\n</center>\n<p>I hope you find this as useful as I do!\n\n<p>P.S. One thing that is possibly still missing here is support for shared parameters.\nIf you need that, add it, and let us know, please.\n</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p>"
  },
  {
    "original_filename": "0656_unofficial_param",
    "header_text": "Snooping and the Built-in Parameter Checker",
    "local_header_href": "#snooping-and-the-built-in-parameter-checker",
    "chunk_text": "<h4>Snooping and the Built-in Parameter Checker</h4><p>Here is a code snippet with a loop that shows how to retrieve all parameters from an element. Actually, it may not retrieve all, but it mostly retrieves more than the official Parameters collection contains:\n\n<pre class=\"code\">\nArray bips = Enum.GetValues(typeof(BuiltInParameter));\nParameter p;\nforeach (BuiltInParameter a in bips)\n{\n  try\n  {\n    p = elem.get_Parameter(a);\n  }\n  catch { }\n}\n</pre>\n<p>This kind of loop to retrieve a value for each and every built-in parameter enumeration value is also used by the RevitLookup 'Built-In Enum Snoop' in the Snoop Parameters dialogue and my own built-in parameter checker.\nHere are some explorations I made in the past in which I discussed the use of these tools and provided the source code for my built-in parameter checker:\n\n<!--\n042_exploring_param.htm:and now we will recapitulate some basic\n099_locked_dimension.htm:built-in parameter checker.\n118_deeper_param_exploration.htm:<p>Looking at the element inst\n220_door_marks.htm:built-in parameter checker</a> to\n246_room_occupancy.htm:built-in parameter checker</a>.\n247_title_block_of_sheet.htm:built-in parameter checker</a> can\n364_pre_post_pick_select.htm:<a href=\"http://thebuildingcoder.t\n371_sheet_size.htm:<p>I analysed a sample project using the Rev\n512_lang_indep_subcat.htm:<p><strong>Answer:</strong> Have you\n\nExploring Element Parameters\nLocked Dimensioning\nDeeper Parameter Exploration\nDoor Marks\nRoom Occupancy\nTitle Block of Sheet\nPre-, Post- and Pick Select\nDetermine Sheet Size\n-->\n<ul>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2008/11/exploring-element-parameters.html\">Exploring element parameters</a>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2009/02/locked-dimensioning.html\">Locked dimensioning</a>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2009/04/deeper-parameter-exploration.html\">Deeper parameter exploration</a>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2009/09/door-marks.html\">Door marks</a>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2009/11/room-occupancy.html\">Room occupancy</a>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2009/11/title-block-of-sheet.html\">Title block of sheet</a>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2010/05/pre-post-and-pick-select.html\">Pre-, post- and pick selection</a>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2010/05/determine-sheet-size.html\">Determining sheet size</a>\n</li></li></li></li></li></li></li></li></ul>\n<p>Since I do find my built-in parameter checker a very handy tool I decided to simplify access to and installation of it by extracting the code from the obsolete Revit API Introduction Labs.\n\n<p>Besides simply displaying the list of 'unofficial' element parameter values, like the RevitLookup 'Built-In Enum Snoop' functionality, this tool provides the following additional advantages:\n\n<ul>\n<li>For elements than cannot be selected on the screen, prompt to enter the element id to select them instead.\n<li>For elements with a type, prompt whether to display type or instance parameter data.\n<li>List the results in a data grid view.\n<li>Display the built-in parameter enumeration value and the user visible parameter name side by side.\n<li>Display both the internal database value and the user visible string value of real-valued data.\n<li>Sort the results by the values of any column.\n<li>Copy the entire list of data to the clipboard.\n</li></li></li></li></li></li></li></ul>\n<p>The ability to sort by any column makes it much easier to find the records you are interested in, since you can sort by and then locate by either built-in parameter enumeration value, user visibly name, type, string or database value, or even read-write status.\n\n<p>Extracting and cleaning up this code also provided a welcome opportunity to make use of the generic CanHaveTypeAssigned and GetTypeId element methods.\nPreviously, the tool only supported displaying the type parameters for family instances.\nNow, this functionality should work for all elements that can have a type.\nThe updated code of the external command Execute mainline below includes both the old family instance code and the implementation of the new generic functionality:\n\n<pre class=\"code\">\n<span class=\"blue\">public</span> <span class=\"teal\">Result</span> Execute(\n  <span class=\"teal\">ExternalCommandData</span> commandData,\n  <span class=\"blue\">ref</span> <span class=\"blue\">string</span> message,\n  <span class=\"teal\">ElementSet</span> elements )\n{\n  <span class=\"teal\">UIApplication</span> uiapp = commandData.Application;\n  <span class=\"teal\">UIDocument</span> uidoc = uiapp.ActiveUIDocument;\n  <span class=\"teal\">Document</span> doc = uidoc.Document;\n \n  <span class=\"green\">// Select element:</span>\n \n  <span class=\"teal\">Element</span> e \n    = <span class=\"teal\">Util</span>.GetSingleSelectedElementOrPrompt( \n      uidoc );\n \n  <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == e )\n  {\n    <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Cancelled;\n  }\n  <span class=\"blue\">bool</span> isSymbol = <span class=\"blue\">false</span>;\n  <span class=\"blue\">string</span> family_name = <span class=\"blue\">string</span>.Empty;\n \n  <span class=\"green\">// For a family instance, ask user whether to </span>\n  <span class=\"green\">// display instance or type parameters; in a </span>\n  <span class=\"green\">// similar manner, we could add dedicated </span>\n  <span class=\"green\">// switches for Wall --&gt; WallType, </span>\n  <span class=\"green\">// Floor --&gt; FloorType etc. ...</span>\n \n  <span class=\"blue\">if</span>( e <span class=\"blue\">is</span> <span class=\"teal\">FamilyInstance</span> )\n  {\n    <span class=\"teal\">FamilyInstance</span> inst = e <span class=\"blue\">as</span> <span class=\"teal\">FamilyInstance</span>;\n    <span class=\"blue\">if</span>( <span class=\"blue\">null</span> != inst.Symbol )\n    {\n      <span class=\"blue\">string</span> symbol_name = <span class=\"teal\">Util</span>.ElementDescription( \n        inst.Symbol, <span class=\"blue\">true</span> );\n \n      family_name = <span class=\"teal\">Util</span>.ElementDescription( \n        inst.Symbol.Family, <span class=\"blue\">true</span> );\n \n      <span class=\"blue\">string</span> msg = <span class=\"blue\">string</span>.Format( _type_prompt,\n        <span class=\"maroon\">\"is a family instance\"</span> );\n \n      <span class=\"blue\">if</span>( !<span class=\"teal\">Util</span>.QuestionMsg( msg ) )\n      {\n        e = inst.Symbol;\n        isSymbol = <span class=\"blue\">true</span>;\n      }\n    }\n  }\n  <span class=\"blue\">else</span> <span class=\"blue\">if</span>( e.CanHaveTypeAssigned() )\n  {\n    <span class=\"teal\">ElementId</span> typeId = e.GetTypeId();\n    <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == typeId )\n    {\n      <span class=\"teal\">Util</span>.InfoMsg( <span class=\"maroon\">\"Element can have a type,\"</span>\n        + <span class=\"maroon\">\" but the current type is null.\"</span> );\n    }\n    <span class=\"blue\">else</span> <span class=\"blue\">if</span>( <span class=\"teal\">ElementId</span>.InvalidElementId == typeId )\n    {\n      <span class=\"teal\">Util</span>.InfoMsg( <span class=\"maroon\">\"Element can have a type,\"</span>\n        + <span class=\"maroon\">\" but the current type id is the\"</span>\n        + <span class=\"maroon\">\" invalid element id.\"</span> );\n    }\n    <span class=\"blue\">else</span>\n \n    {\n      <span class=\"teal\">Element</span> type = doc.get_Element( typeId );\n \n      <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == type )\n      {\n        <span class=\"teal\">Util</span>.InfoMsg( <span class=\"maroon\">\"Element has a type,\"</span>\n          + <span class=\"maroon\">\" but it cannot be accessed.\"</span> );\n      }\n      <span class=\"blue\">else</span>\n      {\n        <span class=\"blue\">string</span> msg = <span class=\"blue\">string</span>.Format( _type_prompt,\n          <span class=\"maroon\">\"has an element type\"</span> );\n \n        <span class=\"blue\">if</span>( !<span class=\"teal\">Util</span>.QuestionMsg( msg ) )\n        {\n          e = type;\n          isSymbol = <span class=\"blue\">true</span>;\n        }\n      }\n    }\n  }\n \n  <span class=\"green\">// Retrieve parameter data:</span>\n \n  <span class=\"teal\">SortableBindingList</span>&lt;<span class=\"teal\">ParameterData</span>&gt; data \n    = <span class=\"blue\">new</span> <span class=\"teal\">SortableBindingList</span>&lt;<span class=\"teal\">ParameterData</span>&gt;();\n \n  {\n    <span class=\"teal\">WaitCursor</span> waitCursor = <span class=\"blue\">new</span> <span class=\"teal\">WaitCursor</span>();\n \n    <span class=\"teal\">Array</span> bips = <span class=\"teal\">Enum</span>.GetValues( \n      <span class=\"blue\">typeof</span>( <span class=\"teal\">BuiltInParameter</span> ) );\n \n    <span class=\"blue\">int</span> n = bips.Length;\n    <span class=\"teal\">Parameter</span> p;\n \n    <span class=\"blue\">foreach</span>( <span class=\"teal\">BuiltInParameter</span> a <span class=\"blue\">in</span> bips )\n    {\n      <span class=\"blue\">try</span>\n      {\n        p = e.get_Parameter( a );\n \n        <span class=\"blue\">if</span>( <span class=\"blue\">null</span> != p )\n        {\n          <span class=\"blue\">string</span> valueString = \n            (<span class=\"teal\">StorageType</span>.ElementId == p.StorageType)\n              ? <span class=\"teal\">Util</span>.GetParameterValue2( p, doc )\n              : p.AsValueString();\n \n          data.Add( <span class=\"blue\">new</span> <span class=\"teal\">ParameterData</span>( a, p, \n            valueString ) );\n        }\n      }\n      <span class=\"blue\">catch</span>( <span class=\"teal\">Exception</span> ex )\n      {\n        <span class=\"teal\">Debug</span>.Print( \n          <span class=\"maroon\">\"Exception retrieving built-in parameter {0}: {1}\"</span>,\n          a, ex );\n      }\n    }\n  }\n \n  <span class=\"green\">// Display form:</span>\n \n  <span class=\"blue\">string</span> description \n    = <span class=\"teal\">Util</span>.ElementDescription( e, <span class=\"blue\">true</span> ) \n    + ( isSymbol \n      ? <span class=\"maroon\">\" Type\"</span> \n      : <span class=\"maroon\">\" Instance\"</span> );\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">BuiltInParamsCheckerForm</span> form \n    = <span class=\"blue\">new</span> <span class=\"teal\">BuiltInParamsCheckerForm</span>( \n      description, data ) )\n  {\n    form.ShowDialog();\n  }\n  <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Succeeded;\n}\n</pre>\n<p>For the rest of the implementation, please refer to\n\n<a href=\"zip/BipChecker01.zip\">BipChecker01.zip</a> containing \n\nthe full source code, add-in manifest, and Visual Studio solution for BipChecker version 2012.0.1.0.\n\n<p><strong>Response:</strong> I understood that parameters may not appear in the Element.Parameters collection, and also how to get them via the Element.get_Parameter method.  I still do not understand why Autodesk developers make some parameters hidden from user. \nI guess that these hidden parameters are system related and used in system methods. \nIs that it?  \n\n<p>I find it difficult to know whether parameter is present in the Element.Parameters collection or not. \nI've found only one way to check it:\n\n<pre class=\"code\">\n<span class=\"blue\">bool</span> IsParameterInCollection( <span class=\"teal\">Parameter</span> parameter )\n{\n  <span class=\"blue\">foreach</span>( <span class=\"teal\">Parameter</span> p \n    <span class=\"blue\">in</span> parameter.Element.Parameters )\n  {\n    <span class=\"blue\">if</span>( p.IsShared \n      != _parameter.IsShared )\n    {\n      <span class=\"blue\">return</span> <span class=\"blue\">false</span>;\n    }\n \n    <span class=\"blue\">if</span>( ( p.Definition <span class=\"blue\">as</span> \n        <span class=\"teal\">InternalDefinition</span> ).BuiltInParameter \n      == ( _parameter.Definition <span class=\"blue\">as</span> \n        <span class=\"teal\">InternalDefinition</span> ).BuiltInParameter )\n    {\n      _parameterInElementParametersCollection = <span class=\"blue\">true</span>;\n      <span class=\"blue\">return</span> <span class=\"blue\">true</span>;\n    }\n  }\n  <span class=\"blue\">return</span> <span class=\"blue\">false</span>;\n}\n</pre>\n<p>Regarding the second question on how to get the length of any element:\n\n<p>I agree with you that looking for parameter whose name contains 'Length' is a bad approach.\n\n<p>You say 'Better is to determine exactly which built-in parameter corresponds to it and use that instead'.\nBut how I can do it if I don't know anything about the element I am analysing? \nIn my case it may be absolutely any element.\n\n<p>I've found some parameters among BuiltInParameters that contains word 'LENGTH' but named not 'length'. \nSo, my other approach is not good either.\n\n<p>Now I think apply next algorithm to find length:\n\n<ul>\n<li>Get all visible parameters of element. It's easy – Element.Parameters.\n<li>Check if (Parameter.Definition as InternalDefinition).BuiltInParameter contains 'LENGTH' substring.\n<li>Check if Parameter.Definition.ParameterGroup == PG_GEOMETRY.\n<li>Profit if parameter exists :-)\n</li></li></li></li></ul>\n<p>I looked at your useful BipChecker tool and made some little changes. \n\n<p>I added a ParameterGroup field to the ParameterData class, and added a different parameter form with grouping using a ListView instead of DataGridView. Now you can see which parameters are provided by the Element.Parameters collection and which are retrieved via BuiltInParameter. \nIt seems more user friendly than in DataGridView. \n\n<p>I hope you like these changes.\n\n<p>Here is \n\n<a href=\"zip/BipCheckerVc.zip\">BipCheckerVc.zip</a> containing \n\nVictor's version using the list view display.\n\n<p><strong>Answer:</strong> Great, I love the addition of the new properties for the parameter group, group name, and whether or not a parameter is included in the Element.Parameters collection or not.\n\n<p>Since the ParameterData class is getting a bit heavy now, I moved it out into a new module of its own.\n\n<p>I do not like the list view all that much, because it segregates the parameters into separate groups and prevents me from sorting them all in one collection by any one of the properties.\nI therefore re-implemented the data grid view as well. \nYou can switch back and forth between the two views by setting a compile time pragma and rebuilding:\n\n<pre class=\"code\">\n<span class=\"blue\">#if</span> USE_LIST_VIEW\n<span class=\"gray\">  using( BuiltInParamsCheckerFormListView form</span>\n<span class=\"gray\">    = new BuiltInParamsCheckerFormListView(</span>\n<span class=\"gray\">      description, data ) )</span>\n<span class=\"blue\">#else</span>\n  <span class=\"blue\">using</span> (<span class=\"teal\">BuiltInParamsCheckerForm</span> form\n    = <span class=\"blue\">new</span> <span class=\"teal\">BuiltInParamsCheckerForm</span>(\n      description, data))\n<span class=\"blue\">#endif</span> <span class=\"green\">// USE_LIST_VIEW</span>\n  {\n    form.ShowDialog();\n  }\n</pre>\n<p>I have not defined USE_LIST_VIEW in my code, and therefore the data grid view is used.\nIf you want to use the list view instead, simply add the following as the first line of the file:\n\n<pre class=\"code\">\n<span class=\"blue\">#define</span> USE_LIST_VIEW\n</pre>\n<h4>Determining Whether a Parameter is Contained in Element.Parameters</h4>\n<p>Yes, I see that it is indeed unexpectedly difficult to determine whether a given parameter retrieved from an element using the Parameter property is contained in the official Element.Parameters collection.\n\n<p>The ParameterSet returned by Element.Parameters does provide a Contains method, but it does not return the expected result.\n\n<p>For example, for a wall, which has a parameter named \"Length\" with the built-in parameter id CURVE_ELEM_LENGTH, the following code snippet will still return false:\n\n<pre class=\"code\">\n  wall.Parameters.Contains( \n    wall.get_Parameter( \n      <span class=\"teal\">BuiltInParameter</span>.CURVE_ELEM_LENGTH ) )\n</pre>\n<p>I used your code as a basis for implementing the following workaround:\n\n<pre class=\"code\">\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n<span class=\"gray\">///</span><span class=\"green\"> Return BuiltInParameter id for a given parameter,</span>\n<span class=\"gray\">///</span><span class=\"green\"> assuming it is a built-in parameter.</span>\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n<span class=\"blue\">static</span> <span class=\"teal\">BuiltInParameter</span> BipOf( <span class=\"teal\">Parameter</span> p )\n{\n  <span class=\"blue\">return</span> ( p.Definition <span class=\"blue\">as</span> <span class=\"teal\">InternalDefinition</span> )\n    .BuiltInParameter;\n}\n \n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n<span class=\"gray\">///</span><span class=\"green\"> Check whether two given parameters represent</span>\n<span class=\"gray\">///</span><span class=\"green\"> the same parameter, i.e. shared parameters</span>\n<span class=\"gray\">///</span><span class=\"green\"> have the same GUID, others the same built-in</span>\n<span class=\"gray\">///</span><span class=\"green\"> parameter id.</span>\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n<span class=\"blue\">static</span> <span class=\"blue\">bool</span> IsSameParameter( <span class=\"teal\">Parameter</span> p, <span class=\"teal\">Parameter</span> q )\n{\n  <span class=\"blue\">return</span>( p.IsShared == q.IsShared )\n    &amp;&amp; ( p.IsShared\n      ? p.GUID.Equals( q.GUID )\n      : BipOf( p ) == BipOf( q ) );\n}\n \n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n<span class=\"gray\">///</span><span class=\"green\"> Return true if the given element parameter </span>\n<span class=\"gray\">///</span><span class=\"green\"> retrieved by  get_parameter( BuiltInParameter ) </span>\n<span class=\"gray\">///</span><span class=\"green\"> is contained in the element Parameters collection.</span>\n<span class=\"gray\">///</span><span class=\"green\"> Workaround to replace ParameterSet.Contains.</span>\n<span class=\"gray\">///</span><span class=\"green\"> Why does this not work?</span>\n<span class=\"gray\">///</span><span class=\"green\"> return _parameter.Element.Parameters.Contains(_parameter);</span>\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n<span class=\"blue\">bool</span> ContainedInCollection( <span class=\"teal\">Parameter</span> p, <span class=\"teal\">ParameterSet</span> set )\n{\n  <span class=\"blue\">bool</span> rc = <span class=\"blue\">false</span>;\n \n  <span class=\"blue\">foreach</span>( <span class=\"teal\">Parameter</span> q <span class=\"blue\">in</span> set )\n  {\n    rc = IsSameParameter( p, q );\n \n    <span class=\"blue\">if</span>( rc )\n    {\n      <span class=\"blue\">break</span>;\n    }\n  }\n  <span class=\"blue\">return</span> rc;\n}\n</pre>\n<p>Of course, as Victor pointed out, in the current context, one of the parameters will always be a built-in one obtained from the iteration over the BuiltInParameter enumeration, so the situation that both parameters are shared will never arise.\n\n<p>Furthermore, the comparison above can be vastly simplified by using the parameters Id property instead of the GUID or the built-in parameter id.\n\n<p>Making use of the Id property and letting LINQ perform the list processing operations for us in a generic fashion, all three methods above can be condensed into\n\n<pre class=\"code\">\n  <span class=\"blue\">bool</span> ContainedInCollection( \n    <span class=\"teal\">Parameter</span> p, \n    <span class=\"teal\">ParameterSet</span> set )\n  {\n    <span class=\"blue\">return</span> set\n      .OfType&lt;<span class=\"teal\">Parameter</span>&gt;()\n      .Any( x =&gt; x.Id == p.Id );\n  }\n</pre>\n<p>Here is \n\n<a href=\"zip/BipChecker03.zip\">BipChecker03.zip</a> containing \n\nthe source code, add-in manifest, and Visual Studio solution for the updated BipChecker version 2012.0.3.0.\n\n<p>Here is what it looks like now displaying the parameters of a standard wall:</p>\n<center>\n<img alt=\"BipChecker\" src=\"img/BipChecker.png\"/>\n</center>\n<p>I hope you find this as useful as I do!\n\n<p>P.S. One thing that is possibly still missing here is support for shared parameters.\nIf you need that, add it, and let us know, please.\n</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p>"
  },
  {
    "original_filename": "0656_unofficial_param",
    "header_text": "Determining Whether a Parameter is Contained in Element.Parameters",
    "local_header_href": "#determining-whether-a-parameter-is-contained-in-elementparameters",
    "chunk_text": "<h4>Determining Whether a Parameter is Contained in Element.Parameters</h4><p>Yes, I see that it is indeed unexpectedly difficult to determine whether a given parameter retrieved from an element using the Parameter property is contained in the official Element.Parameters collection.\n\n<p>The ParameterSet returned by Element.Parameters does provide a Contains method, but it does not return the expected result.\n\n<p>For example, for a wall, which has a parameter named \"Length\" with the built-in parameter id CURVE_ELEM_LENGTH, the following code snippet will still return false:\n\n<pre class=\"code\">\n  wall.Parameters.Contains( \n    wall.get_Parameter( \n      <span class=\"teal\">BuiltInParameter</span>.CURVE_ELEM_LENGTH ) )\n</pre>\n<p>I used your code as a basis for implementing the following workaround:\n\n<pre class=\"code\">\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n<span class=\"gray\">///</span><span class=\"green\"> Return BuiltInParameter id for a given parameter,</span>\n<span class=\"gray\">///</span><span class=\"green\"> assuming it is a built-in parameter.</span>\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n<span class=\"blue\">static</span> <span class=\"teal\">BuiltInParameter</span> BipOf( <span class=\"teal\">Parameter</span> p )\n{\n  <span class=\"blue\">return</span> ( p.Definition <span class=\"blue\">as</span> <span class=\"teal\">InternalDefinition</span> )\n    .BuiltInParameter;\n}\n \n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n<span class=\"gray\">///</span><span class=\"green\"> Check whether two given parameters represent</span>\n<span class=\"gray\">///</span><span class=\"green\"> the same parameter, i.e. shared parameters</span>\n<span class=\"gray\">///</span><span class=\"green\"> have the same GUID, others the same built-in</span>\n<span class=\"gray\">///</span><span class=\"green\"> parameter id.</span>\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n<span class=\"blue\">static</span> <span class=\"blue\">bool</span> IsSameParameter( <span class=\"teal\">Parameter</span> p, <span class=\"teal\">Parameter</span> q )\n{\n  <span class=\"blue\">return</span>( p.IsShared == q.IsShared )\n    &amp;&amp; ( p.IsShared\n      ? p.GUID.Equals( q.GUID )\n      : BipOf( p ) == BipOf( q ) );\n}\n \n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n<span class=\"gray\">///</span><span class=\"green\"> Return true if the given element parameter </span>\n<span class=\"gray\">///</span><span class=\"green\"> retrieved by  get_parameter( BuiltInParameter ) </span>\n<span class=\"gray\">///</span><span class=\"green\"> is contained in the element Parameters collection.</span>\n<span class=\"gray\">///</span><span class=\"green\"> Workaround to replace ParameterSet.Contains.</span>\n<span class=\"gray\">///</span><span class=\"green\"> Why does this not work?</span>\n<span class=\"gray\">///</span><span class=\"green\"> return _parameter.Element.Parameters.Contains(_parameter);</span>\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n<span class=\"blue\">bool</span> ContainedInCollection( <span class=\"teal\">Parameter</span> p, <span class=\"teal\">ParameterSet</span> set )\n{\n  <span class=\"blue\">bool</span> rc = <span class=\"blue\">false</span>;\n \n  <span class=\"blue\">foreach</span>( <span class=\"teal\">Parameter</span> q <span class=\"blue\">in</span> set )\n  {\n    rc = IsSameParameter( p, q );\n \n    <span class=\"blue\">if</span>( rc )\n    {\n      <span class=\"blue\">break</span>;\n    }\n  }\n  <span class=\"blue\">return</span> rc;\n}\n</pre>\n<p>Of course, as Victor pointed out, in the current context, one of the parameters will always be a built-in one obtained from the iteration over the BuiltInParameter enumeration, so the situation that both parameters are shared will never arise.\n\n<p>Furthermore, the comparison above can be vastly simplified by using the parameters Id property instead of the GUID or the built-in parameter id.\n\n<p>Making use of the Id property and letting LINQ perform the list processing operations for us in a generic fashion, all three methods above can be condensed into\n\n<pre class=\"code\">\n  <span class=\"blue\">bool</span> ContainedInCollection( \n    <span class=\"teal\">Parameter</span> p, \n    <span class=\"teal\">ParameterSet</span> set )\n  {\n    <span class=\"blue\">return</span> set\n      .OfType&lt;<span class=\"teal\">Parameter</span>&gt;()\n      .Any( x =&gt; x.Id == p.Id );\n  }\n</pre>\n<p>Here is \n\n<a href=\"zip/BipChecker03.zip\">BipChecker03.zip</a> containing \n\nthe source code, add-in manifest, and Visual Studio solution for the updated BipChecker version 2012.0.3.0.\n\n<p>Here is what it looks like now displaying the parameters of a standard wall:</p>\n<center>\n<img alt=\"BipChecker\" src=\"img/BipChecker.png\"/>\n</center>\n<p>I hope you find this as useful as I do!\n\n<p>P.S. One thing that is possibly still missing here is support for shared parameters.\nIf you need that, add it, and let us know, please.\n</p></p></p></p></p></p></p></p></p></p>"
  }
]