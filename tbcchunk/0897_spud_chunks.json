[
  {
    "original_filename": "0897_spud",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<head>\n<meta content=\"text/html; charset=utf-8\" http-equiv=\"Content-Type\"/>\n<link href=\"bc.css\" rel=\"stylesheet\" type=\"text/css\"/>\n</head>"
  },
  {
    "original_filename": "0897_spud",
    "header_text": "Adjustable Versus Perpendicular Spud",
    "local_header_href": "#adjustable-versus-perpendicular-spud",
    "chunk_text": "<h3>Adjustable Versus Perpendicular Spud</h3><p>I recently presented an explanation of some Revit\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2013/02/content-localisation.html#3\">\nMEP family editor part type classes</a>,\n\nwhich led to a follow-up:\n\n<p><strong>Question:</strong> Thank you for the detailed answer about the duct fittings.\nI have a similar problem with one of the pipe fittings, namely spud. I know what a spud is, but not the difference between an adjustable and a perpendicular one.</p>\n<p>Can you explain the actual difference, please?</p>\n<p>Here is an image with some different spuds that I collected:</p>\n<center>\n<img alt=\"Spuds\" src=\"img/spud2.jpg\"/>\n</center>\n<p><strong>Answer:</strong> Spuds are analogous to taps in ductwork, which also have adjustable and perpendicular part types.\n\n<p>Their difference is probably best described by example.\nHere are two smaller branches, both routed from the larger main at 45 degrees:</p>\n<center>\n<img alt=\"Adjustable and perpendicular spuds\" src=\"img/spud_adjust_perp.png\"/>\n</center>\n<p>The adjustable tap on the left adjusted to accommodate the 45-degree route.\n\n<p>The perpendicular tap on the right is constrained to tap perpendicularly off the main.\nThen, an elbow is automatically inserted after a short duct length to route the branch to the picked point.\n\n<p>Many thanks to Martin Schmid for this explanation.</p>\n<!--\n\n<a name=\"2\"></a>\n\n<h4>Determining Purgeable Elements</h4>\n\n<p>A question that crops up from time to time and is rather hard to answer exactyl and exhaustively is on purgeable elements:</p>\n\nthe <p><strong>Question:</strong> What is the best way to get all of the elements that can be purged? I can use WhereElementIsElementType filter to return all types, and WhereElementISNotElementType to return instances, but comparing the two lists does not leave me with the purgable result. I could compare individual lists of types (i.e. family symbol and family instance), but that seems prone to error. Is there any good way to get this information out of the model?\n\n<p><strong>Answer:</strong> Yes, the Revit API does not currently provide any direct method to determine this.\n\n<p>Let's see what can be done about it anyway already.\n\n<p>When you say \"all of the elements that can be purged\", that can be a pretty huge task.\n\n<p>I would suggest breaking that down into individual sub-tasks for different types of purgeable elements, which will require pretty different handling.\n\n<p>For example, I implemented a method DeleteUnnamedNonHostingReferencePlanes to find and\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2012/03/melbourne-devlab.html#2\">\ndelete all reference planes not hosting any elements</a>.\n\n<p>An explicit reference to the term purge is used in the post on\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/11/purge-unused-text-note-types.html\">\nremoving unused text note types</a>.\n\n<p>One way to determine whether a certain element A is required by another one B is to delete A and check the return value of the Delete method, which provides a list of deleted element ids. In some cases, B is deleted as well, and its element id is included the resulting list of deleted element ids. This is used by the\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/03/object-relationships.html\">\nobject relationship analyser</a>\n\n(<a href=\"http://thebuildingcoder.typepad.com/blog/2010/03/object-relationships-in-vb.html\">VB</a>).\n\n<p>The deletion can be made temporary by encapsulating it in a transaction that is later rolled back. Here is a discussion of\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2012/10/the-temporary-transaction-trick-for-gross-slab-data.html\">\nthe temporary transaction trick</a> including\n\na list of numerous usage examples, and later\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2012/11/temporary-transaction-trick-touchup.html\">\ntouched up slightly</a>.\n\n\n<p>When you have access to a one-way relationship between two classes of objects, e.g. pointers from doors, windows and openings hosted in walls to their respective wall host elements, you can easily invert the relationship to determine the list of hosted object for each host. This is demonstrated in my discussion of the\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2008/10/relationship-in.html\">\nrelationship inverter</a> in\n\none of the very first blog posts.\n\n<p>The rest of your query deals with types only, which is a small subset of the potentially purgeable elements.\n\n<p>A similar one-way relationship as the one between hosted objects and their hosts is defined between non-element types and types, since the former provide a property named GetTypeId pointing to the type. You could make use of this in a similar manner to find all unused types as follows:\n\n<ol>\n<li>Determine all non-type elements using WhereElementISNotElementType\n\n<li>Iterate over all non-type elements. Determine the element id of each one, and build a dictionary D of the inverse relationship, mapping type element id to a list or the elements using that type.\n\n<li>Use WhereElementIsElementType to determine all element types. Iterate over them. For each type, check D to see how many elements are referencing it. If D has no entry for this type, it is not being used and can be deleted.\n</ol>\n\n<p>There is no guarantee whatsoever that this will really work, though, since there may be any number of exceptional cases that need to be handled differently on a cases by case base.\n\n<p>You can try this out, though, see whether you corrupt the database in any way, test thoroughly, possibly add handling of all special cases that you encounter, and maybe achieve your goal  in the long run.\n\n-->\n</p></p></p></p>"
  }
]