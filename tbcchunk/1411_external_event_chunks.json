[
  {
    "original_filename": "1411_external_event",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n<link rel=\"stylesheet\" type=\"text/css\" href=\"bc.css\">\n<script src=\"run_prettify.js\" type=\"text/javascript\"></script>\n<!---\n<script src=\"https://google-code-prettify.googlecode.com/svn/loader/run_prettify.js\" type=\"text/javascript\"></script>\n-->\n</head>\n\n<!---\n\n\n#dotnet #csharp\n#fsharp #python\n#grevit\n#responsivedesign #typepad\n#ah8 #augi #dotnet\n#stingray #rendering\n#3dweb #3dviewAPI #html5 #threejs #webgl #3d #mobile #vr #ecommerce\n#Markdown #Fusion360 #Fusion360Hackathon\n#javascript\n#RestSharp #restAPI\n#mongoosejs #mongodb #nodejs\n#rtceur\n#xaml\n#3dweb #a360 #3dwebaccel #webgl @adskForge\n@AutodeskReCap @Adsk3dsMax\n#revitAPI #bim #aec #3dwebcoder #adsk #adskdevnetwrk @jimquanci @keanw\n#au2015 #rtceur\n#eraofconnection\n#RMS @researchdigisus\n@adskForge #3dwebaccel\n#a360\n@github\n\nRevit API, Jeremy Tammik, akn_include\n\nImplementing the TrackChangesCloud External Event #revitAPI #3dwebcoder @AutodeskRevit #bim #aec #adsk #adskdevnetwrk\n\nToday, I'll discuss this morning's work\n&ndash; TrackChanges enhancement idea\n&ndash; The TrackChangesCloud add-in\n&ndash; The TrackChangesCloud external event\n&ndash; Creating and raising an external event\n&ndash; Raising the external event from a separate thread\n&ndash; First test run\n&ndash; Trigger immediate execution by setting Revit foreground window\n&ndash; Complete external application module\n&ndash; Next steps\n&ndash; Download...\n\n-->"
  },
  {
    "original_filename": "1411_external_event",
    "header_text": "Implementing the TrackChangesCloud External Event",
    "local_header_href": "#implementing-the-trackchangescloud-external-event",
    "chunk_text": "### Implementing the TrackChangesCloud External Event\n\nToday, I'll discuss this morning's work:\n\n- [TrackChanges enhancement idea](#2)\n- [The TrackChangesCloud add-in](#3)\n- [The TrackChangesCloud external event](#4)\n- [Creating and raising an external event](#5)\n- [Raising the external event from a separate thread](#6)\n- [First test run](#7)\n- [Trigger immediate execution by setting Revit foreground window](#8)\n- [Complete external application module](#9)\n- [Next steps](#10)\n- [Download](#11)\n\nI implemented a suggestion\nfor [tracking element modification](http://thebuildingcoder.typepad.com/blog/2016/01/tracking-element-modification.html) a\nmonth ago and created\nthe [TrackChanges GitHub repository](https://github.com/jeremytammik/TrackChanges) to host its solution and source code.\n\nThat met with significant interest and triggered the following idea for an enhancement."
  },
  {
    "original_filename": "1411_external_event",
    "header_text": "<a name=\"2\"></a>TrackChanges Enhancement Idea",
    "local_header_href": "#a-name2atrackchanges-enhancement-idea",
    "chunk_text": "#### <a name=\"2\"></a>TrackChanges Enhancement Idea\n\nI am pondering an enhancement of this external command that I suggested to Tim Corneliussen in\nthe [Revit API discussion forum](http://forums.autodesk.com/t5/revit-api/bd-p/160) thread\non [dynamic model update after loading family](http://forums.autodesk.com/t5/revit-api/dynamic-model-update-after-loading-family/m-p/6052310):\n\nTim says he needs to track changes, and wondered whether to use the DocumentChanged event or the dynamic model updater framework DMU to do so.\n\nI suggested that he take a look at TrackChanges instead.\n\n**Response:** Your solution looks really impressive. I haven't had the chance to implement the main fundamentals in my project yet. As a starting programmer, the concept of hash code is still new to me but it looks like the right way to go. My main concern is how it will affect the performance of the routine.\n\nThe main purpose of my tool is that each addition or modification will be registered by modifying some parameters including a \"time-parameter\" and \"date-parameter\". To do so, but correct me if I'm wrong, I need to trigger an event or use a DMU to determine when an element is added or modified.\n\nMaybe I can use your snapshot technique combining it with a DMU. But doing so the DMU also collects a lot of data next to the snapshot routine. Is this necessary? Are there alternatives to avoid this sort of useless multiple data collecting?\n\nDo elements themselves contain relevant information about their own creation or modification (perhaps a certain property that most people aren't aware of)? If so, I can use a single event (sort of like your suggestion on your blog), for example the DocumentSavingAs event. Last possible solution I can think of at the moment is a way to look even deeper in to the updaterdata/-information hoping it contains more general information about the addition or modification of the relevant elements.\n\nHoping that you'll understand the scenario I'm describing. For now I will try to use the snapshot routine combining it with a DMU and a viewactivating event. Last mentioned will be used to determine whether another document becomes active (when a user has opened multiple projects). I will place an update when I have successfully created a working solution to discuss the results with you fellow readers. If someone can tell me if this solution probably won't really work please do so.\n\n**Answer:** Thank you very much for your appreciation.\n\nI think the main characteristic of the modification tracker is simplicity, rather than impressiveness.\n\nOf course, simplicity is much more impressive than impressiveness :-)\n\nIf you want to be notified on every single modification of an element and store that information immediately, then indeed you can and have to use either DMU or the DocumentChanged event.\n\nThe latter does not allow you to modify anything in the same transaction, though, whereas the former does.\n\nIf you want to guarantee that your date and time markers stored in Revit parameters are always up to date, immediately, then you need to use DMU.\n\nBut do you really need that?\n\nYou need to understand that DMU is complex and adds a significant burden to Revit, depending on how many elements trigger it, which in your case would be many.\n\nDo you really need to keep track of the element modification on a split second-by-second basis?\n\nWould it not be enough to track changes every minute, or every ten minutes?\n\nIf so, then you can vastly simplify your approach and vastly reduce the burden on Revit by using the modification tracker and completely avoiding DMU and the DocumentChanged event.\n\nJust track changes based on snapshots taken every X minutes, for instance.\n\nRegarding the issue of the hash code: that is a minor detail, and pretty irrelevant.\n\nYou can just store the full data. Depending on what criteria you use to define when an element has changed, you might need to store a lot of information for each element.\n\nI suggested the hash code as a way to reduce and unify that data storage, but that has absolutely nothing to do with the fundamental concept.\n\nTo quote the original post: \"We use the hash code to determine whether the state has been modified compared to a new element state snapshot made at a later time. We could obviously also store the entire original string representation instead of using a hash code. The hash code is small and handy, whereas the entire string contains all the original data. It is up to you to choose which you would like to use.\"\n\nThe hash code will not affect performance much, just reduce the memory used to cache the starting snapshot.\n\nI would recommend thinking this through in depth and peace and quiet.\n\nIf you do not require split-second time slice data, I would avoid the DMU and DocumentChanged events, both, completely.\n\nI am very much looking forward to hearing and discussing your further thoughts on this."
  },
  {
    "original_filename": "1411_external_event",
    "header_text": "<a name=\"3\"></a>The TrackChangesCloud Add-In",
    "local_header_href": "#a-name3athe-trackchangescloud-add-in",
    "chunk_text": "#### <a name=\"3\"></a>The TrackChangesCloud Add-In\n\nI am thinking of testing the suggestions I propose above myself.\n\nMy idea is:\n\n- Trigger automatic snapshots of element modifications every couple of minutes.\n- Store the results in a cloud-based database.\n\nThat will also represent another step in my explorations on connecting the desktop and the cloud.\n\nI created a new add-in [TrackChangesCloud](https://github.com/jeremytammik/TrackChangesCloud) to explore them in.\n\nI prefer to leave the original TrackChanges unmodified, since it clearly and simply demonstrates the snapshot idea.\n\nIt would be a shame to make it more confusing by adding the complexity required by the external application and event handling.\n\nOne way to trigger the snapshots at regular intervals, and probably the cleanest approach, is by implementing an external event."
  },
  {
    "original_filename": "1411_external_event",
    "header_text": "<a name=\"4\"></a>The TrackChangesCloud External Event",
    "local_header_href": "#a-name4athe-trackchangescloud-external-event",
    "chunk_text": "#### <a name=\"4\"></a>The TrackChangesCloud External Event\n\nThe Building Coder topic group\non [Idling and external events](http://thebuildingcoder.typepad.com/blog/about-the-author.html#5.28) is\ngrowing pretty large and explains all the background information on this in full detail.\n\nI implemented a skeleton for the external event named `ModificationLogger` that does nothing so far, except get raised when I say so.\n\nTherefore, the implementation is completely trivial:\n\n<pre class=\"code\">\n&nbsp; <span class=\"blue\">class</span> <span class=\"teal\">ModificationLogger</span> : <span class=\"teal\">IExternalEventHandler</span>\n&nbsp; {\n&nbsp; &nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n&nbsp; &nbsp; <span class=\"gray\">///</span><span class=\"green\"> Required IExternalEventHandler interface </span>\n&nbsp; &nbsp; <span class=\"gray\">///</span><span class=\"green\"> method returning a descriptive name.</span>\n&nbsp; &nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n&nbsp; &nbsp; <span class=\"blue\">public</span> <span class=\"blue\">string</span> GetName()\n&nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; <span class=\"blue\">return</span> <span class=\"maroon\">&quot;TrackChangesCloud ModificationLogger&quot;</span>;\n&nbsp; &nbsp; }\n&nbsp;\n&nbsp; &nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n&nbsp; &nbsp; <span class=\"gray\">///</span><span class=\"green\"> Execute method invoked by Revit via the </span>\n&nbsp; &nbsp; <span class=\"gray\">///</span><span class=\"green\"> external event as a reaction to a call </span>\n&nbsp; &nbsp; <span class=\"gray\">///</span><span class=\"green\"> to its Raise method.</span>\n&nbsp; &nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n&nbsp; &nbsp; <span class=\"blue\">public</span> <span class=\"blue\">void</span> Execute( <span class=\"teal\">UIApplication</span> a )\n&nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; <span class=\"teal\">Util</span>.Log( <span class=\"maroon\">&quot;ModificationLogger.Execute&quot;</span> );\n&nbsp; &nbsp; }\n&nbsp; }\n</pre>\n\nLater on, the `Execute` method will do more, of course, e.g. create a modification tracking snapshot and store it in the cloud."
  },
  {
    "original_filename": "1411_external_event",
    "header_text": "<a name=\"5\"></a>Creating and Raising an External Event",
    "local_header_href": "#a-name5acreating-and-raising-an-external-event",
    "chunk_text": "#### <a name=\"5\"></a>Creating and Raising an External Event\n\nThese two steps are both completely trivial one-liners, implemented in the external application module `App.cs`.\n\nIn the `OnStartup` method, I subscribe to the `ApplicationInitialized` event:\n\n<pre class=\"code\">\n&nbsp; a.ControlledApplication.ApplicationInitialized\n&nbsp; &nbsp; += OnApplicationInitialized;\n</pre>\n\nIn the event handler, I create the external event by instantiating my implementation:\n\n<pre class=\"code\">\n&nbsp; <span class=\"green\">// Create our custom external event.</span>\n&nbsp;\n&nbsp; _event = <span class=\"teal\">ExternalEvent</span>.Create(\n&nbsp; &nbsp; <span class=\"blue\">new</span> <span class=\"teal\">ModificationLogger</span>() );\n</pre>\n\nTo trigger the event, causing Revit to wait for an opportune moment and then call its `Execute` method, I call its `Raise` method:\n\n<pre class=\"code\">\n&nbsp; _event.Raise();\n</pre>\n\nThat's all there is to it.\n\nBut how do we ensure that the `Raise` call is executed at the times we wish?\n\nFor that I implemented a separate driver thread, which is also very simple."
  },
  {
    "original_filename": "1411_external_event",
    "header_text": "<a name=\"6\"></a>Raising the External Event from a Separate Thread",
    "local_header_href": "#a-name6araising-the-external-event-from-a-separate-thread",
    "chunk_text": "#### <a name=\"6\"></a>Raising the External Event from a Separate Thread\n\nIn order to control the regular raising of my external event, I can run an infinite triggering loop in a separate thread.\n\nThe loop is implemented in the following `TriggerModificationLogger` method:\n\n<pre class=\"code\">\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> Trigger a modification tracker snapshot at </span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> regular intervals. Relinquish control and wait </span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> for the specified timeout period between each </span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> snapshot. This method runs in a separate thread.</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n&nbsp; <span class=\"blue\">static</span> <span class=\"blue\">void</span> TriggerModificationLogger()\n&nbsp; {\n&nbsp; &nbsp; <span class=\"blue\">while</span>( <span class=\"blue\">true</span> )\n&nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; ++_nSnapshots;\n&nbsp;\n&nbsp; &nbsp; &nbsp; <span class=\"teal\">Util</span>.Log( <span class=\"blue\">string</span>.Format(\n&nbsp; &nbsp; &nbsp; &nbsp; <span class=\"maroon\">&quot;TriggerModificationLogger snapshot {0}&quot;</span>,\n&nbsp; &nbsp; &nbsp; &nbsp; _nSnapshots ) );\n&nbsp;\n&nbsp; &nbsp; &nbsp; _event.Raise();\n\n&nbsp; &nbsp; &nbsp; <span class=\"green\">// Wait and relinquish control </span>\n&nbsp; &nbsp; &nbsp; <span class=\"green\">// before next snapshot.</span>\n&nbsp;\n&nbsp; &nbsp; &nbsp; <span class=\"teal\">Thread</span>.Sleep( _timeout );\n&nbsp; &nbsp; }\n&nbsp; }\n</pre>\n\nIt endlessly loops, raising the external event at regular intervals specified by the `_timeout` constant.\n\nI start the looping in the `ApplicationInitialized` event handler, directly after instantiating my external event:\n\n<pre class=\"code\">\n&nbsp; <span class=\"blue\">void</span> OnApplicationInitialized(\n&nbsp; &nbsp; <span class=\"blue\">object</span> sender,\n&nbsp; &nbsp; <span class=\"teal\">ApplicationInitializedEventArgs</span> e )\n&nbsp; {\n&nbsp; &nbsp; <span class=\"green\">// Create our custom external event.</span>\n&nbsp;\n&nbsp; &nbsp; _event = <span class=\"teal\">ExternalEvent</span>.Create(\n&nbsp; &nbsp; &nbsp; <span class=\"blue\">new</span> <span class=\"teal\">ModificationLogger</span>() );\n&nbsp;\n&nbsp; &nbsp; <span class=\"green\">// Start a thread to raise it regularly.</span>\n&nbsp;\n&nbsp; &nbsp; _thread = <span class=\"blue\">new</span> <span class=\"teal\">Thread</span>(\n&nbsp; &nbsp; &nbsp; TriggerModificationLogger );\n&nbsp;\n&nbsp; &nbsp; _thread.Start();\n&nbsp; }\n</pre>"
  },
  {
    "original_filename": "1411_external_event",
    "header_text": "<a name=\"7\"></a>First Test Run",
    "local_header_href": "#a-name7afirst-test-run",
    "chunk_text": "#### <a name=\"7\"></a>First Test Run\n\nThis works perfectly, with one teeny weeny little flaw: even though the external event is raised at the moment I specify, the `Execute` method is not called until the Revit window is activated:\n\n<pre>\nTrackChanges 10:59:14.067 TriggerModificationLogger snapshot 1\nTrackChanges 10:59:14.635 ModificationLogger.Execute\nTrackChanges 11:00:14.074 TriggerModificationLogger snapshot 2\n*manually activated Revit*\nTrackChanges 11:00:44.050 ModificationLogger.Execute\nTrackChanges 11:01:14.075 TriggerModificationLogger snapshot 3\n*manually activated Revit*\nTrackChanges 11:01:23.877 ModificationLogger.Execute\n</pre>\n\nThis may or may not be a problem, depending on the intended use.\n\nMaybe you don't care if the external event is not triggered as long as Revit is in the background.\n\nHowever, this is quite easy to rectify, so let's do so."
  },
  {
    "original_filename": "1411_external_event",
    "header_text": "<a name=\"8\"></a>Trigger Immediate Execution by Setting Revit Foreground Window",
    "local_header_href": "#a-name8atrigger-immediate-execution-by-setting-revit-foreground-window",
    "chunk_text": "#### <a name=\"8\"></a>Trigger Immediate Execution by Setting Revit Foreground Window\n\nI implemented the following helper method to check whether Revit is the current foreground window.\n\nIf it is not, it is temporarily brought to the foreground using the Windows API:\n\n<pre class=\"code\">\n&nbsp; <span class=\"green\">// DLL imports from user32.dll to set focus to</span>\n&nbsp; <span class=\"green\">// Revit to force it to forward the external event</span>\n&nbsp; <span class=\"green\">// Raise to actually call the external event </span>\n&nbsp; <span class=\"green\">// Execute.</span>\n&nbsp;\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> The GetForegroundWindow function returns a </span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> handle to the foreground window.</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n&nbsp; [<span class=\"teal\">DllImport</span>( <span class=\"maroon\">&quot;user32.dll&quot;</span> )]\n&nbsp; <span class=\"blue\">static</span> <span class=\"blue\">extern</span> <span class=\"teal\">IntPtr</span> GetForegroundWindow();\n&nbsp;\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> Move the window associated with the passed </span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> handle to the front.</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n&nbsp; [<span class=\"teal\">DllImport</span>( <span class=\"maroon\">&quot;user32.dll&quot;</span> )]\n&nbsp; <span class=\"blue\">static</span> <span class=\"blue\">extern</span> <span class=\"blue\">bool</span> SetForegroundWindow(\n&nbsp; &nbsp; <span class=\"teal\">IntPtr</span> hWnd );\n&nbsp;\n&nbsp; <span class=\"blue\">static</span> <span class=\"blue\">void</span> SetFocusToRevit()\n&nbsp; {\n&nbsp; &nbsp; <span class=\"teal\">IntPtr</span> hRevit = <span class=\"teal\">ComponentManager</span>.ApplicationWindow;\n&nbsp; &nbsp; <span class=\"teal\">IntPtr</span> hBefore = GetForegroundWindow();\n&nbsp;\n&nbsp; &nbsp; <span class=\"blue\">if</span>( hBefore != hRevit )\n&nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; SetForegroundWindow( hRevit );\n&nbsp; &nbsp; &nbsp; SetForegroundWindow( hBefore );\n&nbsp; &nbsp; }\n&nbsp; }\n</pre>\n\nNow, if I add a call to `SetFocusToRevit` directly after calling `Raise`, the `Execute` method is invoked immediately, regardless of whether Revit is in the background or not:\n\n<pre>\nTrackChanges 11:26:23.431 TriggerModificationLogger snapshot 1\nTrackChanges 11:26:24.047 ModificationLogger.Execute\nTrackChanges 11:27:23.445 TriggerModificationLogger snapshot 2\nTrackChanges 11:27:23.499 ModificationLogger.Execute\nTrackChanges 11:28:23.506 TriggerModificationLogger snapshot 3\nTrackChanges 11:28:23.560 ModificationLogger.Execute\nTrackChanges 11:29:23.569 TriggerModificationLogger snapshot 4\nTrackChanges 11:29:23.623 ModificationLogger.Execute\nTrackChanges 11:30:23.638 TriggerModificationLogger snapshot 5\nTrackChanges 11:30:23.697 ModificationLogger.Execute\nTrackChanges 11:31:23.706 TriggerModificationLogger snapshot 6\nTrackChanges 11:31:23.790 ModificationLogger.Execute\n</pre>\n\nNo manual intervention required.\n\nHowever, the screen will flash!\n\nIf the purpose of this tool is to track modifications made to the BIM by end users, then obviously they will have the Revit window up and visible, so the call to `SetFocusToRevit` can be removed again."
  },
  {
    "original_filename": "1411_external_event",
    "header_text": "<a name=\"9\"></a>Complete External Application Module",
    "local_header_href": "#a-name9acomplete-external-application-module",
    "chunk_text": "#### <a name=\"9\"></a>Complete External Application Module\n\nTo show how the external event and thread handling work together, here is the complete implementation of the external application module `App.cs`:\n\n<pre class=\"code\">\n<span class=\"blue\">class</span> <span class=\"teal\">App</span> : <span class=\"teal\">IExternalApplication</span>\n{\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> Store the external event.</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n&nbsp; <span class=\"blue\">static</span> <span class=\"teal\">ExternalEvent</span> _event = <span class=\"blue\">null</span>;\n&nbsp;\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> Separate thread running a timer to trigger</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> the modification tracker at regular intervals.</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n&nbsp; <span class=\"blue\">static</span> <span class=\"teal\">Thread</span> _thread = <span class=\"blue\">null</span>;\n&nbsp;\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> Count total number of modification tracker</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> snapshots taken so far in this session.</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n&nbsp; <span class=\"blue\">static</span> <span class=\"blue\">int</span> _nSnapshots = 0;\n&nbsp;\n&nbsp; <span class=\"blue\">static</span> <span class=\"blue\">int</span> _timeout_minutes = 1;\n&nbsp;\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> Number of milliseconds to wait and relinquish</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> CPU control before next snapshot.</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n&nbsp; <span class=\"blue\">static</span> <span class=\"blue\">int</span> _timeout = 1000 * 60 * _timeout_minutes;\n&nbsp;\n<span class=\"blue\">&nbsp; #region</span> SetFocusToRevit\n&nbsp; <span class=\"green\">// DLL imports from user32.dll to set focus to</span>\n&nbsp; <span class=\"green\">// Revit to force it to forward the external event</span>\n&nbsp; <span class=\"green\">// Raise to actually call the external event </span>\n&nbsp; <span class=\"green\">// Execute.</span>\n&nbsp;\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> The GetForegroundWindow function returns a </span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> handle to the foreground window.</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n&nbsp; [<span class=\"teal\">DllImport</span>( <span class=\"maroon\">&quot;user32.dll&quot;</span> )]\n&nbsp; <span class=\"blue\">static</span> <span class=\"blue\">extern</span> <span class=\"teal\">IntPtr</span> GetForegroundWindow();\n&nbsp;\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> Move the window associated with the passed </span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> handle to the front.</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n&nbsp; [<span class=\"teal\">DllImport</span>( <span class=\"maroon\">&quot;user32.dll&quot;</span> )]\n&nbsp; <span class=\"blue\">static</span> <span class=\"blue\">extern</span> <span class=\"blue\">bool</span> SetForegroundWindow(\n&nbsp; &nbsp; <span class=\"teal\">IntPtr</span> hWnd );\n&nbsp;\n&nbsp; <span class=\"blue\">static</span> <span class=\"blue\">void</span> SetFocusToRevit()\n&nbsp; {\n&nbsp; &nbsp; <span class=\"teal\">IntPtr</span> hRevit = <span class=\"teal\">ComponentManager</span>.ApplicationWindow;\n&nbsp; &nbsp; <span class=\"teal\">IntPtr</span> hBefore = GetForegroundWindow();\n&nbsp;\n&nbsp; &nbsp; <span class=\"blue\">if</span>( hBefore != hRevit )\n&nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; SetForegroundWindow( hRevit );\n&nbsp; &nbsp; &nbsp; SetForegroundWindow( hBefore );\n&nbsp; &nbsp; }\n&nbsp; }\n<span class=\"blue\">&nbsp; #endregion</span> <span class=\"green\">// SetFocusToRevit</span>\n&nbsp;\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> Trigger a modification tracker snapshot at </span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> regular intervals. Relinquish control and wait </span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> for the specified timeout period between each </span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> snapshot. This method runs in a separate thread.</span>\n&nbsp; <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n&nbsp; <span class=\"blue\">static</span> <span class=\"blue\">void</span> TriggerModificationLogger()\n&nbsp; {\n&nbsp; &nbsp; <span class=\"blue\">while</span>( <span class=\"blue\">true</span> )\n&nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; ++_nSnapshots;\n&nbsp;\n&nbsp; &nbsp; &nbsp; <span class=\"teal\">Util</span>.Log( <span class=\"blue\">string</span>.Format(\n&nbsp; &nbsp; &nbsp; &nbsp; <span class=\"maroon\">&quot;TriggerModificationLogger snapshot {0}&quot;</span>,\n&nbsp; &nbsp; &nbsp; &nbsp; _nSnapshots ) );\n&nbsp;\n&nbsp; &nbsp; &nbsp; _event.Raise();\n&nbsp;\n&nbsp; &nbsp; &nbsp; <span class=\"green\">// Set focus to Revit for a moment.</span>\n&nbsp; &nbsp; &nbsp; <span class=\"green\">// Without this, Revit will not forward the </span>\n&nbsp; &nbsp; &nbsp; <span class=\"green\">// event Raise to the external event handler </span>\n&nbsp; &nbsp; &nbsp; <span class=\"green\">// Execute method until the Revit window is</span>\n&nbsp; &nbsp; &nbsp; <span class=\"green\">// activated. This causes the screen to flash.</span>\n&nbsp;\n&nbsp; &nbsp; &nbsp; SetFocusToRevit();\n&nbsp;\n&nbsp; &nbsp; &nbsp; <span class=\"green\">// Wait and relinquish control </span>\n&nbsp; &nbsp; &nbsp; <span class=\"green\">// before next snapshot.</span>\n&nbsp;\n&nbsp; &nbsp; &nbsp; <span class=\"teal\">Thread</span>.Sleep( _timeout );\n&nbsp; &nbsp; }\n&nbsp; }\n&nbsp;\n&nbsp; <span class=\"blue\">public</span> <span class=\"teal\">Result</span> OnStartup( <span class=\"teal\">UIControlledApplication</span> a )\n&nbsp; {\n&nbsp; &nbsp; a.ControlledApplication.ApplicationInitialized\n&nbsp; &nbsp; &nbsp; += OnApplicationInitialized;\n&nbsp;\n&nbsp; &nbsp; <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Succeeded;\n&nbsp; }\n&nbsp;\n&nbsp; <span class=\"blue\">void</span> OnApplicationInitialized(\n&nbsp; &nbsp; <span class=\"blue\">object</span> sender,\n&nbsp; &nbsp; <span class=\"teal\">ApplicationInitializedEventArgs</span> e )\n&nbsp; {\n&nbsp; &nbsp; <span class=\"green\">// Create our custom external event.</span>\n&nbsp;\n&nbsp; &nbsp; _event = <span class=\"teal\">ExternalEvent</span>.Create(\n&nbsp; &nbsp; &nbsp; <span class=\"blue\">new</span> <span class=\"teal\">ModificationLogger</span>() );\n&nbsp;\n&nbsp; &nbsp; <span class=\"green\">// Start a thread to raise it regularly.</span>\n&nbsp;\n&nbsp; &nbsp; _thread = <span class=\"blue\">new</span> <span class=\"teal\">Thread</span>(\n&nbsp; &nbsp; &nbsp; TriggerModificationLogger );\n&nbsp;\n&nbsp; &nbsp; _thread.Start();\n&nbsp; }\n&nbsp;\n&nbsp; <span class=\"blue\">public</span> <span class=\"teal\">Result</span> OnShutdown( <span class=\"teal\">UIControlledApplication</span> a )\n&nbsp; {\n&nbsp; &nbsp; _thread.Abort();\n&nbsp; &nbsp; _thread = <span class=\"blue\">null</span>;\n&nbsp; &nbsp; _event.Dispose();\n&nbsp;\n&nbsp; &nbsp; <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Succeeded;\n&nbsp; }\n}\n</pre>"
  },
  {
    "original_filename": "1411_external_event",
    "header_text": "<a name=\"10\"></a>Next Steps",
    "local_header_href": "#a-name10anext-steps",
    "chunk_text": "#### <a name=\"10\"></a>Next Steps\n\nThe next steps are obvious:\n\n- Implement the cloud database to hold the modification tracking data.\n- Implement the database upload.\n\nBoth of these are clearly and extensively demonstrated by the cloud storage approach developed for\nthe [FireRatingCloud project](https://github.com/jeremytammik/FireRatingCloud)."
  },
  {
    "original_filename": "1411_external_event",
    "header_text": "<a name=\"11\"></a>Download",
    "local_header_href": "#a-name11adownload",
    "chunk_text": "#### <a name=\"11\"></a>Download\n\nThis project is hosted in\nthe [TrackChanges GitHub repository](https://github.com/jeremytammik/TrackChanges),\nand the version discussed above\nis [release 2016.0.0.4](https://github.com/jeremytammik/TrackChangesCloud/releases/tag/2016.0.0.4).\n\n<center>\n<img src=\"img/track_changes_diff.png\" alt=\"TrackChanges diff\" width=\"340\">\n</center>"
  }
]