[
  {
    "original_filename": "0454_model_elements",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<head>\n<link href=\"bc.css\" rel=\"stylesheet\" type=\"text/css\"/>\n</head>"
  },
  {
    "original_filename": "0454_model_elements",
    "header_text": "Model Elements Revisited",
    "local_header_href": "#model-elements-revisited",
    "chunk_text": "<h3>Model Elements Revisited</h3><p>Scott Conover responded with a wealth of ideas to yesterday's \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/10/selecting-model-elements.html\">\nmodel element selection</a> discussion, \n\nwhich in turn has gone through numerous previous iterations, so this really seems like an endless theme.\n\n<p>Actually it is not even yesterday's, yet, it is still today's.\nWe both wanted to fix it fast.\n\n<p>Here are Scott's comments and suggestions:\n\n<p>First, on the original solution:\n\n<pre class=\"code\">\n  <span class=\"teal\">IList</span>&lt;<span class=\"teal\">Element</span>&gt; found\n    = collector\n      .WhereElementIsNotElementType()\n      .WhereElementIsViewIndependent()\n      .WherePasses( <span class=\"blue\">new</span> <span class=\"teal\">LogicalOrFilter</span>(\n        <span class=\"blue\">new</span> <span class=\"teal\">ElementIsElementTypeFilter</span>( <span class=\"blue\">false</span> ),\n        <span class=\"blue\">new</span> <span class=\"teal\">ElementIsElementTypeFilter</span>( <span class=\"blue\">true</span> ) ) )\n      .ToElements();\n</pre>\n<p>The WherePasses clause is totally unnecessary.  \nI know this is the 'original' example, but I certainly hope that nobody copies this for further use.\n\n<!--\n[SC1]I don\u0019t know if this is necessary for your followup \u0013 I was kind of hoping you would edit the original post (at least add a comment around that set of lines indicating it is not useful).\n-->\n<p>Your 'first solution' post from 2009 appends filters to each other one at a time.  \nOur new LogicalOrFilters support more than two inputs, so it should actually be updated to make more efficient use of 2011 filtering.\n\n<!--\n[SC2]We could definitely mention it.  Again, is it more useful to go back and edit the original post, or at least put this note there as well?  What is the correct \u001cblogger\u0019s etiquette\u001d for this?  To me, I prefer to view your blog as a resource for searching for useful techniques rather than a sequential time-based set of posts which may grow out-of-date; not sure if this is what you intend.\n-->\n<p>Regarding your second solution regarding HasMaterialQuantities – I guess it may not find all required elements.  \nFurniture, for example, doesn't have material quantities, but it is a physical element in the model.  \n\n<p>Another solution might be:\n\n<ul>\n<li>Start temporary transaction\n<li>Create a default 3D view\n<li>Create FilteredElementCollection on view elements.\n<li>Apply WhereElementIsNotElementType\n<li>Iteration\n<li>Rollback to remove created view\n</li></li></li></li></li></li></ul>\n<p>Since it seems that 3D elements are what is wanted here, all elements visible in the new (unfiltered) 3D view are targets.\n\n<p>Finally, the final solution contains a redundancy:\n\n<pre class=\"code\">\n  <span class=\"teal\">FilteredElementCollector</span> collector \n    = <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( doc );\n \n  collector\n    .WhereElementIsNotElementType()\n    .WhereElementIsViewIndependent()\n    .ToElements();\n \n  <span class=\"blue\">foreach</span>( <span class=\"teal\">Element</span> element <span class=\"blue\">in</span> collector )\n  {\n    <span class=\"green\">// . . .</span>\n  }\n</pre>\n<p>The redundancy consists in the call to ToElements.\nIt executes the filter over the document and returns all found elements in a collection.  \nForeach over the collector does the same execution a second time.  \nYou should either skip the ToElements call (which is what I would do), or declare a local IList<element> to hold the return of ToElements and run foreach over that.\n\n<!--\n[SC3]This you are welcome to call attention to in this post.  But perhaps it should also have a note in the previous post.  See above.\n-->\n<p>Many thanks to Scott for this valuable feedback!\n\n<!-- .NET, 2011, Element Relationships, Filters, Geometry, Performance, Utilities -->\n</p></element></p></p></p></p></p></p></p></p></p></p></p>"
  }
]