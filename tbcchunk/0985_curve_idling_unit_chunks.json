[
  {
    "original_filename": "0985_curve_idling_unit",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<head>\n<link href=\"bc.css\" rel=\"stylesheet\" type=\"text/css\"/>\n<meta content=\"text/html; charset=utf-8\" http-equiv=\"Content-Type\"/>\n</head>"
  },
  {
    "original_filename": "0985_curve_idling_unit",
    "header_text": "Curve Length, Idling, Units and RevitPythonShell",
    "local_header_href": "#curve-length-idling-units-and-revitpythonshell",
    "chunk_text": "<h3>Curve Length, Idling, Units and RevitPythonShell</h3><p>Here are a couple of recent interesting questions that came up:</p><ul>\n<li><a href=\"#2\">Curve Length versus ApproximateLength</a></li>\n<li><a href=\"#3\">Potential SetRaiseWithoutDelay workaround</a></li>\n<li><a href=\"#4\">Unit handling improvements</a></li>\n<li><a href=\"#5\">Self-contained RevitPythonShell deployment</a></li>\n</ul><a name=\"2\"></a>"
  },
  {
    "original_filename": "0985_curve_idling_unit",
    "header_text": "Curve Length versus ApproximateLength",
    "local_header_href": "#curve-length-versus-approximatelength",
    "chunk_text": "<h4>Curve Length versus ApproximateLength</h4><p><strong>Question:</strong> What is the difference between the Curve Length and ApproximateLength properties, please?</p><p>I am using them to obtain an arc wall length.\nAs far as I can tell, the result is exactly the same, so which one should I normally use?</p><p><strong>Answer:</strong> All Revit geometry\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/01/curve-parameterisation.html\">\ncurves are parameterised</a>.\n\n<p>A curve is a mapping from a simple one-dimensional parameter range, e.g. the interval [0,1] or [0,2Ï€], to a set of contiguous points in 2D or 3D space.</p>\n<p>Whereas the parameter range is normally very simple, the resulting curve points in space are a different matter.</p>\n<p>For a complex curve, the range spanned by the points and the resulting curve length may be difficult to determine exactly.\nThe Length property may calculate it using numeric integration, which provides a pretty good approximation and may be expensive to compute.</p>\n<p>The ApproximateLength property uses a simpler, faster, more efficient algorithm to determine an approximate length without integration.</p>\n<p>However, as stated in the documentation, the results may be off by a significant amount.</p>\n<p>For arcs and lines there is no difference, as you noted.\nIn those simple cases, the result and performance for both will always be identical.</p>\n<p>Therefore, for walls, under normal circumstances, it will make no difference which one of the two methods you use.</p>\n<p>The only difference will occur for complex curves, in which case you need to decide for yourself whether speed or precision is of greater importance for you.</p>\n<p>If you have a plan requiring a wall that returns different results for these two properties, your architect is probably mad.  :-)</p>\n<a name=\"3\"></a>\n<h4>Potential SetRaiseWithoutDelay Workaround</h4>\n<p>Revit 2014 introduced a new\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2012/04/idling-enhancements-and-external-events.html#2\">\ndefault Idling behaviour</a>,\n\nraising the event one single time each time Revit enters an idle session, and the SetRaiseWithoutDelay method to restore the non-default mode, calling the event handler repeatedly.\n\n<p>Calling SetRaiseWithoutDelay may cause more calls than needed and degrade system performance.</p>\n<p>However, not calling it means that your Idling event handler will be called once only when Revit enters the idle state, and never again unless the user moves the mouse or takes some other action.</p>\n<p>Joe Ye presented a\n\n<a href=\"http://adndevblog.typepad.com/aec/2013/07/tricks-to-force-trigger-idling-event.html\">\ntrick to force trigger Idling event</a> that\n\ncan be used to achieve something in between the two extremes by simulating a mouse move, triggering a new Idling call without calling SetRaiseWithoutDelay.\n\n<p>It may or may not be possible to combine this trick with a timer to achieve any desired delay between the calls.</p>\n<a name=\"4\"></a>\n<h4>Unit Handling Improvements</h4>\n<p><strong>Question:</strong> My add-in needs to create a list of all DisplayUnitTypes (e.g. DUT_DECIMAL_INCHES, DUT_FEET_FRACTIONAL_INCHES) that are valid for a given UnitType (e.g. UT_Length) in a family document.\n\n<p>The only way I could find to do this previously was to try applying every DisplayUnitType enum value to the FormatOptions.Units object for the given UnitType.\nThe invalid ones throw an exception, so the rest are presumably valid.</p>\n<p>Since this is a time-consuming process, I cache the results for all UnitTypes.</p>\n<p>The Revit 2014 API introduced the FormatOptions.DisplayUnits property.\nThe Visual Studio IntelliSense says it can throw three exceptions: ArgumentException, ArgumentOutOfRangeException and InvalidOperationException.</p>\n<p>However, in all my tests so far, the method <b>never</b> throws an exception.\nMy add-in therefore concludes that every possible DisplayUnitType is valid for the FormatOptions for every UnitType.</p>\n<p>I know that significant changes were made to the Units engine.</p>\n<p>Is there any better built-in way to generate the list of DisplayUnitTypes that are valid for a UnitType?</p>\n<p><strong>Answer:</strong> This is working as designed:\n\n<p>FormatOptions.DisplayUnits rejects only \"invalid display units\".\nThe documentation refers to UnitUtils.GetValidDisplayUnits, which says, \"A display unit is considered valid if it is an actual unit like meters or feet. Obsolete values and the special values DUT_CUSTOM and DUT_UNDEFINED are not considered valid.\"</p>\n<p>So no attempt is made to coordinate display units with the unit type that generated the FormatOptions.</p>\n<p>Note that SetFormatOptions does throw an exception for invalid combinations of UnitType and DisplayUnitType if you add this code to the check:</p>\n<pre class=\"code\">\n  oFormatOption.DisplayUnits = eDisplayUnitType;\n\n  using (Transaction t = new Transaction(doc))\n  {\n    t.Start(\"Set options\");\n    units.SetFormatOptions(unitType, oFormatOption);\n    t.Commit();\n  }\n</pre>\n<p>On the other hand, there really is an easier way to achieve this:</p>\n<p>Call UnitUtils.GetValidDisplayUnits(UnitType), which directly returns valid types without any further complications.</p>\n<a name=\"5\"></a>\n<h4>Self-contained RevitPythonShell Deployment</h4>\n<p>Daren Thomas points out the\n\n<a href=\"http://darenatwork.blogspot.ch/2013/05/deploying-rps-scripts-with.html\">\nnew RevitPythonShell deployment functionality</a> that\n\nenables the creation of a self-contained set of DLLs for deploying RevitPythonShell scripts without requiring the user to install RevitPythonShell.\nYou still need to create an installer, and a HelloWorld example with a sample InnoSetup installer is provided.</p>\n</p></p></p></p></p>"
  },
  {
    "original_filename": "0985_curve_idling_unit",
    "header_text": "Potential SetRaiseWithoutDelay Workaround",
    "local_header_href": "#potential-setraisewithoutdelay-workaround",
    "chunk_text": "<h4>Potential SetRaiseWithoutDelay Workaround</h4><p>Revit 2014 introduced a new\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2012/04/idling-enhancements-and-external-events.html#2\">\ndefault Idling behaviour</a>,\n\nraising the event one single time each time Revit enters an idle session, and the SetRaiseWithoutDelay method to restore the non-default mode, calling the event handler repeatedly.\n\n<p>Calling SetRaiseWithoutDelay may cause more calls than needed and degrade system performance.</p>\n<p>However, not calling it means that your Idling event handler will be called once only when Revit enters the idle state, and never again unless the user moves the mouse or takes some other action.</p>\n<p>Joe Ye presented a\n\n<a href=\"http://adndevblog.typepad.com/aec/2013/07/tricks-to-force-trigger-idling-event.html\">\ntrick to force trigger Idling event</a> that\n\ncan be used to achieve something in between the two extremes by simulating a mouse move, triggering a new Idling call without calling SetRaiseWithoutDelay.\n\n<p>It may or may not be possible to combine this trick with a timer to achieve any desired delay between the calls.</p>\n<a name=\"4\"></a>\n<h4>Unit Handling Improvements</h4>\n<p><strong>Question:</strong> My add-in needs to create a list of all DisplayUnitTypes (e.g. DUT_DECIMAL_INCHES, DUT_FEET_FRACTIONAL_INCHES) that are valid for a given UnitType (e.g. UT_Length) in a family document.\n\n<p>The only way I could find to do this previously was to try applying every DisplayUnitType enum value to the FormatOptions.Units object for the given UnitType.\nThe invalid ones throw an exception, so the rest are presumably valid.</p>\n<p>Since this is a time-consuming process, I cache the results for all UnitTypes.</p>\n<p>The Revit 2014 API introduced the FormatOptions.DisplayUnits property.\nThe Visual Studio IntelliSense says it can throw three exceptions: ArgumentException, ArgumentOutOfRangeException and InvalidOperationException.</p>\n<p>However, in all my tests so far, the method <b>never</b> throws an exception.\nMy add-in therefore concludes that every possible DisplayUnitType is valid for the FormatOptions for every UnitType.</p>\n<p>I know that significant changes were made to the Units engine.</p>\n<p>Is there any better built-in way to generate the list of DisplayUnitTypes that are valid for a UnitType?</p>\n<p><strong>Answer:</strong> This is working as designed:\n\n<p>FormatOptions.DisplayUnits rejects only \"invalid display units\".\nThe documentation refers to UnitUtils.GetValidDisplayUnits, which says, \"A display unit is considered valid if it is an actual unit like meters or feet. Obsolete values and the special values DUT_CUSTOM and DUT_UNDEFINED are not considered valid.\"</p>\n<p>So no attempt is made to coordinate display units with the unit type that generated the FormatOptions.</p>\n<p>Note that SetFormatOptions does throw an exception for invalid combinations of UnitType and DisplayUnitType if you add this code to the check:</p>\n<pre class=\"code\">\n  oFormatOption.DisplayUnits = eDisplayUnitType;\n\n  using (Transaction t = new Transaction(doc))\n  {\n    t.Start(\"Set options\");\n    units.SetFormatOptions(unitType, oFormatOption);\n    t.Commit();\n  }\n</pre>\n<p>On the other hand, there really is an easier way to achieve this:</p>\n<p>Call UnitUtils.GetValidDisplayUnits(UnitType), which directly returns valid types without any further complications.</p>\n<a name=\"5\"></a>\n<h4>Self-contained RevitPythonShell Deployment</h4>\n<p>Daren Thomas points out the\n\n<a href=\"http://darenatwork.blogspot.ch/2013/05/deploying-rps-scripts-with.html\">\nnew RevitPythonShell deployment functionality</a> that\n\nenables the creation of a self-contained set of DLLs for deploying RevitPythonShell scripts without requiring the user to install RevitPythonShell.\nYou still need to create an installer, and a HelloWorld example with a sample InnoSetup installer is provided.</p>\n</p></p></p></p>"
  },
  {
    "original_filename": "0985_curve_idling_unit",
    "header_text": "Unit Handling Improvements",
    "local_header_href": "#unit-handling-improvements",
    "chunk_text": "<h4>Unit Handling Improvements</h4><p><strong>Question:</strong> My add-in needs to create a list of all DisplayUnitTypes (e.g. DUT_DECIMAL_INCHES, DUT_FEET_FRACTIONAL_INCHES) that are valid for a given UnitType (e.g. UT_Length) in a family document.\n\n<p>The only way I could find to do this previously was to try applying every DisplayUnitType enum value to the FormatOptions.Units object for the given UnitType.\nThe invalid ones throw an exception, so the rest are presumably valid.</p>\n<p>Since this is a time-consuming process, I cache the results for all UnitTypes.</p>\n<p>The Revit 2014 API introduced the FormatOptions.DisplayUnits property.\nThe Visual Studio IntelliSense says it can throw three exceptions: ArgumentException, ArgumentOutOfRangeException and InvalidOperationException.</p>\n<p>However, in all my tests so far, the method <b>never</b> throws an exception.\nMy add-in therefore concludes that every possible DisplayUnitType is valid for the FormatOptions for every UnitType.</p>\n<p>I know that significant changes were made to the Units engine.</p>\n<p>Is there any better built-in way to generate the list of DisplayUnitTypes that are valid for a UnitType?</p>\n<p><strong>Answer:</strong> This is working as designed:\n\n<p>FormatOptions.DisplayUnits rejects only \"invalid display units\".\nThe documentation refers to UnitUtils.GetValidDisplayUnits, which says, \"A display unit is considered valid if it is an actual unit like meters or feet. Obsolete values and the special values DUT_CUSTOM and DUT_UNDEFINED are not considered valid.\"</p>\n<p>So no attempt is made to coordinate display units with the unit type that generated the FormatOptions.</p>\n<p>Note that SetFormatOptions does throw an exception for invalid combinations of UnitType and DisplayUnitType if you add this code to the check:</p>\n<pre class=\"code\">\n  oFormatOption.DisplayUnits = eDisplayUnitType;\n\n  using (Transaction t = new Transaction(doc))\n  {\n    t.Start(\"Set options\");\n    units.SetFormatOptions(unitType, oFormatOption);\n    t.Commit();\n  }\n</pre>\n<p>On the other hand, there really is an easier way to achieve this:</p>\n<p>Call UnitUtils.GetValidDisplayUnits(UnitType), which directly returns valid types without any further complications.</p>\n<a name=\"5\"></a>\n<h4>Self-contained RevitPythonShell Deployment</h4>\n<p>Daren Thomas points out the\n\n<a href=\"http://darenatwork.blogspot.ch/2013/05/deploying-rps-scripts-with.html\">\nnew RevitPythonShell deployment functionality</a> that\n\nenables the creation of a self-contained set of DLLs for deploying RevitPythonShell scripts without requiring the user to install RevitPythonShell.\nYou still need to create an installer, and a HelloWorld example with a sample InnoSetup installer is provided.</p>\n</p></p>"
  },
  {
    "original_filename": "0985_curve_idling_unit",
    "header_text": "Self-contained RevitPythonShell Deployment",
    "local_header_href": "#self-contained-revitpythonshell-deployment",
    "chunk_text": "<h4>Self-contained RevitPythonShell Deployment</h4><p>Daren Thomas points out the\n\n<a href=\"http://darenatwork.blogspot.ch/2013/05/deploying-rps-scripts-with.html\">\nnew RevitPythonShell deployment functionality</a> that\n\nenables the creation of a self-contained set of DLLs for deploying RevitPythonShell scripts without requiring the user to install RevitPythonShell.\nYou still need to create an installer, and a HelloWorld example with a sample InnoSetup installer is provided.</p>"
  }
]