[
  {
    "original_filename": "0020_filter_conclusion",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<style type=\"text/css\">\n.blue { color: blue; }\n.teal { color: teal; }\n.maroon { color: maroon; }\n</style>"
  },
  {
    "original_filename": "0020_filter_conclusion",
    "header_text": "Filter Performance Conclusion",
    "local_header_href": "#filter-performance-conclusion",
    "chunk_text": "<h3>Filter Performance Conclusion</h3><p>Continuing the topic of the \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2008/10/more-filter-per.html\">\nRevit API filter performance</a>, \n\nGuy responds to Ralf:</p><p>Ralf raises some good points.</p><p>A good point on the order in filters, I did not think about that and I did think the speed improvement was larger than normal. I've found in past testing using the TypeFilter in most cases 2-10% slower than using some form of .NET filtering for real world projects and where other filters are not appropriate.</p><p>I agree that an anonymous method is not as elegant; I haven't used this method in any production code. It just gave you a list as per your original code. Almost without exception, all my commands use the ElementIterator getElements() rather than populating a list. And for that reason the point I should have made in the previous post was that IMO I still think the TypeFilter is redundant. This is how I would have processed the elements in the command:</p><pre class=\"code\">\n  <span class=\"teal\">Filter</span> f1 = cf.NewCategoryFilter(\n    <span class=\"teal\">BuiltInCategory</span>.OST_Doors );\n\n  <span class=\"teal\">Filter</span> f2 = cf.NewCategoryFilter(\n    <span class=\"teal\">BuiltInCategory</span>.OST_Windows );\n\n  <span class=\"teal\">Filter</span> f3 = cf.NewLogicOrFilter( f1, f2 );\n\n  <span class=\"teal\">ElementIterator</span> itor = doc.get_Elements( f3 );\n  <span class=\"blue\">int</span> n = 0;\n  <span class=\"blue\">while</span>( itor.MoveNext() )\n  {\n    <span class=\"blue\">if</span>( itor.Current <span class=\"blue\">is</span> <span class=\"teal\">FamilyInstance</span> )\n    {\n      n++;\n      <span class=\"teal\">FamilyInstance</span> elem = itor.Current\n        <span class=\"blue\">as</span> <span class=\"teal\">FamilyInstance</span>;\n    }\n  }\n</pre><p>Against the 100 MB project this is still 1-3% faster than including the type filter, even including the casting to a FamilyInstance.</p><p>The other point Ralf raises is that x &gt;&gt; y where x is the total element number and y is the number of elements of interest, e.g. of the desired category. I would go a step further and say for most commands x &gt;&gt; y &gt;&gt; z, where z is the number of particular instances of a family you are interested in processing. For that reason a vast majority of production commands I've written use parameter filtering, yet I have none with type filtering.</p><p>I've also found in testing that type filter performance is very dependent on whether a project has been recently purged of unused objects. As users will know, purging on a regular basis helps project performance. The difference in performance between a purged versus a non purged project for API commands can be very dramatic, as the total object count often drops significantly.</p><p>As you can tell, I'm not a big fan of the type filter but every project is different ;-)</p><p>For completeness sake, here is how I would use the ElementIterator in the original code:</p><pre class=\"code\">\n<span class=\"blue\">private</span> <span class=\"teal\">Dictionary</span>&lt;<span class=\"teal\">ElementId</span>, <span class=\"teal\">List</span>&lt;<span class=\"teal\">ElementId</span>&gt;&gt;\n  getElementIds( <span class=\"teal\">ElementIterator</span> itor)\n{\n  <span class=\"teal\">Dictionary</span>&lt;<span class=\"teal\">ElementId</span>, <span class=\"teal\">List</span>&lt;<span class=\"teal\">ElementId</span>&gt;&gt; dict\n    = <span class=\"blue\">new</span> <span class=\"teal\">Dictionary</span>&lt;<span class=\"teal\">ElementId</span>, <span class=\"teal\">List</span>&lt;<span class=\"teal\">ElementId</span>&gt;&gt;();\n\n  <span class=\"blue\">string</span> fmt = <span class=\"maroon\">\"{0} is hosted by {1}\"</span>;\n\n  <span class=\"blue\">while</span>( itor.MoveNext() )\n  {\n    <span class=\"blue\">object</span> elem = itor.Current;\n    <span class=\"blue\">if</span>( elem <span class=\"blue\">is</span> <span class=\"teal\">FamilyInstance</span> )\n    {\n      <span class=\"teal\">FamilyInstance</span> fi = elem <span class=\"blue\">as</span> <span class=\"teal\">FamilyInstance</span>;\n      <span class=\"teal\">ElementId</span> id = fi.Id;\n \n      <span class=\"teal\">ElementId</span> idHost = fi.Host.Id;\n \n      <span class=\"teal\">Debug</span>.WriteLine( <span class=\"blue\">string</span>.Format( fmt,\n        ElementDescription( fi ),\n        ElementDescription( idHost ) ) );\n\n      <span class=\"blue\">if</span>( !dict.ContainsKey( idHost ) )\n      {\n        dict.Add( idHost, <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">ElementId</span>&gt;() );\n      }\n      dict[idHost].Add( id );\n    }\n  }\n  <span class=\"blue\">return</span> dict;\n}\n</pre>"
  }
]