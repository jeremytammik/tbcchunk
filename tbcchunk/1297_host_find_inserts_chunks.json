[
  {
    "original_filename": "1297_host_find_inserts",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<head>\n<meta content=\"text/html; charset=utf-8\" http-equiv=\"Content-Type\"/>\n<link href=\"bc.css\" rel=\"stylesheet\" type=\"text/css\"/>\n</head>"
  },
  {
    "original_filename": "1297_host_find_inserts",
    "header_text": "FindInserts Retrieves All Openings in All Wall Types",
    "local_header_href": "#findinserts-retrieves-all-openings-in-all-wall-types",
    "chunk_text": "<h3>FindInserts Retrieves All Openings in All Wall Types</h3><p>On Tuesday, I presented the new\n\n<a href=\"https://github.com/jeremytammik/SpatialElementGeometryCalculator\">\nSpatialElementGeometryCalculator sample</a> for\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2015/03/calculating-gross-and-net-wall-areas.html\">\ncalculating gross and net wall areas</a>.</p><p>It discusses a whole bunch of interesting aspects, e.g.:</p><ul>\n<li>Use of the SpatialElementGeometryCalculator class.</li>\n<li>Porting a VB.NET Revit add-in to C#.</li>\n<li>Use of the <a href=\"http://thebuildingcoder.typepad.com/blog/2012/10/the-temporary-transaction-trick-for-gross-slab-data.html\">\ntemporary transaction trick</a>.</li>\n<li>Use of filtered element collectors to determine all openings in a wall.</li>\n<li>Filtered element collector optimisation possibilities, e.g. integer instead of string comparison, use of a parameter filter instead of .NET post-processing.</li>\n</ul><p>Vilo submitted a very relevant\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2015/03/calculating-gross-and-net-wall-areas.html?cid=6a00e553e16897883301b8d0eee480970c#comment-6a00e553e16897883301b8d0eee480970c\">\ncomment</a> on that sample, asking:\n\n<p><strong>Question:</strong>\n\nWhy not use <code>(wall as HostObject).FindInserts(...)</code> to determine the instances nested into the given wall?</p>\n<p>Maybe the method above gives better performance?</p>\n<p><strong>Response:</strong>\n\nThat is a very valid question indeed.</p>\n<p>The simple answer is: I was unaware of it, in spite of it being used in the\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2013/07/football-and-space-adjacency-for-heat-load-calculation.html#3\">\nspace adjacency for heat load calculation</a> sample.</p>\n<p>In olden times, methods similar to that shown above were the only way to retrieve this information.</p>\n<p>Hence, for instance, this <a href=\"http://thebuildingcoder.typepad.com/blog/2008/10/relationship-in.html\">relationship inverter implementation</a>.</p>\n<p>Thank you very much for this valuable hint!</p>\n<p>By the way, there is no need to say 'wall as HostObject', because the wall is a HostObject, being derived from it. You can simply use wall. FindInserts directly.</p>\n<p><strong>Later:</strong>\n\nI see what you mean now, of course. In the code above, the 'wall' variable is of type Element. I added the following debug code to verify that at least the number of openings retrieved is equal:</p>\n<pre class=\"code\">\n  <span class=\"green\">// This approach is much more efficient and</span>\n  <span class=\"green\">// entirely avoids the use of all filtered</span>\n  <span class=\"green\">// element collectors.</span>\n \n  <span class=\"teal\">IList</span>&lt;<span class=\"teal\">ElementId</span>&gt; inserts = ( wall <span class=\"blue\">as</span> <span class=\"teal\">HostObject</span> )\n    .FindInserts( <span class=\"blue\">true</span>, <span class=\"blue\">true</span>, <span class=\"blue\">true</span>, <span class=\"blue\">true</span> );\n \n  <span class=\"teal\">Debug</span>.Assert(\n    lstTotempDel.Count.Equals( inserts.Count ),\n    <span class=\"maroon\">\"expected FindInserts to return the same openings\"</span> );\n</pre>\n<p>The\n\n<a href=\"https://github.com/jeremytammik/SpatialElementGeometryCalculator\">\nSpatialElementGeometryCalculator GitHub repository</a> code\n\nis updated now.</p>\n<p>Thank you!</p>\n<p>I passed on this information to Phillip Miller of <a href=\"\">Kiwi Codes Solutions Ltd</a>, who provided the initial VB.NET implementation based on the\n\n<a href=\"http://forums.autodesk.com/t5/revit-api/bd-p/160\">Revit API discussion forum</a> thread on\n\n<a href=\"http://forums.autodesk.com/t5/revit-api/door-window-areas/td-p/5535565\">door/window areas</a>, and he replies:</p>\n<p><strong>Response:</strong>\n\nYou will not believe the timing on yours and Vilo's post.</p>\n<p>I had already made the filtered element collector more optimised as you suggested in your blog post, but like you I didn't know about the <code>FindInserts</code> method.  It rocks.</p>\n<p>Just this morning I was contacted by my client saying the custom API works great on walls with hosted families but not with walls that had structure separated with lining walls, e.g., three walls making up one wall with the linings walls joined the structural wall.</p>\n<p>As you can see in my code I was comparing FamilyInstance.HostID with the wall.id.  In a compound wall situation like above the cut opening in the linings wall has a different ID that the FamilyInstance HostID, so it didn't find any openings.</p>\n<p>The <code>FindInserts</code> method solved all this in a much nicer way.</p>\n<p><strong>Answer:</strong>\n\nThank you very much for your confirmation and providing samples in which the <code>FindInserts</code> method really makes a significant difference, besides the performance improvement.</p>\n<p>Implementing a solution for the compound wall situation would probably be possible using filtered element collectors as well, but much more complex.</p>\n<p>The code using FindInserts is a lot simpler and more succinct than the filtered element collector code, even for the non-compound situation.</p>\n<p>Here is the updated C# implementation using it:</p>\n<pre class=\"code\">\n[<span class=\"teal\">Transaction</span>( <span class=\"teal\">TransactionMode</span>.Manual )]\n<span class=\"blue\">public</span> <span class=\"blue\">class</span> <span class=\"teal\">Command</span> : <span class=\"teal\">IExternalCommand</span>\n{\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n  <span class=\"gray\">///</span><span class=\"green\"> Convert square feet to square meters </span>\n  <span class=\"gray\">///</span><span class=\"green\"> with two decimal places precision.</span>\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n  <span class=\"blue\">double</span> sqFootToSquareM( <span class=\"blue\">double</span> sqFoot )\n  {\n    <span class=\"blue\">return</span> <span class=\"teal\">Math</span>.Round( sqFoot * 0.092903, 2 );\n  }\n \n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n  <span class=\"gray\">///</span><span class=\"green\"> Calculate wall area minus openings. Temporarily</span>\n  <span class=\"gray\">///</span><span class=\"green\"> delete all openings in a transaction that is</span>\n  <span class=\"gray\">///</span><span class=\"green\"> rolled back.</span>\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;param name=\"subfaceArea\"&gt;</span><span class=\"green\">Initial gross subface area</span><span class=\"gray\">&lt;/param&gt;</span>\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;param name=\"wall\"&gt;&lt;/param&gt;</span>\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;param name=\"doc\"&gt;&lt;/param&gt;</span>\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;param name=\"room\"&gt;&lt;/param&gt;</span>\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;returns&gt;&lt;/returns&gt;</span>\n  <span class=\"blue\">double</span> calwallAreaMinusOpenings(\n    <span class=\"blue\">double</span> subfaceArea,\n    <span class=\"teal\">Element</span> wall,\n    <span class=\"teal\">Room</span> room )\n  {\n    <span class=\"teal\">Document</span> doc = wall.Document;\n \n    <span class=\"green\">// Is this a reliable way to compare documents?</span>\n \n    <span class=\"teal\">Debug</span>.Assert(\n      room.Document.ProjectInformation.UniqueId.Equals(\n        doc.ProjectInformation.UniqueId ),\n      <span class=\"maroon\">\"expected wall and room from same document\"</span> );\n \n    <span class=\"green\">// Determine all openings in the given wall.</span>\n \n    <span class=\"teal\">IList</span>&lt;<span class=\"teal\">ElementId</span>&gt; inserts = ( wall <span class=\"blue\">as</span> <span class=\"teal\">HostObject</span> )\n      .FindInserts( <span class=\"blue\">true</span>, <span class=\"blue\">true</span>, <span class=\"blue\">true</span>, <span class=\"blue\">true</span> );\n \n    <span class=\"green\">// Determine total area of all openings.</span>\n \n    <span class=\"blue\">double</span> openingArea = 0;\n \n    <span class=\"blue\">if</span>( 0 &lt; inserts.Count )\n    {\n      <span class=\"teal\">Transaction</span> t = <span class=\"blue\">new</span> <span class=\"teal\">Transaction</span>( doc );\n \n      <span class=\"blue\">double</span> wallAreaNet = wall.get_Parameter(\n        <span class=\"teal\">BuiltInParameter</span>.HOST_AREA_COMPUTED )\n          .AsDouble();\n \n      t.Start( <span class=\"maroon\">\"tmp Delete\"</span> );\n      doc.Delete( inserts );\n      doc.Regenerate();\n      <span class=\"blue\">double</span> wallAreaGross = wall.get_Parameter(\n        <span class=\"teal\">BuiltInParameter</span>.HOST_AREA_COMPUTED )\n          .AsDouble();\n      t.RollBack();\n \n      openingArea = wallAreaGross - wallAreaNet;\n    }\n \n    <span class=\"blue\">return</span> subfaceArea - openingArea;\n  }\n \n  <span class=\"blue\">public</span> <span class=\"teal\">Result</span> Execute(\n    <span class=\"teal\">ExternalCommandData</span> commandData,\n    <span class=\"blue\">ref</span> <span class=\"blue\">string</span> message,\n    <span class=\"teal\">ElementSet</span> elements )\n  {\n    <span class=\"teal\">UIApplication</span> app = commandData.Application;\n    <span class=\"teal\">Document</span> doc = app.ActiveUIDocument.Document;\n \n    <span class=\"teal\">SpatialElementBoundaryOptions</span> sebOptions\n      = <span class=\"blue\">new</span> <span class=\"teal\">SpatialElementBoundaryOptions</span>();\n \n    sebOptions.SpatialElementBoundaryLocation\n      = <span class=\"teal\">SpatialElementBoundaryLocation</span>.Finish;\n \n    <span class=\"teal\">Result</span> rc;\n \n    <span class=\"blue\">try</span>\n    {\n      <span class=\"teal\">FilteredElementCollector</span> roomCol\n        = <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( doc )\n          .OfClass( <span class=\"blue\">typeof</span>( <span class=\"teal\">SpatialElement</span> ) );\n \n      <span class=\"blue\">string</span> s = <span class=\"maroon\">\"Finished populating Rooms with \"</span>\n        + <span class=\"maroon\">\"Boundary Data\\r\\n\\r\\n\"</span>;\n \n      <span class=\"blue\">foreach</span>( <span class=\"teal\">SpatialElement</span> e <span class=\"blue\">in</span> roomCol )\n      {\n        <span class=\"teal\">Room</span> room = e <span class=\"blue\">as</span> <span class=\"teal\">Room</span>;\n \n        <span class=\"blue\">if</span>( room != <span class=\"blue\">null</span> )\n        {\n          <span class=\"blue\">try</span>\n          {\n            Autodesk.Revit.DB\n              .<span class=\"teal\">SpatialElementGeometryCalculator</span>\n                calc = <span class=\"blue\">new</span> Autodesk.Revit.DB\n                  .<span class=\"teal\">SpatialElementGeometryCalculator</span>(\n                    doc, sebOptions );\n \n            <span class=\"teal\">SpatialElementGeometryResults</span> results\n              = calc.CalculateSpatialElementGeometry(\n                room );\n \n            <span class=\"teal\">Solid</span> roomSolid = results.GetGeometry();\n \n            <span class=\"blue\">foreach</span>( <span class=\"teal\">Face</span> face <span class=\"blue\">in</span> roomSolid.Faces )\n            {\n              <span class=\"teal\">IList</span>&lt;<span class=\"teal\">SpatialElementBoundarySubface</span>&gt;\n                subfaceList = results.GetBoundaryFaceInfo(\n                  face );\n \n              <span class=\"blue\">foreach</span>( <span class=\"teal\">SpatialElementBoundarySubface</span>\n                subface <span class=\"blue\">in</span> subfaceList )\n              {\n                <span class=\"blue\">if</span>( subface.SubfaceType\n                  == <span class=\"teal\">SubfaceType</span>.Side )\n                {\n                  <span class=\"teal\">Element</span> wall = doc.GetElement(\n                    subface.SpatialBoundaryElement\n                      .HostElementId );\n \n                  <span class=\"blue\">double</span> subfaceArea = subface\n                    .GetSubface().Area;\n \n                  <span class=\"blue\">double</span> netArea = sqFootToSquareM(\n                    calwallAreaMinusOpenings(\n                      subfaceArea, wall, room ) );\n \n                  s = s + <span class=\"maroon\">\"Room \"</span>\n                    + room.get_Parameter(\n                      <span class=\"teal\">BuiltInParameter</span>.ROOM_NUMBER )\n                        .AsString()\n                    + <span class=\"maroon\">\" : Wall \"</span> + wall.get_Parameter(\n                      <span class=\"teal\">BuiltInParameter</span>.ALL_MODEL_MARK )\n                        .AsString()\n                    + <span class=\"maroon\">\" : Area \"</span> + netArea.ToString()\n                    + <span class=\"maroon\">\" m2\\r\\n\"</span>;\n                }\n              }\n            }\n            s = s + <span class=\"maroon\">\"\\r\\n\"</span>;\n          }\n          <span class=\"blue\">catch</span>( <span class=\"teal\">Exception</span> )\n          {\n          }\n        }\n      }\n      <span class=\"teal\">TaskDialog</span>.Show( <span class=\"maroon\">\"Room Boundaries\"</span>, s );\n \n      rc = <span class=\"teal\">Result</span>.Succeeded;\n    }\n    <span class=\"blue\">catch</span>( <span class=\"teal\">Exception</span> ex )\n    {\n      <span class=\"teal\">TaskDialog</span>.Show( <span class=\"maroon\">\"Room Boundaries\"</span>,\n        ex.Message.ToString() + <span class=\"maroon\">\"\\r\\n\"</span>\n        + ex.StackTrace.ToString() );\n \n      rc = <span class=\"teal\">Result</span>.Failed;\n    }\n    <span class=\"blue\">return</span> rc;\n  }\n}\n</pre>\n<p>I updated the C# implementation, but not the VB.NET one, in the\n\n<a href=\"https://github.com/jeremytammik/SpatialElementGeometryCalculator\">SpatialElementGeometryCalculator GitHub repository</a> containing\n\nthe complete source code, Visual Solution files and add-in manifests for both and tagged the version presented here as\n\n<a href=\"https://github.com/jeremytammik/SpatialElementGeometryCalculator/releases/tag/2015.0.0.2\">\nrelease 2015.0.0.2</a>.</p>\n<p>Many thanks to Phillip and Vilo for the significant improvement of this important solution!</p>\n</p>"
  }
]