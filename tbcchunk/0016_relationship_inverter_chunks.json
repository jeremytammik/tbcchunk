[
  {
    "original_filename": "0016_relationship_inverter",
    "header_text": "Relationship Inverter",
    "local_header_href": "#relationship-inverter",
    "chunk_text": "<h3>Relationship Inverter</h3><style type=\"text/css\">\n.blue { color: blue; }\n.green { color: green; }\n.teal { color: teal; }\n.gray { color: gray; }\n.maroon { color: maroon; }\n</style><p>Moving away from the topic of geometry, I have another sample that I would like to share from the Revit API introductory workshop that I recently held. In this sample, we address the following topics:</p><ul>\n<li>Using a Boolean combination of Revit API filters to find certain elements.</li>\n<li>Retrieving the hosted to host relationship between doors, windows, and walls.</li>\n<li>Inverting the relationship, i.e. determining the host to hosted one.</li>\n</ul><p>This sample also introduces some new little utility functions, such as ElementDescription() to return a string describing a given Revit element.</p><p>As said, we are interested in the relationship between door and window openings and the walls hosting them. The Revit API provides a one-way relationship from hosted element to its host in the form of the FamilyInstance.Host property, which returns the containing element if the family instance is contained within another element. In our case, the doors and windows are family instances, and the containing element is a wall.</p><p>In a first step, we create a Boolean combination of filters to select the elements we are interested in from the building model database. We do not need to retrieve the walls, because they do not provide any relationship information about their hosted elements. All we need is to access the doors and windows. These can be identified by having the class FamilyInstance and either door or window category. We can use a TypeFilter to match the class, and CategoryFilter instances for the categories. The category filters can be combined using a Boolean OR to match either door or window. The resulting filter can in turn be combined with the class filter using a Boolean AND. The result is described in the code below as</p><pre>\nf5 = f1 &amp;&amp; f4\n   = f1 &amp;&amp; (f2 || f3)\n   = family instance and (door or window)\n</pre><p>Once all doors and windows in the model have been retrieved, we can simply loop through them and query the host of each. For each host element id, we create a new entry into a dictionary using the host element id as a key and a list of all hosted element ids as its value. The elements being processed are also logged to the Visual Studio debug output window using the Debug.WriteLine() method provided by the very useful System.Diagnostics namespace.</p><p>At this point, we are actually already done. The resulting dictionary now implements the inverted relationship. We started out with each hosted element knowing its host, and now we have the dictionary with the host element id as key, and a list of ids of all  its hosted elements as a value. All that remains to do is list this information in the debug output window, or use it in some other way.</p><p>Here is the code for this little command:</p><pre class=\"code\">\n<span class=\"blue\">#region</span> Namespaces\n<span class=\"blue\">using</span> System;\n<span class=\"blue\">using</span> System.Collections.Generic;\n<span class=\"blue\">using</span> System.Diagnostics;\n<span class=\"blue\">using</span> Autodesk.Revit;\n<span class=\"blue\">using</span> Autodesk.Revit.Elements;\n<span class=\"blue\">using</span> Autodesk.Revit.Parameters;\n<span class=\"blue\">using</span> <span class=\"teal\">CmdResult</span>\n  = Autodesk.Revit.<span class=\"teal\">IExternalCommand</span>.<span class=\"teal\">Result</span>;\n<span class=\"blue\">#endregion</span> <span class=\"green\">// Namespaces</span>\n \n<span class=\"blue\">namespace</span> BuildingCoder\n{\n  <span class=\"blue\">public</span> <span class=\"blue\">class</span> <span class=\"teal\">CmdRelationshipInverter</span>\n    : <span class=\"teal\">IExternalCommand</span>\n  {\n    <span class=\"blue\">private</span> <span class=\"teal\">Document</span> m_doc;\n \n    <span class=\"blue\">public</span> <span class=\"blue\">static</span> <span class=\"blue\">string</span> PluralSuffix( <span class=\"blue\">int</span> n )\n    {\n      <span class=\"blue\">return</span> 1 == n ? <span class=\"maroon\">\"\"</span> : <span class=\"maroon\">\"s\"</span>;\n    }\n \n    <span class=\"blue\">public</span> <span class=\"blue\">static</span> <span class=\"blue\">string</span> DotOrColon( <span class=\"blue\">int</span> n )\n    {\n      <span class=\"blue\">return</span> 1 &lt; n ? <span class=\"maroon\">\":\"</span> : <span class=\"maroon\">\".\"</span>;\n    }\n \n    <span class=\"blue\">string</span> ElementDescription( <span class=\"teal\">Element</span> e )\n    {\n      <span class=\"green\">// for a wall, the element name equals the </span>\n      <span class=\"green\">// wall type name, which is equivalent to the </span>\n      <span class=\"green\">// family name ...</span>\n      <span class=\"teal\">FamilyInstance</span> fi = e <span class=\"blue\">as</span> <span class=\"teal\">FamilyInstance</span>;\n      <span class=\"blue\">string</span> fn = <span class=\"blue\">string</span>.Empty;\n      <span class=\"blue\">if</span>( <span class=\"blue\">null</span> != fi )\n      {\n        fn = fi.Symbol.Family.Name + <span class=\"maroon\">\" \"</span>;\n      }\n      <span class=\"blue\">return</span> <span class=\"blue\">string</span>.Format( <span class=\"maroon\">\"{0} {1}&lt;{2} {3}&gt;\"</span>,\n        e.Category.Name, fn,\n        e.Id.Value.ToString(), e.Name );\n    }\n \n    <span class=\"blue\">string</span> ElementDescription( <span class=\"teal\">ElementId</span> id )\n    {\n      <span class=\"teal\">Element</span> e = m_doc.get_Element( <span class=\"blue\">ref</span> id );\n      <span class=\"blue\">return</span> ElementDescription( e );\n    }\n \n    <span class=\"blue\">private</span> <span class=\"teal\">Dictionary</span>&lt;<span class=\"teal\">ElementId</span>, <span class=\"teal\">List</span>&lt;<span class=\"teal\">ElementId</span>&gt;&gt;\n      getElementIds( <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt; elements )\n    {\n      <span class=\"teal\">Dictionary</span>&lt;<span class=\"teal\">ElementId</span>, <span class=\"teal\">List</span>&lt;<span class=\"teal\">ElementId</span>&gt;&gt; dict =\n        <span class=\"blue\">new</span> <span class=\"teal\">Dictionary</span>&lt;<span class=\"teal\">ElementId</span>, <span class=\"teal\">List</span>&lt;<span class=\"teal\">ElementId</span>&gt;&gt;();\n \n      <span class=\"blue\">string</span> fmt = <span class=\"maroon\">\"{0} is hosted by {1}\"</span>;\n \n      <span class=\"blue\">foreach</span>( <span class=\"teal\">FamilyInstance</span> fi <span class=\"blue\">in</span> elements )\n      {\n        <span class=\"teal\">ElementId</span> id = fi.Id;\n        <span class=\"teal\">ElementId</span> idHost = fi.Host.Id;\n \n        <span class=\"teal\">Debug</span>.WriteLine( <span class=\"blue\">string</span>.Format( fmt,\n          ElementDescription( fi ),\n          ElementDescription( idHost ) ) );\n \n        <span class=\"blue\">if</span>( !dict.ContainsKey( idHost ) )\n        {\n          dict.Add( idHost, <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">ElementId</span>&gt;() );\n        }\n        dict[idHost].Add( id );\n      }\n      <span class=\"blue\">return</span> dict;\n    }\n \n    <span class=\"blue\">private</span> <span class=\"blue\">void</span> dumpHostedElements(\n      <span class=\"teal\">Dictionary</span>&lt;<span class=\"teal\">ElementId</span>, <span class=\"teal\">List</span>&lt;<span class=\"teal\">ElementId</span>&gt;&gt; ids )\n    {\n      <span class=\"blue\">foreach</span>( <span class=\"teal\">ElementId</span> idHost <span class=\"blue\">in</span> ids.Keys )\n      {\n        <span class=\"blue\">string</span> s = <span class=\"blue\">string</span>.Empty;\n \n        <span class=\"blue\">foreach</span>( <span class=\"teal\">ElementId</span> id <span class=\"blue\">in</span> ids[idHost] )\n        {\n          <span class=\"blue\">if</span>( 0 &lt; s.Length )\n          {\n            s += <span class=\"maroon\">\", \"</span>;\n          }\n          s += ElementDescription( id );\n        }\n \n        <span class=\"blue\">int</span> n = ids[idHost].Count;\n \n        <span class=\"teal\">Debug</span>.WriteLine(<span class=\"blue\">string</span>.Format(\n          <span class=\"maroon\">\"{0} hosts {1} opening{2}: {3}\"</span>,\n          ElementDescription( idHost ),\n          n, PluralSuffix( n ), s ) );\n      }\n    }\n \n    <span class=\"blue\">public</span> <span class=\"teal\">CmdResult</span> Execute(\n      <span class=\"teal\">ExternalCommandData</span> commandData,\n      <span class=\"blue\">ref</span> <span class=\"blue\">string</span> message,\n      <span class=\"teal\">ElementSet</span> elements )\n    {\n      <span class=\"teal\">Application</span> app = commandData.Application;\n      m_doc = app.ActiveDocument;\n \n      <span class=\"green\">// f5 = f1 &amp;&amp; f4 </span>\n      <span class=\"green\">//    = f1 &amp;&amp; (f2 || f3) </span>\n      <span class=\"green\">//    = family instance and (door or window)</span>\n      Autodesk.Revit.Creation.<span class=\"teal\">Filter</span> cf\n        = app.Create.Filter;\n \n      <span class=\"teal\">Filter</span> f1 = cf.NewTypeFilter(\n        <span class=\"blue\">typeof</span>( <span class=\"teal\">FamilyInstance</span> ) );\n \n      <span class=\"teal\">Filter</span> f2 = cf.NewCategoryFilter(\n        <span class=\"teal\">BuiltInCategory</span>.OST_Doors );\n      <span class=\"teal\">Filter</span> f3 = cf.NewCategoryFilter(\n        <span class=\"teal\">BuiltInCategory</span>.OST_Windows );\n \n      <span class=\"teal\">Filter</span> f4 = cf.NewLogicOrFilter( f2, f3 );\n      <span class=\"teal\">Filter</span> f5 = cf.NewLogicAndFilter( f1, f4 );\n \n      <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt; openings = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt;();\n      <span class=\"blue\">int</span> n = m_doc.get_Elements( f5, openings );\n \n      <span class=\"green\">// map with key = host element id and</span>\n      <span class=\"green\">// value = list of hosted element ids:</span>\n      <span class=\"teal\">Dictionary</span>&lt;<span class=\"teal\">ElementId</span>, <span class=\"teal\">List</span>&lt;<span class=\"teal\">ElementId</span>&gt;&gt; ids =\n        getElementIds( openings );\n \n      dumpHostedElements( ids );\n      m_doc = <span class=\"blue\">null</span>;\n \n      <span class=\"blue\">return</span> <span class=\"teal\">CmdResult</span>.Succeeded;\n    }\n  }\n}\n</pre><p>Here is a log file from a sample run. As you can see, we first traverse all the hosted elements and determine the hosting wall of each. These are inserted into the dictionary representing the inverse relationship, which dumps its contents using dumpHostedElements() before the command ends. Please excuse the long overflowing lines:</p><pre>\nDoors M_Single-Flush &lt;127252 0915 x 2134mm&gt; is hosted by Walls &lt;127248 Generic - 200mm&gt;\nWindows M_Fixed &lt;127255 0406 x 0610mm&gt; is hosted by Walls &lt;127248 Generic - 200mm&gt;\nWindows M_Fixed &lt;127258 0406 x 0610mm&gt; is hosted by Walls &lt;127248 Generic - 200mm&gt;\nDoors M_Single-Flush &lt;127295 0915 x 2134mm&gt; is hosted by Walls &lt;127167 Generic - 200mm&gt;\nDoors M_Single-Flush &lt;127331 0915 x 2134mm&gt; is hosted by Walls &lt;127167 Generic - 200mm&gt;\nWindows M_Fixed &lt;127356 0406 x 0610mm&gt; is hosted by Walls &lt;127240 Generic - 200mm&gt;\nWindows M_Fixed &lt;127411 0406 x 0610mm&gt; is hosted by Walls &lt;127240 Generic - 200mm&gt;\nWindows M_Fixed &lt;127436 0406 x 0610mm&gt; is hosted by Walls &lt;127240 Generic - 200mm&gt;\nWindows M_Fixed &lt;127462 0406 x 0610mm&gt; is hosted by Walls &lt;127215 Generic - 200mm&gt;\nWindows M_Fixed &lt;127484 0406 x 0610mm&gt; is hosted by Walls &lt;127215 Generic - 200mm&gt;\nWindows M_Fixed &lt;127502 0406 x 0610mm&gt; is hosted by Walls &lt;127215 Generic - 200mm&gt;\nWindows M_Fixed &lt;127526 0406 x 0610mm&gt; is hosted by Walls &lt;127215 Generic - 200mm&gt;\nWalls &lt;127248 Generic - 200mm&gt; hosts 3 openings: Doors M_Single-Flush &lt;127252 0915 x 2134mm&gt;, Windows M_Fixed &lt;127255 0406 x 0610mm&gt;, Windows M_Fixed &lt;127258 0406 x 0610mm&gt;\nWalls &lt;127167 Generic - 200mm&gt; hosts 2 openings: Doors M_Single-Flush &lt;127295 0915 x 2134mm&gt;, Doors M_Single-Flush &lt;127331 0915 x 2134mm&gt;\nWalls &lt;127240 Generic - 200mm&gt; hosts 3 openings: Windows M_Fixed &lt;127356 0406 x 0610mm&gt;, Windows M_Fixed &lt;127411 0406 x 0610mm&gt;, Windows M_Fixed &lt;127436 0406 x 0610mm&gt;\nWalls &lt;127215 Generic - 200mm&gt; hosts 4 openings: Windows M_Fixed &lt;127462 0406 x 0610mm&gt;, Windows M_Fixed &lt;127484 0406 x 0610mm&gt;, Windows M_Fixed &lt;127502 0406 x 0610mm&gt;, Windows M_Fixed &lt;127526 0406 x 0610mm&gt;\n</pre><p>For your convenience, I am adding the complete Visual Studio solution here. This version 1.0.0.3 includes the three commands we discussed so far: CmdListWalls, CmdRelationshipInverter and CmdWallDimensions.</p>"
  }
]