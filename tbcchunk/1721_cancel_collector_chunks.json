[
  {
    "original_filename": "1721_cancel_collector",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n<link rel=\"stylesheet\" type=\"text/css\" href=\"bc.css\">\n<script src=\"https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js\" type=\"text/javascript\"></script>\n</head>\n\n<!---\n\ntwitter:\n\nAborting filtered element collection in the #RevitAPI @AutodeskForge @AutodeskRevit #bim #DynamoBim #ForgeDevCon http://bit.ly/abortfilter\n\nI just discovered an interesting and not completely obvious aspect of using a filtered element collector in\nthe Revit API discussion forum thread on aborting a long running filtered element collector.\nQuestion: I have really large models where I use an <code>ElementIntersectsElementFilter</code> that can take a long time to process, and sometimes I want to abort it in a graceful way. Is this possible?\n\n&ndash; \n...\n\nlinkedin:\n\nof [The Building Coder samples](https://github.com/jeremytammik/the_building_coder_samples/releases/tag/2019.0.145.4).\n\n-->"
  },
  {
    "original_filename": "1721_cancel_collector",
    "header_text": "Aborting Filtered Element Collection",
    "local_header_href": "#aborting-filtered-element-collection",
    "chunk_text": "### Aborting Filtered Element Collection\n\nI just discovered an interesting and not completely obvious aspect of using a filtered element collector in\nthe [Revit API discussion forum](http://forums.autodesk.com/t5/revit-api-forum/bd-p/160) thread\non [aborting a long running `ElementIntersectsElementFilter`](https://forums.autodesk.com/t5/revit-api-forum/aborting-long-running-elementintersectselementfilter/m-p/8576368):\n\n**Question:** I have really large models where I use an `ElementIntersectsElementFilter` that can take a long time to process, and sometimes I want to abort it in a graceful way. Is this possible?\n\nI've read about task cancellation tokens, but all the examples I've seen using this approach have been loops where I can check if cancellation has been requested. But the ElementIntersectsElementFilter is out of my control and I can't really see how I can cancel it.\n\nI tried to implement the filter as efficiently as possible.\n\nI thought maybe a bounding box filter would make it quicker.\n\nHowever, after trying, the `ElementIntersectsElementFilter` seemed to be a bit faster than that.\n\nThis is how it currently looks.\nI have a loop that I can cancel via a cancellation token.\nBut I'm still interested in a more efficient filter if possible.\nDo you see anything obvious?\n\n<pre class=\"code\">\n&nbsp;&nbsp;<span style=\"color:#2b91af;\">List</span>&lt;<span style=\"color:#2b91af;\">Element</span>&gt;&nbsp;WallMepClashDetection(&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:#2b91af;\">Document</span>&nbsp;doc,&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:#2b91af;\">List</span>&lt;<span style=\"color:#2b91af;\">Element</span>&gt;&nbsp;walls&nbsp;)\n&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">var</span>&nbsp;filterCategories&nbsp;=&nbsp;<span style=\"color:blue;\">new</span>&nbsp;<span style=\"color:#2b91af;\">List</span>&lt;<span style=\"color:#2b91af;\">BuiltInCategory</span>&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:#2b91af;\">BuiltInCategory</span>.OST_DuctCurves,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:#2b91af;\">BuiltInCategory</span>.OST_PipeCurves\n&nbsp;&nbsp;&nbsp;&nbsp;};\n \n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">foreach</span>(&nbsp;<span style=\"color:blue;\">var</span>&nbsp;wall&nbsp;<span style=\"color:blue;\">in</span>&nbsp;walls&nbsp;)\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">var</span>&nbsp;clashingElements&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;<span style=\"color:blue;\">new</span>&nbsp;<span style=\"color:#2b91af;\">FilteredElementCollector</span>(&nbsp;doc&nbsp;)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.WhereElementIsNotElementType()\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.WherePasses(&nbsp;<span style=\"color:blue;\">new</span>&nbsp;<span style=\"color:#2b91af;\">ElementMulticategoryFilter</span>(&nbsp;filterCategories&nbsp;)&nbsp;)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.WherePasses(&nbsp;<span style=\"color:blue;\">new</span>&nbsp;<span style=\"color:#2b91af;\">ElementIntersectsElementFilter</span>(&nbsp;wall&nbsp;)&nbsp;);\n \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:green;\">//&nbsp;Do&nbsp;stuff...</span>\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;}\n</pre>\n\n**Answer:** I can hardly imagine that it remains slow if you optimise it as much as possible, however large the model is.\n\nThe bounding box filter is a quick filter, whereas the element intersection one is slow,\ncf., [quick, slow and LINQ element filtering](http://thebuildingcoder.typepad.com/blog/2015/12/quick-slow-and-linq-element-filtering.html)\n\nThis can make a huge difference, especially in large models.\n\nCan you try this for starters?\n\n<pre class=\"code\">\n&nbsp;&nbsp;<span style=\"color:blue;\">var</span>&nbsp;cats&nbsp;=&nbsp;<span style=\"color:blue;\">new</span>&nbsp;<span style=\"color:#2b91af;\">List</span>&lt;<span style=\"color:#2b91af;\">BuiltInCategory</span>&gt;\n&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:#2b91af;\">BuiltInCategory</span>.OST_DuctCurves,\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:#2b91af;\">BuiltInCategory</span>.OST_PipeCurves\n&nbsp;&nbsp;};\n \n&nbsp;&nbsp;<span style=\"color:blue;\">var</span>&nbsp;mepfilter&nbsp;=&nbsp;<span style=\"color:blue;\">new</span>&nbsp;<span style=\"color:#2b91af;\">ElementMulticategoryFilter</span>(&nbsp;cats&nbsp;);\n \n&nbsp;&nbsp;<span style=\"color:#2b91af;\">BoundingBoxXYZ</span>&nbsp;bb&nbsp;=&nbsp;wall.get_BoundingBox(&nbsp;<span style=\"color:blue;\">null</span>&nbsp;);\n&nbsp;&nbsp;<span style=\"color:#2b91af;\">Outline</span>&nbsp;o&nbsp;=&nbsp;<span style=\"color:blue;\">new</span>&nbsp;<span style=\"color:#2b91af;\">Outline</span>(&nbsp;bb.Min,&nbsp;bb.Max&nbsp;);\n \n&nbsp;&nbsp;<span style=\"color:blue;\">var</span>&nbsp;bbfilter&nbsp;=&nbsp;<span style=\"color:blue;\">new</span>&nbsp;<span style=\"color:#2b91af;\">BoundingBoxIntersectsFilter</span>(&nbsp;o&nbsp;);\n \n&nbsp;&nbsp;<span style=\"color:blue;\">var</span>&nbsp;clashingElements\n&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;<span style=\"color:blue;\">new</span>&nbsp;<span style=\"color:#2b91af;\">FilteredElementCollector</span>(&nbsp;doc&nbsp;)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.WhereElementIsNotElementType()\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.WherePasses(&nbsp;mepfilter&nbsp;)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.WherePasses(&nbsp;bbfilter&nbsp;);\n</pre>\n\nIf the element intersection filter is equally fast or faster, that means that all your elements have already been completely loaded when the collector is executed.\nI guess you have a lot of memory.\n\n**Response:** Should I use the `BoundingBoxIntersectsFilter` to lower the memory footprint?\n\n**Answer:** If your elements are not already all loaded in memory, the element intersection filter will force them to load.\nThe bounding box filter will not.\n\nAnother question: Do you want to cancel because you found what you were looking for, or because you reached some time limit?\n\nGenerally, the evaluation is on demand, using iterators, so as long as you don't try to convert the results to a collection, you can write the code to stop whenever you  want.\n\n**Response:** Oh, that's interesting. I will have to check memory usage when comparing the two cases, just out of curiosity.\n\nWhen I started out I didn't have any means of seeing progress when running heavy intersection filters. And my main motivation was to be able to cancel if the command felt unresponsive or hung. But I've since refactored to use the loop approach which makes it possible to do that and also show a progress bar. I think this applies to any long running command that is out of the control of the developer.\n\n**Answer:** Yes, please check memory usage.\n\nAlso understand the concept of iterators.\n\nYou can do the following:\n\n<pre class=\"code\">\n  filtered element collector X = ...\n  foreach element in X:\n    do something with element\n    break out of the loop if you wish at any time\n</pre>\n\nYou can interrupt your processing of the results returned by the collector at any time.\n\nYou should NOT convert the collector to a list or any other collection.\n\nThat would force it to return all the elements, which would cost time and memory, with a performance hit if there are many of them.\n\nIterating over them one by one does not, costs no time, and can be interrupted any time you like.\n\nYou loop over walls and call the same filter for each.\nSo, there's an opportunity to stop at each wall before calling it again.\nIn addition, even within the same iteration, you can break early, any time you like, e.g., if you reach some limit.\n\n**Response:** Thank you for the information.\n\nI use loops now so I will be able to cancel the command as suggested.\n\nThanks for taking the time to help, I've learned some things &nbsp; =)\n\n<center>\n<img src=\"img/file_is_processing.png\" alt=\"File is processing...\" width=\"117\">\n</center>"
  }
]