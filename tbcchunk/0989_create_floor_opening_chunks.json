[
  {
    "original_filename": "0989_create_floor_opening",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<head>\n<meta content=\"text/html; charset=utf-8\" http-equiv=\"Content-Type\"/>\n<link href=\"bc.css\" rel=\"stylesheet\" type=\"text/css\"/>\n</head>"
  },
  {
    "original_filename": "0989_create_floor_opening",
    "header_text": "Create a Floor with an Opening or Complex Boundary",
    "local_header_href": "#create-a-floor-with-an-opening-or-complex-boundary",
    "chunk_text": "<h3>Create a Floor with an Opening or Complex Boundary</h3><p>Here is another question raised and solved by Victor Chekalin, Виктор Чекалин:</p><p><strong>Question:</strong> I need to programmatically create a floor.\nThe problem is that the floor is complex with different boundary loops, like this:</p><center>\n<img alt=\"Complex floor boundaries\" src=\"img/vc_complex_floor_boundaries.png\" width=\"200\"/>\n</center><p>The API provides only one single method to create a new floor – Document.NewFloor.\nI have to pass a CurveArray to this method, and the floor will be created on these curves.</p><p>But using this method I cannot create a complex floor as shown, with openings.\nIf I create an array containing eight lines for the outer and inner boundary loops, it produces the following:</p><center>\n<img alt=\"Erroneous resulting floor\" src=\"img/vc_complex_floor_creating_result.png\" width=\"200\"/>\n</center><p>Actually, I also cannot find the way retrieve the existing floor boundaries.\nThe ones displayed above were obtained from the floor geometry solid, which does not produce exactly the same results as its boundary.</p><p>Is there way to create a floor programmatically with several boundary loops?</p><p><strong>Answer:</strong> Here are the examples of using the NewFloor method that I am aware of:\n\n<ul>\n<li>SDK samples: FoundationSlab, GenerateFloor\n<li>RevitLookup: Utils/Elements.cs and TestElements.cs\n<li>Blog posts:\n<ul>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2008/11/editing-a-floor-profile.html\">Editing a Floor Profile</a></li>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2009/02/boolean-operations-for-2d-polygons.html\">Boolean Operations for 2D Polygons</a></li>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2009/05/hole-in-a-floor.html\">Hole in a Floor</a></li>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2011/08/floor-creation.html\">Floor Creation</a></li>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2011/11/pick-corners-and-create-floor.html\">Pick Corners and Create Floor</a></li>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2012/08/validate-roof-type-and-view-obj-on-android.html\">Validate Roof Type and View OBJ on Android</a></li>\n</ul>\n</li></li></li></ul>\n<p>Have you looked at all of these?</p>\n<p>The blog post discussing a hole in a floor states that you have to use an opening to generate the hole.</p>\n<p>Is there any other way to create a floor with a hole manually, or does it also require a shaft or an opening of some kind?</p>\n<p>If that is the case, then the API will impose the same requirement.</p>\n<p>Mostly the API will not allow you to model things that you cannot also create manually.</p>\n<!-- <p>If you can assure me that the user interface enables direct creation of a floor with holes in it, i.e. by specifying multiple boundary loops defining the outer perimeter and the interior holes in one go, then I will happily ask the development team how to define the appropriate floor profile including multiple loops defining an outer boundary and inner holes using the CurveArray argument provided as input to the NewFloor method.</p> -->\n<p><strong>Response:</strong> In fact I already could copy floor without openings like in your sample to\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2008/11/editing-a-floor-profile.html\">\nedit a floor profile</a>.</p>\n<p>After reading the posts you listed, I created the function to copy existing floor with openings.\nI assumed that the first EdgeArray in the Face.EdgeLoops is the outer boundary of the floor and the following ones are opening boundaries.\nAs it turns out, this is not always the case.</p>\n<p>Here is the\n\n<a href=\"http://pastebin.com/sWXvLyKc\">\ncode implementing this</a>:</p>\n<pre class=\"code\">\n[<span class=\"teal\">Transaction</span>( <span class=\"teal\">TransactionMode</span>.Manual )]\n<span class=\"blue\">public</span> <span class=\"blue\">class</span> <span class=\"teal\">ElementRoomInfoCommand</span> : <span class=\"teal\">IExternalCommand</span>\n{\n  <span class=\"blue\">const</span> <span class=\"blue\">double</span> _eps = 1.0e-9;\n \n  <span class=\"blue\">public</span> <span class=\"teal\">Result</span> Execute(\n    <span class=\"teal\">ExternalCommandData</span> commandData,\n    <span class=\"blue\">ref</span> <span class=\"blue\">string</span> message,\n    <span class=\"teal\">ElementSet</span> elements )\n  {\n    <span class=\"teal\">UIApplication</span> uiapp = commandData.Application;\n    <span class=\"teal\">UIDocument</span> uidoc = uiapp.ActiveUIDocument;\n    <span class=\"teal\">Application</span> app = uiapp.Application;\n    <span class=\"teal\">Document</span> doc = uidoc.Document;\n \n    <span class=\"teal\">Reference</span> r;\n    <span class=\"blue\">try</span>\n    {\n      r = uidoc.Selection.PickObject( <span class=\"teal\">ObjectType</span>.Element,\n        <span class=\"blue\">new</span> <span class=\"teal\">FloorSelectionFilter</span>(), <span class=\"maroon\">\"Select a floor\"</span> );\n    }\n    <span class=\"blue\">catch</span>( <span class=\"teal\">Exception</span> )\n    {\n      <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Cancelled;\n    }\n \n    <span class=\"blue\">var</span> floor = doc.GetElement( r.ElementId ) <span class=\"blue\">as</span> <span class=\"teal\">Floor</span>;\n \n    <span class=\"blue\">using</span>( <span class=\"teal\">Transaction</span> t = <span class=\"blue\">new</span> <span class=\"teal\">Transaction</span>( doc ) )\n    {\n      t.Start( <span class=\"maroon\">\"Copy Floor\"</span> );\n \n      <span class=\"blue\">var</span> newFloor = CopyFloor( floor );\n \n      <span class=\"blue\">var</span> moveRes =\n        newFloor.Location.Move( <span class=\"blue\">new</span> <span class=\"teal\">XYZ</span>( 0, 0, 10 ) );\n \n      t.Commit();\n \n      t.Start( <span class=\"maroon\">\"Create new floor openings\"</span> );\n \n      CreateFloorOpenings( floor, newFloor );\n \n      <span class=\"blue\">var</span> res = t.Commit();\n    }\n    <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Succeeded;\n  }\n \n  <span class=\"blue\">private</span> <span class=\"blue\">void</span> CreateFloorOpenings(\n    <span class=\"teal\">Floor</span> sourceFloor,\n    <span class=\"teal\">Floor</span> destFloor )\n  {\n    <span class=\"green\">// Looking if source floor has openings</span>\n \n    <span class=\"blue\">var</span> floorGeometryElement =\n        sourceFloor.get_Geometry( <span class=\"blue\">new</span> <span class=\"teal\">Options</span>() );\n \n    <span class=\"blue\">foreach</span>( <span class=\"blue\">var</span> geometryObject <span class=\"blue\">in</span> floorGeometryElement )\n    {\n      <span class=\"blue\">var</span> floorSolid =\n        geometryObject <span class=\"blue\">as</span> <span class=\"teal\">Solid</span>;\n \n      <span class=\"blue\">if</span>( floorSolid == <span class=\"blue\">null</span> )\n        <span class=\"blue\">continue</span>;\n \n      <span class=\"blue\">var</span> topFace =\n        GetTopFace( floorSolid );\n \n      <span class=\"blue\">if</span>( topFace == <span class=\"blue\">null</span> )\n        <span class=\"blue\">throw</span> <span class=\"blue\">new</span> <span class=\"teal\">NotSupportedException</span>(\n          <span class=\"maroon\">\"Floor does not have top face\"</span> );\n \n      <span class=\"blue\">if</span>( topFace.EdgeLoops.IsEmpty )\n        <span class=\"blue\">throw</span> <span class=\"blue\">new</span> <span class=\"teal\">NotSupportedException</span>(\n          <span class=\"maroon\">\"Floor top face does not have edges\"</span> );\n \n      <span class=\"green\">// If source floor has openings</span>\n \n      <span class=\"blue\">if</span>( topFace.EdgeLoops.Size &gt; 1 )\n      {\n        <span class=\"blue\">for</span>( <span class=\"blue\">int</span> i = 1; i &lt; topFace.EdgeLoops.Size; i++ )\n        {\n          <span class=\"blue\">var</span> openingEdges =\n            topFace.EdgeLoops.get_Item( i );\n \n          <span class=\"blue\">var</span> openingCurveArray =\n            GetCurveArrayFromEdgeArary( openingEdges );\n \n          <span class=\"blue\">var</span> opening =\n            sourceFloor\n              .Document\n              .Create\n              .NewOpening( destFloor,\n                    openingCurveArray,\n                    <span class=\"blue\">true</span> );\n        }\n      }\n    }\n  }\n \n  <span class=\"blue\">private</span> <span class=\"teal\">Floor</span> CopyFloor( <span class=\"teal\">Floor</span> sourceFloor )\n  {\n    <span class=\"blue\">var</span> floorGeometryElement =\n      sourceFloor.get_Geometry( <span class=\"blue\">new</span> <span class=\"teal\">Options</span>() );\n \n    <span class=\"blue\">foreach</span>( <span class=\"blue\">var</span> geometryObject <span class=\"blue\">in</span> floorGeometryElement )\n    {\n      <span class=\"blue\">var</span> floorSolid =\n        geometryObject <span class=\"blue\">as</span> <span class=\"teal\">Solid</span>;\n \n      <span class=\"blue\">if</span>( floorSolid == <span class=\"blue\">null</span> )\n        <span class=\"blue\">continue</span>;\n \n      <span class=\"blue\">var</span> topFace =\n        GetTopFace( floorSolid );\n \n      <span class=\"blue\">if</span>( topFace == <span class=\"blue\">null</span> )\n        <span class=\"blue\">throw</span> <span class=\"blue\">new</span> <span class=\"teal\">NotSupportedException</span>(\n          <span class=\"maroon\">\"Floor does not have top face\"</span> );\n \n      <span class=\"blue\">if</span>( topFace.EdgeLoops.IsEmpty )\n        <span class=\"blue\">throw</span> <span class=\"blue\">new</span> <span class=\"teal\">NotSupportedException</span>(\n          <span class=\"maroon\">\"Floor top face does not have edges\"</span> );\n \n      <span class=\"blue\">var</span> outerBoundary =\n        topFace.EdgeLoops.get_Item( 0 );\n \n      <span class=\"green\">// Create new floor using source </span>\n      <span class=\"green\">// floor outer boundaries</span>\n \n      <span class=\"teal\">CurveArray</span> floorCurveArray =\n        GetCurveArrayFromEdgeArary( outerBoundary );\n \n      <span class=\"blue\">var</span> newFloor =\n        sourceFloor\n          .Document\n          .Create\n          .NewFloor( floorCurveArray, <span class=\"blue\">false</span> );\n \n      <span class=\"blue\">return</span> newFloor;\n    }\n    <span class=\"blue\">return</span> <span class=\"blue\">null</span>;\n  }\n \n  <span class=\"blue\">private</span> <span class=\"teal\">CurveArray</span> GetCurveArrayFromEdgeArary(\n    <span class=\"teal\">EdgeArray</span> edgeArray )\n  {\n    <span class=\"teal\">CurveArray</span> curveArray =\n      <span class=\"blue\">new</span> <span class=\"teal\">CurveArray</span>();\n \n    <span class=\"blue\">foreach</span>( <span class=\"teal\">Edge</span> edge <span class=\"blue\">in</span> edgeArray )\n    {\n      <span class=\"blue\">var</span> edgeCurve =\n          edge.AsCurve();\n \n      curveArray.Append( edgeCurve );\n    }\n    <span class=\"blue\">return</span> curveArray;\n  }\n \n  <span class=\"teal\">PlanarFace</span> GetTopFace( <span class=\"teal\">Solid</span> solid )\n  {\n    <span class=\"teal\">PlanarFace</span> topFace = <span class=\"blue\">null</span>;\n    <span class=\"teal\">FaceArray</span> faces = solid.Faces;\n    <span class=\"blue\">foreach</span>( <span class=\"teal\">Face</span> f <span class=\"blue\">in</span> faces )\n    {\n      <span class=\"teal\">PlanarFace</span> pf = f <span class=\"blue\">as</span> <span class=\"teal\">PlanarFace</span>;\n      <span class=\"blue\">if</span>( <span class=\"blue\">null</span> != pf\n        &amp;&amp; ( <span class=\"teal\">Math</span>.Abs( pf.Normal.X - 0 ) &lt; _eps\n        &amp;&amp; <span class=\"teal\">Math</span>.Abs( pf.Normal.Y - 0 ) &lt; _eps ) )\n      {\n        <span class=\"blue\">if</span>( ( <span class=\"blue\">null</span> == topFace )\n          || ( topFace.Origin.Z &lt; pf.Origin.Z ) )\n        {\n          topFace = pf;\n        }\n      }\n    }\n    <span class=\"blue\">return</span> topFace;\n  }\n}\n \n<span class=\"blue\">public</span> <span class=\"blue\">class</span> <span class=\"teal\">FloorSelectionFilter</span> : <span class=\"teal\">ISelectionFilter</span>\n{\n  <span class=\"blue\">public</span> <span class=\"blue\">bool</span> AllowElement( <span class=\"teal\">Element</span> elem )\n  {\n    <span class=\"blue\">return</span> elem <span class=\"blue\">is</span> <span class=\"teal\">Floor</span>;\n  }\n \n  <span class=\"blue\">public</span> <span class=\"blue\">bool</span> AllowReference( <span class=\"teal\">Reference</span> r, <span class=\"teal\">XYZ</span> p )\n  {\n    <span class=\"blue\">throw</span> <span class=\"blue\">new</span> <span class=\"teal\">NotImplementedException</span>();\n  }\n}\n</pre>\n<p>Unfortunately, this produces an error when I try to copy a floor with openings:</p>\n<center>\n<img alt=\"Error message\" src=\"img/vc_complex_floor1.png\" width=\"400\"/>\n</center>\n<p>The reason is that Revit cannot create an opening in the floor until after the floor creation transaction has been committed.\nThat means that you cannot copy a floor with openings in one single transaction.</p>\n<p>My next attempt consists in copying the floor without its openings, committing the transaction, and then creating the openings in a second step.</p>\n<p>This method works.\nHere is the main implementation source code:</p>\n<pre class=\"code\">\n  <span class=\"blue\">private</span> <span class=\"teal\">Floor</span> CopyFloor( <span class=\"teal\">Floor</span> sourceFloor )\n  {\n    <span class=\"blue\">var</span> floorGeometry =\n      sourceFloor.get_Geometry( <span class=\"blue\">new</span> <span class=\"teal\">Options</span>() );\n \n    <span class=\"blue\">foreach</span>( <span class=\"blue\">var</span> geometryObject <span class=\"blue\">in</span> floorGeometry )\n    {\n      <span class=\"blue\">var</span> floorSolid =\n        geometryObject <span class=\"blue\">as</span> <span class=\"teal\">Solid</span>;\n \n      <span class=\"blue\">if</span>( floorSolid == <span class=\"blue\">null</span> )\n        <span class=\"blue\">continue</span>;\n \n      <span class=\"blue\">var</span> topFace =\n        GetTopFace( floorSolid );\n \n      <span class=\"blue\">if</span>( topFace == <span class=\"blue\">null</span> )\n        <span class=\"blue\">throw</span> <span class=\"blue\">new</span> <span class=\"teal\">NotSupportedException</span>(\n          <span class=\"maroon\">\"Floor does not have top face\"</span> );\n \n      <span class=\"blue\">if</span>( topFace.EdgeLoops.IsEmpty )\n        <span class=\"blue\">throw</span> <span class=\"blue\">new</span> <span class=\"teal\">NotSupportedException</span>(\n          <span class=\"maroon\">\"Floor top face does not have edges\"</span> );\n \n      <span class=\"blue\">var</span> outerBoundary =\n        topFace.EdgeLoops.get_Item( 0 );\n \n      <span class=\"green\">// Create new floor using source </span>\n      <span class=\"green\">// floor outer boundaries</span>\n \n      <span class=\"teal\">CurveArray</span> floorCurveArray =\n        GetCurveArrayFromEdgeArary( outerBoundary );\n \n      <span class=\"blue\">var</span> newFloor =\n        sourceFloor\n          .Document\n          .Create\n          .NewFloor( floorCurveArray, <span class=\"blue\">false</span> );\n \n      <span class=\"green\">// If source floor has openings</span>\n \n      <span class=\"blue\">if</span>( topFace.EdgeLoops.Size &gt; 1 )\n      {\n        <span class=\"blue\">for</span>( <span class=\"blue\">int</span> i = 1; i &lt; topFace.EdgeLoops.Size; i++ )\n        {\n          <span class=\"blue\">var</span> openingEdges =\n            topFace.EdgeLoops.get_Item( i );\n \n          <span class=\"blue\">var</span> openingCurveArray =\n            GetCurveArrayFromEdgeArary( openingEdges );\n \n          <span class=\"blue\">var</span> opening =\n            sourceFloor\n              .Document\n              .Create\n              .NewOpening( newFloor,\n                openingCurveArray,\n                <span class=\"blue\">true</span> );\n        }\n      }\n      <span class=\"blue\">return</span> newFloor;\n    }\n    <span class=\"blue\">return</span> <span class=\"blue\">null</span>;\n  }\n \n  <span class=\"blue\">private</span> <span class=\"teal\">CurveArray</span> GetCurveArrayFromEdgeArary(\n    <span class=\"teal\">EdgeArray</span> edgeArray )\n  {\n    <span class=\"teal\">CurveArray</span> curveArray =\n      <span class=\"blue\">new</span> <span class=\"teal\">CurveArray</span>();\n \n    <span class=\"blue\">foreach</span>( <span class=\"teal\">Edge</span> edge <span class=\"blue\">in</span> edgeArray )\n    {\n      <span class=\"blue\">var</span> edgeCurve =\n          edge.AsCurve();\n \n      curveArray.Append( edgeCurve );\n    }\n    <span class=\"blue\">return</span> curveArray;\n  }\n \n  <span class=\"teal\">PlanarFace</span> GetTopFace( <span class=\"teal\">Solid</span> solid )\n  {\n    <span class=\"teal\">PlanarFace</span> topFace = <span class=\"blue\">null</span>;\n    <span class=\"teal\">FaceArray</span> faces = solid.Faces;\n    <span class=\"blue\">foreach</span>( <span class=\"teal\">Face</span> f <span class=\"blue\">in</span> faces )\n    {\n      <span class=\"teal\">PlanarFace</span> pf = f <span class=\"blue\">as</span> <span class=\"teal\">PlanarFace</span>;\n      <span class=\"blue\">if</span>( <span class=\"blue\">null</span> != pf\n        &amp;&amp; ( <span class=\"teal\">Math</span>.Abs( pf.Normal.X - 0 ) &lt; _eps\n        &amp;&amp; <span class=\"teal\">Math</span>.Abs( pf.Normal.Y - 0 ) &lt; _eps ) )\n      {\n        <span class=\"blue\">if</span>( ( <span class=\"blue\">null</span> == topFace )\n          || ( topFace.Origin.Z &lt; pf.Origin.Z ) )\n        {\n          topFace = pf;\n        }\n      }\n    }\n    <span class=\"blue\">return</span> topFace;\n  }\n</pre>\n<p>Here is the result, with the original floor at the bottom and the copy at the top:</p>\n<center>\n<img alt=\"Floor with openings\" src=\"img/vc_complex_floor2.png\" width=\"400\"/>\n</center>\n<p>But, as you pointed out, the copied floor is not an exact replica of the original floor:</p>\n<center>\n<img alt=\"Floor with openings\" src=\"img/vc_complex_floor3.png\" width=\"400\"/>\n</center>\n<p>They have only the same visualization:</p>\n<center>\n<img alt=\"Floor with openings\" src=\"img/vc_complex_floor4.png\" width=\"400\"/>\n</center>\n<p>The original floor does not have an opening. It has complex multiply boundaries.</p>\n<p>Also, the problem is that my approach is not right.\nThe first item in the Face.EdgeLoops is not always the outer boundary.\nA floor may contain several EdgeArrays without boundaries, for example like this single floor consisting of multiple disjoint pieces:</p>\n<center>\n<img alt=\"Floor with several pieces\" src=\"img/vc_complex_floor5.png\" width=\"400\"/>\n</center>\n<p>This is one single floor, whose geometry contains one single solid.\nThe top face of this solid has four separate EdgeArrays and the floor doesn't have any openings.\nSo, I have to implement a method to determine whether a given EdgeArray represents an opening or not.\nI think I can do it by just checking if each edge of the EdgeArray is inside any previous EdgeArray, which would mean that it represents an opening.</p>\n<p>The other problem: even if I determine all openings and create a 'copy' of the floor, I cannot create a copy of the copy using the same method.</p>\n<p>Conclusion:</p>\n<ul>\n<li>There is no way to create an exact copy of a floor with holes using API as in the UI.</li>\n<li>There is a workaround to create holes in the floor using openings instead.</li>\n</ul>\n<p>The entire source code and Visual Studio project implementing this command to copy a floor with openings is available from Victor's\n\n<a href=\"https://github.com/vchekalin/RevitFloorCopy\">\nRevitFloorCopy GitHub repository</a>,\n\nwhich also includes this direct link to the\n\n<a href=\"https://github.com/vchekalin/RevitFloorCopy/archive/master.zip\">\ncomplete zip archive</a>.</p>\n<p>Thank you very much, Victor, for your persistent and insightful research and sharing this valuable solution!</p>\n</p>"
  }
]