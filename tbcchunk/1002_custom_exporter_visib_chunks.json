[
  {
    "original_filename": "1002_custom_exporter_visib",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<head>\n<meta content=\"text/html; charset=utf-8\" http-equiv=\"Content-Type\"/>\n<link href=\"bc.css\" rel=\"stylesheet\" type=\"text/css\"/>\n</head>"
  },
  {
    "original_filename": "1002_custom_exporter_visib",
    "header_text": "Determining Absolutely All Visible Elements",
    "local_header_href": "#determining-absolutely-all-visible-elements",
    "chunk_text": "<h3>Determining Absolutely All Visible Elements</h3><p>Yesterday, I discussed the\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2013/08/view-filter-api.html\">\nview filter API</a>.</p><p>One issue mentioned that was not completely answered was the following:</p><p style=\"color: darkblue\"><strong>Question 3:</strong> I would like to export only visible objects.\nUsing the element IsHidden method reports whether it was hidden using the Hide in View &gt; Elements menu option, but ignores Hide in View filters, and so does the\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2009/11/visible-elements.html\">\nIsHiddenElementOrCategory</a> method.</p><p style=\"color: darkblue\">How can my application determine exactly what the user actually sees on the screen?\nOur customers obviously expect this functionality for the export.</p><p>The cavalry is coming to the rescue here in the shape of Scott Conover of the Revit development team and Joel Spahn, software developer for\n\n<a href=\"http://www.agi32.com\">Lighting Analysts, Inc.</a> and\n\n<a href=\"http://www.elumtools.com\">ElumTools</a>.</p><p>Scott and Joel explain how the new\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2013/07/graphics-pipeline-custom-exporter.html\">\ncustom exporter framework</a> can\n\nbe used to solve this completely, cleanly and efficiently.\n\n<p>I already showed how to make use of it to export to\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2013/07/graphics-pipeline-custom-exporter.html#4\">XML</a>,\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2013/07/graphics-pipeline-custom-exporter.html#5\">Collada</a> and the\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2013/07/adn-mesh-data-custom-exporter-to-json.html\">\nADN mesh data JSON</a> file formats.</p>\n<p>Scott and Joel point out that it can also be used in a more trivial fashion simply to determine the visibility of building elements, including all the different ways of controlling visibility, also covering elements in linked files.</p>\n<p>Here is the description and part of the evolution of this project:</p>\n<p><strong>Goal:</strong> I want to find out if an element is visible in a view taking into account:</p>\n<ul>\n<li>Everything</li>\n<ol type=\"a\">\n<li>Whether the element is 'hidden'.</li>\n<li>Whether the element category (or one of its parent categories) is not visible.</li>\n<li>Visibility filters, e.g. set in visibility graphics.</li>\n<li>Etc.</li>\n<ul>\n<li>Crop Regions</li>\n<li>View Range</li>\n<li>Scope Box</li>\n<li>Depth Clipping</li>\n<li>Differences between Floor &amp; Ceiling views</li>\n<li>Phases</li>\n<li>Design Options</li>\n<li>Etc.</li>\n</ul>\n</ol>\n</ul>\n<p>I have built methods to take into account whether the category is hidden.\nMust I now test all the filters and filter rules associated with the given view?\nOr is there a shortcut?</p>\n<p>A filtered element collector taking a view id argument would cover all of this, which would constitute a big time saver.</p>\n<p>That works great!</p>\n<p>Now for the inevitable 'however':</p>\n<p>Given an element from a linked document (found via a filtered element collector), how can I tell if the linked element is visible in a view that lives in the main document?</p>\n<p>The view settings don’t necessarily carry over from host to link, so using FilteredElementCollector in this way won’t work.</p>\n<p>It is not possible to create a filtered element collector where the document being filtered is a linked document, but the view being filtered is in the main document.</p>\n<p>It may be possible to use a tool that is seemingly not appropriate to the task: CustomExporter.</p>\n<p>This new capability processes a 3D view and has callbacks for when Links begin and end, and Elements begin and end.</p>\n<p>So it may be possible to build a tree of elements that are considered visible in this view by using this and always returning RenderNodeAction.Skip for elements so that the child nodes (faces, meshes) are not gathered and passed.</p>\n<p>I was able to get a CustomExporter up and running in minutes to produce a map of visible element ids that I store in a Dictionary mapping Document to HashSet of ElementId.</p>\n<p>With larger models I was experiencing an undesirable performance hit until I started returning RenderNodeAction.Skip from the OnElementBegin method.\nI can return that for all elements, since all I need is the element id in the first place.</p>\n<p>Returning Skip immediately is the right approach to avoid generation of data you don’t care about.</p>\n<p>There is also the small matter of keeping track which document each element belongs to. After exporting the desired views you can call the ElementVisible property to determine whether an element is visible in one of the exported views.</p>\n<p>One other point of note here is the choice between using the Document instance itself or the Doc.PathName as a dictionary key. I chose to use the document path as the key because I wanted to persist the data for a while, and wasn’t sure how long I could hold on to the Document object before it became invalid.  It would certainly be cleaner to use the Document object as the key.  Also I may at some point use a HashSet of Integer instead of ElementId if I need to persist the data.</p>\n<p>I think Document.PathName is better for a key as of now.\nThe Document class does override Equals and GetHashCode, but they do not seem to work correctly in all scenarios.</p>\n<p>All in all, this should provide a complete solution to the issue #3 listed above.</p>\n<p>It also shows the implementation of a custom export context in VB.NET.</p>\n<p>Here is the code implementing ElementsVisibleInViewExportContext and its ElementVisible property:</p>\n<pre class=\"code\">\n<span class=\"blue\">Public</span> <span class=\"blue\">Class</span> <span class=\"teal\">ElementsVisibleInViewExportContext</span>\n  <span class=\"blue\">Implements</span> <span class=\"teal\">IExportContext</span>\n \n  <span class=\"blue\">Private</span> Documents <span class=\"blue\">As</span> <span class=\"blue\">New</span> <span class=\"teal\">Stack</span>(<span class=\"blue\">Of</span> <span class=\"teal\">Document</span>)\n  <span class=\"blue\">Private</span> <span class=\"blue\">Property</span> Elements <span class=\"blue\">As</span> <span class=\"blue\">New</span> <span class=\"teal\">Dictionary</span>( _\n    <span class=\"blue\">Of</span> <span class=\"blue\">String</span>, <span class=\"teal\">HashSet</span>(<span class=\"blue\">Of</span> <span class=\"teal\">ElementId</span>))\n \n  <span class=\"blue\">Public</span> <span class=\"blue\">ReadOnly</span> <span class=\"blue\">Property</span> ElementVisible( _\n    <span class=\"blue\">ByVal</span> doc <span class=\"blue\">As</span> <span class=\"teal\">Document</span>, <span class=\"blue\">ByVal</span> id <span class=\"blue\">As</span> <span class=\"teal\">ElementId</span>) _\n    <span class=\"blue\">As</span> <span class=\"blue\">Boolean</span>\n \n    <span class=\"blue\">Get</span>\n      <span class=\"blue\">Dim</span> ids <span class=\"blue\">As</span> <span class=\"teal\">HashSet</span>(<span class=\"blue\">Of</span> <span class=\"teal\">ElementId</span>)\n \n      <span class=\"blue\">If</span> Elements.TryGetValue(doc.PathName, ids) <span class=\"blue\">Then</span>\n        <span class=\"blue\">If</span> ids.Contains(id) <span class=\"blue\">Then</span>\n \n          <span class=\"blue\">Return</span> <span class=\"blue\">True</span>\n \n        <span class=\"blue\">End</span> <span class=\"blue\">If</span>\n      <span class=\"blue\">End</span> <span class=\"blue\">If</span>\n \n      <span class=\"blue\">Return</span> <span class=\"blue\">False</span>\n    <span class=\"blue\">End</span> <span class=\"blue\">Get</span>\n \n  <span class=\"blue\">End</span> <span class=\"blue\">Property</span>\n \n  <span class=\"blue\">Public</span> <span class=\"blue\">Sub</span> <span class=\"blue\">New</span>(<span class=\"blue\">ByVal</span> mainDocument <span class=\"blue\">As</span> <span class=\"teal\">Document</span>)\n \n    Documents.Push(mainDocument)\n    Elements.Add(mainDocument.PathName,\n                 <span class=\"blue\">New</span> <span class=\"teal\">HashSet</span>(<span class=\"blue\">Of</span> <span class=\"teal\">ElementId</span>))\n \n  <span class=\"blue\">End</span> <span class=\"blue\">Sub</span>\n \n  <span class=\"blue\">Public</span> <span class=\"blue\">Function</span> Start() <span class=\"blue\">As</span> <span class=\"blue\">Boolean</span> _\n    <span class=\"blue\">Implements</span> <span class=\"teal\">IExportContext</span>.Start\n \n    <span class=\"blue\">Return</span> <span class=\"blue\">True</span>\n \n  <span class=\"blue\">End</span> <span class=\"blue\">Function</span>\n \n  <span class=\"blue\">Public</span> <span class=\"blue\">Sub</span> Finish() _\n    <span class=\"blue\">Implements</span> <span class=\"teal\">IExportContext</span>.Finish\n \n    <span class=\"green\">'Nothing.</span>\n \n  <span class=\"blue\">End</span> <span class=\"blue\">Sub</span>\n \n  <span class=\"blue\">Public</span> <span class=\"blue\">Function</span> OnViewBegin( _\n    <span class=\"blue\">ByVal</span> node <span class=\"blue\">As</span> <span class=\"teal\">ViewNode</span>) _\n    <span class=\"blue\">As</span> <span class=\"teal\">RenderNodeAction</span> _\n    <span class=\"blue\">Implements</span> <span class=\"teal\">IExportContext</span>.OnViewBegin\n \n    <span class=\"blue\">Return</span> <span class=\"teal\">RenderNodeAction</span>.Proceed\n \n  <span class=\"blue\">End</span> <span class=\"blue\">Function</span>\n \n  <span class=\"blue\">Public</span> <span class=\"blue\">Sub</span> OnViewEnd( _\n    <span class=\"blue\">ByVal</span> elementId <span class=\"blue\">As</span> <span class=\"teal\">ElementId</span>) _\n    <span class=\"blue\">Implements</span> <span class=\"teal\">IExportContext</span>.OnViewEnd\n \n    <span class=\"green\">'Nothing.</span>\n \n  <span class=\"blue\">End</span> <span class=\"blue\">Sub</span>\n \n  <span class=\"blue\">Public</span> <span class=\"blue\">Function</span> OnLinkBegin( _\n    <span class=\"blue\">ByVal</span> node <span class=\"blue\">As</span> <span class=\"teal\">LinkNode</span>) _\n    <span class=\"blue\">As</span> <span class=\"teal\">RenderNodeAction</span> _\n    <span class=\"blue\">Implements</span> <span class=\"teal\">IExportContext</span>.OnLinkBegin\n \n    <span class=\"blue\">Dim</span> doc = node.GetDocument\n \n    Documents.Push(doc)\n    <span class=\"blue\">If</span> <span class=\"blue\">Not</span> Elements.ContainsKey(doc.PathName) <span class=\"blue\">Then</span>\n      Elements.Add(doc.PathName, _\n                   <span class=\"blue\">New</span> <span class=\"teal\">HashSet</span>(<span class=\"blue\">Of</span> <span class=\"teal\">ElementId</span>))\n    <span class=\"blue\">End</span> <span class=\"blue\">If</span>\n \n    <span class=\"blue\">Return</span> <span class=\"teal\">RenderNodeAction</span>.Proceed\n \n  <span class=\"blue\">End</span> <span class=\"blue\">Function</span>\n \n  <span class=\"blue\">Public</span> <span class=\"blue\">Sub</span> OnLinkEnd(<span class=\"blue\">ByVal</span> node <span class=\"blue\">As</span> <span class=\"teal\">LinkNode</span>) _\n    <span class=\"blue\">Implements</span> <span class=\"teal\">IExportContext</span>.OnLinkEnd\n \n    <span class=\"blue\">Dim</span> doc = Documents.Pop()\n \n  <span class=\"blue\">End</span> <span class=\"blue\">Sub</span>\n \n  <span class=\"blue\">Public</span> <span class=\"blue\">Function</span> OnElementBegin( _\n    <span class=\"blue\">ByVal</span> elementId <span class=\"blue\">As</span> <span class=\"teal\">ElementId</span>) _\n    <span class=\"blue\">As</span> <span class=\"teal\">RenderNodeAction</span> _\n    <span class=\"blue\">Implements</span> <span class=\"teal\">IExportContext</span>.OnElementBegin\n \n    Elements(Documents.Peek.PathName).Add(elementId)\n \n    <span class=\"blue\">Return</span> <span class=\"teal\">RenderNodeAction</span>.Skip\n \n  <span class=\"blue\">End</span> <span class=\"blue\">Function</span>\n \n  <span class=\"blue\">Public</span> <span class=\"blue\">Sub</span> OnElementEnd(<span class=\"blue\">ByVal</span> elementId <span class=\"blue\">As</span> <span class=\"teal\">ElementId</span>) _\n    <span class=\"blue\">Implements</span> <span class=\"teal\">IExportContext</span>.OnElementEnd\n \n    <span class=\"green\">'Nothing.</span>\n \n  <span class=\"blue\">End</span> <span class=\"blue\">Sub</span>\n \n  <span class=\"blue\">Public</span> <span class=\"blue\">Function</span> OnInstanceBegin( _\n    <span class=\"blue\">ByVal</span> node <span class=\"blue\">As</span> <span class=\"teal\">InstanceNode</span>) <span class=\"blue\">As</span> <span class=\"teal\">RenderNodeAction</span> _\n  <span class=\"blue\">Implements</span> <span class=\"teal\">IExportContext</span>.OnInstanceBegin\n \n    <span class=\"blue\">Return</span> <span class=\"teal\">RenderNodeAction</span>.Skip\n \n  <span class=\"blue\">End</span> <span class=\"blue\">Function</span>\n \n  <span class=\"blue\">Public</span> <span class=\"blue\">Sub</span> OnInstanceEnd(<span class=\"blue\">ByVal</span> node <span class=\"blue\">As</span> <span class=\"teal\">InstanceNode</span>) _\n    <span class=\"blue\">Implements</span> <span class=\"teal\">IExportContext</span>.OnInstanceEnd\n \n    <span class=\"green\">'Nothing.</span>\n \n  <span class=\"blue\">End</span> <span class=\"blue\">Sub</span>\n \n  <span class=\"blue\">Public</span> <span class=\"blue\">Function</span> OnFaceBegin(<span class=\"blue\">ByVal</span> node <span class=\"blue\">As</span> <span class=\"teal\">FaceNode</span>) _\n    <span class=\"blue\">As</span> <span class=\"teal\">RenderNodeAction</span> _\n    <span class=\"blue\">Implements</span> <span class=\"teal\">IExportContext</span>.OnFaceBegin\n \n    <span class=\"blue\">Return</span> <span class=\"teal\">RenderNodeAction</span>.Skip\n \n  <span class=\"blue\">End</span> <span class=\"blue\">Function</span>\n \n  <span class=\"blue\">Public</span> <span class=\"blue\">Sub</span> OnFaceEnd(<span class=\"blue\">ByVal</span> node <span class=\"blue\">As</span> <span class=\"teal\">FaceNode</span>) _\n    <span class=\"blue\">Implements</span> <span class=\"teal\">IExportContext</span>.OnFaceEnd\n \n    <span class=\"green\">'Nothing.</span>\n \n  <span class=\"blue\">End</span> <span class=\"blue\">Sub</span>\n \n  <span class=\"blue\">Public</span> <span class=\"blue\">Sub</span> OnMaterial(<span class=\"blue\">ByVal</span> node <span class=\"blue\">As</span> <span class=\"teal\">MaterialNode</span>) _\n    <span class=\"blue\">Implements</span> <span class=\"teal\">IExportContext</span>.OnMaterial\n \n    <span class=\"green\">'Nothing.</span>\n \n  <span class=\"blue\">End</span> <span class=\"blue\">Sub</span>\n \n  <span class=\"blue\">Public</span> <span class=\"blue\">Sub</span> OnPolymesh(<span class=\"blue\">ByVal</span> node <span class=\"blue\">As</span> <span class=\"teal\">PolymeshTopology</span>) _\n    <span class=\"blue\">Implements</span> <span class=\"teal\">IExportContext</span>.OnPolymesh\n \n    <span class=\"green\">'Nothing.</span>\n \n  <span class=\"blue\">End</span> <span class=\"blue\">Sub</span>\n \n  <span class=\"blue\">Public</span> <span class=\"blue\">Sub</span> OnRPC(<span class=\"blue\">ByVal</span> node <span class=\"blue\">As</span> <span class=\"teal\">RPCNode</span>) _\n    <span class=\"blue\">Implements</span> <span class=\"teal\">IExportContext</span>.OnRPC\n \n    <span class=\"green\">'Nothing.</span>\n \n  <span class=\"blue\">End</span> <span class=\"blue\">Sub</span>\n \n  <span class=\"blue\">Public</span> <span class=\"blue\">Sub</span> OnDaylightPortal( _\n    <span class=\"blue\">ByVal</span> node <span class=\"blue\">As</span> <span class=\"teal\">DaylightPortalNode</span>) _\n    <span class=\"blue\">Implements</span> <span class=\"teal\">IExportContext</span>.OnDaylightPortal\n \n    <span class=\"green\">'Nothing.</span>\n \n  <span class=\"blue\">End</span> <span class=\"blue\">Sub</span>\n \n  <span class=\"blue\">Public</span> <span class=\"blue\">Sub</span> OnLight(<span class=\"blue\">ByVal</span> node <span class=\"blue\">As</span> <span class=\"teal\">LightNode</span>) _\n    <span class=\"blue\">Implements</span> <span class=\"teal\">IExportContext</span>.OnLight\n \n    <span class=\"green\">'Nothing.</span>\n \n  <span class=\"blue\">End</span> <span class=\"blue\">Sub</span>\n \n  <span class=\"blue\">Public</span> <span class=\"blue\">Function</span> IsCanceled() <span class=\"blue\">As</span> <span class=\"blue\">Boolean</span> _\n    <span class=\"blue\">Implements</span> <span class=\"teal\">IExportContext</span>.IsCanceled\n \n    <span class=\"blue\">Return</span> <span class=\"blue\">False</span>\n \n  <span class=\"blue\">End</span> <span class=\"blue\">Function</span>\n \n<span class=\"blue\">End</span> <span class=\"blue\">Class</span>\n</pre>\n<p>For the sake of completeness, here is\n\n<a href=\"zip/CustomExporterElementVisibleInView.zip\">CustomExporterElementVisibleInView.zip</a> providing\n\nthis code in pure VB as well.</p>\n<p>This works wonderfully and may be the only solution for determining the visibility of an element in a linked model due to the visibility settings in the host model.</p>\n<p>I hope you find this useful.</p>\n<p>Many thanks to Scott and Joel for their idea, development, testing and sharing!</p>\n<a name=\"2\"></a>\n<p><strong>Addendum</strong> by Arnošt Löbel: This information is very correct.\nUsing filters and visibility settings may give somehow adequate results, but widespread opinion in the Revit graphics team considers the only way of truly figuring out what is or is not visible in a view running it through an export context, e.g. via a Custom Exporter.</p>\n<p>However, you do need to keep in mind and note that the current Custom Exporter only processes (and sends to an export context) items that would be rendered, which may not include all objects that are actually visible in a 3D view.\nFor example, model lines are not processed, because they do not render.</p>\n<!-- In a future we may support more Contexts for other kind of exports/views, maybe even for exporting 2D views (eventually, one day :-) -->\n\nmein haus besichtigen\nueberlegen, ob es eventuell irgendwie in unser konzept und weitere ueberlegungen beruecksichtigt werden koennte und sollte  :-)\nsich weiter kennenlernen\nnett zusammen zu abend essen\n</p>"
  }
]