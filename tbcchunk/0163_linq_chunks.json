[
  {
    "original_filename": "0163_linq",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<style>\n.blue { color: blue; }\n.teal { color: teal; }\n.maroon { color: maroon; }\n.green { color: green; }\n.gray { color: gray; }\n</style>"
  },
  {
    "original_filename": "0163_linq",
    "header_text": "Language Integrated Query Linq",
    "local_header_href": "#language-integrated-query-linq",
    "chunk_text": "<h3>Language Integrated Query Linq</h3><p>The \n\n<a href=\"http://en.wikipedia.org/wiki/Language_Integrated_Query\">\nLanguage Integrated Query</a>\n\nor \n\n<a href=\"http://en.wikipedia.org/wiki/Language_Integrated_Query\">\nLinq</a>\n\nis a .NET Framework component that adds powerful native data querying capabilities to .NET languages.</p><p>Here is a contribution by Joel Karr of\n\n<a href=\"http://www.esdesign.com\">\nEnvironmental Systems Design, Inc</a>\n\non this exciting topic, demonstrating how it can be used to achieve huge performance improvements when analysing large Revit models.</p>"
  },
  {
    "original_filename": "0163_linq",
    "header_text": "Using LINQ to Query",
    "local_header_href": "#using-linq-to-query",
    "chunk_text": "<h3>Using LINQ to Query</h3><p>Here at Environmental Systems Design, www.esdesign.com, we have seen that a simple task in Revit, such as changing a single parameter of an object, can take an immense amount of time when multiplied over thousands of elements in a model.  \nThrough the use of LINQ, we have found that we have a wide range of powerful query tools that can help us avoid the costly time associated with constant calls to the Revit API.  \nWe can store the information we need once, and then efficiently query that data in a similar way to the familiar SQL database queries.</p><p>LINQ was introduced with the .NET Framework 3.5.\nThe main benefit is an advanced native data query capability.\nFor example, if we wanted to find all diffusers in a model that had a CFM of over 500, we could use a LINQ query to find them:</p><pre class=\"code\">\n  <span class=\"blue\">var</span> results \n    = <span class=\"blue\">from</span> d <span class=\"blue\">in</span> allDiffusers\n      <span class=\"blue\">let</span> x = 500\n      <span class=\"blue\">where</span> d.CFM &lt; x\n      <span class=\"blue\">select</span> d;\n</pre><p>Although LINQ takes a little more time to set up initially, repeated queries will perform much faster.  We had an instance where we wanted to place nearly 15,000 connectors in our model to correspond with an architectural model.</p><p>LINQ queries have a running time of O(n), but when used with Revit we find that we can greatly reduce our search time if we store information in an object that we will reuse.  Our initial method kept a list of elements and then checked each element.Location for a match.  This caused us to use the Revit API thousands of times unnecessarily.  By storing the location in an object and then using LINQ to find a match, our process time went from over 14 hours down to under 10 minutes.</p><p>We created an object that stored the information about each lighting fixture in the architect's model and also the information we needed about our connectors.  Through the use of a LINQ query, we were able to search to see if a connector existed at the same location as the architect's lighting fixture.</p><p>It became as simple as the following code to find out if a connector existed in the same location as the lighting fixture we were checking:</p><pre class=\"code\">\n  <span class=\"blue\">var</span> found \n    = <span class=\"blue\">from</span> con <span class=\"blue\">in</span> Connectors\n      <span class=\"blue\">where</span> con.ConLocation.Equals( location )\n      <span class=\"blue\">select</span> con;\n</pre><p>LINQ can work with a ton of different type of data sources.  Some of the most popular are SQL, XML, ADO.NET datasets, .NET objects and several other third party sources which even include an ongoing project for the creation of LINQ to Google.  In order to keep our code self contained and as simple as possible, we create a custom object to use with our LINQ queries.</p><p>To start with, we need to create a new class to store the information that we would like to query:</p><pre class=\"code\">\n<span class=\"blue\">class</span> <span class=\"teal\">InstanceData</span>\n{\n<span class=\"blue\">  #region</span> Field Data\n  <span class=\"blue\">private</span> <span class=\"teal\">Element</span> _instance;\n  <span class=\"blue\">private</span> <span class=\"teal\">String</span> _param1;\n  <span class=\"blue\">private</span> <span class=\"blue\">bool</span> _param2;\n  <span class=\"blue\">private</span> <span class=\"blue\">int</span> _param3;\n<span class=\"blue\">  #endregion</span>\n \n<span class=\"blue\">  #region</span> Properties\n  <span class=\"blue\">public</span> <span class=\"teal\">Element</span> Instance\n  {\n      <span class=\"blue\">get</span> { <span class=\"blue\">return</span> _instance; }\n      <span class=\"blue\">set</span> { _instance = <span class=\"blue\">value</span>; }\n  }\n  <span class=\"blue\">public</span> <span class=\"teal\">String</span> Param1\n  {\n      <span class=\"blue\">get</span> { <span class=\"blue\">return</span> _param1; }\n      <span class=\"blue\">set</span> { _param1 = <span class=\"blue\">value</span>; }\n  }\n  <span class=\"blue\">public</span> <span class=\"blue\">bool</span> Param2\n  {\n      <span class=\"blue\">get</span> { <span class=\"blue\">return</span> _param2; }\n      <span class=\"blue\">set</span> { _param2 = <span class=\"blue\">value</span>; }\n  }\n  <span class=\"blue\">public</span> <span class=\"blue\">int</span> Param3\n  {\n      <span class=\"blue\">get</span> { <span class=\"blue\">return</span> _param3; }\n      <span class=\"blue\">set</span> { _param3 = <span class=\"blue\">value</span>; }\n  }\n<span class=\"blue\">  #endregion</span>\n \n<span class=\"blue\">  #region</span> Constructors\n  <span class=\"blue\">public</span> InstanceData( <span class=\"teal\">Element</span> instance )\n  {\n    Instance = instance;\n \n    <span class=\"blue\">foreach</span>( <span class=\"teal\">Parameter</span> param <span class=\"blue\">in</span> Instance.Parameters )\n    {\n      <span class=\"green\">// Param1 returns string value</span>\n      <span class=\"blue\">if</span>( param.Definition.Name == <span class=\"maroon\">\"Param1\"</span> )\n      {\n        Param1 = param.AsString();\n      }\n \n      <span class=\"green\">// Param2 is a checkbox returning 0 or 1</span>\n      <span class=\"blue\">if</span>( param.Definition.Name == <span class=\"maroon\">\"Param2\"</span> )\n      {\n        Param2 = (0 != param.AsInteger());\n      }\n \n      <span class=\"green\">// Param3 returns an integer value</span>\n      <span class=\"blue\">if</span>( param.Definition.Name == <span class=\"maroon\">\"Param3\"</span> )\n      {\n        Param3 = param.AsInteger();\n      }\n    }\n  }\n<span class=\"blue\">  #endregion</span>\n}\n</pre><p>Now that we have our custom class created, we just need to populate it with the data we would like to query.  \nThis can be done many ways.\nFor this example we will simply retrieve all the family instances in the model:</p><pre class=\"code\">\n<span class=\"teal\">CreationFilter</span> cf = app.Create.Filter;\n<span class=\"teal\">Filter</span> f1 = cf.NewTypeFilter( <span class=\"blue\">typeof</span>( <span class=\"teal\">FamilyInstance</span> ) );\n \n<span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt; a = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt;();\ndoc.get_Elements( f1, a );\n \n<span class=\"teal\">List</span>&lt;<span class=\"teal\">InstanceData</span>&gt; instanceDataList \n  = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">InstanceData</span>&gt;();\n \n<span class=\"blue\">foreach</span>( <span class=\"teal\">Element</span> e <span class=\"blue\">in</span> a )\n{\n  instanceDataList.Add( \n    <span class=\"blue\">new</span> <span class=\"teal\">InstanceData</span>( e ) );\n}\n \n<span class=\"blue\">string</span> s = <span class=\"maroon\">\"value1\"</span>;\n<span class=\"blue\">bool</span> b = <span class=\"blue\">true</span>;\n<span class=\"blue\">int</span> i = 42;\n \n<span class=\"blue\">var</span> found = <span class=\"blue\">from</span> instance <span class=\"blue\">in</span> instanceDataList <span class=\"blue\">where</span> \n  (instance.Param1.Equals( s )\n  &amp;&amp; b == instance.Param2\n  &amp;&amp; i &lt; instance.Param3)\n<span class=\"blue\">select</span> instance;\n \n<span class=\"blue\">foreach</span>( <span class=\"teal\">InstanceData</span> instance <span class=\"blue\">in</span> found )\n{  \n  <span class=\"green\">// Do whatever you would like</span>\n}\n</pre><p>So that was it from Joel, and back to Jeremy again. \nThank you ever so much, Joel, for this fantastic introduction and example!</p><p>While preparing this article, I was a bit stumped to compile the sample code as part of The Building Coder samples until I noticed that I have to switch to the .NET Framework 3.5 before I can use Linq in C#. Watch out for this if you are trying to add Linq functionality to existing older projects.</p><p>Two things to note here, which make this information ever more globally usable:</p><ul>\n<li>This is a very powerful optimisation technology in any environment, whether inside of Revit or elsewhere.\n<li>Possibly the same kind of performance enhancement could be achieved by using some other caching mechanism independent of Linq. The main factor here is possibly the local storage of the data to be processed, avoiding repeated expensive calls to query it from Revit.\n</li></li></ul><p>One extremely powerful advantage of Linq is its extremely readable query syntax.</p>"
  }
]