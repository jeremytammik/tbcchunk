[
  {
    "original_filename": "0134_nested_instance_geo",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<style>\n.blue { color: blue; }\n.teal { color: teal; }\n.maroon { color: maroon; }\n.green { color: green; }\n</style>"
  },
  {
    "original_filename": "0134_nested_instance_geo",
    "header_text": "Nested Instance Geometry",
    "local_header_href": "#nested-instance-geometry",
    "chunk_text": "<h3>Nested Instance Geometry</h3><p>This is in response to a\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2008/09/geometry-viewer.html?cid=6a00e553e1689788330115705bbc01970b#comment-6a00e553e1689788330115705bbc01970b\">\nquery from Benson</a>\n\nabout the structure and geometry of nested family instances.\nIn the answer, we also present some useful comparison operators which enable us to use Revit XYZ points and vectors as keys in generic .NET dictionaries, and sort them lexicographically, as well as utility functions for extracting and listing all the vertices of a solid.\nHere is the original query, slightly rephrased:</p><p><strong>Question:</strong>\nI would like to obtain the internal hierarchy defined within a family instance, but its geometry only returns a flat list of solids.\n\n<p>For example: a top level family instance F includes one column C0, and two nested family instances F1 and F2.\nF1 includes two more columns C1 and C2, and F2 includes two further columns C3 and C4.\nThe result I am trying to achieve is the geometry with the associated hierarchy:</p>\n<pre>\n  F\n  }\n  +-- C0\n  }\n  +-- F1\n  }   }\n  }   +-- C1\n  }   }\n  }   +-- C2\n  }\n  +-- F2\n      }\n      +-- C3\n      }\n      +-- C4\n</pre>\n<p>Here are my steps to create the family instances in this structure:\n\n<ol>\n<li>Run Revit 2009.\n<li>Select File &gt; New &gt; Family and open a metric template such as Metric Funiture.rft.\n<li>Delete all objects in the new family project, switch to 3D view.\n<li>Select File &gt; Load from Library &gt; Load Family and select an RFA file, with a column in it.\n<li>Now, we can find the column in the project browser panel &gt; Families &gt; Columns.\n<li>Select this column, right click on it, and select \"Create Instance\".\nRepeat step 6, so we now have two columns in the family project.\n<li>Save the project as myFamily1.rfa, then click File &gt; Save As to save it again as myFamily2.rfa.\nNow, we have two family projects myFamily1.rfa and myFamily2.rfa.\n<li>Repeat steps 2, 3, and 4, this time selecting a column family, myFamily1, and myFamily2.\n<li>Create instances of the column, myFamily1, myFamily2 in the current family project like step 6.\n<li>Save the project as myFamily3.rfa.\n<li>Create a normal project, for instance named Project1.rvt, using File &gt; New &gt; Project.\n<li>Load myFamily3.rfa like step 4.\n<li>Add an instance of myFamily3 like step 6.\n</li></li></li></li></li></li></li></li></li></li></li></li></li></ol>\n<p>Now we have the structure shown above, with F represented by myFamily3, and F1 and F2 by myFamily1 and myFamily2 respectively.\n\n<p><strong>Answer:</strong>\nThe geometry of the top level family instance F does indeed just contain a flat list of solids.\nYou can obtain some information about the hierarchical structure of the nested family instances by recursively exploring the family instance symbol family components.\nFor a given family instance a, they are accessible through a.Symbol.Family.Components.\nThese components include information about their location within the containing family.\nUsing this information, you can build up the structure you seek.</p>\n<p>I created the project as you suggest and analysed the geometry and symbol family components of the\ntop level family instance F.\nI used a rectangular column, so each of the columns is a simple quadrilateral with six faces.</p>\n<p>In the geometry of the top level family instance F, I see one instance object.\nThe important properties of a geometry instance are its Symbol, SymbolGeometry, and Transform:</p>\n<ul>\n<li>Symbol, the symbol element that this object is referring to.\n<li>SymbolGeometry, the geometric representation of the symbol.\n<li>Transform, the affine transformation of the symbol into the instance coordinate space.\n</li></li></li></ul>\n<p>In my case, the symbol geometry contains six solids.\nOne of these is empty, i.e. has no edges or faces, so I simply ignore that one.\nThe remaining five represent the five different column instances visible in the project.\nThese five different instances can be differentiated by the different face vertex coordinates.</p>\n<p>To explore and compare complex geometry like that of a solid, it is important to have some powerful tools at your disposal to reduce the amount of detailed information you have to analyse and compare.\nIn this case, in order to display the solids in an easily read fashion, I implemented a helper method named GetVertices to extract the vertices of a solid and store them in a sorted list in a XYZArray.</p>\n<p>GetVertices iterates over all the faces of the given solid, triangulates each face, and iterates over the vertices of the resulting mesh.\nThese are added into a container, which is designed to ensure that every vertex occurs once only.\nI implement this container by using a generic dictionary class and attaching an equality comparison class which ensures that almost equal points are regarded as being exactly equal, allowing for some fuzziness due to numerical imprecision.\nHere is the definition of my XyzEqualityComparer class:</p>\n<pre class=\"code\">\n<span class=\"blue\">class</span> <span class=\"teal\">XyzEqualityComparer</span> : <span class=\"teal\">IEqualityComparer</span>&lt;<span class=\"teal\">XYZ</span>&gt;\n{\n  <span class=\"blue\">public</span> <span class=\"blue\">bool</span> Equals( <span class=\"teal\">XYZ</span> p, <span class=\"teal\">XYZ</span> q )\n  {\n    <span class=\"blue\">return</span> p.AlmostEqual( q );\n  }\n \n  <span class=\"blue\">public</span> <span class=\"blue\">int</span> GetHashCode( <span class=\"teal\">XYZ</span> p )\n  {\n    <span class=\"blue\">return</span> <span class=\"teal\">Util</span>.PointString( p ).GetHashCode();\n  }\n}\n</pre>\n<p>The hash code calculation could certainly be optimised by avoiding the detour through a string representation, but this is the quickest and easiest solution that came to mind. \nI am not sure that it will work reliably under all circumstances, though. \nIt is probably necessary to increase the precision in the string representation generated by PointString to match the precision used by the AlmostEqual method.</p>\n<p>With this equality comparer, we can employ the standard .NET generic dictionary class using Revit XYZ points and vectors as dictionary keys.</p>\n<p>In order to further facilitate the comparison of solids with each other, I sort their vertices before storing them into the array.\nThe sorting process requires another fuzzy comparison routine, a Compare function which determines whether a given point is larger than, equal to, or smaller than another one, and correspondingly returns 1, 0 or -1.\nWe define this comparison algorithm by comparing the X, Y and Z coordinates in the canonical order.\nIf all three are almost equal, the two points are considered equal.\nOtherwise, the first pair of coordinates to differ is used to determine whether the first point is considered to be greater or smaller than the second.\nHere is the implementation of this comparison method:</p>\n<pre class=\"code\">\n<span class=\"blue\">const</span> <span class=\"blue\">double</span> _eps = 1.0e-9;\n \n<span class=\"blue\">public</span> <span class=\"blue\">static</span> <span class=\"blue\">bool</span> IsZero( <span class=\"blue\">double</span> a )\n{\n  <span class=\"blue\">return</span> _eps &gt; <span class=\"teal\">Math</span>.Abs( a );\n}\n \n<span class=\"blue\">public</span> <span class=\"blue\">static</span> <span class=\"blue\">bool</span> IsEqual( <span class=\"blue\">double</span> a, <span class=\"blue\">double</span> b )\n{\n  <span class=\"blue\">return</span> IsZero( b - a );\n}\n \n<span class=\"blue\">public</span> <span class=\"blue\">static</span> <span class=\"blue\">int</span> Compare( <span class=\"blue\">double</span> a, <span class=\"blue\">double</span> b )\n{\n  <span class=\"blue\">return</span> IsEqual( a, b ) ? 0 : ( a &lt; b ? -1 : 1 );\n}\n \n<span class=\"blue\">public</span> <span class=\"blue\">static</span> <span class=\"blue\">int</span> Compare( <span class=\"teal\">XYZ</span> p, <span class=\"teal\">XYZ</span> q )\n{\n  <span class=\"blue\">int</span> diff = Compare( p.X, q.X );\n  <span class=\"blue\">if</span>( 0 == diff ) {\n    diff = Compare( p.Y, q.Y );\n    <span class=\"blue\">if</span>( 0 == diff ) {\n      diff = Compare( p.Z, q.Z );\n    }\n  }\n  <span class=\"blue\">return</span> diff;\n}\n</pre>\n<p>With these two comparison helpers in place, I can implement my GetVertices helper method to extract a sorted list of solid vertices and store them in a sorted manner in a XYZArray like this:</p>\n<pre class=\"code\">\n<span class=\"blue\">static</span> <span class=\"blue\">void</span> GetVertices( <span class=\"teal\">XYZArray</span> vertices, <span class=\"teal\">Solid</span> s )\n{\n  <span class=\"teal\">Debug</span>.Assert( 0 &lt; s.Edges.Size,\n    <span class=\"maroon\">\"expected a non-empty solid\"</span> );\n \n  <span class=\"teal\">Dictionary</span>&lt;<span class=\"teal\">XYZ</span>, <span class=\"blue\">int</span>&gt; a\n    = <span class=\"blue\">new</span> <span class=\"teal\">Dictionary</span>&lt;<span class=\"teal\">XYZ</span>, <span class=\"blue\">int</span>&gt;(\n      <span class=\"blue\">new</span> <span class=\"teal\">XyzEqualityComparer</span>() );\n \n  <span class=\"blue\">foreach</span>( <span class=\"teal\">Face</span> f <span class=\"blue\">in</span> s.Faces )\n  {\n    <span class=\"teal\">Mesh</span> m = f.Triangulate();\n    <span class=\"blue\">foreach</span>( <span class=\"teal\">XYZ</span> p <span class=\"blue\">in</span> m.Vertices )\n    {\n      <span class=\"blue\">if</span>( !a.ContainsKey( p ) )\n      {\n        a.Add( p, 1 );\n      }\n      <span class=\"blue\">else</span>\n      {\n        ±±a[p];\n      }\n    }\n  }\n  <span class=\"teal\">List</span>&lt;<span class=\"teal\">XYZ</span>&gt; keys = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">XYZ</span>&gt;( a.Keys );\n \n  <span class=\"teal\">Debug</span>.Assert( 8 == keys.Count,\n    <span class=\"maroon\">\"expected eight vertices for a rectangular column\"</span> );\n \n  keys.Sort( <span class=\"teal\">Util</span>.Compare );\n \n  <span class=\"blue\">foreach</span>( <span class=\"teal\">XYZ</span> p <span class=\"blue\">in</span> keys )\n  {\n    <span class=\"teal\">Debug</span>.Assert( 3 == a[p],\n      <span class=\"maroon\">\"expected every vertex of solid to appear in exactly three faces\"</span> );\n \n    vertices.Append( p );\n  }\n}\n</pre>\n<p>The two assertions checking the total number of vertices, 8, and the number of coincident vertices in each corner, 3, are only valid for this special case, where I am looking at quadrilateral columns.\nThey will be removed in a future version, if I make use of this method for more general cases.</p>\n<p>With this code in place, I can easily retrieve a sorted list of each of the solids' vertices for display and comparison purposes.</p>\n<p>I used the code you provided in your original comment as a basis for a new command\nnamed CmdNestedInstanceGeo, specifically tailored to explore this situation.\nIt first iterates over the solids contained in the top level family instance geometry and lists their vertices.\nIt then explores the family instance components and lists their names and location points.\nHere is the code for the Execute methods that implements this:</p>\n<pre class=\"code\">\n<span class=\"teal\">Application</span> app = commandData.Application;\n<span class=\"teal\">Document</span> doc = app.ActiveDocument;\n \n<span class=\"teal\">List</span>&lt;<span class=\"teal\">RvtElement</span>&gt; a = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">RvtElement</span>&gt;();\n \n<span class=\"blue\">if</span>( !<span class=\"teal\">Util</span>.GetSelectedElementsOrAll( a, doc,\n  <span class=\"blue\">typeof</span>( <span class=\"teal\">FamilyInstance</span> ) ) )\n{\n  <span class=\"teal\">Selection</span> sel = doc.Selection;\n  message = ( 0 &lt; sel.Elements.Size )\n    ? <span class=\"maroon\">\"Please select some family instances.\"</span>\n    : <span class=\"maroon\">\"No family instances found.\"</span>;\n  <span class=\"blue\">return</span> <span class=\"teal\">CmdResult</span>.Failed;\n}\n<span class=\"teal\">FamilyInstance</span> inst = a[0] <span class=\"blue\">as</span> <span class=\"teal\">FamilyInstance</span>;\n \n<span class=\"teal\">Options</span> opts = app.Create.NewGeometryOptions();\n<span class=\"teal\">GeoElement</span> geoElement = inst.get_Geometry( opts );\n \n<span class=\"teal\">GeometryObjectArray</span> a1 = geoElement.Objects;\n<span class=\"blue\">int</span> n = a1.Size;\n \n<span class=\"teal\">Debug</span>.Print(\n  <span class=\"maroon\">\"Family instance geometry has {0} geometry object{1}{2}\"</span>,\n  n, <span class=\"teal\">Util</span>.PluralSuffix( n ), <span class=\"teal\">Util</span>.DotOrColon( n ) );\n \n<span class=\"blue\">int</span> i = 0;\n<span class=\"blue\">foreach</span>( <span class=\"teal\">GeometryObject</span> o1 <span class=\"blue\">in</span> a1 )\n{\n  <span class=\"teal\">GeoInstance</span> geoInstance = o1 <span class=\"blue\">as</span> <span class=\"teal\">GeoInstance</span>;\n  <span class=\"blue\">if</span>( <span class=\"blue\">null</span> != geoInstance )\n  {\n    <span class=\"teal\">GeoElement</span> symbolGeo = geoInstance.SymbolGeometry;\n    <span class=\"teal\">GeometryObjectArray</span> a2 = symbolGeo.Objects;\n\n    <span class=\"blue\">foreach</span>( <span class=\"teal\">GeometryObject</span> o2 <span class=\"blue\">in</span> a2 )\n    {\n      <span class=\"teal\">Solid</span> s = o2 <span class=\"blue\">as</span> <span class=\"teal\">Solid</span>;\n      <span class=\"blue\">if</span>( <span class=\"blue\">null</span> != s &amp;&amp; 0 &lt; s.Edges.Size )\n      {\n        <span class=\"teal\">XYZArray</span> vertices = app.Create.NewXYZArray();\n        GetVertices( vertices, s );\n        n = vertices.Size;\n \n        <span class=\"teal\">Debug</span>.Print( <span class=\"maroon\">\"Solid {0} has {1} vertices{2} {3}\"</span>,\n          i++, n, <span class=\"teal\">Util</span>.DotOrColon( n ),\n          <span class=\"teal\">Util</span>.PointArrayString( vertices ) );\n      }\n    }\n  }\n}\n<span class=\"teal\">ElementSet</span> components = inst.Symbol.Family.Components;\nn = components.Size;\n \n<span class=\"teal\">Debug</span>.Print(\n  <span class=\"maroon\">\"Family instance symbol family has {0} component{1}{2}\"</span>,\n  n, <span class=\"teal\">Util</span>.PluralSuffix( n ), <span class=\"teal\">Util</span>.DotOrColon( n ) );\n \n<span class=\"blue\">foreach</span>( <span class=\"teal\">RvtElement</span> e <span class=\"blue\">in</span> components )\n{\n  <span class=\"teal\">LocationPoint</span> lp = e.Location <span class=\"blue\">as</span> <span class=\"teal\">LocationPoint</span>;\n  <span class=\"teal\">Debug</span>.Print( <span class=\"maroon\">\"{0} at {1}\"</span>,\n    <span class=\"teal\">Util</span>.ElementDescription( e ),\n    <span class=\"teal\">Util</span>.PointString( lp.Point ) );\n}\n<span class=\"blue\">return</span> <span class=\"teal\">CmdResult</span>.Failed;\n</pre>\n<p>It accesses the one and only family instance in the file and stores it in 'inst'.\nIt then iterates over its geometry, extracts the vertices from each solid, and lists them in the debug output window.\nHere is the result of that listing:</p>\n<pre>\nFamily instance geometry has 1 geometry object:\nSolid 0 has 8 vertices: (32.15,8.02,0), (32.15,8.02,13.12), (32.15,9.57,0), (32.15,9.57,13.12), (34.15,8.02,0), (34.15,8.02,13.12), (34.15,9.57,0), (34.15,9.57,13.12)\nSolid 1 has 8 vertices: (28.24,3.23,0), (28.24,3.23,13.12), (28.24,4.79,0), (28.24,4.79,13.12), (30.24,3.23,0), (30.24,3.23,13.12), (30.24,4.79,0), (30.24,4.79,13.12)\nSolid 2 has 8 vertices: (16,7.4,0), (16,7.4,13.12), (16,8.96,0), (16,8.96,13.12), (18,7.4,0), (18,7.4,13.12), (18,8.96,0), (18,8.96,13.12)\nSolid 3 has 8 vertices: (12.08,2.61,0), (12.08,2.61,13.12), (12.08,4.17,0), (12.08,4.17,13.12), (14.09,2.61,0), (14.09,2.61,13.12), (14.09,4.17,0), (14.09,4.17,13.12)\nSolid 4 has 8 vertices: (10.16,-4.19,0), (10.16,-4.19,13.12), (10.16,-2.19,0), (10.16,-2.19,13.12), (12.16,-4.19,0), (12.16,-4.19,13.12), (12.16,-2.19,0), (12.16,-2.19,13.12)\n</pre>\n<p>These lines are probably too long to be displayed in their entirety, but the main thing is to see that we have five identical solids which only differ from each other by a translation. You can see the full lines by copying and posting them into an editor.</p>\n<p>The command next iterates over the family instance symbol family components, just like you suggested, and lists each one of these together with its location point:</p>\n<pre>\nFamily instance symbol family has 3 components:\nColumns M_Rectangular Column &lt;2384 610 x 610mm&gt; at (11.16,-3.19,0)\nFurniture myFamily1 &lt;3525 myFamily1&gt; at (-2.48,2.65,0)\nFurniture myFamily2 &lt;4665 myFamily2&gt; at (13.68,3.26,0)\n</pre>\n<p>As you can see, the column instance C0 and the two furniture family instances myFamily1 and myFamily2 are listed.\nDiving into myFamily1 in the debugger and again traversing into its family instance components, I see the two nested columns C1 and C2, and so on.\nWe could enhance the code to traverse this structure recursively.</p>\n<p>If you look at the location points of these instances and compare them with the offsets between the five solids, you can determine the correspondence between the internal nested structure and the detailed geometrical representation.</p>\n<p>In this case, we defined our families extremely haphazardly, which makes it harder to understand the results. In a well designed family, I would expect both the structure and the locations of internal components to be less arbitrary.</p>\n<p>I hope that this exploration helps you understand the structure, and provides some useful tools to explore it further.</p>\n<p>Here is\n\n<a href=\"zip/bc10032.zip\">\nversion 1.0.0.32</a>\n\nof the complete Visual Studio solution with the new command.</p>\n</p></p></p>"
  }
]