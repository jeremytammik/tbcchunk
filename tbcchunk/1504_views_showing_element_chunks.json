[
  {
    "original_filename": "1504_views_showing_element",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n<link rel=\"stylesheet\" type=\"text/css\" href=\"bc.css\">\n<script src=\"run_prettify.js\" type=\"text/javascript\"></script>\n<!--\n<script src=\"https://google-code-prettify.googlecode.com/svn/loader/run_prettify.js\" type=\"text/javascript\"></script>\n-->\n</head>\n\n<!---\n\n- filtering for elements visible in views and quick filter performance\n  http://forums.autodesk.com/t5/revit-api/find-views-in-which-an-element-is-visible-by-geometry-or-actual/m-p/6522892\n\nDetermining Views Showing an Element #RevitAPI @AutodeskRevit #aec #bim #dynamobim @AutodeskForge\n\nThe topic of how to determine all views in which a given element is visible has been discussed several times on the past, and a couple of viable solutions have been suggested.\nHowever, for large projects, performance becomes an issue.\nThis question was raised again by Abba Lustgarten and Erik Eriksson in the Revit API discussion forum thread on finding views in which an element is visible (by geometry or actual visibility), with Erik sharing a <code>View</code> extension method <code>IntersectsBoundingBox</code> that helps alleviate the performance impact...\n\n-->"
  },
  {
    "original_filename": "1504_views_showing_element",
    "header_text": "Determining Views Showing an Element",
    "local_header_href": "#determining-views-showing-an-element",
    "chunk_text": "### Determining Views Showing an Element\n\nThe topic of how to determine all views in which a given element is visible has been discussed several times on the past, and a couple of viable solutions have been suggested.\n\nHowever, for large projects, performance becomes an issue.\n\nThis question was raised again by Abba Lustgarten\nof [Abba CAD Abba Inc.](http://www.abbaservicesinc.com) and\ndiscussed quite extensively with Erik Eriksson\nof [White](http://white.se) in\nthe [Revit API discussion forum](http://forums.autodesk.com/t5/revit-api/bd-p/160) thread\non [finding views in which an element is visible (by geometry or actual visibility)](http://forums.autodesk.com/t5/revit-api-forum/find-views-in-which-an-element-is-visible-by-geometry-or-actual/m-p/6522892),\nwith Erik sharing a `View` extension method `IntersectsBoundingBox` that helps alleviate the performance impact.\n\nBefore getting to that, here is a picture from the early morning stroll from the hotel to the Munich Forge accelerator:\n\n<center>\n<img src=\"img/2016-12-07_devday_munich_312_cropped.jpg\" alt=\"Early morning on the way to the Munich Forge accelerator\" width=\"500\"/>\n</center>\n\n\n####<a name=\"2\"></a>Question\n\nHere is what I would like to do:\n\n- Given any particular element (by extension, perhaps a set of elements):\n    - Find all views in the project in which the element is visible.\n\nFor example, if I select a specific door, then I want to find all the floor plan views that include the door, plus section views that show the door (cut or projection), any elevation views that show the door, etc.\n\nWithout having given this too much work yet, it would seem that there are two general issues here, and I am guessing that Revit might deal with them differently:\n\n- Given the geometric location of the element, does it occupy the space that is visible in any given view (considering clipping, etc.)\n- Given the visibility parameters, filters, etc. &ndash; is the element shown/hidden due to its category, parameters, etc.\n\nIn my situation, what I really would like to find at the moment is: If all visibility of all model elements is on, then what views would show the element.\n\n####<a name=\"3\"></a>Answer\n\nLucky you, asking the right question.\n\nThis one, we can answer, and already have, including a dedicated external command `CmdViewsShowingElements` to prove it to The Building Coder samples:\n\n- [Determine Views Displaying Given Element](http://thebuildingcoder.typepad.com/blog/2014/05/views-displaying-given-element-svg-and-nosql.html#6)\n- [Revision help: which views show this object?](http://forums.autodesk.com/t5/Revit-API/Revision-help-which-views-show-this-object/m-p/5029772)\n- [The Building Coder samples GitHub repository](https://github.com/jeremytammik/the_building_coder_samples)\n    - [`CmdViewsShowingElements`](https://github.com/jeremytammik/the_building_coder_samples/blob/master/BuildingCoder/BuildingCoder/CmdViewsShowingElements.cs)\n    \n\n####<a name=\"4\"></a>Response\n\nThanks for your reference to the sample code and the brief history of this.\n\nI am just going to give your `CmdViewsShowingElements` a try, and will let you know how it works for me.\n\nAs I do so, I just have this question:\n\nYou mentioned that your initial solution for this involved looping through views and using a filtered element collector (with a view_ID parameter) to check for object visibility.  Colin pointed out the potential slowness of this, and your note implied that he had come up with what you considered to be a 'better way'.\n\nFrom my first glance, it looks to me like this sample also loops through a series of views and uses a view-specific filtered element collector to check for element visibility in each view.  I don't see your original code to compare, but I am wondering if Colin's code does in fact overcome the efficiency problem that he pointed out, or if he just found a better way to implement the approach.\n\nI am only asking to make sure I am not missing something, and to make sure I don't go too far down the wrong path as I am bringing my Revit API skills up to speed.\n\n####<a name=\"5\"></a>Answer\n\nI think the blog post is pretty clear on that: \"Here is the `CmdViewsShowingElements` implementation including Colin's two extension methods...\"\n\nWhat more can I do to clarify?\n\nPlease note that the GitHub repo is maintained and contains the most up-to-date code.\n\n####<a name=\"5\"></a>Response\n\nWhat I wanted to clarify was this:\n\nIn the 'original' code, (which I haven't seen), Colin raised the concern\nthat when checking each view for element visibility, Revit would essentially\nhave to open the view and this could take a long time, especially if a lot\nof views are being checked.\n\nIn the posted code, do you think this problem is overcome? Or would the\nimplementation of the filtered element collector still be 'opening' the views,\nwith the potential time problem.\n\nIn my case, I am likely to be looking at hundreds of views, so this could be\nsignificant.\n\nPractically speaking, as you advise, I am working on the assumption that the\nGitHub posted sample is most recently 'recommended' approach. Thanks for\nputting it there and helping me find it.\n\n####<a name=\"6\"></a>Answer\n\nRevit will open all the views and it is going to take A LOT of time if you have a lot of views within a complex project.\n\nI've just run into that problem and ended up here.\n\nRevit caches the results for a while so if you ask for the same thing one more time it's going to go a lot faster, but if you change your input, you are going to have to wait again.\n\nI'm seeing times of 11 sec when I'm going through 560 views.\n\nI don't think the filtered element collector is designed with this in mind...\n\n####<a name=\"7\"></a>Response\n\nSo far, there isn't an alternative that I can see easily. It seems that the\nkey for me will probably be to 'pre-filter' the list of views that I want to\ncheck.\n\nFor example, by the name of the view, or by the type of view (only Floor\nPlans, or Section Views, etc.).\n\nI built an interface that does this and gives me a list of 'eligible' views\nand lets me select the ones I want to check for element visibility. This is\nmostly for testing the whole mechanism at the moment, since I don't totally\ntrust the filter mechanism yet.\n\nThis is all a bit preliminary. \nI found that if I select something like a Stair, or a wall, it seems to\nreliably find it in views. However, I tried selecting some other things,\nlike a mullion on a curtain wall, etc., and that doesn't seem to register as\nvisible to the filtered element collector, even though it seems to be\nvisible in the view. If and when I find a clearer pattern, I will post\nsomething about it, and if I don't, I will post something about it.\n\nAs for the performance, I also noticed that 'cache' effect, so that running\nthe filter repeatedly on the same view is much faster.\n\nI am actually seeing the Revit interface show me that it is regenerating the\nview (at the bottom of the screen) when it is big and takes a while.\n\nI have a question for you:\n\nYou mentioned 560 views taking 11 seconds. Did that mean 11 seconds to scan\nall of them, or 11 seconds per view?\n\nI.e., are you getting through 50 views per second?\n\nI am looking at quite a large model with some fairly big and complex views,\nbut it is averaging a few views per second on small ones and a few seconds\nper view on big ones.\n\nFor my purposes, 11 seconds for 560 views would be ok.\n\nAgain, thanks for your contributions. I would be eager to hear if you have\nsomething working well for you.\n\n####<a name=\"8\"></a>Answer\n\nOk, yes. Minimising the views is key, I also prefilter a lot.\n\nYes, the 11 sec are for all 560 views and that's the total time for prefiltering as well, so I might be getting little less than 10 secs for the views.\n\nHowever, I might have found another way that looks really promising.\n\nBy taking and comparing bounding boxes of views and the target elements (intersections), I was able to get results in under a second for all views.\nHowever, in contrast to the filtered element collector way, this requires some testing and setup to get accurate results.\nYou need to make sure that the view has cropping enabled, set the correct height of the view bounding box and some more.\nFurthermore, I noticed that section views need some special care.\n\nI haven't finished my tests, but like I said, it looks promising.\n\n####<a name=\"9\"></a>Response\n\nDoes sound promising. I was planning on using the bounding box idea, but I\nam somewhat new at the Revit API, and have not dealt with the bounding box\nof views yet. Somehow I suspect there is a level of complexity once you\nfactor in different coordinate systems (e.g. shared coordinates), view\nclipping, floor level heights, etc.\n\nIf you have encountered any of these pitfalls, I would love to hear about them.\n\n####<a name=\"10\"></a>Answer\n\nThank you for the valuable discussion, especially Erik with his in-depth real-world experience.\n\nThe note on the huge speed-up using bounding boxes is of fundamental importance.\n\nYou absolutely must be aware\nof [quick filters](http://thebuildingcoder.typepad.com/blog/2015/12/quick-slow-and-linq-element-filtering.html#6)\nversus [slow filters](http://thebuildingcoder.typepad.com/blog/2015/12/quick-slow-and-linq-element-filtering.html#7) and \nthe difference between them.\n\nQuick filters can be executed without regenerating the views and without fully loading the nitty-gritty detailed data of a huge model.\n\nThe bounding box check is a quick filter.\n\n####<a name=\"11\"></a>Answer\n\nActually, I'm not using the quick filter. I tried to, but the bounding boxes of the views need altering because the Z values are not correct (for plan views at least). I'm prefiltering a lot with quick filters, but when it comes to the actual bounding box comparison I've expanded the views into memory. You can see this in the code in the bottom.\n\nAnyway, I've perfected my bounding box filter into something that works for me. I tried to get it to work in section views, but that was just too big of an obstacle for me today, the client didn't need that in the end, so I just skipped that part. The problem was figuring out the bounding box since the coordinate system shifts in section views.\n\nI tried to look at the transform of the bounding box, and shift it accordingly, but it didn't work.\n\nMaybe you can shed some light on what is wrong or how to accomplish it, Jeremy?\n\nThe performance of the bounding box version is extreme in comparison, using a stopwatch I measured the following times:\n\n- ~22 secs for the traditional way\n- 125 ms using the bounding box way\n\nAnyway, here is the extension method I use right now:\n\n<pre class=\"code\">\n∫∫<span style=\"color:gray;\">///</span><span style=\"color:green;\">&nbsp;</span><span style=\"color:gray;\">&lt;</span><span style=\"color:gray;\">summary</span><span style=\"color:gray;\">&gt;</span>\n<span style=\"color:gray;\">///</span><span style=\"color:green;\">&nbsp;View&nbsp;extension&nbsp;predicate&nbsp;method:&nbsp;does&nbsp;</span>\n<span style=\"color:gray;\">///</span><span style=\"color:green;\">&nbsp;this&nbsp;view&nbsp;intersect&nbsp;the&nbsp;given&nbsp;bounding&nbsp;box?</span>\n<span style=\"color:gray;\">///</span><span style=\"color:green;\">&nbsp;</span><span style=\"color:gray;\">&lt;/</span><span style=\"color:gray;\">summary</span><span style=\"color:gray;\">&gt;</span>\n<span style=\"color:blue;\">public</span>&nbsp;<span style=\"color:blue;\">static</span>&nbsp;<span style=\"color:blue;\">bool</span>&nbsp;IntersectsBoundingBox(&nbsp;\n&nbsp;&nbsp;<span style=\"color:blue;\">this</span>&nbsp;<span style=\"color:#2b91af;\">View</span>&nbsp;view,&nbsp;\n&nbsp;&nbsp;<span style=\"color:#2b91af;\">BoundingBoxXYZ</span>&nbsp;targetBoundingBox&nbsp;)\n{\n&nbsp;&nbsp;<span style=\"color:#2b91af;\">Document</span>&nbsp;doc&nbsp;=&nbsp;view.Document;\n&nbsp;&nbsp;<span style=\"color:blue;\">var</span>&nbsp;viewBoundingBox&nbsp;=&nbsp;view.CropBox;\n \n&nbsp;&nbsp;<span style=\"color:blue;\">if</span>(&nbsp;!view.CropBoxActive&nbsp;)\n&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">using</span>(&nbsp;<span style=\"color:#2b91af;\">Transaction</span>&nbsp;tr&nbsp;=&nbsp;<span style=\"color:blue;\">new</span>&nbsp;<span style=\"color:#2b91af;\">Transaction</span>(&nbsp;doc&nbsp;)&nbsp;)\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:green;\">//If&nbsp;the&nbsp;cropbox&nbsp;is&nbsp;not&nbsp;active&nbsp;we&nbsp;can&#39;t&nbsp;</span>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:green;\">//extract&nbsp;the&nbsp;boundingbox&nbsp;(we&nbsp;rollback&nbsp;so&nbsp;we&nbsp;</span>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:green;\">//don&#39;t&nbsp;change&nbsp;anything&nbsp;and&nbsp;also&nbsp;increase&nbsp;</span>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:green;\">//performance)</span>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tr.Start(&nbsp;<span style=\"color:#a31515;\">&quot;Temp&quot;</span>&nbsp;);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;view.CropBoxActive&nbsp;=&nbsp;<span style=\"color:blue;\">true</span>;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;viewBoundingBox&nbsp;=&nbsp;view.CropBox;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tr.RollBack();\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;}\n \n&nbsp;&nbsp;<span style=\"color:#2b91af;\">Outline</span>&nbsp;viewOutline&nbsp;=&nbsp;<span style=\"color:blue;\">null</span>;\n \n&nbsp;&nbsp;<span style=\"color:blue;\">if</span>(&nbsp;view&nbsp;<span style=\"color:blue;\">is</span>&nbsp;<span style=\"color:#2b91af;\">ViewPlan</span>&nbsp;)\n&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">var</span>&nbsp;viewRange&nbsp;=&nbsp;(&nbsp;view&nbsp;<span style=\"color:blue;\">as</span>&nbsp;<span style=\"color:#2b91af;\">ViewPlan</span>&nbsp;).GetViewRange();\n \n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:green;\">//We&nbsp;need&nbsp;to&nbsp;change&nbsp;the&nbsp;boundingbox&nbsp;Z-values&nbsp;because&nbsp;</span>\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:green;\">//they&nbsp;are&nbsp;not&nbsp;correct&nbsp;(for&nbsp;some&nbsp;reason).</span>\n \n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">var</span>&nbsp;bottomXYZ&nbsp;=&nbsp;(&nbsp;doc.GetElement(&nbsp;viewRange\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.GetLevelId(&nbsp;<span style=\"color:#2b91af;\">PlanViewPlane</span>.BottomClipPlane&nbsp;)&nbsp;)&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">as</span>&nbsp;<span style=\"color:#2b91af;\">Level</span>&nbsp;).Elevation&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+&nbsp;viewRange.GetOffset(&nbsp;<span style=\"color:#2b91af;\">PlanViewPlane</span>.BottomClipPlane&nbsp;);\n \n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">var</span>&nbsp;topXYZ&nbsp;=&nbsp;(&nbsp;doc.GetElement(&nbsp;viewRange\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.GetLevelId(&nbsp;<span style=\"color:#2b91af;\">PlanViewPlane</span>.CutPlane&nbsp;)&nbsp;)&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">as</span>&nbsp;<span style=\"color:#2b91af;\">Level</span>&nbsp;).Elevation&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+&nbsp;viewRange.GetOffset(&nbsp;<span style=\"color:#2b91af;\">PlanViewPlane</span>.CutPlane&nbsp;);\n \n&nbsp;&nbsp;&nbsp;&nbsp;viewOutline&nbsp;=&nbsp;<span style=\"color:blue;\">new</span>&nbsp;<span style=\"color:#2b91af;\">Outline</span>(&nbsp;<span style=\"color:blue;\">new</span>&nbsp;<span style=\"color:#2b91af;\">XYZ</span>(&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;viewBoundingBox.Min.X,&nbsp;viewBoundingBox.Min.Y,&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bottomXYZ&nbsp;),&nbsp;<span style=\"color:blue;\">new</span>&nbsp;<span style=\"color:#2b91af;\">XYZ</span>(&nbsp;viewBoundingBox.Max.X,&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;viewBoundingBox.Max.Y,&nbsp;topXYZ&nbsp;)&nbsp;);\n&nbsp;&nbsp;}\n \n&nbsp;&nbsp;<span style=\"color:green;\">//this&nbsp;is&nbsp;where&nbsp;I&nbsp;try&nbsp;to&nbsp;handle&nbsp;section views.&nbsp;</span>\n&nbsp;&nbsp;<span style=\"color:green;\">//But&nbsp;I&nbsp;can&#39;t&nbsp;get&nbsp;it&nbsp;to&nbsp;work!!</span>\n \n&nbsp;&nbsp;<span style=\"color:blue;\">if</span>(&nbsp;!viewBoundingBox.Transform.BasisY.IsAlmostEqualTo(&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:#2b91af;\">XYZ</span>.BasisY&nbsp;)&nbsp;)&nbsp;\n&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;viewOutline&nbsp;=&nbsp;<span style=\"color:blue;\">new</span>&nbsp;<span style=\"color:#2b91af;\">Outline</span>(&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">new</span>&nbsp;<span style=\"color:#2b91af;\">XYZ</span>(&nbsp;viewBoundingBox.Min.X,&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;viewBoundingBox.Min.Z,&nbsp;viewBoundingBox.Min.Y&nbsp;),\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">new</span>&nbsp;<span style=\"color:#2b91af;\">XYZ</span>(&nbsp;viewBoundingBox.Max.X,&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;viewBoundingBox.Max.Z,&nbsp;viewBoundingBox.Max.Y&nbsp;)&nbsp;);\n&nbsp;&nbsp;}\n \n&nbsp;&nbsp;<span style=\"color:blue;\">using</span>(&nbsp;<span style=\"color:blue;\">var</span>&nbsp;boundingBoxAsOutline&nbsp;=&nbsp;<span style=\"color:blue;\">new</span>&nbsp;<span style=\"color:#2b91af;\">Outline</span>(&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;targetBoundingBox.Min,&nbsp;targetBoundingBox.Max&nbsp;)&nbsp;)\n&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">return</span>&nbsp;boundingBoxAsOutline.Intersects(&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;viewOutline,&nbsp;0&nbsp;);\n&nbsp;&nbsp;}\n}\n</pre>\n\nI hope someone finds it useful and good luck Abba!\n\n####<a name=\"12\"></a>Response\n\nThank you Erik. I will hopefully soon have a chance to dig into this in\nfull. Right away, I can see a few major tricks that I am sure would have\ntaken me quite a while to uncover.\n\nIn particular, needing to make the crop box active to get the bounding box,\nand thus using a transaction and rolling it back in order to do this.\nQuestion: if the cropping box is NOT active on a particular view, is the\nbounding box really what reflects the visibility of an object in it?\n\nMy gut told me that levels, transforms, etc. would be necessary to filter\nviews according to their geometrical extents. This seems to have been\nright, and I haven't gotten my hands very wet with those yet. Jeremy, can\nyou give a brief tutorial (or point to a sample or previous overview) on:\n\n- Bounding Boxes (views/elements)\n- Coordinate systems and their relationship to levels\n- Transformations of coordinates\n\nIt turns out that section views are probably the most important for me, so\nit would be great to have a 'universal' view extent calculator method.\n\nIt does make sense that filtering by the geometrical extents would be much\nfaster, even with slow filters, since we are considering the extents of only\na few objects (view, cropping box, element?), compared with many thousands\nof elements that must be processed in some way when a view is actually\nopened, as seems to happen when the filtered element collector goes at it.\nHowever, I think it will be critical to make it work reliably on all\nappropriate types of views.\n\nThanks especially for the snippet. If and when I get this working, I will\npost whatever extent-getter I come up with.\n\n####<a name=\"13\"></a>Answer\n\nI'm glad you found some useful bits.\n\nI don't think that Revit is using the bounding box to calculate of the element is visible in the view, it's far too slow for that (select element by id and press show, for instance...).\nIt's just another way of doing it, maybe they don't do it because they too know they can't rely on the bounding box extents and the fact that it must be turned on or maybe we'll see a much faster way of showing elements in the UI in the coming version of Revit =P\n\nI'm sure there is a way of using this method with section views and from what I've seen, Jeremy is a whole lot better at this type of math than I am =)\n\nBy looking at the bounding box of the section view, it's pretty clear that the Z values are messed up here to (or have some other meaning, that I can't comprehend).\n\nGod, while writing this I started investigating a little bit more.\n\nI wrote a Room drawing generator last year and that had some heavy lifting when it came section views and figuring out and changing their cropboxes.\n\nThis is a theory: but if you skip the original cropbox and use the new `GetCropRegionShape` using the `CropManager`. You get the crop in lines in project coordinates and then you can create a Solid by extrusion (using the far clip offset) using the GeometryCreationUtils and then use the SolidUtils and calculate solid intersections. That would probably be a lot faster.\n\nThis has an obvious problem and that is that there could still be elements hiding your elements in the views. That is a problem I have in my bounding box version too.\n\nThis is just me thinking out loud, there might be other problems with this workflow, what do you think, Jeremy?\n\n####<a name=\"14\"></a>Conclusion\n\nSorry that I never answered your questions, guys, and left some open ends dangling.\n\nI hope we can resolve them by and by.\n\nHere are some pretty old and rudimentary introductions to the topics that you asked for, Abba:\n\n- [Element Bounding Box](http://thebuildingcoder.typepad.com/blog/2008/10/element-bounding-box.html)\n- [Transform](http://thebuildingcoder.typepad.com/blog/2009/03/transform.html)\n- [Transform instance coordinates](http://thebuildingcoder.typepad.com/blog/2009/03/transform-instance-coordinates.html)\n\nI added Erik's `View` extension method `IntersectsBoundingBox` \nto [The Building Coder samples](https://github.com/jeremytammik/the_building_coder_samples)\n[release 2017.0.131.3](https://github.com/jeremytammik/the_building_coder_samples/releases/tag/2017.0.131.3) in the\nmodule [CmdViewsShowingElements.cs](https://github.com/jeremytammik/the_building_coder_samples/blob/master/BuildingCoder/BuildingCoder/CmdViewsShowingElements.cs),\nin case anyone else would like to play with it."
  }
]