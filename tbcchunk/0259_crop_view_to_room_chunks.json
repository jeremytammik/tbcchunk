[
  {
    "original_filename": "0259_crop_view_to_room",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<head>\n<link href=\"bc.css\" rel=\"stylesheet\" type=\"text/css\"/>\n</head>"
  },
  {
    "original_filename": "0259_crop_view_to_room",
    "header_text": "Crop 3D View to Room",
    "local_header_href": "#crop-3d-view-to-room",
    "chunk_text": "<h3>Crop 3D View to Room</h3><p>In case you have heard enough about both climbing and AU and AUv in the last few posts and would prefer to read about the Revit API and nothing but the Revit API, here is something for you.\nThis is based on a recent case handled by Joe Ye and deals with the 3D view crop box and the transformations required to set it up properly, an issue we have never previously looked at.\n\n<p><strong>Question:</strong> I would like to set the crop box of a 3D view to correspond to a single room.\n\n<p><strong>Answer:</strong> As the 3D view rotates the room, the original bounding box of the plan view will not be suitable to use for the 3D view crop box.\nHere is an idea to calculate the crop box.  \nRetrieve all the corner point vertex coordinates of the room, and project them onto the plane perpendicular to the 3D view's view direction. \nThis produces projected point coordinates.  \nFrom these result point coordinates, determine the maximum and minimum X and Y values.  \nFrom the max and min points, create the 3D view's crop box.\n\n<p>Here are the detailed steps to implement this idea:\n\n<ul>\n<li>Retrieve all vertex coordinates of the room.\n\n<li>Project these coordinates to the plane perpendicular to the 3D view's view direction.   \nTo do so, create a face perpendicular to the view direction. \nThe projected results can be obtained from the Face.Project method taking an XYZ point argument. \nFor more information, see the Revit API help file RevitAPI.chm for the usage and return value of this method.\n\n<li>Go through the resulting coordinates and determine the maximum and minimum X and Y coordinate values.\n\n<li>Use the four values to determine a bounding box:\n\n<pre>\nBoundingBoxXYZ bb = new BoundingBoxXYZ(); \nbb.Min = NewXYZ( xMin, yMin, 0 );\nbb.Max = NewXYZ( xMax, yMax, 0 );\n</pre>\n<li>Use the bounding box to set the 3D view crop box:\n\n<pre>\nView3d.CropBox = bb;\n</pre>\n</li></li></li></li></li></ul>\n<p>Actually, after some further investigation, I found a better way to determine the room extents. \nIt is hard to create a solid and make one face of it perpendicular to the view direction.\n\n<p>You can also use the Transform class to calculate the crop box of the 3D view instead.  \n\n<p>First, determine the transformation for translating coordinates in the 3D view to the world coordinate system WCS from the View3d.CropBox.Transform property. \n\nThen invert it to obtain the transformation to translate model WCS coordinates back to the 3D view coordinates. \n\n<p>Determine the room vertices from its ClosedShell property, and translate them to 3D view coordinates. \nFind the minimum and maximum X and Y coordinate values as described above and set the 3D view's crop box Max and Min properties using these.\n\n<p>You do need to activate and make the crop box visible to see the effect.\nYou can do so using the Crop View and Show Crop Region buttons in the user interface:</p>\n<center>\n<img alt=\"Activate 3D view crop box\" src=\"img/crop_settings.png\"/>\n</center>\n<p>This can also be achieved programmatically using:</p>\n<pre class=\"code\">\n  view3d.CropBoxActive = true;\n  view3d.CropBoxVisible = true;\n</pre>\n<p>So far for Joe's idea. Many thanks to Joe for all the research into this!\n\n<p>I implemented a new Building Coder sample command CmdCropToRoom to test and demonstrate this.\nIn order to show how the crop box can be set to various different regions in the model, it iterates over all the rooms in the model and sets the crop box of the current 3D view to the next room in the sequence on each call.\nWe retrieve a list of all rooms in the model using doc.get_Elements:\n\n<pre class=\"code\">\n<span class=\"teal\">List</span>&lt;<span class=\"teal\">RvtElement</span>&gt; rooms = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">RvtElement</span>&gt;();\n<span class=\"blue\">int</span> n = doc.get_Elements( <span class=\"blue\">typeof</span>( <span class=\"teal\">Room</span> ), rooms );\n</pre>\n<p>To loop through the rooms in the model and step to the next room in the list on each invocation of the command, we use their index in the list of elements returned by this call.\nThe last index used is stored in a static variable _i, and the method BumpRoomIndex is used to increment it by one on each call:\n\n<pre class=\"code\">\n<span class=\"blue\">static</span> <span class=\"blue\">int</span> _i = -1;\n\n<span class=\"blue\">static</span> <span class=\"blue\">int</span> BumpRoomIndex( <span class=\"blue\">int</span> room_count )\n{\n  ++_i;\n \n  <span class=\"blue\">if</span>( _i &gt;= room_count )\n  {\n    _i = 0;\n  }\n  <span class=\"blue\">return</span> _i;\n}\n</pre>\n<p>The next room to crop the view to is selected using \n\n<pre class=\"code\">\n<span class=\"teal\">Room</span> room = (0 &lt; n) \n  ? rooms[BumpRoomIndex( n )] <span class=\"blue\">as</span> <span class=\"teal\">Room</span> \n  : <span class=\"blue\">null</span>;\n</pre>\n<p>Here is the entire code of the CmdCropToRoom external command Execute method which crops the current 3D view to the next room extents:\n\n<pre class=\"code\">\n<span class=\"teal\">Application</span> app = commandData.Application;\n<span class=\"teal\">Document</span> doc = app.ActiveDocument;\n<span class=\"teal\">View3D</span> view3d = doc.ActiveView <span class=\"blue\">as</span> <span class=\"teal\">View3D</span>;\n \n<span class=\"blue\">if</span>( <span class=\"blue\">null</span> == view3d )\n{\n  message = <span class=\"maroon\">\"Please activate a 3D view\"</span>\n    + <span class=\"maroon\">\" before running this command.\"</span>;\n \n  <span class=\"blue\">return</span> <span class=\"teal\">CmdResult</span>.Failed;\n}\n \n<span class=\"green\">// get the 3d view crop box:</span>\n \n<span class=\"teal\">BoundingBoxXYZ</span> bb = view3d.CropBox;\n \n<span class=\"green\">// get the transform from the current view </span>\n<span class=\"green\">// to the 3D model:</span>\n \n<span class=\"teal\">Transform</span> transform = bb.Transform;\n \n<span class=\"green\">// get the transform from the 3D model </span>\n<span class=\"green\">// to the current view:</span>\n \n<span class=\"teal\">Transform</span> transformInverse = transform.Inverse;\n \n<span class=\"green\">// get all rooms in the model:</span>\n \n<span class=\"teal\">List</span>&lt;<span class=\"teal\">RvtElement</span>&gt; rooms = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">RvtElement</span>&gt;();\n<span class=\"blue\">int</span> n = doc.get_Elements( <span class=\"blue\">typeof</span>( <span class=\"teal\">Room</span> ), rooms );\n \n<span class=\"teal\">Room</span> room = (0 &lt; n) \n  ? rooms[BumpRoomIndex( n )] <span class=\"blue\">as</span> <span class=\"teal\">Room</span> \n  : <span class=\"blue\">null</span>;\n \n<span class=\"blue\">if</span>( <span class=\"blue\">null</span> == room )\n{\n  message = <span class=\"maroon\">\"No room element found in project.\"</span>;\n  <span class=\"blue\">return</span> <span class=\"teal\">CmdResult</span>.Failed;\n}\n \n<span class=\"green\">// collect all vertices of room closed shell </span>\n<span class=\"green\">// to determine its extents:</span>\n \n<span class=\"teal\">GeoElement</span> e = room.ClosedShell;\n<span class=\"teal\">XYZArray</span> vertices = app.Create.NewXYZArray();\n \n<span class=\"blue\">foreach</span>( <span class=\"teal\">GeometryObject</span> o <span class=\"blue\">in</span> e.Objects )\n{\n  <span class=\"blue\">if</span>( o <span class=\"blue\">is</span> <span class=\"teal\">Solid</span> )\n  {\n    <span class=\"green\">// iterate over all the edges of all solids:</span>\n \n    <span class=\"teal\">Solid</span> solid = o <span class=\"blue\">as</span> <span class=\"teal\">Solid</span>;\n \n    <span class=\"blue\">foreach</span>( <span class=\"teal\">Edge</span> edge <span class=\"blue\">in</span> solid.Edges )\n    {\n      <span class=\"blue\">foreach</span>( <span class=\"teal\">XYZ</span> p <span class=\"blue\">in</span> edge.Tessellate() )\n      {\n        <span class=\"green\">// collect all vertices, </span>\n        <span class=\"green\">// including duplicates:</span>\n \n        vertices.Append( p );\n      }\n    }\n  }\n}\n \n<span class=\"teal\">XYZArray</span> verticesIn3dView \n  = app.Create.NewXYZArray();\n \n<span class=\"blue\">foreach</span>( <span class=\"teal\">XYZ</span> p <span class=\"blue\">in</span> vertices )\n{\n  verticesIn3dView.Append( \n    transformInverse.OfPoint( p ) );\n}\n \n<span class=\"green\">// ignore the Z coorindates and find the </span>\n<span class=\"green\">// min and max X and Y in the 3d view:</span>\n \n<span class=\"blue\">double</span> xMin = 0, yMin = 0, xMax = 0, yMax = 0;\n \n<span class=\"blue\">bool</span> first = <span class=\"blue\">true</span>;\n<span class=\"blue\">foreach</span>( <span class=\"teal\">XYZ</span> p <span class=\"blue\">in</span> verticesIn3dView )\n{\n  <span class=\"blue\">if</span>( first )\n  {\n    xMin = p.X;\n    yMin = p.Y;\n    xMax = p.X;\n    yMax = p.Y;\n    first = <span class=\"blue\">false</span>;\n  }\n  <span class=\"blue\">else</span>\n  {\n    <span class=\"blue\">if</span>( xMin &gt; p.X )\n      xMin = p.X;\n    <span class=\"blue\">if</span>( yMin &gt; p.Y )\n      yMin = p.Y;\n    <span class=\"blue\">if</span>( xMax &lt; p.X )\n      xMax = p.X;\n    <span class=\"blue\">if</span>( yMax &lt; p.Y )\n      yMax = p.Y;\n  }\n}\n \n<span class=\"green\">// grow the crop box by one twentieth of its </span>\n<span class=\"green\">// size to include the walls of the room:</span>\n \n<span class=\"blue\">double</span> d = 0.05 * ( xMax - xMin );\nxMin = xMin - d;\nxMax = xMax + d;\n \nd = 0.05 * ( yMax - yMin );\nyMin = yMin - d;\nyMax = yMax + d;\n \nbb.Max = <span class=\"blue\">new</span> <span class=\"teal\">XYZ</span>( xMax, yMax, bb.Max.Z );\nbb.Min = <span class=\"blue\">new</span> <span class=\"teal\">XYZ</span>( xMin, yMin, bb.Min.Z );\n \nview3d.CropBox = bb;\n \n<span class=\"green\">// change the crop view setting manually or </span>\n<span class=\"green\">// programmatically to see the result:</span>\n \nview3d.CropBoxActive = <span class=\"blue\">true</span>;\nview3d.CropBoxVisible = <span class=\"blue\">true</span>;\n \n<span class=\"blue\">return</span> <span class=\"teal\">CmdResult</span>.Succeeded;\n</pre>\n<p>Here is a minimal model with two rooms to test this command:</p>\n<center>\n<img alt=\"Sample model with 3D view of two rooms\" src=\"img/crop_to_room_0.png\"/>\n</center>\n<p>Running the external command defined by CmdCropToRoom sets the 3D view crop box to the extents of the first room:</p>\n<center>\n<img alt=\"3D view crop box set to first room extents\" src=\"img/crop_to_room_1.png\"/>\n</center>\n<p>Running it another time increments the current room index and sets the 3D view crop box to its extents instead:</p>\n<center>\n<img alt=\"3D view crop box set to next room extents\" src=\"img/crop_to_room_2.png\"/>\n</center>\n<p>Here is\n\n<a href=\"zip/bc11056.zip\">\nversion 1.1.0.56</a>\n\nof the complete Building Coder sample source code and Visual Studio solution including the new command.</p>\n<p>There are a number of conceivable enhancements to this code.\nOne of the most obvious would be to eliminate duplicate vertices before applying the inverse transformations and searching for the minimum and maximum coordinate values.\nWe did implement some useful functionality for doing that with the XyzEqualityComparer class and GetVertices method in the \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2009/05/nested-instance-geometry.html\">\nnested instances geometry retrieval</a>.\n\nIt might also be possible to use generic collections such as List&lt;XYZ&gt; instead of XYZArray for the original and transformed vertices, and generic .NET functionality to apply the transformation and determine the max and min coordinate values.\nWe left out such enhancements in this case for the sake of clarity, but if you have any suggestions to make, please feel free to do so.\n</p></p></p></p></p></p></p></p></p></p></p></p></p></p>"
  }
]