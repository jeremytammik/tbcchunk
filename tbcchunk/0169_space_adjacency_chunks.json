[
  {
    "original_filename": "0169_space_adjacency",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<style>\n.blue { color: blue; }\n.teal { color: teal; }\n.maroon { color: maroon; }\n.green { color: green; }\n.gray { color: gray; }\n</style>"
  },
  {
    "original_filename": "0169_space_adjacency",
    "header_text": "Space Adjacency",
    "local_header_href": "#space-adjacency",
    "chunk_text": "<h3>Space Adjacency</h3><p>We looked at the topic of\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2009/01/room-and-wall-adjacency.html\">\nroom and wall adjacency</a>\n\na while back.\nMartin Schmid now implemented a nice little related utility to check adjacencies between spaces. \nIt demonstrates a beautiful use of the new Space.IsPointInSpace method.\nHere is an example of the kind of situation he is interested in:</p><img alt=\"Adjacent spaces\" src=\"img/adjacent_spaces.png\"/><p>The aim is to obtain a list of all adjacent spaces from this model.</p><p>Martin added a new external command CmdSpaceAdjacency to The Building Coder sample application to analyse and report the space adjacency relationships in such a model.\nHere are some more implementation notes on this from Martin:</p><span style=\"color: darkblue\">\n<p>Basically, this command starts by collecting all the segments from all spaces, tessellating any curved segments.  \nIt then iterates each space's segments over all the other spaces' segments to find the segment 'closest' to it.  \nThis is done by FindClosestSegments( segmentPairs, segments );</p>\n<p>However, just because a pair of segments from two different spaces are 'close' to one another, doesn't necessarily mean they are to be considered adjacent. \nThere could be an outlying 'space', e.g., a storage shed or garage, and one surface of the space would be considered 'closest' to the main building itself, but in terms of being 'adjacent' for analysis, there is actually a considerable 'air space' between them. \nTherefore, we need to limit how far apart spaces can be to be considered adjacent.</p>\n<p>To achieve this, DetermineAdjacencies( spaceAdjacencies, segmentPairs ) checks whether the midpoints between each pair are closer than a specified tolerance.\nIt also calculates a test point that should be within the adjacent space and uses the new Space.IsPointInSpace method to check whether this is true.</p>\n<p>This work s on the test models so far. \nI have not yet tested on a larger dataset.  \nThe implementation is probably not optimal, but is a start.</p>\n<p>After speaking with a customer about this, I learned that they needed to limit 'adjacency' to spaces that share a common door between them.  \nImplementing this was actually a little more straightforward:\neach door knows its 'to room' and 'from room', and this can be queried from the model by inspecting the 'linked' model data.\nEach space knows what room encloses it, and this info is available in the 'host' model.\nThus, I was able to establish a relationship between doors and Spaces to figure out the adjacencies.\nSo that is yet another different method for a different analysis scenario.</p>\n<p>It would be nice if there was actually a relationship in Revit between spaces and the walls that enclose it. \nAlso, this is all more cumbersome when working with linked files.  \nThere may be another route, for instance if the ray intersection algorithm could be used to intelligently to seek for room or space boundaries and wall surfaces only.\nHowever, I found that in linked models, it seems that there is no way to determine exactly what object is being hit by the ray. \nApparently, it only tells you that it hit a 'linked model', but not what particular object or type within that linked model.  \nThere are probably some API requirements to eke out of these example scenarios, but I'll leave that for later.<p>\n</p></p></span><p>So much for Martin's explanation of this algorithm and other related work of his.\nHere are some more comments of mine on this command implementation based on reverse engineering:</p><p>The CmdSpaceAdjacency command works with the following data items:</p><ul>\n<li>Segment: a helper class to manage a space boundary segment, managing start and end point and the associated space and including some methods to obtain and compare slope and distance to other segments.\n<li>List&lt;Segment&gt; segments: a list of all spaces' boundary segments.\n<li>Dictionary&lt;Segment, Segment&gt; segmentPairs: a dictionary mapping each segment to the closest other segment in the set.\n<li>Dictionary&lt;Space, List&lt;Space&gt;&gt; spaceAdjacencies: a dictionary mapping each space to a list of all other spaces directly adjacent to it.\n</li></li></li></li></ul><p>This data is generated and processed step by step by the following methods:</p><ul <li=\"\">GetBoundaries: determine all boundary segments for a given space. This method is applied in a loop to all selected spaces, or all spaces in the project if none were manually preselected.\n<li>FindClosestSegments: iterate over the list of segments and determine the closest other segment for each one. This is not fool-proof, since it simply calculates the distance between the midpoints of each segment.\n<li>DetermineAdjacencies: determine the space adjacencies from the pairs of closest boundary segments using the Space.IsPointInSpace method.\n<li>ReportAdjacencies: print the results to the Visual Studio debug output console.\n</li></li></li></ul><p>Here is the Segment class implementation:</p><pre class=\"code\">\n<span class=\"blue\">class</span> <span class=\"teal\">Segment</span>\n{\n  <span class=\"teal\">XYZ</span> _sp;\n  <span class=\"teal\">XYZ</span> _ep;\n  <span class=\"teal\">Space</span> _space;\n \n  <span class=\"blue\">public</span> <span class=\"teal\">XYZ</span> StartPoint\n  {\n    <span class=\"blue\">get</span> { <span class=\"blue\">return</span> _sp; }\n  }\n \n  <span class=\"blue\">public</span> <span class=\"teal\">XYZ</span> EndPoint\n  {\n    <span class=\"blue\">get</span> { <span class=\"blue\">return</span> _ep; }\n  }\n \n  <span class=\"blue\">public</span> <span class=\"teal\">Space</span> Space\n  {\n    <span class=\"blue\">get</span> { <span class=\"blue\">return</span> _space; }\n    <span class=\"blue\">set</span> { _space = <span class=\"blue\">value</span>; }\n  }\n \n  <span class=\"blue\">public</span> Segment( <span class=\"teal\">XYZ</span> sp, <span class=\"teal\">XYZ</span> ep, <span class=\"teal\">Space</span> space )\n  {\n    _sp = sp;\n    _ep = ep;\n    _space = space;\n  }\n \n  <span class=\"blue\">public</span> <span class=\"blue\">double</span> Slope\n  {\n    <span class=\"blue\">get</span>\n    {\n      <span class=\"blue\">double</span> deltaX = _sp.X - _ep.X;\n      <span class=\"blue\">double</span> deltaY = _sp.Y - _ep.Y;\n      <span class=\"blue\">if</span>( deltaX != 0 )\n      {\n        <span class=\"blue\">return</span> deltaY / deltaX;\n      }\n      <span class=\"blue\">return</span> 0;\n    }\n  }\n \n  <span class=\"blue\">public</span> <span class=\"blue\">bool</span> IsHorizontal\n  {\n    <span class=\"blue\">get</span>\n    {\n      <span class=\"blue\">return</span> _sp.Y == _ep.Y;\n    }\n  }\n \n  <span class=\"blue\">public</span> <span class=\"blue\">bool</span> IsVertical\n  {\n    <span class=\"blue\">get</span>\n    {\n      <span class=\"blue\">return</span> _sp.X == _ep.X;\n    }\n  }\n \n  <span class=\"blue\">public</span> <span class=\"blue\">new</span> <span class=\"blue\">string</span> ToString()\n  {\n    <span class=\"blue\">return</span> <span class=\"blue\">string</span>.Format( <span class=\"maroon\">\"{0} {1}\"</span>,\n      <span class=\"teal\">Util</span>.PointString( _sp ),\n      <span class=\"teal\">Util</span>.PointString( _ep ) );\n  }\n \n  <span class=\"blue\">public</span> <span class=\"teal\">XYZ</span> MidPoint\n  {\n    <span class=\"blue\">get</span>\n    {\n      <span class=\"blue\">return</span> _sp + 0.5 * ( _ep - _sp );\n    }\n  }\n \n  <span class=\"blue\">public</span> <span class=\"teal\">XYZ</span> DirectionTo( <span class=\"teal\">Segment</span> a )\n  {\n    <span class=\"teal\">XYZ</span> v = a.MidPoint - MidPoint;\n    <span class=\"blue\">return</span> v.IsZero ? v : v.Normalized;\n  }\n \n  <span class=\"blue\">public</span> <span class=\"blue\">double</span> Distance( <span class=\"teal\">Segment</span> a )\n  {\n    <span class=\"blue\">return</span> MidPoint.Distance( a.MidPoint );\n  }\n \n  <span class=\"blue\">public</span> <span class=\"blue\">bool</span> Parallel( <span class=\"teal\">Segment</span> a )\n  {\n    <span class=\"blue\">return</span> ( IsVertical &amp;&amp; a.IsVertical )\n      || ( IsHorizontal &amp;&amp; a.IsHorizontal )\n      || <span class=\"teal\">Util</span>.IsEqual( Slope, a.Slope );\n  }\n}\n</pre><p>GetBoundaries simply asks a space for its boundary curves, tessellates them, and generates Segment instances for the result:</p><pre class=\"code\">\n<span class=\"blue\">private</span> <span class=\"blue\">void</span> GetBoundaries(\n  <span class=\"teal\">List</span>&lt;<span class=\"teal\">Segment</span>&gt; segments,\n  <span class=\"teal\">Space</span> space )\n{\n  <span class=\"teal\">BoundarySegmentArrayArray</span> boundaries\n    = space.Boundary;\n \n  <span class=\"blue\">foreach</span>( <span class=\"teal\">BoundarySegmentArray</span> b <span class=\"blue\">in</span> boundaries )\n  {\n    <span class=\"blue\">foreach</span>( <span class=\"teal\">BoundarySegment</span> s <span class=\"blue\">in</span> b )\n    {\n      <span class=\"teal\">Curve</span> curve = s.Curve;\n      <span class=\"teal\">XYZArray</span> a = curve.Tessellate();\n      <span class=\"blue\">for</span>( <span class=\"blue\">int</span> i = 1; i &lt; a.Size; i++ )\n      {\n        <span class=\"teal\">Segment</span> segment = <span class=\"blue\">new</span> <span class=\"teal\">Segment</span>(\n          a.get_Item( i - 1 ),\n          a.get_Item( i ), space );\n \n        segments.Add( segment );\n      }\n    }\n  }\n}\n</pre><p>FindClosestSegments iterates over the list of segments and determines the closest other segment for each one by comparing the distance between their midpoints, returning The resulting closest pairs:</p><pre class=\"code\">\n<span class=\"blue\">private</span> <span class=\"blue\">void</span> FindClosestSegments(\n  <span class=\"teal\">Dictionary</span>&lt;<span class=\"teal\">Segment</span>, <span class=\"teal\">Segment</span>&gt; segmentPairs,\n  <span class=\"teal\">List</span>&lt;<span class=\"teal\">Segment</span>&gt; segments )\n{\n  <span class=\"blue\">foreach</span>( <span class=\"teal\">Segment</span> segOuter <span class=\"blue\">in</span> segments )\n  {\n    <span class=\"blue\">bool</span> first = <span class=\"blue\">true</span>;\n    <span class=\"blue\">double</span> dist = 0;\n    <span class=\"teal\">Segment</span> closest = <span class=\"blue\">null</span>;\n \n    <span class=\"blue\">foreach</span>( <span class=\"teal\">Segment</span> segInner <span class=\"blue\">in</span> segments )\n    {\n      <span class=\"blue\">if</span>( segOuter == segInner )\n        <span class=\"blue\">continue</span>;\n \n      <span class=\"blue\">if</span>( segInner.Space == segOuter.Space )\n        <span class=\"blue\">continue</span>;\n \n      <span class=\"blue\">double</span> d = segOuter.Distance(\n        segInner );\n \n      <span class=\"blue\">if</span>( first || d &lt; dist )\n      {\n        dist = d;\n        first = <span class=\"blue\">false</span>;\n        closest = segInner;\n      }\n    }\n \n    segmentPairs.Add( segOuter, closest );\n  }\n}\n</pre><p>DetermineAdjacencies determines the space adjacencies from the pairs of closest boundary segments using the Space.IsPointInSpace method.\nIt analyses the relationship between the two closest segments s and t. \nIf their distance exceeds the maximum wall thickness, the spaces are not considered adjacent.\nOtherwise, a test point two millimetres away from s in the direction of t is calculated and the Space.IsPointInSpace method applied to it to test whether it really lies within the candidate neighbouring space:</p><pre class=\"code\">\n<span class=\"blue\">private</span> <span class=\"blue\">void</span> DetermineAdjacencies(\n  <span class=\"teal\">Dictionary</span>&lt;<span class=\"teal\">Space</span>, <span class=\"teal\">List</span>&lt;<span class=\"teal\">Space</span>&gt;&gt; a,\n  <span class=\"teal\">Dictionary</span>&lt;<span class=\"teal\">Segment</span>, <span class=\"teal\">Segment</span>&gt; segmentPairs )\n{\n  <span class=\"blue\">foreach</span>( <span class=\"teal\">Segment</span> s <span class=\"blue\">in</span> segmentPairs.Keys )\n  {\n    <span class=\"teal\">Segment</span> t = segmentPairs[s];\n    <span class=\"blue\">double</span> d = s.Distance( t );\n    <span class=\"blue\">if</span>( d &lt; MaxWallThickness )\n    {\n      <span class=\"teal\">XYZ</span> direction = s.DirectionTo( t );\n      <span class=\"teal\">XYZ</span> startPt = t.MidPoint;\n      <span class=\"teal\">XYZ</span> testPoint = startPt + direction * D2mm;\n      <span class=\"blue\">if</span>( t.Space.IsPointInSpace( testPoint ) )\n      {\n        <span class=\"blue\">if</span>( !a.ContainsKey( s.Space ) )\n        {\n          a.Add( s.Space, <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">Space</span>&gt;() );\n        }\n        <span class=\"blue\">if</span>( !a[s.Space].Contains( t.Space ) )\n        {\n          a[s.Space].Add( t.Space );\n        }\n      }\n    }\n  }\n}\n</pre><p>Finally, ReportAdjacencies prints the results to the Visual Studio debug output console:</p><pre class=\"code\">\n<span class=\"blue\">private</span> <span class=\"blue\">void</span> PrintSpaceInfo(\n  <span class=\"blue\">string</span> indent,\n  <span class=\"teal\">Space</span> space )\n{\n  <span class=\"teal\">Debug</span>.Print( <span class=\"maroon\">\"{0}{1} {2}\"</span>, indent,\n    space.Name, space.Number );\n}\n \n<span class=\"blue\">private</span> <span class=\"blue\">void</span> ReportAdjacencies(\n  <span class=\"teal\">Dictionary</span>&lt;<span class=\"teal\">Space</span>, <span class=\"teal\">List</span>&lt;<span class=\"teal\">Space</span>&gt;&gt; spaceAdjacencies )\n{\n  <span class=\"teal\">Debug</span>.WriteLine( <span class=\"maroon\">\"\\nReport Space Adjacencies:\"</span> );\n  <span class=\"blue\">foreach</span>( <span class=\"teal\">Space</span> space <span class=\"blue\">in</span> spaceAdjacencies.Keys )\n  {\n    PrintSpaceInfo( <span class=\"maroon\">\"\"</span>, space );\n    <span class=\"blue\">foreach</span>( <span class=\"teal\">Space</span> adj <span class=\"blue\">in</span> spaceAdjacencies[space] )\n    {\n      PrintSpaceInfo( <span class=\"maroon\">\"  \"</span>, adj );\n    }\n  }\n}\n</pre><p>Here is the code of the Execute method which performs these steps in sequence:</p><pre class=\"code\">\n<span class=\"teal\">Application</span> app = commandData.Application;\n<span class=\"teal\">Document</span> doc = app.ActiveDocument;\n \n<span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt; spaces = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt;();\n<span class=\"blue\">if</span>( !<span class=\"teal\">Util</span>.GetSelectedElementsOrAll(\n  spaces, doc, <span class=\"blue\">typeof</span>( <span class=\"teal\">Space</span> ) ) )\n{\n  <span class=\"teal\">Selection</span> sel = doc.Selection;\n  message = (0 &lt; sel.Elements.Size)\n    ? <span class=\"maroon\">\"Please select some space elements.\"</span>\n    : <span class=\"maroon\">\"No space elements found.\"</span>;\n  <span class=\"blue\">return</span> <span class=\"teal\">CmdResult</span>.Failed;\n}\n \n<span class=\"teal\">List</span>&lt;<span class=\"teal\">Segment</span>&gt; segments = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">Segment</span>&gt;();\n \n<span class=\"blue\">foreach</span>( <span class=\"teal\">Space</span> space <span class=\"blue\">in</span> spaces )\n{\n  GetBoundaries( segments, space );\n}\n \n<span class=\"teal\">Dictionary</span>&lt;<span class=\"teal\">Segment</span>, <span class=\"teal\">Segment</span>&gt; segmentPairs\n  = <span class=\"blue\">new</span> <span class=\"teal\">Dictionary</span>&lt;<span class=\"teal\">Segment</span>, <span class=\"teal\">Segment</span>&gt;();\n \nFindClosestSegments( segmentPairs, segments );\n \n<span class=\"teal\">Dictionary</span>&lt;<span class=\"teal\">Space</span>, <span class=\"teal\">List</span>&lt;<span class=\"teal\">Space</span>&gt;&gt; spaceAdjacencies\n  = <span class=\"blue\">new</span> <span class=\"teal\">Dictionary</span>&lt;<span class=\"teal\">Space</span>, <span class=\"teal\">List</span>&lt;<span class=\"teal\">Space</span>&gt;&gt;();\n \nDetermineAdjacencies(\n  spaceAdjacencies, segmentPairs );\n \nReportAdjacencies( spaceAdjacencies );\n \n<span class=\"blue\">return</span> <span class=\"teal\">CmdResult</span>.Failed;\n</pre><p>Here is the result of running the new command CmdSpaceAdjacency on the sample shown above:</p><pre>\nReport Space Adjacencies:\n\nSpace 1 1\n  Space 2 2\nSpace 2 2\n  Space 4 4\n  Space 3 3\n  Space 1 1\nSpace 3 3\n  Space 2 2\n  Space 4 4\nSpace 4 4\n  Space 2 2\n  Space 5 5\n  Space 3 3\nSpace 5 5\n  Space 4 4\n</pre><p>Here is\n\n<a href=\"zip/bc11038.zip\">\nversion 1.1.0.38</a>\n\nof the complete Visual Studio solution with the new command.</p><p>As Martin pointed out above, this sample provides a solution for one specific case.\nIt may not be totally reliable under all circumstances, and as Martin already discovered, many other approaches and different requirements for space adjacency analysis may occur.\nIt does however provide a wonderful example of what can be achieved with relatively little effort.\nAnd as said, it also shows a really nice use of the new Space.IsPointInSpace method.</p><p>Very many thanks to Martin for providing this interesting sample!</p>"
  }
]