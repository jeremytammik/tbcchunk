[
  {
    "original_filename": "0816_view_section_to_scope",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<head>\n<link href=\"bc.css\" rel=\"stylesheet\" type=\"text/css\"/>\n</head>"
  },
  {
    "original_filename": "0816_view_section_to_scope",
    "header_text": "Set View Section Box to Match Scope Box",
    "local_header_href": "#set-view-section-box-to-match-scope-box",
    "chunk_text": "<h3>Set View Section Box to Match Scope Box</h3><p>Here is a case that I really like, demonstrating two interesting aspects:\n\n<ul>\n<li>How to retrieve the exact geometric location, size and orientation of the scope box.\n<li>How to set the exact geometric location, size and orientation of the 3D view section box.\n</li></li></ul>\n<p>In fact, we show how to use the manually adjusted scope box to define the view section box, i.e. specifying exactly how the model is cut in the current 3D view.\n\n<p>I actually already showed how to set up a view section box discussing how to\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2012/06/create-section-view-parallel-to-wall.html\">\ncreate a section view parallel to a wall</a>.\n\n<p>The key is setting up the view SectionBox property properly.\nIt takes a BoundingBoxXYZ input, i.e. a transform plus minimum and maximum values describing the location, orientation and size of the box.\nIn that post, it is fed into the CreateSection method.\n\n<p>To manipulate an existing view instead of creating a new one, you simply set up the bounding box in the same way and assign it to the view SectionBox property as shown below.\n\n<p>Here is the discussion that led up to this solution:\n\n<p><strong>Question:</strong> Here is a model in 3D view containing a scope box represented by the dotted lines.\nThe 3D view SectionBox property is checked, so the view SectionBox is also shown, using solid lines.\nBoth are selected, and thus highlighted in blue:</p>\n<center>\n<img alt=\"Source scope box and target view section box\" src=\"img/view_section_to_scope_1.png\" width=\"400\"/>\n</center>\n<p>Our goal is to programmatically relocate and rotate the section box so it is at the same location and angle as the scope box, and also make the size of the section box the same as the scope box.\n\n<p>How can this be achieved, please?\n\n\n<p><strong>Answer:</strong> You need to implement the following workflow, or rather data flow:\n\n<ol>\n<li>Extract the required data from the scope box.\n<li>Set up the required view SectionBox bounding box data, i.e. transform, min and max points.\n<li>Apply the SectionBox data to the view.\n</li></li></li></ol>\n<p>The last step 3. is trivial: you simply say view.SectionBox = newSectionBox as shown below.\n\n<p>Step 2 is demonstrated by the discussion on how to\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2012/06/create-section-view-parallel-to-wall.html\">\ncreate a section view parallel to a wall</a>.\n\n<p>Step 1 requires reading and interpreting the scope box data.\nThe scope box Location property data is not accessible, so you can't use that.\nAs far as I can tell, the only thing you have to go by is its geometry definition.\n\n<p>Exploring the scope box geometry in RevitLookup, you can see that it consists of exactly twelve lines, the edges of the scope box\n\n<a href=\"http://en.wikipedia.org/wiki/Parallelepiped\">\nparallelepiped</a> itself.\n\n<p>You need to figure out the exact size and orientation from those twelve lines, and then decide how they should determine the view section box.\n\n<p>I implemented a sample command SetSectionBox to test the concept, and a method GetScopeBoxBoundingBox to extract the scope box line geometry data, create a bounding box from that, and assign it to the view section box.\n\n<p>It returns the minimal aligned bounding box for a Revit scope box element.\nThe only information we can obtain from the scope box are its 12 boundary lines.\nAlgorithm:\n\n<ul>\n<li>Pick an arbitrary line as the X axis and its starting point as the origin.\n<li>Find the three other lines starting or ending at the origin, and use them to define the Y and Z axes.\n<li>If necessary, swap Y and Z to form a right-handed coordinate system.\n</li></li></li></ul>\n<a name=\"2\"></a>\n<h4>Determining Coordinate System Right-Handedness</h4>\n<p>Ah, yes, before we get to that, how do we determine whether the three vectors form a right-handed coordinate system?\n\n<p>Well, the coordinate system is right handed if and only if the signed volume of the parallelepiped they span is positive.\nThat volume is calculated by forming the cross product of the first two, then forming the dot product between the result and the third.\nThis is also called Spatprodukt in German.\nHere are the two little one-line helper methods implementing this:\n\n<pre class=\"code\">\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n<span class=\"gray\">///</span><span class=\"green\"> Return the signed volume of the paralleliped </span>\n<span class=\"gray\">///</span><span class=\"green\"> spanned by the vectors a, b and c. In German, </span>\n<span class=\"gray\">///</span><span class=\"green\"> this is also known as Spatprodukt.</span>\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n<span class=\"blue\">static</span> <span class=\"blue\">double</span> SignedParallelipedVolume(\n  <span class=\"teal\">XYZ</span> a,\n  <span class=\"teal\">XYZ</span> b,\n  <span class=\"teal\">XYZ</span> c )\n{\n  <span class=\"blue\">return</span> a.CrossProduct( b ).DotProduct( c );\n}\n \n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n<span class=\"gray\">///</span><span class=\"green\"> Return true if the three vectors a, b and c </span>\n<span class=\"gray\">///</span><span class=\"green\"> form a right handed coordinate system, i.e.</span>\n<span class=\"gray\">///</span><span class=\"green\"> the signed volume of the paralleliped spanned </span>\n<span class=\"gray\">///</span><span class=\"green\"> by them is positive.</span>\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n<span class=\"blue\">bool</span> IsRightHanded( <span class=\"teal\">XYZ</span> a, <span class=\"teal\">XYZ</span> b, <span class=\"teal\">XYZ</span> c )\n{\n  <span class=\"blue\">return</span> 0 &lt; SignedParallelipedVolume( a, b, c );\n}\n \n</pre>\n<a name=\"3\"></a>\n<h4>Determining Bounding Box of Scope Box</h4>\n<p>With that out of the way, here is the code of GetScopeBoxBoundingBox implementing the functionality described above:\n\n<pre class=\"code\">\n<span class=\"teal\">BoundingBoxXYZ</span> GetScopeBoxBoundingBox(\n  <span class=\"teal\">Element</span> scopeBox )\n{\n  <span class=\"teal\">Document</span> doc = scopeBox.Document;\n  <span class=\"teal\">Application</span> app = doc.Application;\n  <span class=\"teal\">Options</span> opt = app.Create.NewGeometryOptions();\n  <span class=\"teal\">GeometryElement</span> geo = scopeBox.get_Geometry( opt );\n  <span class=\"blue\">int</span> n = geo.Count&lt;<span class=\"teal\">GeometryObject</span>&gt;();\n \n  <span class=\"blue\">if</span>( 12 != n )\n  {\n    <span class=\"blue\">throw</span> <span class=\"blue\">new</span> <span class=\"teal\">ArgumentException</span>( <span class=\"maroon\">\"Expected exactly\"</span>\n      + <span class=\"maroon\">\" 12 lines in scope box geometry\"</span> );\n  }\n \n  <span class=\"teal\">XYZ</span> origin = <span class=\"blue\">null</span>;\n  <span class=\"teal\">XYZ</span> vx = <span class=\"blue\">null</span>;\n  <span class=\"teal\">XYZ</span> vy = <span class=\"blue\">null</span>;\n  <span class=\"teal\">XYZ</span> vz = <span class=\"blue\">null</span>;\n \n  <span class=\"green\">// Extract the X, Y and Z axes from the lines</span>\n \n  <span class=\"blue\">foreach</span>( <span class=\"teal\">GeometryObject</span> obj <span class=\"blue\">in</span> geo )\n  {\n    <span class=\"teal\">Debug</span>.Assert( obj <span class=\"blue\">is</span> <span class=\"teal\">Line</span>,\n      <span class=\"maroon\">\"expected only lines in scope box geometry\"</span> );\n \n    <span class=\"teal\">Line</span> line = obj <span class=\"blue\">as</span> <span class=\"teal\">Line</span>;\n \n    <span class=\"teal\">XYZ</span> p = line.get_EndPoint( 0 );\n    <span class=\"teal\">XYZ</span> q = line.get_EndPoint( 1 );\n    <span class=\"teal\">XYZ</span> v = q - p;\n \n    <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == origin )\n    {\n      origin = p;\n      vx = v;\n    }\n    <span class=\"blue\">else</span> <span class=\"blue\">if</span>( p.IsAlmostEqualTo( origin )\n      || q.IsAlmostEqualTo( origin ) )\n    {\n      <span class=\"blue\">if</span>( q.IsAlmostEqualTo( origin ) )\n      {\n        v = v.Negate();\n      }\n      <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == vy )\n      {\n        <span class=\"teal\">Debug</span>.Assert( IsPerpendicular( vx, v ),\n          <span class=\"maroon\">\"expected orthogonal lines in scope box geometry\"</span> );\n \n        vy = v;\n      }\n      <span class=\"blue\">else</span>\n      {\n        <span class=\"teal\">Debug</span>.Assert( <span class=\"blue\">null</span> == vz,\n          <span class=\"maroon\">\"expected exactly three orthogonal lines to originate in one point\"</span> );\n \n        <span class=\"teal\">Debug</span>.Assert( IsPerpendicular( vx, v ),\n          <span class=\"maroon\">\"expected orthogonal lines in scope box geometry\"</span> );\n \n        <span class=\"teal\">Debug</span>.Assert( IsPerpendicular( vy, v ),\n          <span class=\"maroon\">\"expected orthogonal lines in scope box geometry\"</span> );\n \n        vz = v;\n \n        <span class=\"blue\">if</span>( !IsRightHanded( vx, vy, vz ) )\n        {\n          <span class=\"teal\">XYZ</span> tmp = vz;\n          vz = vy;\n          vy = tmp;\n        }\n        <span class=\"blue\">break</span>;\n      }\n    }\n  }\n \n  <span class=\"green\">// Set up the transform</span>\n \n  <span class=\"teal\">Transform</span> t = <span class=\"teal\">Transform</span>.Identity;\n  t.Origin = origin;\n  t.BasisX = vx.Normalize();\n  t.BasisY = vy.Normalize();\n  t.BasisZ = vz.Normalize();\n \n  <span class=\"teal\">Debug</span>.Assert( t.IsConformal,\n    <span class=\"maroon\">\"expected resulting transform to be conformal\"</span> );\n \n  <span class=\"green\">// Set up the bounding box</span>\n \n  <span class=\"teal\">BoundingBoxXYZ</span> bb = <span class=\"blue\">new</span> <span class=\"teal\">BoundingBoxXYZ</span>();\n  bb.Transform = t;\n  bb.Min = <span class=\"teal\">XYZ</span>.Zero;\n  bb.Max = vx + vy + vz;\n \n  <span class=\"blue\">return</span> bb;\n}\n</pre>\n<p>The result is close, but no cigar yet:</p>\n<center>\n<img alt=\"Source scope box partially defining target view section box\" src=\"img/view_section_to_scope_2_rotated.png\" width=\"400\"/>\n</center>\n<a name=\"4\"></a>\n<h4>Determining Suitable View Section Box from Scope Box</h4>\n<p>In a next step, I decided to ensure that the Z axis I define actually is vertical and pointing upwards, take the view direction into account as well, and use the scope box edge closest to the viewer as the section box Z axis.\n\n<p>I therefore implemented a new method GetSectionBoundingBoxFromScopeBox, which returns a suitable bounding box for a Revit section view from the scope box position, taking the view direction into account, by performing the following steps:\n\n<ol>\n<li>Find vertical edge closest to viewer.\n<li>Use its bottom endpoint as the origin.\n<li>Find the other two edges emanating from the origin.\n<li>Use the three edges for the bounding box definition.\n</li></li></li></li></ol>\n<p>To find the vertical edge closest to the viewer, the view direction and scope box bounding box giving its maximum size are used together to determine a view point from which we imagine we are looking at the scope box.\n\n<p>I loop through the twelve lines in the scope box geometry twice.\nIn the first loop, I determine the origin and Z axis.\nIn the second, the X and Y axes are determined as well, based on that information.\n\n<p>The implementation looks like this:\n\n<pre class=\"code\">\n<span class=\"teal\">BoundingBoxXYZ</span> GetSectionBoundingBoxFromScopeBox(\n  <span class=\"teal\">Element</span> scopeBox,\n  <span class=\"teal\">XYZ</span> viewdirTowardViewer )\n{\n  <span class=\"teal\">Document</span> doc = scopeBox.Document;\n  <span class=\"teal\">Application</span> app = doc.Application;\n \n  <span class=\"green\">// Determine a possible view point outside the </span>\n  <span class=\"green\">// scope box extents in the direction of the </span>\n  <span class=\"green\">// viewer.</span>\n \n  <span class=\"teal\">BoundingBoxXYZ</span> bb\n    = scopeBox.get_BoundingBox( <span class=\"blue\">null</span> );\n \n  <span class=\"teal\">XYZ</span> v = bb.Max - bb.Min;\n \n  <span class=\"blue\">double</span> size = v.GetLength();\n \n  <span class=\"teal\">XYZ</span> viewPoint = bb.Min\n    + 10 * size * viewdirTowardViewer;\n \n  <span class=\"green\">// Retrieve scope box geometry, </span>\n  <span class=\"green\">// consisting of exactly twelve lines.</span>\n \n  <span class=\"teal\">Options</span> opt = app.Create.NewGeometryOptions();\n  <span class=\"teal\">GeometryElement</span> geo = scopeBox.get_Geometry( opt );\n  <span class=\"blue\">int</span> n = geo.Count&lt;<span class=\"teal\">GeometryObject</span>&gt;();\n \n  <span class=\"blue\">if</span>( 12 != n )\n  {\n    <span class=\"blue\">throw</span> <span class=\"blue\">new</span> <span class=\"teal\">ArgumentException</span>( <span class=\"maroon\">\"Expected exactly\"</span>\n      + <span class=\"maroon\">\" 12 lines in scope box geometry\"</span> );\n  }\n \n  <span class=\"green\">// Determine origin as the bottom endpoint of </span>\n  <span class=\"green\">// the edge closest to the viewer, and vz as the </span>\n  <span class=\"green\">// vertical upwards pointing vector emanating</span>\n  <span class=\"green\">// from it. (Todo: if several edges are equally </span>\n  <span class=\"green\">// close, pick the leftmost one, assuming the </span>\n  <span class=\"green\">// given view direction and Z is upwards.)</span>\n \n  <span class=\"blue\">double</span> dist = <span class=\"blue\">double</span>.MaxValue;\n  <span class=\"teal\">XYZ</span> origin = <span class=\"blue\">null</span>;\n  <span class=\"teal\">XYZ</span> vx = <span class=\"blue\">null</span>;\n  <span class=\"teal\">XYZ</span> vy = <span class=\"blue\">null</span>;\n  <span class=\"teal\">XYZ</span> vz = <span class=\"blue\">null</span>;\n  <span class=\"teal\">XYZ</span> p, q;\n \n  <span class=\"blue\">foreach</span>( <span class=\"teal\">GeometryObject</span> obj <span class=\"blue\">in</span> geo )\n  {\n    <span class=\"teal\">Debug</span>.Assert( obj <span class=\"blue\">is</span> <span class=\"teal\">Line</span>,\n      <span class=\"maroon\">\"expected only lines in scope box geometry\"</span> );\n \n    <span class=\"teal\">Line</span> line = obj <span class=\"blue\">as</span> <span class=\"teal\">Line</span>;\n \n    p = line.get_EndPoint( 0 );\n    q = line.get_EndPoint( 1 );\n    v = q - p;\n \n    <span class=\"blue\">if</span>( IsVertical( v ) )\n    {\n      <span class=\"blue\">if</span>( q.Z &lt; p.Z )\n      {\n        p = q;\n        v = v.Negate();\n      }\n \n      <span class=\"blue\">if</span>( p.DistanceTo( viewPoint ) &lt; dist )\n      {\n        origin = p;\n        dist = origin.DistanceTo( viewPoint );\n        vz = v;\n      }\n    }\n  }\n \n  <span class=\"green\">// Find the other two axes emanating from the </span>\n  <span class=\"green\">// origin, vx and vy, and ensure right-handedness</span>\n \n  <span class=\"blue\">foreach</span>( <span class=\"teal\">GeometryObject</span> obj <span class=\"blue\">in</span> geo )\n  {\n    <span class=\"teal\">Line</span> line = obj <span class=\"blue\">as</span> <span class=\"teal\">Line</span>;\n \n    p = line.get_EndPoint( 0 );\n    q = line.get_EndPoint( 1 );\n    v = q - p;\n \n    <span class=\"blue\">if</span>( IsVertical( v ) ) <span class=\"green\">// already handled this</span>\n    {\n      <span class=\"blue\">continue</span>;\n    }\n \n    <span class=\"blue\">if</span>( p.IsAlmostEqualTo( origin )\n      || q.IsAlmostEqualTo( origin ) )\n    {\n      <span class=\"blue\">if</span>( q.IsAlmostEqualTo( origin ) )\n      {\n        v = v.Negate();\n      }\n      <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == vx )\n      {\n        <span class=\"teal\">Debug</span>.Assert( IsPerpendicular( vz, v ),\n          <span class=\"maroon\">\"expected orthogonal lines in scope box geometry\"</span> );\n \n        vx = v;\n      }\n      <span class=\"blue\">else</span>\n      {\n        <span class=\"teal\">Debug</span>.Assert( <span class=\"blue\">null</span> == vy,\n          <span class=\"maroon\">\"expected exactly three orthogonal lines to originate in one point\"</span> );\n \n        <span class=\"teal\">Debug</span>.Assert( IsPerpendicular( vz, v ),\n          <span class=\"maroon\">\"expected orthogonal lines in scope box geometry\"</span> );\n \n        <span class=\"teal\">Debug</span>.Assert( IsPerpendicular( vx, v ),\n          <span class=\"maroon\">\"expected orthogonal lines in scope box geometry\"</span> );\n \n        vy = v;\n \n        <span class=\"blue\">if</span>( !IsRightHanded( vx, vy, vz ) )\n        {\n          <span class=\"teal\">XYZ</span> tmp = vx;\n          vx = vy;\n          vy = tmp;\n        }\n        <span class=\"blue\">break</span>;\n      }\n    }\n  }\n \n  <span class=\"green\">// Set up the transform</span>\n \n  <span class=\"teal\">Transform</span> t = <span class=\"teal\">Transform</span>.Identity;\n  t.Origin = origin;\n  t.BasisX = vx.Normalize();\n  t.BasisY = vy.Normalize();\n  t.BasisZ = vz.Normalize();\n \n  <span class=\"teal\">Debug</span>.Assert( t.IsConformal,\n    <span class=\"maroon\">\"expected resulting transform to be conformal\"</span> );\n \n  <span class=\"green\">// Set up the bounding box</span>\n \n  bb = <span class=\"blue\">new</span> <span class=\"teal\">BoundingBoxXYZ</span>();\n  bb.Transform = t;\n  bb.Min = <span class=\"teal\">XYZ</span>.Zero;\n  bb.Max = vx + vy + vz;\n \n  <span class=\"blue\">return</span> bb;\n}\n</pre>\n<a name=\"5\"></a>\n<h4>Putting it Together</h4>\n<p>Finally, let's take a look at the Execute method tying together and making use of this functionality.\n\n<p>For quick testing purposes, it assumes that a 3D view is currently active, and picks the first (only) scope box element it encounters.\nIt performs the following steps:\n\n<ul>\n<li>Access the current view and test that it is a 3D one.\n<li>Select the scope box element.\n<li>Determine the new view section box from the scope box using the GetSectionBoundingBoxFromScopeBox method, taking the view direction into account.\n<li>Assign the new view section box definition to the view SectionBox property.\n</li></li></li></li></ul>\n<p>Here is the code:\n\n<pre class=\"code\">\n  <span class=\"teal\">UIApplication</span> uiapp = commandData.Application;\n  <span class=\"teal\">UIDocument</span> uidoc = uiapp.ActiveUIDocument;\n  <span class=\"teal\">Application</span> app = uiapp.Application;\n  <span class=\"teal\">Document</span> doc = uidoc.Document;\n \n  <span class=\"teal\">View3D</span> view = doc.ActiveView <span class=\"blue\">as</span> <span class=\"teal\">View3D</span>;\n \n  <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == view )\n  {\n    message = <span class=\"maroon\">\"Please run this command in a 3D view.\"</span>;\n    <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n  }\n \n  <span class=\"teal\">Element</span> scopeBox\n    = <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( doc, view.Id )\n      .OfCategory( <span class=\"teal\">BuiltInCategory</span>.OST_VolumeOfInterest )\n      .WhereElementIsNotElementType()\n      .FirstElement();\n \n  <span class=\"teal\">BoundingBoxXYZ</span> viewSectionBox\n    = GetSectionBoundingBoxFromScopeBox(\n      scopeBox, view.ViewDirection );\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">Transaction</span> tx = <span class=\"blue\">new</span> <span class=\"teal\">Transaction</span>( doc ) )\n  {\n    tx.Start( <span class=\"maroon\">\"Move And Resize Section Box\"</span> );\n \n    view.SectionBox = viewSectionBox;\n \n    tx.Commit();\n  }\n  <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Succeeded;\n</pre>\n<p>The result in the original model looks like this, which is exactly what we were after:</p>\n<center>\n<img alt=\"Source scope box data transferred to target view section box\" src=\"img/view_section_to_scope_3.png\" width=\"400\"/>\n</center>\n<p>The dotted lines representing the scope box are completely obscured by the continuous view section box lines after running the command.\n\n<p>Nice, huh?\n\n<p>Here is\n\n<a href=\"zip/SetSectionBox.zip\">SetSectionBox.zip</a> containing\n\nthe complete source code, Visual Studio solution, and add-in manifest of this command.\n</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p>"
  },
  {
    "original_filename": "0816_view_section_to_scope",
    "header_text": "Determining Coordinate System Right-Handedness",
    "local_header_href": "#determining-coordinate-system-right-handedness",
    "chunk_text": "<h4>Determining Coordinate System Right-Handedness</h4><p>Ah, yes, before we get to that, how do we determine whether the three vectors form a right-handed coordinate system?\n\n<p>Well, the coordinate system is right handed if and only if the signed volume of the parallelepiped they span is positive.\nThat volume is calculated by forming the cross product of the first two, then forming the dot product between the result and the third.\nThis is also called Spatprodukt in German.\nHere are the two little one-line helper methods implementing this:\n\n<pre class=\"code\">\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n<span class=\"gray\">///</span><span class=\"green\"> Return the signed volume of the paralleliped </span>\n<span class=\"gray\">///</span><span class=\"green\"> spanned by the vectors a, b and c. In German, </span>\n<span class=\"gray\">///</span><span class=\"green\"> this is also known as Spatprodukt.</span>\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n<span class=\"blue\">static</span> <span class=\"blue\">double</span> SignedParallelipedVolume(\n  <span class=\"teal\">XYZ</span> a,\n  <span class=\"teal\">XYZ</span> b,\n  <span class=\"teal\">XYZ</span> c )\n{\n  <span class=\"blue\">return</span> a.CrossProduct( b ).DotProduct( c );\n}\n \n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n<span class=\"gray\">///</span><span class=\"green\"> Return true if the three vectors a, b and c </span>\n<span class=\"gray\">///</span><span class=\"green\"> form a right handed coordinate system, i.e.</span>\n<span class=\"gray\">///</span><span class=\"green\"> the signed volume of the paralleliped spanned </span>\n<span class=\"gray\">///</span><span class=\"green\"> by them is positive.</span>\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n<span class=\"blue\">bool</span> IsRightHanded( <span class=\"teal\">XYZ</span> a, <span class=\"teal\">XYZ</span> b, <span class=\"teal\">XYZ</span> c )\n{\n  <span class=\"blue\">return</span> 0 &lt; SignedParallelipedVolume( a, b, c );\n}\n \n</pre>\n<a name=\"3\"></a>\n<h4>Determining Bounding Box of Scope Box</h4>\n<p>With that out of the way, here is the code of GetScopeBoxBoundingBox implementing the functionality described above:\n\n<pre class=\"code\">\n<span class=\"teal\">BoundingBoxXYZ</span> GetScopeBoxBoundingBox(\n  <span class=\"teal\">Element</span> scopeBox )\n{\n  <span class=\"teal\">Document</span> doc = scopeBox.Document;\n  <span class=\"teal\">Application</span> app = doc.Application;\n  <span class=\"teal\">Options</span> opt = app.Create.NewGeometryOptions();\n  <span class=\"teal\">GeometryElement</span> geo = scopeBox.get_Geometry( opt );\n  <span class=\"blue\">int</span> n = geo.Count&lt;<span class=\"teal\">GeometryObject</span>&gt;();\n \n  <span class=\"blue\">if</span>( 12 != n )\n  {\n    <span class=\"blue\">throw</span> <span class=\"blue\">new</span> <span class=\"teal\">ArgumentException</span>( <span class=\"maroon\">\"Expected exactly\"</span>\n      + <span class=\"maroon\">\" 12 lines in scope box geometry\"</span> );\n  }\n \n  <span class=\"teal\">XYZ</span> origin = <span class=\"blue\">null</span>;\n  <span class=\"teal\">XYZ</span> vx = <span class=\"blue\">null</span>;\n  <span class=\"teal\">XYZ</span> vy = <span class=\"blue\">null</span>;\n  <span class=\"teal\">XYZ</span> vz = <span class=\"blue\">null</span>;\n \n  <span class=\"green\">// Extract the X, Y and Z axes from the lines</span>\n \n  <span class=\"blue\">foreach</span>( <span class=\"teal\">GeometryObject</span> obj <span class=\"blue\">in</span> geo )\n  {\n    <span class=\"teal\">Debug</span>.Assert( obj <span class=\"blue\">is</span> <span class=\"teal\">Line</span>,\n      <span class=\"maroon\">\"expected only lines in scope box geometry\"</span> );\n \n    <span class=\"teal\">Line</span> line = obj <span class=\"blue\">as</span> <span class=\"teal\">Line</span>;\n \n    <span class=\"teal\">XYZ</span> p = line.get_EndPoint( 0 );\n    <span class=\"teal\">XYZ</span> q = line.get_EndPoint( 1 );\n    <span class=\"teal\">XYZ</span> v = q - p;\n \n    <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == origin )\n    {\n      origin = p;\n      vx = v;\n    }\n    <span class=\"blue\">else</span> <span class=\"blue\">if</span>( p.IsAlmostEqualTo( origin )\n      || q.IsAlmostEqualTo( origin ) )\n    {\n      <span class=\"blue\">if</span>( q.IsAlmostEqualTo( origin ) )\n      {\n        v = v.Negate();\n      }\n      <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == vy )\n      {\n        <span class=\"teal\">Debug</span>.Assert( IsPerpendicular( vx, v ),\n          <span class=\"maroon\">\"expected orthogonal lines in scope box geometry\"</span> );\n \n        vy = v;\n      }\n      <span class=\"blue\">else</span>\n      {\n        <span class=\"teal\">Debug</span>.Assert( <span class=\"blue\">null</span> == vz,\n          <span class=\"maroon\">\"expected exactly three orthogonal lines to originate in one point\"</span> );\n \n        <span class=\"teal\">Debug</span>.Assert( IsPerpendicular( vx, v ),\n          <span class=\"maroon\">\"expected orthogonal lines in scope box geometry\"</span> );\n \n        <span class=\"teal\">Debug</span>.Assert( IsPerpendicular( vy, v ),\n          <span class=\"maroon\">\"expected orthogonal lines in scope box geometry\"</span> );\n \n        vz = v;\n \n        <span class=\"blue\">if</span>( !IsRightHanded( vx, vy, vz ) )\n        {\n          <span class=\"teal\">XYZ</span> tmp = vz;\n          vz = vy;\n          vy = tmp;\n        }\n        <span class=\"blue\">break</span>;\n      }\n    }\n  }\n \n  <span class=\"green\">// Set up the transform</span>\n \n  <span class=\"teal\">Transform</span> t = <span class=\"teal\">Transform</span>.Identity;\n  t.Origin = origin;\n  t.BasisX = vx.Normalize();\n  t.BasisY = vy.Normalize();\n  t.BasisZ = vz.Normalize();\n \n  <span class=\"teal\">Debug</span>.Assert( t.IsConformal,\n    <span class=\"maroon\">\"expected resulting transform to be conformal\"</span> );\n \n  <span class=\"green\">// Set up the bounding box</span>\n \n  <span class=\"teal\">BoundingBoxXYZ</span> bb = <span class=\"blue\">new</span> <span class=\"teal\">BoundingBoxXYZ</span>();\n  bb.Transform = t;\n  bb.Min = <span class=\"teal\">XYZ</span>.Zero;\n  bb.Max = vx + vy + vz;\n \n  <span class=\"blue\">return</span> bb;\n}\n</pre>\n<p>The result is close, but no cigar yet:</p>\n<center>\n<img alt=\"Source scope box partially defining target view section box\" src=\"img/view_section_to_scope_2_rotated.png\" width=\"400\"/>\n</center>\n<a name=\"4\"></a>\n<h4>Determining Suitable View Section Box from Scope Box</h4>\n<p>In a next step, I decided to ensure that the Z axis I define actually is vertical and pointing upwards, take the view direction into account as well, and use the scope box edge closest to the viewer as the section box Z axis.\n\n<p>I therefore implemented a new method GetSectionBoundingBoxFromScopeBox, which returns a suitable bounding box for a Revit section view from the scope box position, taking the view direction into account, by performing the following steps:\n\n<ol>\n<li>Find vertical edge closest to viewer.\n<li>Use its bottom endpoint as the origin.\n<li>Find the other two edges emanating from the origin.\n<li>Use the three edges for the bounding box definition.\n</li></li></li></li></ol>\n<p>To find the vertical edge closest to the viewer, the view direction and scope box bounding box giving its maximum size are used together to determine a view point from which we imagine we are looking at the scope box.\n\n<p>I loop through the twelve lines in the scope box geometry twice.\nIn the first loop, I determine the origin and Z axis.\nIn the second, the X and Y axes are determined as well, based on that information.\n\n<p>The implementation looks like this:\n\n<pre class=\"code\">\n<span class=\"teal\">BoundingBoxXYZ</span> GetSectionBoundingBoxFromScopeBox(\n  <span class=\"teal\">Element</span> scopeBox,\n  <span class=\"teal\">XYZ</span> viewdirTowardViewer )\n{\n  <span class=\"teal\">Document</span> doc = scopeBox.Document;\n  <span class=\"teal\">Application</span> app = doc.Application;\n \n  <span class=\"green\">// Determine a possible view point outside the </span>\n  <span class=\"green\">// scope box extents in the direction of the </span>\n  <span class=\"green\">// viewer.</span>\n \n  <span class=\"teal\">BoundingBoxXYZ</span> bb\n    = scopeBox.get_BoundingBox( <span class=\"blue\">null</span> );\n \n  <span class=\"teal\">XYZ</span> v = bb.Max - bb.Min;\n \n  <span class=\"blue\">double</span> size = v.GetLength();\n \n  <span class=\"teal\">XYZ</span> viewPoint = bb.Min\n    + 10 * size * viewdirTowardViewer;\n \n  <span class=\"green\">// Retrieve scope box geometry, </span>\n  <span class=\"green\">// consisting of exactly twelve lines.</span>\n \n  <span class=\"teal\">Options</span> opt = app.Create.NewGeometryOptions();\n  <span class=\"teal\">GeometryElement</span> geo = scopeBox.get_Geometry( opt );\n  <span class=\"blue\">int</span> n = geo.Count&lt;<span class=\"teal\">GeometryObject</span>&gt;();\n \n  <span class=\"blue\">if</span>( 12 != n )\n  {\n    <span class=\"blue\">throw</span> <span class=\"blue\">new</span> <span class=\"teal\">ArgumentException</span>( <span class=\"maroon\">\"Expected exactly\"</span>\n      + <span class=\"maroon\">\" 12 lines in scope box geometry\"</span> );\n  }\n \n  <span class=\"green\">// Determine origin as the bottom endpoint of </span>\n  <span class=\"green\">// the edge closest to the viewer, and vz as the </span>\n  <span class=\"green\">// vertical upwards pointing vector emanating</span>\n  <span class=\"green\">// from it. (Todo: if several edges are equally </span>\n  <span class=\"green\">// close, pick the leftmost one, assuming the </span>\n  <span class=\"green\">// given view direction and Z is upwards.)</span>\n \n  <span class=\"blue\">double</span> dist = <span class=\"blue\">double</span>.MaxValue;\n  <span class=\"teal\">XYZ</span> origin = <span class=\"blue\">null</span>;\n  <span class=\"teal\">XYZ</span> vx = <span class=\"blue\">null</span>;\n  <span class=\"teal\">XYZ</span> vy = <span class=\"blue\">null</span>;\n  <span class=\"teal\">XYZ</span> vz = <span class=\"blue\">null</span>;\n  <span class=\"teal\">XYZ</span> p, q;\n \n  <span class=\"blue\">foreach</span>( <span class=\"teal\">GeometryObject</span> obj <span class=\"blue\">in</span> geo )\n  {\n    <span class=\"teal\">Debug</span>.Assert( obj <span class=\"blue\">is</span> <span class=\"teal\">Line</span>,\n      <span class=\"maroon\">\"expected only lines in scope box geometry\"</span> );\n \n    <span class=\"teal\">Line</span> line = obj <span class=\"blue\">as</span> <span class=\"teal\">Line</span>;\n \n    p = line.get_EndPoint( 0 );\n    q = line.get_EndPoint( 1 );\n    v = q - p;\n \n    <span class=\"blue\">if</span>( IsVertical( v ) )\n    {\n      <span class=\"blue\">if</span>( q.Z &lt; p.Z )\n      {\n        p = q;\n        v = v.Negate();\n      }\n \n      <span class=\"blue\">if</span>( p.DistanceTo( viewPoint ) &lt; dist )\n      {\n        origin = p;\n        dist = origin.DistanceTo( viewPoint );\n        vz = v;\n      }\n    }\n  }\n \n  <span class=\"green\">// Find the other two axes emanating from the </span>\n  <span class=\"green\">// origin, vx and vy, and ensure right-handedness</span>\n \n  <span class=\"blue\">foreach</span>( <span class=\"teal\">GeometryObject</span> obj <span class=\"blue\">in</span> geo )\n  {\n    <span class=\"teal\">Line</span> line = obj <span class=\"blue\">as</span> <span class=\"teal\">Line</span>;\n \n    p = line.get_EndPoint( 0 );\n    q = line.get_EndPoint( 1 );\n    v = q - p;\n \n    <span class=\"blue\">if</span>( IsVertical( v ) ) <span class=\"green\">// already handled this</span>\n    {\n      <span class=\"blue\">continue</span>;\n    }\n \n    <span class=\"blue\">if</span>( p.IsAlmostEqualTo( origin )\n      || q.IsAlmostEqualTo( origin ) )\n    {\n      <span class=\"blue\">if</span>( q.IsAlmostEqualTo( origin ) )\n      {\n        v = v.Negate();\n      }\n      <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == vx )\n      {\n        <span class=\"teal\">Debug</span>.Assert( IsPerpendicular( vz, v ),\n          <span class=\"maroon\">\"expected orthogonal lines in scope box geometry\"</span> );\n \n        vx = v;\n      }\n      <span class=\"blue\">else</span>\n      {\n        <span class=\"teal\">Debug</span>.Assert( <span class=\"blue\">null</span> == vy,\n          <span class=\"maroon\">\"expected exactly three orthogonal lines to originate in one point\"</span> );\n \n        <span class=\"teal\">Debug</span>.Assert( IsPerpendicular( vz, v ),\n          <span class=\"maroon\">\"expected orthogonal lines in scope box geometry\"</span> );\n \n        <span class=\"teal\">Debug</span>.Assert( IsPerpendicular( vx, v ),\n          <span class=\"maroon\">\"expected orthogonal lines in scope box geometry\"</span> );\n \n        vy = v;\n \n        <span class=\"blue\">if</span>( !IsRightHanded( vx, vy, vz ) )\n        {\n          <span class=\"teal\">XYZ</span> tmp = vx;\n          vx = vy;\n          vy = tmp;\n        }\n        <span class=\"blue\">break</span>;\n      }\n    }\n  }\n \n  <span class=\"green\">// Set up the transform</span>\n \n  <span class=\"teal\">Transform</span> t = <span class=\"teal\">Transform</span>.Identity;\n  t.Origin = origin;\n  t.BasisX = vx.Normalize();\n  t.BasisY = vy.Normalize();\n  t.BasisZ = vz.Normalize();\n \n  <span class=\"teal\">Debug</span>.Assert( t.IsConformal,\n    <span class=\"maroon\">\"expected resulting transform to be conformal\"</span> );\n \n  <span class=\"green\">// Set up the bounding box</span>\n \n  bb = <span class=\"blue\">new</span> <span class=\"teal\">BoundingBoxXYZ</span>();\n  bb.Transform = t;\n  bb.Min = <span class=\"teal\">XYZ</span>.Zero;\n  bb.Max = vx + vy + vz;\n \n  <span class=\"blue\">return</span> bb;\n}\n</pre>\n<a name=\"5\"></a>\n<h4>Putting it Together</h4>\n<p>Finally, let's take a look at the Execute method tying together and making use of this functionality.\n\n<p>For quick testing purposes, it assumes that a 3D view is currently active, and picks the first (only) scope box element it encounters.\nIt performs the following steps:\n\n<ul>\n<li>Access the current view and test that it is a 3D one.\n<li>Select the scope box element.\n<li>Determine the new view section box from the scope box using the GetSectionBoundingBoxFromScopeBox method, taking the view direction into account.\n<li>Assign the new view section box definition to the view SectionBox property.\n</li></li></li></li></ul>\n<p>Here is the code:\n\n<pre class=\"code\">\n  <span class=\"teal\">UIApplication</span> uiapp = commandData.Application;\n  <span class=\"teal\">UIDocument</span> uidoc = uiapp.ActiveUIDocument;\n  <span class=\"teal\">Application</span> app = uiapp.Application;\n  <span class=\"teal\">Document</span> doc = uidoc.Document;\n \n  <span class=\"teal\">View3D</span> view = doc.ActiveView <span class=\"blue\">as</span> <span class=\"teal\">View3D</span>;\n \n  <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == view )\n  {\n    message = <span class=\"maroon\">\"Please run this command in a 3D view.\"</span>;\n    <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n  }\n \n  <span class=\"teal\">Element</span> scopeBox\n    = <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( doc, view.Id )\n      .OfCategory( <span class=\"teal\">BuiltInCategory</span>.OST_VolumeOfInterest )\n      .WhereElementIsNotElementType()\n      .FirstElement();\n \n  <span class=\"teal\">BoundingBoxXYZ</span> viewSectionBox\n    = GetSectionBoundingBoxFromScopeBox(\n      scopeBox, view.ViewDirection );\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">Transaction</span> tx = <span class=\"blue\">new</span> <span class=\"teal\">Transaction</span>( doc ) )\n  {\n    tx.Start( <span class=\"maroon\">\"Move And Resize Section Box\"</span> );\n \n    view.SectionBox = viewSectionBox;\n \n    tx.Commit();\n  }\n  <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Succeeded;\n</pre>\n<p>The result in the original model looks like this, which is exactly what we were after:</p>\n<center>\n<img alt=\"Source scope box data transferred to target view section box\" src=\"img/view_section_to_scope_3.png\" width=\"400\"/>\n</center>\n<p>The dotted lines representing the scope box are completely obscured by the continuous view section box lines after running the command.\n\n<p>Nice, huh?\n\n<p>Here is\n\n<a href=\"zip/SetSectionBox.zip\">SetSectionBox.zip</a> containing\n\nthe complete source code, Visual Studio solution, and add-in manifest of this command.\n</p></p></p></p></p></p></p></p></p></p></p></p></p></p>"
  },
  {
    "original_filename": "0816_view_section_to_scope",
    "header_text": "Determining Bounding Box of Scope Box",
    "local_header_href": "#determining-bounding-box-of-scope-box",
    "chunk_text": "<h4>Determining Bounding Box of Scope Box</h4><p>With that out of the way, here is the code of GetScopeBoxBoundingBox implementing the functionality described above:\n\n<pre class=\"code\">\n<span class=\"teal\">BoundingBoxXYZ</span> GetScopeBoxBoundingBox(\n  <span class=\"teal\">Element</span> scopeBox )\n{\n  <span class=\"teal\">Document</span> doc = scopeBox.Document;\n  <span class=\"teal\">Application</span> app = doc.Application;\n  <span class=\"teal\">Options</span> opt = app.Create.NewGeometryOptions();\n  <span class=\"teal\">GeometryElement</span> geo = scopeBox.get_Geometry( opt );\n  <span class=\"blue\">int</span> n = geo.Count&lt;<span class=\"teal\">GeometryObject</span>&gt;();\n \n  <span class=\"blue\">if</span>( 12 != n )\n  {\n    <span class=\"blue\">throw</span> <span class=\"blue\">new</span> <span class=\"teal\">ArgumentException</span>( <span class=\"maroon\">\"Expected exactly\"</span>\n      + <span class=\"maroon\">\" 12 lines in scope box geometry\"</span> );\n  }\n \n  <span class=\"teal\">XYZ</span> origin = <span class=\"blue\">null</span>;\n  <span class=\"teal\">XYZ</span> vx = <span class=\"blue\">null</span>;\n  <span class=\"teal\">XYZ</span> vy = <span class=\"blue\">null</span>;\n  <span class=\"teal\">XYZ</span> vz = <span class=\"blue\">null</span>;\n \n  <span class=\"green\">// Extract the X, Y and Z axes from the lines</span>\n \n  <span class=\"blue\">foreach</span>( <span class=\"teal\">GeometryObject</span> obj <span class=\"blue\">in</span> geo )\n  {\n    <span class=\"teal\">Debug</span>.Assert( obj <span class=\"blue\">is</span> <span class=\"teal\">Line</span>,\n      <span class=\"maroon\">\"expected only lines in scope box geometry\"</span> );\n \n    <span class=\"teal\">Line</span> line = obj <span class=\"blue\">as</span> <span class=\"teal\">Line</span>;\n \n    <span class=\"teal\">XYZ</span> p = line.get_EndPoint( 0 );\n    <span class=\"teal\">XYZ</span> q = line.get_EndPoint( 1 );\n    <span class=\"teal\">XYZ</span> v = q - p;\n \n    <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == origin )\n    {\n      origin = p;\n      vx = v;\n    }\n    <span class=\"blue\">else</span> <span class=\"blue\">if</span>( p.IsAlmostEqualTo( origin )\n      || q.IsAlmostEqualTo( origin ) )\n    {\n      <span class=\"blue\">if</span>( q.IsAlmostEqualTo( origin ) )\n      {\n        v = v.Negate();\n      }\n      <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == vy )\n      {\n        <span class=\"teal\">Debug</span>.Assert( IsPerpendicular( vx, v ),\n          <span class=\"maroon\">\"expected orthogonal lines in scope box geometry\"</span> );\n \n        vy = v;\n      }\n      <span class=\"blue\">else</span>\n      {\n        <span class=\"teal\">Debug</span>.Assert( <span class=\"blue\">null</span> == vz,\n          <span class=\"maroon\">\"expected exactly three orthogonal lines to originate in one point\"</span> );\n \n        <span class=\"teal\">Debug</span>.Assert( IsPerpendicular( vx, v ),\n          <span class=\"maroon\">\"expected orthogonal lines in scope box geometry\"</span> );\n \n        <span class=\"teal\">Debug</span>.Assert( IsPerpendicular( vy, v ),\n          <span class=\"maroon\">\"expected orthogonal lines in scope box geometry\"</span> );\n \n        vz = v;\n \n        <span class=\"blue\">if</span>( !IsRightHanded( vx, vy, vz ) )\n        {\n          <span class=\"teal\">XYZ</span> tmp = vz;\n          vz = vy;\n          vy = tmp;\n        }\n        <span class=\"blue\">break</span>;\n      }\n    }\n  }\n \n  <span class=\"green\">// Set up the transform</span>\n \n  <span class=\"teal\">Transform</span> t = <span class=\"teal\">Transform</span>.Identity;\n  t.Origin = origin;\n  t.BasisX = vx.Normalize();\n  t.BasisY = vy.Normalize();\n  t.BasisZ = vz.Normalize();\n \n  <span class=\"teal\">Debug</span>.Assert( t.IsConformal,\n    <span class=\"maroon\">\"expected resulting transform to be conformal\"</span> );\n \n  <span class=\"green\">// Set up the bounding box</span>\n \n  <span class=\"teal\">BoundingBoxXYZ</span> bb = <span class=\"blue\">new</span> <span class=\"teal\">BoundingBoxXYZ</span>();\n  bb.Transform = t;\n  bb.Min = <span class=\"teal\">XYZ</span>.Zero;\n  bb.Max = vx + vy + vz;\n \n  <span class=\"blue\">return</span> bb;\n}\n</pre>\n<p>The result is close, but no cigar yet:</p>\n<center>\n<img alt=\"Source scope box partially defining target view section box\" src=\"img/view_section_to_scope_2_rotated.png\" width=\"400\"/>\n</center>\n<a name=\"4\"></a>\n<h4>Determining Suitable View Section Box from Scope Box</h4>\n<p>In a next step, I decided to ensure that the Z axis I define actually is vertical and pointing upwards, take the view direction into account as well, and use the scope box edge closest to the viewer as the section box Z axis.\n\n<p>I therefore implemented a new method GetSectionBoundingBoxFromScopeBox, which returns a suitable bounding box for a Revit section view from the scope box position, taking the view direction into account, by performing the following steps:\n\n<ol>\n<li>Find vertical edge closest to viewer.\n<li>Use its bottom endpoint as the origin.\n<li>Find the other two edges emanating from the origin.\n<li>Use the three edges for the bounding box definition.\n</li></li></li></li></ol>\n<p>To find the vertical edge closest to the viewer, the view direction and scope box bounding box giving its maximum size are used together to determine a view point from which we imagine we are looking at the scope box.\n\n<p>I loop through the twelve lines in the scope box geometry twice.\nIn the first loop, I determine the origin and Z axis.\nIn the second, the X and Y axes are determined as well, based on that information.\n\n<p>The implementation looks like this:\n\n<pre class=\"code\">\n<span class=\"teal\">BoundingBoxXYZ</span> GetSectionBoundingBoxFromScopeBox(\n  <span class=\"teal\">Element</span> scopeBox,\n  <span class=\"teal\">XYZ</span> viewdirTowardViewer )\n{\n  <span class=\"teal\">Document</span> doc = scopeBox.Document;\n  <span class=\"teal\">Application</span> app = doc.Application;\n \n  <span class=\"green\">// Determine a possible view point outside the </span>\n  <span class=\"green\">// scope box extents in the direction of the </span>\n  <span class=\"green\">// viewer.</span>\n \n  <span class=\"teal\">BoundingBoxXYZ</span> bb\n    = scopeBox.get_BoundingBox( <span class=\"blue\">null</span> );\n \n  <span class=\"teal\">XYZ</span> v = bb.Max - bb.Min;\n \n  <span class=\"blue\">double</span> size = v.GetLength();\n \n  <span class=\"teal\">XYZ</span> viewPoint = bb.Min\n    + 10 * size * viewdirTowardViewer;\n \n  <span class=\"green\">// Retrieve scope box geometry, </span>\n  <span class=\"green\">// consisting of exactly twelve lines.</span>\n \n  <span class=\"teal\">Options</span> opt = app.Create.NewGeometryOptions();\n  <span class=\"teal\">GeometryElement</span> geo = scopeBox.get_Geometry( opt );\n  <span class=\"blue\">int</span> n = geo.Count&lt;<span class=\"teal\">GeometryObject</span>&gt;();\n \n  <span class=\"blue\">if</span>( 12 != n )\n  {\n    <span class=\"blue\">throw</span> <span class=\"blue\">new</span> <span class=\"teal\">ArgumentException</span>( <span class=\"maroon\">\"Expected exactly\"</span>\n      + <span class=\"maroon\">\" 12 lines in scope box geometry\"</span> );\n  }\n \n  <span class=\"green\">// Determine origin as the bottom endpoint of </span>\n  <span class=\"green\">// the edge closest to the viewer, and vz as the </span>\n  <span class=\"green\">// vertical upwards pointing vector emanating</span>\n  <span class=\"green\">// from it. (Todo: if several edges are equally </span>\n  <span class=\"green\">// close, pick the leftmost one, assuming the </span>\n  <span class=\"green\">// given view direction and Z is upwards.)</span>\n \n  <span class=\"blue\">double</span> dist = <span class=\"blue\">double</span>.MaxValue;\n  <span class=\"teal\">XYZ</span> origin = <span class=\"blue\">null</span>;\n  <span class=\"teal\">XYZ</span> vx = <span class=\"blue\">null</span>;\n  <span class=\"teal\">XYZ</span> vy = <span class=\"blue\">null</span>;\n  <span class=\"teal\">XYZ</span> vz = <span class=\"blue\">null</span>;\n  <span class=\"teal\">XYZ</span> p, q;\n \n  <span class=\"blue\">foreach</span>( <span class=\"teal\">GeometryObject</span> obj <span class=\"blue\">in</span> geo )\n  {\n    <span class=\"teal\">Debug</span>.Assert( obj <span class=\"blue\">is</span> <span class=\"teal\">Line</span>,\n      <span class=\"maroon\">\"expected only lines in scope box geometry\"</span> );\n \n    <span class=\"teal\">Line</span> line = obj <span class=\"blue\">as</span> <span class=\"teal\">Line</span>;\n \n    p = line.get_EndPoint( 0 );\n    q = line.get_EndPoint( 1 );\n    v = q - p;\n \n    <span class=\"blue\">if</span>( IsVertical( v ) )\n    {\n      <span class=\"blue\">if</span>( q.Z &lt; p.Z )\n      {\n        p = q;\n        v = v.Negate();\n      }\n \n      <span class=\"blue\">if</span>( p.DistanceTo( viewPoint ) &lt; dist )\n      {\n        origin = p;\n        dist = origin.DistanceTo( viewPoint );\n        vz = v;\n      }\n    }\n  }\n \n  <span class=\"green\">// Find the other two axes emanating from the </span>\n  <span class=\"green\">// origin, vx and vy, and ensure right-handedness</span>\n \n  <span class=\"blue\">foreach</span>( <span class=\"teal\">GeometryObject</span> obj <span class=\"blue\">in</span> geo )\n  {\n    <span class=\"teal\">Line</span> line = obj <span class=\"blue\">as</span> <span class=\"teal\">Line</span>;\n \n    p = line.get_EndPoint( 0 );\n    q = line.get_EndPoint( 1 );\n    v = q - p;\n \n    <span class=\"blue\">if</span>( IsVertical( v ) ) <span class=\"green\">// already handled this</span>\n    {\n      <span class=\"blue\">continue</span>;\n    }\n \n    <span class=\"blue\">if</span>( p.IsAlmostEqualTo( origin )\n      || q.IsAlmostEqualTo( origin ) )\n    {\n      <span class=\"blue\">if</span>( q.IsAlmostEqualTo( origin ) )\n      {\n        v = v.Negate();\n      }\n      <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == vx )\n      {\n        <span class=\"teal\">Debug</span>.Assert( IsPerpendicular( vz, v ),\n          <span class=\"maroon\">\"expected orthogonal lines in scope box geometry\"</span> );\n \n        vx = v;\n      }\n      <span class=\"blue\">else</span>\n      {\n        <span class=\"teal\">Debug</span>.Assert( <span class=\"blue\">null</span> == vy,\n          <span class=\"maroon\">\"expected exactly three orthogonal lines to originate in one point\"</span> );\n \n        <span class=\"teal\">Debug</span>.Assert( IsPerpendicular( vz, v ),\n          <span class=\"maroon\">\"expected orthogonal lines in scope box geometry\"</span> );\n \n        <span class=\"teal\">Debug</span>.Assert( IsPerpendicular( vx, v ),\n          <span class=\"maroon\">\"expected orthogonal lines in scope box geometry\"</span> );\n \n        vy = v;\n \n        <span class=\"blue\">if</span>( !IsRightHanded( vx, vy, vz ) )\n        {\n          <span class=\"teal\">XYZ</span> tmp = vx;\n          vx = vy;\n          vy = tmp;\n        }\n        <span class=\"blue\">break</span>;\n      }\n    }\n  }\n \n  <span class=\"green\">// Set up the transform</span>\n \n  <span class=\"teal\">Transform</span> t = <span class=\"teal\">Transform</span>.Identity;\n  t.Origin = origin;\n  t.BasisX = vx.Normalize();\n  t.BasisY = vy.Normalize();\n  t.BasisZ = vz.Normalize();\n \n  <span class=\"teal\">Debug</span>.Assert( t.IsConformal,\n    <span class=\"maroon\">\"expected resulting transform to be conformal\"</span> );\n \n  <span class=\"green\">// Set up the bounding box</span>\n \n  bb = <span class=\"blue\">new</span> <span class=\"teal\">BoundingBoxXYZ</span>();\n  bb.Transform = t;\n  bb.Min = <span class=\"teal\">XYZ</span>.Zero;\n  bb.Max = vx + vy + vz;\n \n  <span class=\"blue\">return</span> bb;\n}\n</pre>\n<a name=\"5\"></a>\n<h4>Putting it Together</h4>\n<p>Finally, let's take a look at the Execute method tying together and making use of this functionality.\n\n<p>For quick testing purposes, it assumes that a 3D view is currently active, and picks the first (only) scope box element it encounters.\nIt performs the following steps:\n\n<ul>\n<li>Access the current view and test that it is a 3D one.\n<li>Select the scope box element.\n<li>Determine the new view section box from the scope box using the GetSectionBoundingBoxFromScopeBox method, taking the view direction into account.\n<li>Assign the new view section box definition to the view SectionBox property.\n</li></li></li></li></ul>\n<p>Here is the code:\n\n<pre class=\"code\">\n  <span class=\"teal\">UIApplication</span> uiapp = commandData.Application;\n  <span class=\"teal\">UIDocument</span> uidoc = uiapp.ActiveUIDocument;\n  <span class=\"teal\">Application</span> app = uiapp.Application;\n  <span class=\"teal\">Document</span> doc = uidoc.Document;\n \n  <span class=\"teal\">View3D</span> view = doc.ActiveView <span class=\"blue\">as</span> <span class=\"teal\">View3D</span>;\n \n  <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == view )\n  {\n    message = <span class=\"maroon\">\"Please run this command in a 3D view.\"</span>;\n    <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n  }\n \n  <span class=\"teal\">Element</span> scopeBox\n    = <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( doc, view.Id )\n      .OfCategory( <span class=\"teal\">BuiltInCategory</span>.OST_VolumeOfInterest )\n      .WhereElementIsNotElementType()\n      .FirstElement();\n \n  <span class=\"teal\">BoundingBoxXYZ</span> viewSectionBox\n    = GetSectionBoundingBoxFromScopeBox(\n      scopeBox, view.ViewDirection );\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">Transaction</span> tx = <span class=\"blue\">new</span> <span class=\"teal\">Transaction</span>( doc ) )\n  {\n    tx.Start( <span class=\"maroon\">\"Move And Resize Section Box\"</span> );\n \n    view.SectionBox = viewSectionBox;\n \n    tx.Commit();\n  }\n  <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Succeeded;\n</pre>\n<p>The result in the original model looks like this, which is exactly what we were after:</p>\n<center>\n<img alt=\"Source scope box data transferred to target view section box\" src=\"img/view_section_to_scope_3.png\" width=\"400\"/>\n</center>\n<p>The dotted lines representing the scope box are completely obscured by the continuous view section box lines after running the command.\n\n<p>Nice, huh?\n\n<p>Here is\n\n<a href=\"zip/SetSectionBox.zip\">SetSectionBox.zip</a> containing\n\nthe complete source code, Visual Studio solution, and add-in manifest of this command.\n</p></p></p></p></p></p></p></p></p></p></p></p>"
  },
  {
    "original_filename": "0816_view_section_to_scope",
    "header_text": "Determining Suitable View Section Box from Scope Box",
    "local_header_href": "#determining-suitable-view-section-box-from-scope-box",
    "chunk_text": "<h4>Determining Suitable View Section Box from Scope Box</h4><p>In a next step, I decided to ensure that the Z axis I define actually is vertical and pointing upwards, take the view direction into account as well, and use the scope box edge closest to the viewer as the section box Z axis.\n\n<p>I therefore implemented a new method GetSectionBoundingBoxFromScopeBox, which returns a suitable bounding box for a Revit section view from the scope box position, taking the view direction into account, by performing the following steps:\n\n<ol>\n<li>Find vertical edge closest to viewer.\n<li>Use its bottom endpoint as the origin.\n<li>Find the other two edges emanating from the origin.\n<li>Use the three edges for the bounding box definition.\n</li></li></li></li></ol>\n<p>To find the vertical edge closest to the viewer, the view direction and scope box bounding box giving its maximum size are used together to determine a view point from which we imagine we are looking at the scope box.\n\n<p>I loop through the twelve lines in the scope box geometry twice.\nIn the first loop, I determine the origin and Z axis.\nIn the second, the X and Y axes are determined as well, based on that information.\n\n<p>The implementation looks like this:\n\n<pre class=\"code\">\n<span class=\"teal\">BoundingBoxXYZ</span> GetSectionBoundingBoxFromScopeBox(\n  <span class=\"teal\">Element</span> scopeBox,\n  <span class=\"teal\">XYZ</span> viewdirTowardViewer )\n{\n  <span class=\"teal\">Document</span> doc = scopeBox.Document;\n  <span class=\"teal\">Application</span> app = doc.Application;\n \n  <span class=\"green\">// Determine a possible view point outside the </span>\n  <span class=\"green\">// scope box extents in the direction of the </span>\n  <span class=\"green\">// viewer.</span>\n \n  <span class=\"teal\">BoundingBoxXYZ</span> bb\n    = scopeBox.get_BoundingBox( <span class=\"blue\">null</span> );\n \n  <span class=\"teal\">XYZ</span> v = bb.Max - bb.Min;\n \n  <span class=\"blue\">double</span> size = v.GetLength();\n \n  <span class=\"teal\">XYZ</span> viewPoint = bb.Min\n    + 10 * size * viewdirTowardViewer;\n \n  <span class=\"green\">// Retrieve scope box geometry, </span>\n  <span class=\"green\">// consisting of exactly twelve lines.</span>\n \n  <span class=\"teal\">Options</span> opt = app.Create.NewGeometryOptions();\n  <span class=\"teal\">GeometryElement</span> geo = scopeBox.get_Geometry( opt );\n  <span class=\"blue\">int</span> n = geo.Count&lt;<span class=\"teal\">GeometryObject</span>&gt;();\n \n  <span class=\"blue\">if</span>( 12 != n )\n  {\n    <span class=\"blue\">throw</span> <span class=\"blue\">new</span> <span class=\"teal\">ArgumentException</span>( <span class=\"maroon\">\"Expected exactly\"</span>\n      + <span class=\"maroon\">\" 12 lines in scope box geometry\"</span> );\n  }\n \n  <span class=\"green\">// Determine origin as the bottom endpoint of </span>\n  <span class=\"green\">// the edge closest to the viewer, and vz as the </span>\n  <span class=\"green\">// vertical upwards pointing vector emanating</span>\n  <span class=\"green\">// from it. (Todo: if several edges are equally </span>\n  <span class=\"green\">// close, pick the leftmost one, assuming the </span>\n  <span class=\"green\">// given view direction and Z is upwards.)</span>\n \n  <span class=\"blue\">double</span> dist = <span class=\"blue\">double</span>.MaxValue;\n  <span class=\"teal\">XYZ</span> origin = <span class=\"blue\">null</span>;\n  <span class=\"teal\">XYZ</span> vx = <span class=\"blue\">null</span>;\n  <span class=\"teal\">XYZ</span> vy = <span class=\"blue\">null</span>;\n  <span class=\"teal\">XYZ</span> vz = <span class=\"blue\">null</span>;\n  <span class=\"teal\">XYZ</span> p, q;\n \n  <span class=\"blue\">foreach</span>( <span class=\"teal\">GeometryObject</span> obj <span class=\"blue\">in</span> geo )\n  {\n    <span class=\"teal\">Debug</span>.Assert( obj <span class=\"blue\">is</span> <span class=\"teal\">Line</span>,\n      <span class=\"maroon\">\"expected only lines in scope box geometry\"</span> );\n \n    <span class=\"teal\">Line</span> line = obj <span class=\"blue\">as</span> <span class=\"teal\">Line</span>;\n \n    p = line.get_EndPoint( 0 );\n    q = line.get_EndPoint( 1 );\n    v = q - p;\n \n    <span class=\"blue\">if</span>( IsVertical( v ) )\n    {\n      <span class=\"blue\">if</span>( q.Z &lt; p.Z )\n      {\n        p = q;\n        v = v.Negate();\n      }\n \n      <span class=\"blue\">if</span>( p.DistanceTo( viewPoint ) &lt; dist )\n      {\n        origin = p;\n        dist = origin.DistanceTo( viewPoint );\n        vz = v;\n      }\n    }\n  }\n \n  <span class=\"green\">// Find the other two axes emanating from the </span>\n  <span class=\"green\">// origin, vx and vy, and ensure right-handedness</span>\n \n  <span class=\"blue\">foreach</span>( <span class=\"teal\">GeometryObject</span> obj <span class=\"blue\">in</span> geo )\n  {\n    <span class=\"teal\">Line</span> line = obj <span class=\"blue\">as</span> <span class=\"teal\">Line</span>;\n \n    p = line.get_EndPoint( 0 );\n    q = line.get_EndPoint( 1 );\n    v = q - p;\n \n    <span class=\"blue\">if</span>( IsVertical( v ) ) <span class=\"green\">// already handled this</span>\n    {\n      <span class=\"blue\">continue</span>;\n    }\n \n    <span class=\"blue\">if</span>( p.IsAlmostEqualTo( origin )\n      || q.IsAlmostEqualTo( origin ) )\n    {\n      <span class=\"blue\">if</span>( q.IsAlmostEqualTo( origin ) )\n      {\n        v = v.Negate();\n      }\n      <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == vx )\n      {\n        <span class=\"teal\">Debug</span>.Assert( IsPerpendicular( vz, v ),\n          <span class=\"maroon\">\"expected orthogonal lines in scope box geometry\"</span> );\n \n        vx = v;\n      }\n      <span class=\"blue\">else</span>\n      {\n        <span class=\"teal\">Debug</span>.Assert( <span class=\"blue\">null</span> == vy,\n          <span class=\"maroon\">\"expected exactly three orthogonal lines to originate in one point\"</span> );\n \n        <span class=\"teal\">Debug</span>.Assert( IsPerpendicular( vz, v ),\n          <span class=\"maroon\">\"expected orthogonal lines in scope box geometry\"</span> );\n \n        <span class=\"teal\">Debug</span>.Assert( IsPerpendicular( vx, v ),\n          <span class=\"maroon\">\"expected orthogonal lines in scope box geometry\"</span> );\n \n        vy = v;\n \n        <span class=\"blue\">if</span>( !IsRightHanded( vx, vy, vz ) )\n        {\n          <span class=\"teal\">XYZ</span> tmp = vx;\n          vx = vy;\n          vy = tmp;\n        }\n        <span class=\"blue\">break</span>;\n      }\n    }\n  }\n \n  <span class=\"green\">// Set up the transform</span>\n \n  <span class=\"teal\">Transform</span> t = <span class=\"teal\">Transform</span>.Identity;\n  t.Origin = origin;\n  t.BasisX = vx.Normalize();\n  t.BasisY = vy.Normalize();\n  t.BasisZ = vz.Normalize();\n \n  <span class=\"teal\">Debug</span>.Assert( t.IsConformal,\n    <span class=\"maroon\">\"expected resulting transform to be conformal\"</span> );\n \n  <span class=\"green\">// Set up the bounding box</span>\n \n  bb = <span class=\"blue\">new</span> <span class=\"teal\">BoundingBoxXYZ</span>();\n  bb.Transform = t;\n  bb.Min = <span class=\"teal\">XYZ</span>.Zero;\n  bb.Max = vx + vy + vz;\n \n  <span class=\"blue\">return</span> bb;\n}\n</pre>\n<a name=\"5\"></a>\n<h4>Putting it Together</h4>\n<p>Finally, let's take a look at the Execute method tying together and making use of this functionality.\n\n<p>For quick testing purposes, it assumes that a 3D view is currently active, and picks the first (only) scope box element it encounters.\nIt performs the following steps:\n\n<ul>\n<li>Access the current view and test that it is a 3D one.\n<li>Select the scope box element.\n<li>Determine the new view section box from the scope box using the GetSectionBoundingBoxFromScopeBox method, taking the view direction into account.\n<li>Assign the new view section box definition to the view SectionBox property.\n</li></li></li></li></ul>\n<p>Here is the code:\n\n<pre class=\"code\">\n  <span class=\"teal\">UIApplication</span> uiapp = commandData.Application;\n  <span class=\"teal\">UIDocument</span> uidoc = uiapp.ActiveUIDocument;\n  <span class=\"teal\">Application</span> app = uiapp.Application;\n  <span class=\"teal\">Document</span> doc = uidoc.Document;\n \n  <span class=\"teal\">View3D</span> view = doc.ActiveView <span class=\"blue\">as</span> <span class=\"teal\">View3D</span>;\n \n  <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == view )\n  {\n    message = <span class=\"maroon\">\"Please run this command in a 3D view.\"</span>;\n    <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n  }\n \n  <span class=\"teal\">Element</span> scopeBox\n    = <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( doc, view.Id )\n      .OfCategory( <span class=\"teal\">BuiltInCategory</span>.OST_VolumeOfInterest )\n      .WhereElementIsNotElementType()\n      .FirstElement();\n \n  <span class=\"teal\">BoundingBoxXYZ</span> viewSectionBox\n    = GetSectionBoundingBoxFromScopeBox(\n      scopeBox, view.ViewDirection );\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">Transaction</span> tx = <span class=\"blue\">new</span> <span class=\"teal\">Transaction</span>( doc ) )\n  {\n    tx.Start( <span class=\"maroon\">\"Move And Resize Section Box\"</span> );\n \n    view.SectionBox = viewSectionBox;\n \n    tx.Commit();\n  }\n  <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Succeeded;\n</pre>\n<p>The result in the original model looks like this, which is exactly what we were after:</p>\n<center>\n<img alt=\"Source scope box data transferred to target view section box\" src=\"img/view_section_to_scope_3.png\" width=\"400\"/>\n</center>\n<p>The dotted lines representing the scope box are completely obscured by the continuous view section box lines after running the command.\n\n<p>Nice, huh?\n\n<p>Here is\n\n<a href=\"zip/SetSectionBox.zip\">SetSectionBox.zip</a> containing\n\nthe complete source code, Visual Studio solution, and add-in manifest of this command.\n</p></p></p></p></p></p></p></p></p></p></p>"
  },
  {
    "original_filename": "0816_view_section_to_scope",
    "header_text": "Putting it Together",
    "local_header_href": "#putting-it-together",
    "chunk_text": "<h4>Putting it Together</h4><p>Finally, let's take a look at the Execute method tying together and making use of this functionality.\n\n<p>For quick testing purposes, it assumes that a 3D view is currently active, and picks the first (only) scope box element it encounters.\nIt performs the following steps:\n\n<ul>\n<li>Access the current view and test that it is a 3D one.\n<li>Select the scope box element.\n<li>Determine the new view section box from the scope box using the GetSectionBoundingBoxFromScopeBox method, taking the view direction into account.\n<li>Assign the new view section box definition to the view SectionBox property.\n</li></li></li></li></ul>\n<p>Here is the code:\n\n<pre class=\"code\">\n  <span class=\"teal\">UIApplication</span> uiapp = commandData.Application;\n  <span class=\"teal\">UIDocument</span> uidoc = uiapp.ActiveUIDocument;\n  <span class=\"teal\">Application</span> app = uiapp.Application;\n  <span class=\"teal\">Document</span> doc = uidoc.Document;\n \n  <span class=\"teal\">View3D</span> view = doc.ActiveView <span class=\"blue\">as</span> <span class=\"teal\">View3D</span>;\n \n  <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == view )\n  {\n    message = <span class=\"maroon\">\"Please run this command in a 3D view.\"</span>;\n    <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n  }\n \n  <span class=\"teal\">Element</span> scopeBox\n    = <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( doc, view.Id )\n      .OfCategory( <span class=\"teal\">BuiltInCategory</span>.OST_VolumeOfInterest )\n      .WhereElementIsNotElementType()\n      .FirstElement();\n \n  <span class=\"teal\">BoundingBoxXYZ</span> viewSectionBox\n    = GetSectionBoundingBoxFromScopeBox(\n      scopeBox, view.ViewDirection );\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">Transaction</span> tx = <span class=\"blue\">new</span> <span class=\"teal\">Transaction</span>( doc ) )\n  {\n    tx.Start( <span class=\"maroon\">\"Move And Resize Section Box\"</span> );\n \n    view.SectionBox = viewSectionBox;\n \n    tx.Commit();\n  }\n  <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Succeeded;\n</pre>\n<p>The result in the original model looks like this, which is exactly what we were after:</p>\n<center>\n<img alt=\"Source scope box data transferred to target view section box\" src=\"img/view_section_to_scope_3.png\" width=\"400\"/>\n</center>\n<p>The dotted lines representing the scope box are completely obscured by the continuous view section box lines after running the command.\n\n<p>Nice, huh?\n\n<p>Here is\n\n<a href=\"zip/SetSectionBox.zip\">SetSectionBox.zip</a> containing\n\nthe complete source code, Visual Studio solution, and add-in manifest of this command.\n</p></p></p></p></p></p>"
  }
]