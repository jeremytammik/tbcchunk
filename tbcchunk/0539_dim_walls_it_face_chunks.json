[
  {
    "original_filename": "0539_dim_walls_it_face",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<head>\n<link href=\"bc.css\" rel=\"stylesheet\" type=\"text/css\"/>\n</head>"
  },
  {
    "original_filename": "0539_dim_walls_it_face",
    "header_text": "Dimension Walls by Iterating Faces",
    "local_header_href": "#dimension-walls-by-iterating-faces",
    "chunk_text": "<h3>Dimension Walls by Iterating Faces</h3><p>I have not seen many published examples of creating dimensioning elements using the Revit API.\n\n<p>The one sample that is provided by the Revit SDK, CreateDimensions, shows how to add dimensioning between the start and end points of selected structural wall, but is limited to exactly that, dimensioning a structural wall, and only in Revit Structure.\n\n<p>To create a dimensioning element, one has to provide an array of stable references to some geometrical features of the building geometry.\nCreateDimensions simplifies the process of providing the references by using the wall's analytical model, which is only accessible in Revit Structure.\n\n<p>The \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2009/10/revit-family-creation-api-labs.html\">\nFamily API labs</a> provide \n\nanother example of \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2009/10/revit-family-creation-api-labs.html#1\">\nsetting up a reference array</a> in \n\norder to create some dimensioning and alignment elements.\n\n<p>So how about creating some dimensioning elements with no additional support from the analytical model, that runs in all flavours of Revit?\n\n<p>Well, there are several ways to obtain references through the Revit API, two of which are:\n\n<ul>\n<li>Query the element geometry and ask it to \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/01/geometry-options.html\">\ncompute references</a>.\n\n<li>Use the \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/01/findreferencesbydirection.html\">\nFindReferencesByDirection</a> method.\n\n</li></li></ul>\n<p>Let's explore the usage of these two approaches to create a dimensioning element between two walls, prompted by the following question:\n\n<p><strong>Question:</strong> Could you please provide the simplest possible code that shows dimensioning between two inside surfaces of two walls in plan view?\nFor example, I have a shaft and I want to dimension its inside width and height. \n\n<p><strong>Answer:</strong> Before getting into the nuts and bolts of determining references on existing walls, let's discuss some basics:\n\n<a name=\"1\"></a>\n<h4>Creating Linear Dimensioning</h4>\n<p>Linear dimensioning such as you describe is created using the NewDimension method provided by the Creation.Document class. \nThe Revit SDK developer guide \"Revit 2011 API Developer Guide.pdf\" includes a snippet of sample code demonstrating how use this method in Code Region 16-3: Duplicating a dimension with NewDimension:\n\n<pre class=\"code\">\n  <span class=\"blue\">public</span> <span class=\"blue\">void</span> DuplicateDimension(\n    <span class=\"teal\">Document</span> doc,\n    <span class=\"teal\">Dimension</span> dimension )\n  {\n    <span class=\"teal\">Line</span> line = dimension.Curve <span class=\"blue\">as</span> <span class=\"teal\">Line</span>;\n \n    <span class=\"blue\">if</span>( <span class=\"blue\">null</span> != line )\n    {\n      Autodesk.Revit.DB.<span class=\"teal\">View</span> view = dimension.View;\n \n      <span class=\"teal\">ReferenceArray</span> references = dimension.References;\n \n      <span class=\"teal\">Dimension</span> newDimension = doc.Create.NewDimension(\n        view, line, references );\n    }\n  }\n</pre>\n<p>Another sample of interest in this context is Code Region 13-9: Labelling a dimension, since it shows in more detail how the view, reference array, and line arguments can be determined and populated. \nIt works in the context of a family document, however:\n\n<pre class=\"code\">\n  <span class=\"blue\">public</span> <span class=\"teal\">Dimension</span> CreateLinearDimension(\n    <span class=\"teal\">Document</span> doc )\n  {\n    <span class=\"teal\">Application</span> app = doc.Application;\n \n    <span class=\"green\">// first create two lines</span>\n \n    <span class=\"teal\">XYZ</span> pt1 = <span class=\"blue\">new</span> <span class=\"teal\">XYZ</span>( 5, 5, 0 );\n    <span class=\"teal\">XYZ</span> pt2 = <span class=\"blue\">new</span> <span class=\"teal\">XYZ</span>( 5, 10, 0 );\n    <span class=\"teal\">Line</span> line = app.Create.NewLine( pt1, pt2, <span class=\"blue\">true</span> );\n    <span class=\"teal\">Plane</span> plane = app.Create.NewPlane( \n      pt1.CrossProduct( pt2 ), pt2 );\n \n    <span class=\"teal\">SketchPlane</span> skplane = doc.FamilyCreate\n      .NewSketchPlane( plane );\n \n    <span class=\"teal\">ModelCurve</span> modelcurve1 = doc.FamilyCreate\n      .NewModelCurve( line, skplane );\n \n    pt1 = <span class=\"blue\">new</span> <span class=\"teal\">XYZ</span>( 10, 5, 0 );\n    pt2 = <span class=\"blue\">new</span> <span class=\"teal\">XYZ</span>( 10, 10, 0 );\n    line = app.Create.NewLine( pt1, pt2, <span class=\"blue\">true</span> );\n    plane = app.Create.NewPlane( \n      pt1.CrossProduct( pt2 ), pt2 );\n \n    skplane = doc.FamilyCreate\n      .NewSketchPlane( plane );\n \n    <span class=\"teal\">ModelCurve</span> modelcurve2 = doc.FamilyCreate\n      .NewModelCurve( line, skplane );\n \n    <span class=\"green\">// now create a linear dimension between them</span>\n \n    <span class=\"teal\">ReferenceArray</span> ra = <span class=\"blue\">new</span> <span class=\"teal\">ReferenceArray</span>();\n    ra.Append( modelcurve1.GeometryCurve.Reference );\n    ra.Append( modelcurve2.GeometryCurve.Reference );\n \n    pt1 = <span class=\"blue\">new</span> <span class=\"teal\">XYZ</span>( 5, 10, 0 );\n    pt2 = <span class=\"blue\">new</span> <span class=\"teal\">XYZ</span>( 10, 10, 0 );\n    line = app.Create.NewLine( pt1, pt2, <span class=\"blue\">true</span> );\n    <span class=\"teal\">Dimension</span> dim = doc.FamilyCreate\n      .NewLinearDimension( doc.ActiveView, line, ra );\n \n    <span class=\"green\">// create a label for the dimension called \"width\"</span>\n \n    <span class=\"teal\">FamilyParameter</span> param = doc.FamilyManager\n      .AddParameter( <span class=\"maroon\">\"width\"</span>,\n        <span class=\"teal\">BuiltInParameterGroup</span>.PG_CONSTRAINTS,\n        <span class=\"teal\">ParameterType</span>.Length, <span class=\"blue\">false</span> );\n \n    dim.Label = param;\n \n    <span class=\"blue\">return</span> dim;\n  }\n</pre>\n<p>In this sample code, two new model lines are created and the dimension element is generated between them.\n\n<a name=\"2\"></a>\n<h4>Determining References to Wall Faces</h4>\n<p>Returning to your question: to dimension two existing walls instead, you need to obtain references to their respective inside surfaces and pass them in to the NewLinearDimension method.\n\n<p>I discussed various methods to determine specific surfaces on the solids of walls and other elements, e.g.\n\n<ul>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2008/10/slab-boundary.html\">Slab boundary</a>.</li>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2008/11/slab-side-faces.html\">Slab side faces</a>.</li>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2008/11/wall-elevation-profile.html\">Wall elevation profile</a>.</li>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2008/12/2d-polygon-areas-and-outer-loop.html\">2D polygon areas and outer loop</a>.</li>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2008/12/3d-polygon-areas.html\">3D polygon areas</a>.</li>\n</ul>\n<p>For the case you describe, one possibility would be to determine the two closest parallel vertical faces of two respective selected opposing walls.\n\n<p>When querying the wall geometry for their solids and faces, one needs to explicitly specify that references be computed, since these are required for the dimensioning creation.\n\n<p>Since I was unable to find a simple ready-made sample that demonstrates this, and your query is a very valid one, I implemented a new Building Coder sample command CmdDimensionWallsIterateFaces to show the exact steps required.\n\n<p>It is as short and simple as I was able to make it, but still rather complex for a Revit API beginner. \n\n<p>First of all, it makes use of a couple of trivial geometrical comparison and helper methods:\n\n<pre class=\"code\">\n  <span class=\"blue\">const</span> <span class=\"blue\">double</span> _eps = 1.0e-9;\n \n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n  <span class=\"gray\">///</span><span class=\"green\"> Check whether two real numbers are equal</span>\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n  <span class=\"blue\">static</span> <span class=\"blue\">public</span> <span class=\"blue\">bool</span> IsEqual( <span class=\"blue\">double</span> a, <span class=\"blue\">double</span> b )\n  {\n    <span class=\"blue\">return</span> <span class=\"teal\">Math</span>.Abs( a - b ) &lt; _eps;\n  }\n \n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n  <span class=\"gray\">///</span><span class=\"green\"> Check whether two vectors are parallel</span>\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n  <span class=\"blue\">static</span> <span class=\"blue\">public</span> <span class=\"blue\">bool</span> IsParallel( <span class=\"teal\">XYZ</span> a, <span class=\"teal\">XYZ</span> b )\n  {\n    <span class=\"blue\">double</span> angle = a.AngleTo( b );\n    <span class=\"blue\">return</span> _eps &gt; angle || IsEqual( angle, <span class=\"teal\">Math</span>.PI );\n  }\n \n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n  <span class=\"gray\">///</span><span class=\"green\"> Return the midpoint between two points.</span>\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n  <span class=\"blue\">static</span> <span class=\"teal\">XYZ</span> Midpoint( <span class=\"teal\">XYZ</span> p, <span class=\"teal\">XYZ</span> q )\n  {\n    <span class=\"blue\">return</span> p + 0.5 * ( q - p );\n  }\n \n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n  <span class=\"gray\">///</span><span class=\"green\"> Return the midpoint of a Line.</span>\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n  <span class=\"blue\">static</span> <span class=\"teal\">XYZ</span> Midpoint( <span class=\"teal\">Line</span> line )\n  {\n    <span class=\"blue\">return</span> Midpoint( line.get_EndPoint( 0 ),\n      line.get_EndPoint( 1 ) );\n  }\n \n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n  <span class=\"gray\">///</span><span class=\"green\"> Return the normal of a Line in the XY plane.</span>\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n  <span class=\"blue\">static</span> <span class=\"teal\">XYZ</span> Normal( <span class=\"teal\">Line</span> line )\n  {\n    <span class=\"teal\">XYZ</span> p = line.get_EndPoint( 0 );\n    <span class=\"teal\">XYZ</span> q = line.get_EndPoint( 1 );\n    <span class=\"teal\">XYZ</span> v = q - p;\n \n    <span class=\"green\">//Debug.Assert( IsZero( v.Z ), </span>\n    <span class=\"green\">//  \"expected horizontal line\" );</span>\n \n    <span class=\"blue\">return</span> v.CrossProduct( <span class=\"teal\">XYZ</span>.BasisZ ).Normalize();\n  }\n</pre>\n<p>Using these, we can implement a helper method GetClosestFace which returns the closest planar face with a given normal vector to a given point p on the element e:\n\n<pre class=\"code\">\n<span class=\"blue\">static</span> <span class=\"teal\">Face</span> GetClosestFace(\n  <span class=\"teal\">Element</span> e,\n  <span class=\"teal\">XYZ</span> p,\n  <span class=\"teal\">XYZ</span> normal,\n  <span class=\"teal\">Options</span> opt )\n{\n  <span class=\"teal\">Face</span> face = <span class=\"blue\">null</span>;\n  <span class=\"blue\">double</span> min_distance = <span class=\"blue\">double</span>.MaxValue;\n  <span class=\"teal\">GeometryElement</span> geo = e.get_Geometry( opt );\n  <span class=\"teal\">GeometryObjectArray</span> objects = geo.Objects;\n  <span class=\"blue\">foreach</span>( <span class=\"teal\">GeometryObject</span> obj <span class=\"blue\">in</span> objects )\n  {\n    <span class=\"teal\">Solid</span> solid = obj <span class=\"blue\">as</span> <span class=\"teal\">Solid</span>;\n    <span class=\"blue\">if</span>( solid != <span class=\"blue\">null</span> )\n    {\n      <span class=\"teal\">FaceArray</span> fa = solid.Faces;\n      <span class=\"blue\">foreach</span>( <span class=\"teal\">Face</span> f <span class=\"blue\">in</span> fa )\n      {\n        <span class=\"teal\">PlanarFace</span> pf = f <span class=\"blue\">as</span> <span class=\"teal\">PlanarFace</span>;\n \n        <span class=\"teal\">Debug</span>.Assert( <span class=\"blue\">null</span> != pf,\n          <span class=\"maroon\">\"expected planar wall faces\"</span> );\n \n        <span class=\"blue\">if</span>( <span class=\"blue\">null</span> != pf\n          &amp;&amp; <span class=\"teal\">Util</span>.IsParallel( normal, pf.Normal ) )\n        {\n          <span class=\"teal\">XYZ</span> v = p - pf.Origin;\n          <span class=\"blue\">double</span> d = v.DotProduct( -pf.Normal );\n          <span class=\"blue\">if</span>( d &lt; min_distance )\n          {\n            face = f;\n            min_distance = d;\n          }\n        }\n      }\n    }\n  }\n  <span class=\"blue\">return</span> face;\n}\n</pre>\n<p>Once the references on the closest opposing wall faces have been determined and collected into an array, the following helper method creates the dimensioning.\n\n<p>It creates a new dimension element using the given references and dimension line end points.\nIt also opens and commits its own transaction, assuming that no transaction is open yet and manual transaction mode is being used.\n\n<p>Note that I only tested this so far using references to surfaces on planar walls in a plan view:\n\n<pre class=\"code\">\n<span class=\"blue\">public</span> <span class=\"blue\">static</span> <span class=\"blue\">void</span> CreateDimensionElement(\n  <span class=\"teal\">View</span> view,\n  <span class=\"teal\">XYZ</span> p1,\n  <span class=\"teal\">Reference</span> r1,\n  <span class=\"teal\">XYZ</span> p2,\n  <span class=\"teal\">Reference</span> r2 )\n{\n  <span class=\"teal\">Document</span> doc = view.Document;\n  <span class=\"teal\">Application</span> app = doc.Application;\n \n  <span class=\"green\">// creation objects, or factories, for database</span>\n  <span class=\"green\">// and non-database resident instances:</span>\n \n  Autodesk.Revit.Creation.<span class=\"teal\">Application</span> creApp \n    = app.Create;\n \n  Autodesk.Revit.Creation.<span class=\"teal\">Document</span> creDoc \n    = doc.Create;\n \n  <span class=\"teal\">ReferenceArray</span> ra = <span class=\"blue\">new</span> <span class=\"teal\">ReferenceArray</span>();\n \n  ra.Append( r1 );\n  ra.Append( r2 );\n \n  <span class=\"teal\">Line</span> line = creApp.NewLineBound( p1, p2 );\n \n  <span class=\"teal\">Transaction</span> t = <span class=\"blue\">new</span> <span class=\"teal\">Transaction</span>( doc,\n    <span class=\"maroon\">\"Dimension Two Walls\"</span> );\n \n  t.Start();\n \n  <span class=\"teal\">Dimension</span> dim = creDoc.NewDimension(\n    doc.ActiveView, line, ra );\n \n  t.Commit();\n}\n</pre>\n<p>Finally, here is the code of the external command and its Execute method putting all of this to use:\n\n<pre class=\"code\">\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n<span class=\"gray\">///</span><span class=\"green\"> Dimension two opposing parallel walls.</span>\n<span class=\"gray\">///</span><span class=\"green\"> For simplicity, the dimension is defined from </span>\n<span class=\"gray\">///</span><span class=\"green\"> wall midpoint to midpoint, so the walls have </span>\n<span class=\"gray\">///</span><span class=\"green\"> to be exactly opposite each other for it to work.</span>\n<span class=\"gray\">///</span><span class=\"green\"> Iterate the wall solid faces to find the two</span>\n<span class=\"gray\">///</span><span class=\"green\"> closest opposing faces and use references to </span>\n<span class=\"gray\">///</span><span class=\"green\"> them to define the dimension element.</span>\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n[<span class=\"teal\">Transaction</span>( <span class=\"teal\">TransactionMode</span>.Manual )]\n[<span class=\"teal\">Regeneration</span>( <span class=\"teal\">RegenerationOption</span>.Manual )]\n<span class=\"blue\">class</span> <span class=\"teal\">CmdDimensionWallsIterateFaces</span> : <span class=\"teal\">IExternalCommand</span>\n{\n  <span class=\"blue\">const</span> <span class=\"blue\">string</span> _prompt\n    = <span class=\"maroon\">\"Please select two parallel opposing straight walls.\"</span>;\n\n  <span class=\"blue\">public</span> <span class=\"teal\">Result</span> Execute(\n    <span class=\"teal\">ExternalCommandData</span> commandData,\n    <span class=\"blue\">ref</span> <span class=\"blue\">string</span> message,\n    <span class=\"teal\">ElementSet</span> elements )\n  {\n    <span class=\"teal\">UIApplication</span> uiapp = commandData.Application;\n    <span class=\"teal\">UIDocument</span> uidoc = uiapp.ActiveUIDocument;\n    <span class=\"teal\">Application</span> app = uiapp.Application;\n    <span class=\"teal\">Document</span> doc = uidoc.Document;\n \n    <span class=\"green\">// obtain the current selection and pick </span>\n    <span class=\"green\">// out all walls from it:</span>\n \n    <span class=\"teal\">Selection</span> sel = uidoc.Selection;\n    <span class=\"teal\">List</span>&lt;<span class=\"teal\">Wall</span>&gt; walls = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">Wall</span>&gt;( 2 );\n    <span class=\"blue\">foreach</span>( <span class=\"teal\">Element</span> e <span class=\"blue\">in</span> sel.Elements )\n    {\n      <span class=\"blue\">if</span>( e <span class=\"blue\">is</span> <span class=\"teal\">Wall</span> )\n      {\n        walls.Add( e <span class=\"blue\">as</span> <span class=\"teal\">Wall</span> );\n      }\n    }\n \n    <span class=\"blue\">if</span>( 2 != walls.Count )\n    {\n      message = _prompt;\n      <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n    }\n \n    <span class=\"green\">// ensure the two selected walls are straight and </span>\n    <span class=\"green\">// parallel; determine their mutual normal vector </span>\n    <span class=\"green\">// and a point on each wall for distance </span>\n    <span class=\"green\">// calculations:</span>\n \n    <span class=\"teal\">List</span>&lt;<span class=\"teal\">Line</span>&gt; lines = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">Line</span>&gt;( 2 );\n    <span class=\"teal\">List</span>&lt;<span class=\"teal\">XYZ</span>&gt; midpoints = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">XYZ</span>&gt;( 2 );\n    <span class=\"teal\">XYZ</span> normal = <span class=\"blue\">null</span>;\n \n    <span class=\"blue\">foreach</span>( <span class=\"teal\">Wall</span> wall <span class=\"blue\">in</span> walls )\n    {\n      <span class=\"teal\">LocationCurve</span> lc = wall.Location <span class=\"blue\">as</span> <span class=\"teal\">LocationCurve</span>;\n      <span class=\"teal\">Curve</span> curve = lc.Curve;\n \n      <span class=\"blue\">if</span>( !( curve <span class=\"blue\">is</span> <span class=\"teal\">Line</span> ) )\n      {\n        message = _prompt;\n        <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n      }\n \n      <span class=\"teal\">Line</span> l = curve <span class=\"blue\">as</span> <span class=\"teal\">Line</span>;\n      lines.Add( l );\n      midpoints.Add( <span class=\"teal\">Util</span>.Midpoint( l ) );\n \n      <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == normal )\n      {\n        normal = <span class=\"teal\">Util</span>.Normal( l );\n      }\n      <span class=\"blue\">else</span>\n      {\n        <span class=\"blue\">if</span>( !<span class=\"teal\">Util</span>.IsParallel( normal, <span class=\"teal\">Util</span>.Normal( l ) ) )\n        {\n          message = _prompt;\n          <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n        }\n      }\n    }\n \n    <span class=\"green\">// find the two closest facing faces on the walls;</span>\n    <span class=\"green\">// they are vertical faces that are parallel to the </span>\n    <span class=\"green\">// wall curve and closest to the other wall.</span>\n \n    <span class=\"teal\">Options</span> opt = app.Create.NewGeometryOptions();\n \n    opt.ComputeReferences = <span class=\"blue\">true</span>;\n \n    <span class=\"teal\">List</span>&lt;<span class=\"teal\">Face</span>&gt; faces = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">Face</span>&gt;( 2 );\n    faces.Add( GetClosestFace( walls[0], midpoints[1], normal, opt ) );\n    faces.Add( GetClosestFace( walls[1], midpoints[0], normal, opt ) );\n \n    <span class=\"green\">// create the dimensioning:</span>\n \n    CreateDimensionElement( doc.ActiveView,\n      midpoints[0], faces[0].Reference,\n      midpoints[1], faces[1].Reference );\n \n    <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Succeeded;\n  }\n}\n</pre>\n<p>For simplicity, the dimension is defined from wall midpoint to midpoint, so the walls have to be exactly opposite for it to work.\n\n<p>Here is a pretty horrible example of some dimensioning elements created by this command, by repeatedly selecting two opposing parallel walls and then launching it:\n\n<center>\n<img alt=\"Dimensioning two opposing walls\" src=\"img/DimensionTwoWalls.png\"/>\n</center>\n<p>This sample has the following limitations: \n\n<ul>\n<li>The dimension line is defined from wall midpoint to wall midpoint. \nSince the dimension line must be perpendicular to the wall faces, this means that the two opposing wall midpoints must be exactly opposite to each other, i.e. the walls must both be centred respective to the other. \nThis fits your requirements for a lift shaft, I assume, but is a rather special case. \nA more general approach would allow the user to pick a point on one of the walls to define where the dimension line should be placed.\n<li>The creation of the dimension element requires an array of references to the wall solid faces being dimensioned. \nThe solution presented iterates over all the wall solid faces to determine the two required faces and their references. \nA completely different approach to obtain these references which may even be simpler than the explicit iteration presented is to use the high-level FindReferencesByDirection Revit API method. \nIt shoots a ray through the Revit model and reports the elements and their faces and the points on the faces intersected by the ray. \nThis is exactly what we need to decide where the dimension line should be located and which two walls and faces are closest to each other from a given point along a given line. \nThis provides an idea for an obvious second sample implementation demonstrating that approach.\n</li></li></ul>\n<a name=\"3\"></a>\n<h4>Determine Normal Vector Using Cross Product</h4>\n<p><strong>Response:</strong> Although I have success in getting this part of my dimensioning correct,\nI'm not exactly sure how your function 'static XYZ Normal' is working, with the call to v.CrossProduct( XYZ.BasisZ ).Normalize();\nI must admit I'm real fuzzy on what is happening here. \nIs there any way that I can get some type of good and simple explanation on this line of code is doing? \nI'm sure this would help me with my next step of dimensioning.\n\n<p><strong>Answer:</strong> You ask about the meaning of the cross product\n\n<pre class=\"code\">\n  v.CrossProduct( <span class=\"teal\">XYZ</span>.BasisZ ).Normalize()\n</pre>\n<p>That calculates the cross product between two vectors. \nHere is an explanation of the term \n\n<a href=\"http://en.wikipedia.org/wiki/Euclidean_vector\">\nEuclidian vector<a>, and its \n\n<a href=\"http://en.wikipedia.org/wiki/Euclidean_vector\">\nlength and normalisation</a>.\n\nThe calculation of the \n\n<a href=\"http://en.wikipedia.org/wiki/Cross_product\">\ncross product</a> of \n\ntwo vectors produces a third vector perpendicular to both of the input vectors.\nThe code snippet above does just that and then normalises the result, i.e. scales it so that its length equals one.\n\n<p>I will continue with this dimensioning topic and address the next step, using FindReferencesByDirection, in a follow-up post.\n\n<p>Here is\n\n<!-- C:\\a\\doc\\revit\\blog\\zip\\bc_11_86.zip -->\n<a href=\"zip/bc_11_86.zip\">\nversion 2011.0.86.0</a>\n\nof The Building Coder samples including the complete source code and Visual Studio solution of the new command.\nActually, to tell the truth, it includes the next yet-to-be-discussed command as well... psst!\n</p></p></a></a></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p>"
  },
  {
    "original_filename": "0539_dim_walls_it_face",
    "header_text": "Creating Linear Dimensioning",
    "local_header_href": "#creating-linear-dimensioning",
    "chunk_text": "<h4>Creating Linear Dimensioning</h4><p>Linear dimensioning such as you describe is created using the NewDimension method provided by the Creation.Document class. \nThe Revit SDK developer guide \"Revit 2011 API Developer Guide.pdf\" includes a snippet of sample code demonstrating how use this method in Code Region 16-3: Duplicating a dimension with NewDimension:\n\n<pre class=\"code\">\n  <span class=\"blue\">public</span> <span class=\"blue\">void</span> DuplicateDimension(\n    <span class=\"teal\">Document</span> doc,\n    <span class=\"teal\">Dimension</span> dimension )\n  {\n    <span class=\"teal\">Line</span> line = dimension.Curve <span class=\"blue\">as</span> <span class=\"teal\">Line</span>;\n \n    <span class=\"blue\">if</span>( <span class=\"blue\">null</span> != line )\n    {\n      Autodesk.Revit.DB.<span class=\"teal\">View</span> view = dimension.View;\n \n      <span class=\"teal\">ReferenceArray</span> references = dimension.References;\n \n      <span class=\"teal\">Dimension</span> newDimension = doc.Create.NewDimension(\n        view, line, references );\n    }\n  }\n</pre>\n<p>Another sample of interest in this context is Code Region 13-9: Labelling a dimension, since it shows in more detail how the view, reference array, and line arguments can be determined and populated. \nIt works in the context of a family document, however:\n\n<pre class=\"code\">\n  <span class=\"blue\">public</span> <span class=\"teal\">Dimension</span> CreateLinearDimension(\n    <span class=\"teal\">Document</span> doc )\n  {\n    <span class=\"teal\">Application</span> app = doc.Application;\n \n    <span class=\"green\">// first create two lines</span>\n \n    <span class=\"teal\">XYZ</span> pt1 = <span class=\"blue\">new</span> <span class=\"teal\">XYZ</span>( 5, 5, 0 );\n    <span class=\"teal\">XYZ</span> pt2 = <span class=\"blue\">new</span> <span class=\"teal\">XYZ</span>( 5, 10, 0 );\n    <span class=\"teal\">Line</span> line = app.Create.NewLine( pt1, pt2, <span class=\"blue\">true</span> );\n    <span class=\"teal\">Plane</span> plane = app.Create.NewPlane( \n      pt1.CrossProduct( pt2 ), pt2 );\n \n    <span class=\"teal\">SketchPlane</span> skplane = doc.FamilyCreate\n      .NewSketchPlane( plane );\n \n    <span class=\"teal\">ModelCurve</span> modelcurve1 = doc.FamilyCreate\n      .NewModelCurve( line, skplane );\n \n    pt1 = <span class=\"blue\">new</span> <span class=\"teal\">XYZ</span>( 10, 5, 0 );\n    pt2 = <span class=\"blue\">new</span> <span class=\"teal\">XYZ</span>( 10, 10, 0 );\n    line = app.Create.NewLine( pt1, pt2, <span class=\"blue\">true</span> );\n    plane = app.Create.NewPlane( \n      pt1.CrossProduct( pt2 ), pt2 );\n \n    skplane = doc.FamilyCreate\n      .NewSketchPlane( plane );\n \n    <span class=\"teal\">ModelCurve</span> modelcurve2 = doc.FamilyCreate\n      .NewModelCurve( line, skplane );\n \n    <span class=\"green\">// now create a linear dimension between them</span>\n \n    <span class=\"teal\">ReferenceArray</span> ra = <span class=\"blue\">new</span> <span class=\"teal\">ReferenceArray</span>();\n    ra.Append( modelcurve1.GeometryCurve.Reference );\n    ra.Append( modelcurve2.GeometryCurve.Reference );\n \n    pt1 = <span class=\"blue\">new</span> <span class=\"teal\">XYZ</span>( 5, 10, 0 );\n    pt2 = <span class=\"blue\">new</span> <span class=\"teal\">XYZ</span>( 10, 10, 0 );\n    line = app.Create.NewLine( pt1, pt2, <span class=\"blue\">true</span> );\n    <span class=\"teal\">Dimension</span> dim = doc.FamilyCreate\n      .NewLinearDimension( doc.ActiveView, line, ra );\n \n    <span class=\"green\">// create a label for the dimension called \"width\"</span>\n \n    <span class=\"teal\">FamilyParameter</span> param = doc.FamilyManager\n      .AddParameter( <span class=\"maroon\">\"width\"</span>,\n        <span class=\"teal\">BuiltInParameterGroup</span>.PG_CONSTRAINTS,\n        <span class=\"teal\">ParameterType</span>.Length, <span class=\"blue\">false</span> );\n \n    dim.Label = param;\n \n    <span class=\"blue\">return</span> dim;\n  }\n</pre>\n<p>In this sample code, two new model lines are created and the dimension element is generated between them.\n\n<a name=\"2\"></a>\n<h4>Determining References to Wall Faces</h4>\n<p>Returning to your question: to dimension two existing walls instead, you need to obtain references to their respective inside surfaces and pass them in to the NewLinearDimension method.\n\n<p>I discussed various methods to determine specific surfaces on the solids of walls and other elements, e.g.\n\n<ul>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2008/10/slab-boundary.html\">Slab boundary</a>.</li>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2008/11/slab-side-faces.html\">Slab side faces</a>.</li>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2008/11/wall-elevation-profile.html\">Wall elevation profile</a>.</li>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2008/12/2d-polygon-areas-and-outer-loop.html\">2D polygon areas and outer loop</a>.</li>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2008/12/3d-polygon-areas.html\">3D polygon areas</a>.</li>\n</ul>\n<p>For the case you describe, one possibility would be to determine the two closest parallel vertical faces of two respective selected opposing walls.\n\n<p>When querying the wall geometry for their solids and faces, one needs to explicitly specify that references be computed, since these are required for the dimensioning creation.\n\n<p>Since I was unable to find a simple ready-made sample that demonstrates this, and your query is a very valid one, I implemented a new Building Coder sample command CmdDimensionWallsIterateFaces to show the exact steps required.\n\n<p>It is as short and simple as I was able to make it, but still rather complex for a Revit API beginner. \n\n<p>First of all, it makes use of a couple of trivial geometrical comparison and helper methods:\n\n<pre class=\"code\">\n  <span class=\"blue\">const</span> <span class=\"blue\">double</span> _eps = 1.0e-9;\n \n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n  <span class=\"gray\">///</span><span class=\"green\"> Check whether two real numbers are equal</span>\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n  <span class=\"blue\">static</span> <span class=\"blue\">public</span> <span class=\"blue\">bool</span> IsEqual( <span class=\"blue\">double</span> a, <span class=\"blue\">double</span> b )\n  {\n    <span class=\"blue\">return</span> <span class=\"teal\">Math</span>.Abs( a - b ) &lt; _eps;\n  }\n \n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n  <span class=\"gray\">///</span><span class=\"green\"> Check whether two vectors are parallel</span>\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n  <span class=\"blue\">static</span> <span class=\"blue\">public</span> <span class=\"blue\">bool</span> IsParallel( <span class=\"teal\">XYZ</span> a, <span class=\"teal\">XYZ</span> b )\n  {\n    <span class=\"blue\">double</span> angle = a.AngleTo( b );\n    <span class=\"blue\">return</span> _eps &gt; angle || IsEqual( angle, <span class=\"teal\">Math</span>.PI );\n  }\n \n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n  <span class=\"gray\">///</span><span class=\"green\"> Return the midpoint between two points.</span>\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n  <span class=\"blue\">static</span> <span class=\"teal\">XYZ</span> Midpoint( <span class=\"teal\">XYZ</span> p, <span class=\"teal\">XYZ</span> q )\n  {\n    <span class=\"blue\">return</span> p + 0.5 * ( q - p );\n  }\n \n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n  <span class=\"gray\">///</span><span class=\"green\"> Return the midpoint of a Line.</span>\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n  <span class=\"blue\">static</span> <span class=\"teal\">XYZ</span> Midpoint( <span class=\"teal\">Line</span> line )\n  {\n    <span class=\"blue\">return</span> Midpoint( line.get_EndPoint( 0 ),\n      line.get_EndPoint( 1 ) );\n  }\n \n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n  <span class=\"gray\">///</span><span class=\"green\"> Return the normal of a Line in the XY plane.</span>\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n  <span class=\"blue\">static</span> <span class=\"teal\">XYZ</span> Normal( <span class=\"teal\">Line</span> line )\n  {\n    <span class=\"teal\">XYZ</span> p = line.get_EndPoint( 0 );\n    <span class=\"teal\">XYZ</span> q = line.get_EndPoint( 1 );\n    <span class=\"teal\">XYZ</span> v = q - p;\n \n    <span class=\"green\">//Debug.Assert( IsZero( v.Z ), </span>\n    <span class=\"green\">//  \"expected horizontal line\" );</span>\n \n    <span class=\"blue\">return</span> v.CrossProduct( <span class=\"teal\">XYZ</span>.BasisZ ).Normalize();\n  }\n</pre>\n<p>Using these, we can implement a helper method GetClosestFace which returns the closest planar face with a given normal vector to a given point p on the element e:\n\n<pre class=\"code\">\n<span class=\"blue\">static</span> <span class=\"teal\">Face</span> GetClosestFace(\n  <span class=\"teal\">Element</span> e,\n  <span class=\"teal\">XYZ</span> p,\n  <span class=\"teal\">XYZ</span> normal,\n  <span class=\"teal\">Options</span> opt )\n{\n  <span class=\"teal\">Face</span> face = <span class=\"blue\">null</span>;\n  <span class=\"blue\">double</span> min_distance = <span class=\"blue\">double</span>.MaxValue;\n  <span class=\"teal\">GeometryElement</span> geo = e.get_Geometry( opt );\n  <span class=\"teal\">GeometryObjectArray</span> objects = geo.Objects;\n  <span class=\"blue\">foreach</span>( <span class=\"teal\">GeometryObject</span> obj <span class=\"blue\">in</span> objects )\n  {\n    <span class=\"teal\">Solid</span> solid = obj <span class=\"blue\">as</span> <span class=\"teal\">Solid</span>;\n    <span class=\"blue\">if</span>( solid != <span class=\"blue\">null</span> )\n    {\n      <span class=\"teal\">FaceArray</span> fa = solid.Faces;\n      <span class=\"blue\">foreach</span>( <span class=\"teal\">Face</span> f <span class=\"blue\">in</span> fa )\n      {\n        <span class=\"teal\">PlanarFace</span> pf = f <span class=\"blue\">as</span> <span class=\"teal\">PlanarFace</span>;\n \n        <span class=\"teal\">Debug</span>.Assert( <span class=\"blue\">null</span> != pf,\n          <span class=\"maroon\">\"expected planar wall faces\"</span> );\n \n        <span class=\"blue\">if</span>( <span class=\"blue\">null</span> != pf\n          &amp;&amp; <span class=\"teal\">Util</span>.IsParallel( normal, pf.Normal ) )\n        {\n          <span class=\"teal\">XYZ</span> v = p - pf.Origin;\n          <span class=\"blue\">double</span> d = v.DotProduct( -pf.Normal );\n          <span class=\"blue\">if</span>( d &lt; min_distance )\n          {\n            face = f;\n            min_distance = d;\n          }\n        }\n      }\n    }\n  }\n  <span class=\"blue\">return</span> face;\n}\n</pre>\n<p>Once the references on the closest opposing wall faces have been determined and collected into an array, the following helper method creates the dimensioning.\n\n<p>It creates a new dimension element using the given references and dimension line end points.\nIt also opens and commits its own transaction, assuming that no transaction is open yet and manual transaction mode is being used.\n\n<p>Note that I only tested this so far using references to surfaces on planar walls in a plan view:\n\n<pre class=\"code\">\n<span class=\"blue\">public</span> <span class=\"blue\">static</span> <span class=\"blue\">void</span> CreateDimensionElement(\n  <span class=\"teal\">View</span> view,\n  <span class=\"teal\">XYZ</span> p1,\n  <span class=\"teal\">Reference</span> r1,\n  <span class=\"teal\">XYZ</span> p2,\n  <span class=\"teal\">Reference</span> r2 )\n{\n  <span class=\"teal\">Document</span> doc = view.Document;\n  <span class=\"teal\">Application</span> app = doc.Application;\n \n  <span class=\"green\">// creation objects, or factories, for database</span>\n  <span class=\"green\">// and non-database resident instances:</span>\n \n  Autodesk.Revit.Creation.<span class=\"teal\">Application</span> creApp \n    = app.Create;\n \n  Autodesk.Revit.Creation.<span class=\"teal\">Document</span> creDoc \n    = doc.Create;\n \n  <span class=\"teal\">ReferenceArray</span> ra = <span class=\"blue\">new</span> <span class=\"teal\">ReferenceArray</span>();\n \n  ra.Append( r1 );\n  ra.Append( r2 );\n \n  <span class=\"teal\">Line</span> line = creApp.NewLineBound( p1, p2 );\n \n  <span class=\"teal\">Transaction</span> t = <span class=\"blue\">new</span> <span class=\"teal\">Transaction</span>( doc,\n    <span class=\"maroon\">\"Dimension Two Walls\"</span> );\n \n  t.Start();\n \n  <span class=\"teal\">Dimension</span> dim = creDoc.NewDimension(\n    doc.ActiveView, line, ra );\n \n  t.Commit();\n}\n</pre>\n<p>Finally, here is the code of the external command and its Execute method putting all of this to use:\n\n<pre class=\"code\">\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n<span class=\"gray\">///</span><span class=\"green\"> Dimension two opposing parallel walls.</span>\n<span class=\"gray\">///</span><span class=\"green\"> For simplicity, the dimension is defined from </span>\n<span class=\"gray\">///</span><span class=\"green\"> wall midpoint to midpoint, so the walls have </span>\n<span class=\"gray\">///</span><span class=\"green\"> to be exactly opposite each other for it to work.</span>\n<span class=\"gray\">///</span><span class=\"green\"> Iterate the wall solid faces to find the two</span>\n<span class=\"gray\">///</span><span class=\"green\"> closest opposing faces and use references to </span>\n<span class=\"gray\">///</span><span class=\"green\"> them to define the dimension element.</span>\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n[<span class=\"teal\">Transaction</span>( <span class=\"teal\">TransactionMode</span>.Manual )]\n[<span class=\"teal\">Regeneration</span>( <span class=\"teal\">RegenerationOption</span>.Manual )]\n<span class=\"blue\">class</span> <span class=\"teal\">CmdDimensionWallsIterateFaces</span> : <span class=\"teal\">IExternalCommand</span>\n{\n  <span class=\"blue\">const</span> <span class=\"blue\">string</span> _prompt\n    = <span class=\"maroon\">\"Please select two parallel opposing straight walls.\"</span>;\n\n  <span class=\"blue\">public</span> <span class=\"teal\">Result</span> Execute(\n    <span class=\"teal\">ExternalCommandData</span> commandData,\n    <span class=\"blue\">ref</span> <span class=\"blue\">string</span> message,\n    <span class=\"teal\">ElementSet</span> elements )\n  {\n    <span class=\"teal\">UIApplication</span> uiapp = commandData.Application;\n    <span class=\"teal\">UIDocument</span> uidoc = uiapp.ActiveUIDocument;\n    <span class=\"teal\">Application</span> app = uiapp.Application;\n    <span class=\"teal\">Document</span> doc = uidoc.Document;\n \n    <span class=\"green\">// obtain the current selection and pick </span>\n    <span class=\"green\">// out all walls from it:</span>\n \n    <span class=\"teal\">Selection</span> sel = uidoc.Selection;\n    <span class=\"teal\">List</span>&lt;<span class=\"teal\">Wall</span>&gt; walls = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">Wall</span>&gt;( 2 );\n    <span class=\"blue\">foreach</span>( <span class=\"teal\">Element</span> e <span class=\"blue\">in</span> sel.Elements )\n    {\n      <span class=\"blue\">if</span>( e <span class=\"blue\">is</span> <span class=\"teal\">Wall</span> )\n      {\n        walls.Add( e <span class=\"blue\">as</span> <span class=\"teal\">Wall</span> );\n      }\n    }\n \n    <span class=\"blue\">if</span>( 2 != walls.Count )\n    {\n      message = _prompt;\n      <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n    }\n \n    <span class=\"green\">// ensure the two selected walls are straight and </span>\n    <span class=\"green\">// parallel; determine their mutual normal vector </span>\n    <span class=\"green\">// and a point on each wall for distance </span>\n    <span class=\"green\">// calculations:</span>\n \n    <span class=\"teal\">List</span>&lt;<span class=\"teal\">Line</span>&gt; lines = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">Line</span>&gt;( 2 );\n    <span class=\"teal\">List</span>&lt;<span class=\"teal\">XYZ</span>&gt; midpoints = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">XYZ</span>&gt;( 2 );\n    <span class=\"teal\">XYZ</span> normal = <span class=\"blue\">null</span>;\n \n    <span class=\"blue\">foreach</span>( <span class=\"teal\">Wall</span> wall <span class=\"blue\">in</span> walls )\n    {\n      <span class=\"teal\">LocationCurve</span> lc = wall.Location <span class=\"blue\">as</span> <span class=\"teal\">LocationCurve</span>;\n      <span class=\"teal\">Curve</span> curve = lc.Curve;\n \n      <span class=\"blue\">if</span>( !( curve <span class=\"blue\">is</span> <span class=\"teal\">Line</span> ) )\n      {\n        message = _prompt;\n        <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n      }\n \n      <span class=\"teal\">Line</span> l = curve <span class=\"blue\">as</span> <span class=\"teal\">Line</span>;\n      lines.Add( l );\n      midpoints.Add( <span class=\"teal\">Util</span>.Midpoint( l ) );\n \n      <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == normal )\n      {\n        normal = <span class=\"teal\">Util</span>.Normal( l );\n      }\n      <span class=\"blue\">else</span>\n      {\n        <span class=\"blue\">if</span>( !<span class=\"teal\">Util</span>.IsParallel( normal, <span class=\"teal\">Util</span>.Normal( l ) ) )\n        {\n          message = _prompt;\n          <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n        }\n      }\n    }\n \n    <span class=\"green\">// find the two closest facing faces on the walls;</span>\n    <span class=\"green\">// they are vertical faces that are parallel to the </span>\n    <span class=\"green\">// wall curve and closest to the other wall.</span>\n \n    <span class=\"teal\">Options</span> opt = app.Create.NewGeometryOptions();\n \n    opt.ComputeReferences = <span class=\"blue\">true</span>;\n \n    <span class=\"teal\">List</span>&lt;<span class=\"teal\">Face</span>&gt; faces = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">Face</span>&gt;( 2 );\n    faces.Add( GetClosestFace( walls[0], midpoints[1], normal, opt ) );\n    faces.Add( GetClosestFace( walls[1], midpoints[0], normal, opt ) );\n \n    <span class=\"green\">// create the dimensioning:</span>\n \n    CreateDimensionElement( doc.ActiveView,\n      midpoints[0], faces[0].Reference,\n      midpoints[1], faces[1].Reference );\n \n    <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Succeeded;\n  }\n}\n</pre>\n<p>For simplicity, the dimension is defined from wall midpoint to midpoint, so the walls have to be exactly opposite for it to work.\n\n<p>Here is a pretty horrible example of some dimensioning elements created by this command, by repeatedly selecting two opposing parallel walls and then launching it:\n\n<center>\n<img alt=\"Dimensioning two opposing walls\" src=\"img/DimensionTwoWalls.png\"/>\n</center>\n<p>This sample has the following limitations: \n\n<ul>\n<li>The dimension line is defined from wall midpoint to wall midpoint. \nSince the dimension line must be perpendicular to the wall faces, this means that the two opposing wall midpoints must be exactly opposite to each other, i.e. the walls must both be centred respective to the other. \nThis fits your requirements for a lift shaft, I assume, but is a rather special case. \nA more general approach would allow the user to pick a point on one of the walls to define where the dimension line should be placed.\n<li>The creation of the dimension element requires an array of references to the wall solid faces being dimensioned. \nThe solution presented iterates over all the wall solid faces to determine the two required faces and their references. \nA completely different approach to obtain these references which may even be simpler than the explicit iteration presented is to use the high-level FindReferencesByDirection Revit API method. \nIt shoots a ray through the Revit model and reports the elements and their faces and the points on the faces intersected by the ray. \nThis is exactly what we need to decide where the dimension line should be located and which two walls and faces are closest to each other from a given point along a given line. \nThis provides an idea for an obvious second sample implementation demonstrating that approach.\n</li></li></ul>\n<a name=\"3\"></a>\n<h4>Determine Normal Vector Using Cross Product</h4>\n<p><strong>Response:</strong> Although I have success in getting this part of my dimensioning correct,\nI'm not exactly sure how your function 'static XYZ Normal' is working, with the call to v.CrossProduct( XYZ.BasisZ ).Normalize();\nI must admit I'm real fuzzy on what is happening here. \nIs there any way that I can get some type of good and simple explanation on this line of code is doing? \nI'm sure this would help me with my next step of dimensioning.\n\n<p><strong>Answer:</strong> You ask about the meaning of the cross product\n\n<pre class=\"code\">\n  v.CrossProduct( <span class=\"teal\">XYZ</span>.BasisZ ).Normalize()\n</pre>\n<p>That calculates the cross product between two vectors. \nHere is an explanation of the term \n\n<a href=\"http://en.wikipedia.org/wiki/Euclidean_vector\">\nEuclidian vector<a>, and its \n\n<a href=\"http://en.wikipedia.org/wiki/Euclidean_vector\">\nlength and normalisation</a>.\n\nThe calculation of the \n\n<a href=\"http://en.wikipedia.org/wiki/Cross_product\">\ncross product</a> of \n\ntwo vectors produces a third vector perpendicular to both of the input vectors.\nThe code snippet above does just that and then normalises the result, i.e. scales it so that its length equals one.\n\n<p>I will continue with this dimensioning topic and address the next step, using FindReferencesByDirection, in a follow-up post.\n\n<p>Here is\n\n<!-- C:\\a\\doc\\revit\\blog\\zip\\bc_11_86.zip -->\n<a href=\"zip/bc_11_86.zip\">\nversion 2011.0.86.0</a>\n\nof The Building Coder samples including the complete source code and Visual Studio solution of the new command.\nActually, to tell the truth, it includes the next yet-to-be-discussed command as well... psst!\n</p></p></a></a></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p>"
  },
  {
    "original_filename": "0539_dim_walls_it_face",
    "header_text": "Determining References to Wall Faces",
    "local_header_href": "#determining-references-to-wall-faces",
    "chunk_text": "<h4>Determining References to Wall Faces</h4><p>Returning to your question: to dimension two existing walls instead, you need to obtain references to their respective inside surfaces and pass them in to the NewLinearDimension method.\n\n<p>I discussed various methods to determine specific surfaces on the solids of walls and other elements, e.g.\n\n<ul>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2008/10/slab-boundary.html\">Slab boundary</a>.</li>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2008/11/slab-side-faces.html\">Slab side faces</a>.</li>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2008/11/wall-elevation-profile.html\">Wall elevation profile</a>.</li>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2008/12/2d-polygon-areas-and-outer-loop.html\">2D polygon areas and outer loop</a>.</li>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2008/12/3d-polygon-areas.html\">3D polygon areas</a>.</li>\n</ul>\n<p>For the case you describe, one possibility would be to determine the two closest parallel vertical faces of two respective selected opposing walls.\n\n<p>When querying the wall geometry for their solids and faces, one needs to explicitly specify that references be computed, since these are required for the dimensioning creation.\n\n<p>Since I was unable to find a simple ready-made sample that demonstrates this, and your query is a very valid one, I implemented a new Building Coder sample command CmdDimensionWallsIterateFaces to show the exact steps required.\n\n<p>It is as short and simple as I was able to make it, but still rather complex for a Revit API beginner. \n\n<p>First of all, it makes use of a couple of trivial geometrical comparison and helper methods:\n\n<pre class=\"code\">\n  <span class=\"blue\">const</span> <span class=\"blue\">double</span> _eps = 1.0e-9;\n \n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n  <span class=\"gray\">///</span><span class=\"green\"> Check whether two real numbers are equal</span>\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n  <span class=\"blue\">static</span> <span class=\"blue\">public</span> <span class=\"blue\">bool</span> IsEqual( <span class=\"blue\">double</span> a, <span class=\"blue\">double</span> b )\n  {\n    <span class=\"blue\">return</span> <span class=\"teal\">Math</span>.Abs( a - b ) &lt; _eps;\n  }\n \n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n  <span class=\"gray\">///</span><span class=\"green\"> Check whether two vectors are parallel</span>\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n  <span class=\"blue\">static</span> <span class=\"blue\">public</span> <span class=\"blue\">bool</span> IsParallel( <span class=\"teal\">XYZ</span> a, <span class=\"teal\">XYZ</span> b )\n  {\n    <span class=\"blue\">double</span> angle = a.AngleTo( b );\n    <span class=\"blue\">return</span> _eps &gt; angle || IsEqual( angle, <span class=\"teal\">Math</span>.PI );\n  }\n \n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n  <span class=\"gray\">///</span><span class=\"green\"> Return the midpoint between two points.</span>\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n  <span class=\"blue\">static</span> <span class=\"teal\">XYZ</span> Midpoint( <span class=\"teal\">XYZ</span> p, <span class=\"teal\">XYZ</span> q )\n  {\n    <span class=\"blue\">return</span> p + 0.5 * ( q - p );\n  }\n \n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n  <span class=\"gray\">///</span><span class=\"green\"> Return the midpoint of a Line.</span>\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n  <span class=\"blue\">static</span> <span class=\"teal\">XYZ</span> Midpoint( <span class=\"teal\">Line</span> line )\n  {\n    <span class=\"blue\">return</span> Midpoint( line.get_EndPoint( 0 ),\n      line.get_EndPoint( 1 ) );\n  }\n \n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n  <span class=\"gray\">///</span><span class=\"green\"> Return the normal of a Line in the XY plane.</span>\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n  <span class=\"blue\">static</span> <span class=\"teal\">XYZ</span> Normal( <span class=\"teal\">Line</span> line )\n  {\n    <span class=\"teal\">XYZ</span> p = line.get_EndPoint( 0 );\n    <span class=\"teal\">XYZ</span> q = line.get_EndPoint( 1 );\n    <span class=\"teal\">XYZ</span> v = q - p;\n \n    <span class=\"green\">//Debug.Assert( IsZero( v.Z ), </span>\n    <span class=\"green\">//  \"expected horizontal line\" );</span>\n \n    <span class=\"blue\">return</span> v.CrossProduct( <span class=\"teal\">XYZ</span>.BasisZ ).Normalize();\n  }\n</pre>\n<p>Using these, we can implement a helper method GetClosestFace which returns the closest planar face with a given normal vector to a given point p on the element e:\n\n<pre class=\"code\">\n<span class=\"blue\">static</span> <span class=\"teal\">Face</span> GetClosestFace(\n  <span class=\"teal\">Element</span> e,\n  <span class=\"teal\">XYZ</span> p,\n  <span class=\"teal\">XYZ</span> normal,\n  <span class=\"teal\">Options</span> opt )\n{\n  <span class=\"teal\">Face</span> face = <span class=\"blue\">null</span>;\n  <span class=\"blue\">double</span> min_distance = <span class=\"blue\">double</span>.MaxValue;\n  <span class=\"teal\">GeometryElement</span> geo = e.get_Geometry( opt );\n  <span class=\"teal\">GeometryObjectArray</span> objects = geo.Objects;\n  <span class=\"blue\">foreach</span>( <span class=\"teal\">GeometryObject</span> obj <span class=\"blue\">in</span> objects )\n  {\n    <span class=\"teal\">Solid</span> solid = obj <span class=\"blue\">as</span> <span class=\"teal\">Solid</span>;\n    <span class=\"blue\">if</span>( solid != <span class=\"blue\">null</span> )\n    {\n      <span class=\"teal\">FaceArray</span> fa = solid.Faces;\n      <span class=\"blue\">foreach</span>( <span class=\"teal\">Face</span> f <span class=\"blue\">in</span> fa )\n      {\n        <span class=\"teal\">PlanarFace</span> pf = f <span class=\"blue\">as</span> <span class=\"teal\">PlanarFace</span>;\n \n        <span class=\"teal\">Debug</span>.Assert( <span class=\"blue\">null</span> != pf,\n          <span class=\"maroon\">\"expected planar wall faces\"</span> );\n \n        <span class=\"blue\">if</span>( <span class=\"blue\">null</span> != pf\n          &amp;&amp; <span class=\"teal\">Util</span>.IsParallel( normal, pf.Normal ) )\n        {\n          <span class=\"teal\">XYZ</span> v = p - pf.Origin;\n          <span class=\"blue\">double</span> d = v.DotProduct( -pf.Normal );\n          <span class=\"blue\">if</span>( d &lt; min_distance )\n          {\n            face = f;\n            min_distance = d;\n          }\n        }\n      }\n    }\n  }\n  <span class=\"blue\">return</span> face;\n}\n</pre>\n<p>Once the references on the closest opposing wall faces have been determined and collected into an array, the following helper method creates the dimensioning.\n\n<p>It creates a new dimension element using the given references and dimension line end points.\nIt also opens and commits its own transaction, assuming that no transaction is open yet and manual transaction mode is being used.\n\n<p>Note that I only tested this so far using references to surfaces on planar walls in a plan view:\n\n<pre class=\"code\">\n<span class=\"blue\">public</span> <span class=\"blue\">static</span> <span class=\"blue\">void</span> CreateDimensionElement(\n  <span class=\"teal\">View</span> view,\n  <span class=\"teal\">XYZ</span> p1,\n  <span class=\"teal\">Reference</span> r1,\n  <span class=\"teal\">XYZ</span> p2,\n  <span class=\"teal\">Reference</span> r2 )\n{\n  <span class=\"teal\">Document</span> doc = view.Document;\n  <span class=\"teal\">Application</span> app = doc.Application;\n \n  <span class=\"green\">// creation objects, or factories, for database</span>\n  <span class=\"green\">// and non-database resident instances:</span>\n \n  Autodesk.Revit.Creation.<span class=\"teal\">Application</span> creApp \n    = app.Create;\n \n  Autodesk.Revit.Creation.<span class=\"teal\">Document</span> creDoc \n    = doc.Create;\n \n  <span class=\"teal\">ReferenceArray</span> ra = <span class=\"blue\">new</span> <span class=\"teal\">ReferenceArray</span>();\n \n  ra.Append( r1 );\n  ra.Append( r2 );\n \n  <span class=\"teal\">Line</span> line = creApp.NewLineBound( p1, p2 );\n \n  <span class=\"teal\">Transaction</span> t = <span class=\"blue\">new</span> <span class=\"teal\">Transaction</span>( doc,\n    <span class=\"maroon\">\"Dimension Two Walls\"</span> );\n \n  t.Start();\n \n  <span class=\"teal\">Dimension</span> dim = creDoc.NewDimension(\n    doc.ActiveView, line, ra );\n \n  t.Commit();\n}\n</pre>\n<p>Finally, here is the code of the external command and its Execute method putting all of this to use:\n\n<pre class=\"code\">\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n<span class=\"gray\">///</span><span class=\"green\"> Dimension two opposing parallel walls.</span>\n<span class=\"gray\">///</span><span class=\"green\"> For simplicity, the dimension is defined from </span>\n<span class=\"gray\">///</span><span class=\"green\"> wall midpoint to midpoint, so the walls have </span>\n<span class=\"gray\">///</span><span class=\"green\"> to be exactly opposite each other for it to work.</span>\n<span class=\"gray\">///</span><span class=\"green\"> Iterate the wall solid faces to find the two</span>\n<span class=\"gray\">///</span><span class=\"green\"> closest opposing faces and use references to </span>\n<span class=\"gray\">///</span><span class=\"green\"> them to define the dimension element.</span>\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n[<span class=\"teal\">Transaction</span>( <span class=\"teal\">TransactionMode</span>.Manual )]\n[<span class=\"teal\">Regeneration</span>( <span class=\"teal\">RegenerationOption</span>.Manual )]\n<span class=\"blue\">class</span> <span class=\"teal\">CmdDimensionWallsIterateFaces</span> : <span class=\"teal\">IExternalCommand</span>\n{\n  <span class=\"blue\">const</span> <span class=\"blue\">string</span> _prompt\n    = <span class=\"maroon\">\"Please select two parallel opposing straight walls.\"</span>;\n\n  <span class=\"blue\">public</span> <span class=\"teal\">Result</span> Execute(\n    <span class=\"teal\">ExternalCommandData</span> commandData,\n    <span class=\"blue\">ref</span> <span class=\"blue\">string</span> message,\n    <span class=\"teal\">ElementSet</span> elements )\n  {\n    <span class=\"teal\">UIApplication</span> uiapp = commandData.Application;\n    <span class=\"teal\">UIDocument</span> uidoc = uiapp.ActiveUIDocument;\n    <span class=\"teal\">Application</span> app = uiapp.Application;\n    <span class=\"teal\">Document</span> doc = uidoc.Document;\n \n    <span class=\"green\">// obtain the current selection and pick </span>\n    <span class=\"green\">// out all walls from it:</span>\n \n    <span class=\"teal\">Selection</span> sel = uidoc.Selection;\n    <span class=\"teal\">List</span>&lt;<span class=\"teal\">Wall</span>&gt; walls = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">Wall</span>&gt;( 2 );\n    <span class=\"blue\">foreach</span>( <span class=\"teal\">Element</span> e <span class=\"blue\">in</span> sel.Elements )\n    {\n      <span class=\"blue\">if</span>( e <span class=\"blue\">is</span> <span class=\"teal\">Wall</span> )\n      {\n        walls.Add( e <span class=\"blue\">as</span> <span class=\"teal\">Wall</span> );\n      }\n    }\n \n    <span class=\"blue\">if</span>( 2 != walls.Count )\n    {\n      message = _prompt;\n      <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n    }\n \n    <span class=\"green\">// ensure the two selected walls are straight and </span>\n    <span class=\"green\">// parallel; determine their mutual normal vector </span>\n    <span class=\"green\">// and a point on each wall for distance </span>\n    <span class=\"green\">// calculations:</span>\n \n    <span class=\"teal\">List</span>&lt;<span class=\"teal\">Line</span>&gt; lines = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">Line</span>&gt;( 2 );\n    <span class=\"teal\">List</span>&lt;<span class=\"teal\">XYZ</span>&gt; midpoints = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">XYZ</span>&gt;( 2 );\n    <span class=\"teal\">XYZ</span> normal = <span class=\"blue\">null</span>;\n \n    <span class=\"blue\">foreach</span>( <span class=\"teal\">Wall</span> wall <span class=\"blue\">in</span> walls )\n    {\n      <span class=\"teal\">LocationCurve</span> lc = wall.Location <span class=\"blue\">as</span> <span class=\"teal\">LocationCurve</span>;\n      <span class=\"teal\">Curve</span> curve = lc.Curve;\n \n      <span class=\"blue\">if</span>( !( curve <span class=\"blue\">is</span> <span class=\"teal\">Line</span> ) )\n      {\n        message = _prompt;\n        <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n      }\n \n      <span class=\"teal\">Line</span> l = curve <span class=\"blue\">as</span> <span class=\"teal\">Line</span>;\n      lines.Add( l );\n      midpoints.Add( <span class=\"teal\">Util</span>.Midpoint( l ) );\n \n      <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == normal )\n      {\n        normal = <span class=\"teal\">Util</span>.Normal( l );\n      }\n      <span class=\"blue\">else</span>\n      {\n        <span class=\"blue\">if</span>( !<span class=\"teal\">Util</span>.IsParallel( normal, <span class=\"teal\">Util</span>.Normal( l ) ) )\n        {\n          message = _prompt;\n          <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n        }\n      }\n    }\n \n    <span class=\"green\">// find the two closest facing faces on the walls;</span>\n    <span class=\"green\">// they are vertical faces that are parallel to the </span>\n    <span class=\"green\">// wall curve and closest to the other wall.</span>\n \n    <span class=\"teal\">Options</span> opt = app.Create.NewGeometryOptions();\n \n    opt.ComputeReferences = <span class=\"blue\">true</span>;\n \n    <span class=\"teal\">List</span>&lt;<span class=\"teal\">Face</span>&gt; faces = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">Face</span>&gt;( 2 );\n    faces.Add( GetClosestFace( walls[0], midpoints[1], normal, opt ) );\n    faces.Add( GetClosestFace( walls[1], midpoints[0], normal, opt ) );\n \n    <span class=\"green\">// create the dimensioning:</span>\n \n    CreateDimensionElement( doc.ActiveView,\n      midpoints[0], faces[0].Reference,\n      midpoints[1], faces[1].Reference );\n \n    <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Succeeded;\n  }\n}\n</pre>\n<p>For simplicity, the dimension is defined from wall midpoint to midpoint, so the walls have to be exactly opposite for it to work.\n\n<p>Here is a pretty horrible example of some dimensioning elements created by this command, by repeatedly selecting two opposing parallel walls and then launching it:\n\n<center>\n<img alt=\"Dimensioning two opposing walls\" src=\"img/DimensionTwoWalls.png\"/>\n</center>\n<p>This sample has the following limitations: \n\n<ul>\n<li>The dimension line is defined from wall midpoint to wall midpoint. \nSince the dimension line must be perpendicular to the wall faces, this means that the two opposing wall midpoints must be exactly opposite to each other, i.e. the walls must both be centred respective to the other. \nThis fits your requirements for a lift shaft, I assume, but is a rather special case. \nA more general approach would allow the user to pick a point on one of the walls to define where the dimension line should be placed.\n<li>The creation of the dimension element requires an array of references to the wall solid faces being dimensioned. \nThe solution presented iterates over all the wall solid faces to determine the two required faces and their references. \nA completely different approach to obtain these references which may even be simpler than the explicit iteration presented is to use the high-level FindReferencesByDirection Revit API method. \nIt shoots a ray through the Revit model and reports the elements and their faces and the points on the faces intersected by the ray. \nThis is exactly what we need to decide where the dimension line should be located and which two walls and faces are closest to each other from a given point along a given line. \nThis provides an idea for an obvious second sample implementation demonstrating that approach.\n</li></li></ul>\n<a name=\"3\"></a>\n<h4>Determine Normal Vector Using Cross Product</h4>\n<p><strong>Response:</strong> Although I have success in getting this part of my dimensioning correct,\nI'm not exactly sure how your function 'static XYZ Normal' is working, with the call to v.CrossProduct( XYZ.BasisZ ).Normalize();\nI must admit I'm real fuzzy on what is happening here. \nIs there any way that I can get some type of good and simple explanation on this line of code is doing? \nI'm sure this would help me with my next step of dimensioning.\n\n<p><strong>Answer:</strong> You ask about the meaning of the cross product\n\n<pre class=\"code\">\n  v.CrossProduct( <span class=\"teal\">XYZ</span>.BasisZ ).Normalize()\n</pre>\n<p>That calculates the cross product between two vectors. \nHere is an explanation of the term \n\n<a href=\"http://en.wikipedia.org/wiki/Euclidean_vector\">\nEuclidian vector<a>, and its \n\n<a href=\"http://en.wikipedia.org/wiki/Euclidean_vector\">\nlength and normalisation</a>.\n\nThe calculation of the \n\n<a href=\"http://en.wikipedia.org/wiki/Cross_product\">\ncross product</a> of \n\ntwo vectors produces a third vector perpendicular to both of the input vectors.\nThe code snippet above does just that and then normalises the result, i.e. scales it so that its length equals one.\n\n<p>I will continue with this dimensioning topic and address the next step, using FindReferencesByDirection, in a follow-up post.\n\n<p>Here is\n\n<!-- C:\\a\\doc\\revit\\blog\\zip\\bc_11_86.zip -->\n<a href=\"zip/bc_11_86.zip\">\nversion 2011.0.86.0</a>\n\nof The Building Coder samples including the complete source code and Visual Studio solution of the new command.\nActually, to tell the truth, it includes the next yet-to-be-discussed command as well... psst!\n</p></p></a></a></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p>"
  },
  {
    "original_filename": "0539_dim_walls_it_face",
    "header_text": "Determine Normal Vector Using Cross Product",
    "local_header_href": "#determine-normal-vector-using-cross-product",
    "chunk_text": "<h4>Determine Normal Vector Using Cross Product</h4><p><strong>Response:</strong> Although I have success in getting this part of my dimensioning correct,\nI'm not exactly sure how your function 'static XYZ Normal' is working, with the call to v.CrossProduct( XYZ.BasisZ ).Normalize();\nI must admit I'm real fuzzy on what is happening here. \nIs there any way that I can get some type of good and simple explanation on this line of code is doing? \nI'm sure this would help me with my next step of dimensioning.\n\n<p><strong>Answer:</strong> You ask about the meaning of the cross product\n\n<pre class=\"code\">\n  v.CrossProduct( <span class=\"teal\">XYZ</span>.BasisZ ).Normalize()\n</pre>\n<p>That calculates the cross product between two vectors. \nHere is an explanation of the term \n\n<a href=\"http://en.wikipedia.org/wiki/Euclidean_vector\">\nEuclidian vector<a>, and its \n\n<a href=\"http://en.wikipedia.org/wiki/Euclidean_vector\">\nlength and normalisation</a>.\n\nThe calculation of the \n\n<a href=\"http://en.wikipedia.org/wiki/Cross_product\">\ncross product</a> of \n\ntwo vectors produces a third vector perpendicular to both of the input vectors.\nThe code snippet above does just that and then normalises the result, i.e. scales it so that its length equals one.\n\n<p>I will continue with this dimensioning topic and address the next step, using FindReferencesByDirection, in a follow-up post.\n\n<p>Here is\n\n<!-- C:\\a\\doc\\revit\\blog\\zip\\bc_11_86.zip -->\n<a href=\"zip/bc_11_86.zip\">\nversion 2011.0.86.0</a>\n\nof The Building Coder samples including the complete source code and Visual Studio solution of the new command.\nActually, to tell the truth, it includes the next yet-to-be-discussed command as well... psst!\n</p></p></a></a></p></p></p>"
  }
]