[
  {
    "original_filename": "0605_transformed_geo",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<head>\n<link href=\"bc.css\" rel=\"stylesheet\" type=\"text/css\"/>\n</head>"
  },
  {
    "original_filename": "0605_transformed_geo",
    "header_text": "Get Transformed Family Instance Geometry",
    "local_header_href": "#get-transformed-family-instance-geometry",
    "chunk_text": "<h3>Get Transformed Family Instance Geometry</h3><p>One of the new methods added to the \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2011/03/revit-2012-api-features.html\">\nRevit 2012 API</a>\n\nis the GeometryElement GetTransformed method, which returns a transformed copy of the geometry in this element, and can also be used to obtain the geometry of a family instance in its model space coordinates.\n\n<p>This led to the following interesting question by Olli Kattelus of \n\n<!-- <a href=\"http://www.progman.fi/en/contact-information/about-us\">Progman Oy</a> -->\n<a href=\"http://magicad.com/node/40\">Progman Oy</a>:\n\n<p><strong>Question:</strong> First of all a salute for new features of Revit 2012 API and the improved handling of geometry. \nThe API now gives variety of tools to handle geometry i.e. in linked models. \nGreat!\n\n<p>I have faced a little bit strange behaviour and I would like to know what the reason is.\n\n<p>It is related to the linked DWG and the coordinate transformation. \nIf I apply transform to the DWG link geometry instance, it somehow applies a double transformation to the geometry returned.\n\n<p>I am using the following helper method to make the call to GetTransformed:\n\n<pre class=\"code\">\n<span class=\"blue\">protected</span> <span class=\"teal\">Mesh</span> fetchSomeMesh( \n  <span class=\"teal\">GeometryElement</span> gElem, \n  <span class=\"teal\">Transform</span> transform )\n{\n  <span class=\"green\">// Apply transformation and seek for Meshes</span>\n \n  <span class=\"teal\">GeometryElement</span> transformed \n    = gElem.GetTransformed( transform );\n \n  <span class=\"blue\">foreach</span>( <span class=\"teal\">GeometryObject</span> obj <span class=\"blue\">in</span> transformed.Objects )\n  {\n    <span class=\"teal\">Mesh</span> gMesh = obj <span class=\"blue\">as</span> <span class=\"teal\">Mesh</span>;\n    <span class=\"blue\">if</span>( <span class=\"blue\">null</span> != gMesh )\n    {\n      <span class=\"blue\">return</span> gMesh;\n    }\n  }\n \n  <span class=\"green\">// Loop and seek for geometry instances</span>\n \n  <span class=\"blue\">foreach</span>( <span class=\"teal\">GeometryObject</span> obj <span class=\"blue\">in</span> gElem.Objects )\n  {\n    <span class=\"teal\">GeometryInstance</span> gInstance \n      = obj <span class=\"blue\">as</span> <span class=\"teal\">GeometryInstance</span>;\n \n    <span class=\"blue\">if</span>( <span class=\"blue\">null</span> != gInstance )\n    {\n      <span class=\"green\">// If it's GeometryInstance, combine </span>\n      <span class=\"green\">// transformations and go recursive</span>\n \n      <span class=\"teal\">Transform</span> combinedTransform = gInstance\n        .Transform.Multiply( transform );\n \n      <span class=\"blue\">return</span> fetchSomeMesh( \n        gInstance.SymbolGeometry, \n        combinedTransform );\n    }\n  }\n  <span class=\"blue\">return</span> <span class=\"blue\">null</span>;\n}\n</pre>\n<p>The helper method is called and the first resulting vertex printed out like this:\n\n<pre class=\"code\">\n<span class=\"blue\">void</span> checkLinkedDwg( <span class=\"teal\">Element</span> linked )\n{\n  <span class=\"teal\">Instance</span> inst = linked <span class=\"blue\">as</span> <span class=\"teal\">Instance</span>;\n  <span class=\"teal\">Transform</span> transform = inst.GetTransform();\n \n  <span class=\"teal\">Options</span> opt = <span class=\"blue\">new</span> <span class=\"teal\">Options</span>();\n  opt.View = _doc.ActiveView;\n \n  <span class=\"teal\">GeometryElement</span> gElem = inst.get_Geometry( opt );\n \n  <span class=\"teal\">Debug</span>.Print( <span class=\"maroon\">\"Point without Transformation: \"</span> \n    + fetchSomeMesh( gElem ).Vertices[0].ToString() );\n \n  <span class=\"teal\">XYZ</span> vertex = fetchSomeMesh( gElem, transform ).Vertices[0];\n  <span class=\"teal\">Debug</span>.Print( <span class=\"maroon\">\"Point when Transformed: \"</span> + vertex.ToString() );\n \n  <span class=\"teal\">Debug</span>.Print( <span class=\"maroon\">\"Point when Transformed + inverse: \"</span> \n    + transform.Inverse.OfPoint( vertex ).ToString() );\n}\n</pre>\n<p><strong>Answer:</strong> I ported your original managed C++ version to C# and tested it, and I see the following results executing it on a sample model:\n\n<pre>\nPoint without Transformation: (0.0, 0.0, 0.0)\nPoint when Transformed: (2379.1, 1307.1, 0.0)\nPoint when Transformed + inverse: (1203.5, 662.6, 0.0)\n</pre>\n<p>It does indeed look as if the transform is applied twice in the second row, and the inverse transformation removes one of the two translations that were applied.\n\n<p>Looking at your code and guessing the internals of the GetTransformed method, I had a hunch that you need not pass in the transformation to it at all. \nThat is an optional extra. \nThe original transformation applied to the family instance itself is already built in to the method call. \nSo I implemented a new and simpler version of your fetchSomeMesh method called fetchSomeMeshTransformed which takes no transform argument at all, and simply always passes in the identity transform:\n\n<pre class=\"code\">\n<span class=\"blue\">protected</span> <span class=\"teal\">Mesh</span> fetchSomeMeshTransformed( \n  <span class=\"teal\">GeometryElement</span> gElem )\n{\n  <span class=\"green\">// Apply transformation and seek for Meshes</span>\n \n  <span class=\"teal\">GeometryElement</span> transformed \n    = gElem.GetTransformed( <span class=\"teal\">Transform</span>.Identity );\n \n  <span class=\"blue\">foreach</span>( <span class=\"teal\">GeometryObject</span> obj <span class=\"blue\">in</span> transformed.Objects )\n  {\n    <span class=\"teal\">Mesh</span> gMesh = obj <span class=\"blue\">as</span> <span class=\"teal\">Mesh</span>;\n    <span class=\"blue\">if</span>( <span class=\"blue\">null</span> != gMesh )\n    {\n      <span class=\"blue\">return</span> gMesh;\n    }\n  }\n \n  <span class=\"green\">// Loop and seek for geometry instances</span>\n \n  <span class=\"blue\">foreach</span>( <span class=\"teal\">GeometryObject</span> obj <span class=\"blue\">in</span> gElem.Objects )\n  {\n    <span class=\"teal\">GeometryInstance</span> gInstance \n      = obj <span class=\"blue\">as</span> <span class=\"teal\">GeometryInstance</span>;\n \n    <span class=\"blue\">if</span>( <span class=\"blue\">null</span> != gInstance )\n    {\n      <span class=\"blue\">return</span> fetchSomeMeshTransformed( \n        gInstance.SymbolGeometry );\n    }\n  }\n  <span class=\"blue\">return</span> <span class=\"blue\">null</span>;\n}\n</pre>\n<p>I added another row of output to the testing call:\n\n<pre class=\"code\">\n  <span class=\"teal\">Debug</span>.Print( <span class=\"maroon\">\"Point without Transformation: \"</span> \n    + fetchSomeMesh( gElem ).Vertices[0].ToString() );\n \n  <span class=\"teal\">XYZ</span> vertex = fetchSomeMesh( gElem, transform ).Vertices[0];\n  <span class=\"teal\">Debug</span>.Print( <span class=\"maroon\">\"Point when Transformed: \"</span> + vertex.ToString() );\n \n  <span class=\"teal\">Debug</span>.Print( <span class=\"maroon\">\"Point when Transformed + inverse: \"</span> \n    + transform.Inverse.OfPoint( vertex ).ToString() );\n \n  <span class=\"teal\">Debug</span>.Print( <span class=\"maroon\">\"Point with ID Transformation: \"</span> \n    + fetchSomeMeshTransformed( gElem ).Vertices[0].ToString() );\n \n</pre>\n<p>Lo and behold, the sample now produces the following new and correct result in the fourth row:\n\n<pre>\nPoint without Transformation: (0.0, 0.0, 0.0)\nPoint when Transformed: (2379.1, 1307.1, 0.0)\nPoint when Transformed + inverse: (1203.5, 662.6, 0.0)\nPoint with ID Transformation: (1203.5, 662.6, 0.0)\n</pre>\n<p>In other words, and to be completely clear about this, the transform argument to the GetTransformed method can be used to define an additional transformation of the element geometry, and is concatenated with the transformation already applied to the symbol geometry to place it appropriately for a given instance.\n\n<p>If you just need the element geometry at its current location in the model, you can pass in an identity transform.\n\n<p>For completeness' sake, here is the source code and Visual Studio solution for the original managed C++ version \n\n<a href=\"zip/transform2.zip\">transform2.zip</a>,\n\nand the C# port \n\n<a href=\"zip/Transform3.zip\">Transform3.zip</a>.\n</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p>"
  }
]