[
  {
    "original_filename": "0063_family_category",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<style>\n.blue { color: blue; }\n.teal { color: teal; }\n.maroon { color: maroon; }\n.green { color: green; }\n</style>"
  },
  {
    "original_filename": "0063_family_category",
    "header_text": "Family Category and Filtering",
    "local_header_href": "#family-category-and-filtering",
    "chunk_text": "<h3>Family Category and Filtering</h3><p>So here we are in a brand new year, 2009. \nWelcome back! \nHere is an interesting question regarding families, their categories, and filtering, raised last year by Martin Schmid of Autodesk.</p><p><strong>Question:</strong> In the following code, I attempt to use Revit API filtering to select all families with a built-in category value of BuiltInCategory.OST_MechanicalEquipment:</p><pre class=\"code\">\n<span class=\"teal\">Document</span> doc = app.ActiveDocument;\n<span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt; famsInCat = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">Element</span>&gt;();\n \nAutodesk.Revit.Creation.<span class=\"teal\">Filter</span> cf\n  = app.Create.Filter;\n \n<span class=\"teal\">TypeFilter</span> typeFilter\n  = cf.NewTypeFilter( <span class=\"blue\">typeof</span>( <span class=\"teal\">Family</span> ) );\n \n<span class=\"teal\">CategoryFilter</span> catFilter\n  = cf.NewCategoryFilter( bic );\n \n<span class=\"teal\">LogicAndFilter</span> andFilter\n  = cf.NewLogicAndFilter( typeFilter, catFilter );\n \ndoc.get_Elements( andFilter, famsInCat );\n<span class=\"blue\">return</span> famsInCat;\n</pre><p>Unfortunately, this does not work as expected, even when some mechanical equipment families have been loaded into the model.</p><p>Instead, this more cumbersome iterative approach can be used successfully:</p><pre class=\"code\">\n<span class=\"teal\">Category</span> categoryMechanicalEquipment\n  = doc.Settings.Categories.get_Item( bic );\n \n<span class=\"teal\">ElementId</span> categoryId\n  = categoryMechanicalEquipment.Id;\n \n<span class=\"teal\">ElementIterator</span> it\n  = doc.get_Elements( <span class=\"blue\">typeof</span>( <span class=\"teal\">Family</span> ) );\n \n<span class=\"blue\">while</span>( it.MoveNext() )\n{\n  <span class=\"teal\">Family</span> family = it.Current <span class=\"blue\">as</span> <span class=\"teal\">Family</span>;\n  <span class=\"blue\">bool</span> categoryMatches\n    = family.FamilyCategory.Id.Equals( categoryId );\n \n  <span class=\"blue\">if</span>( categoryMatches )\n  {\n    famsInCat.Add( family );\n  }\n}\n<span class=\"blue\">return</span> famsInCat;\n</pre><p>Do you see any errors in my logic?</p><p><strong>Answer:</strong> The reason it does not work is because the Family class does not implement the Category property for all family files.\nAlthough the property is provided by the Family class, it sometimes returns null.\nThe filter is probably using this property internally, but to no avail.</p><p>Therefore, you have to use some other method to check the category of a family.\nOn some family instances, you can use FamilyCategory instead of Category, like you are doing in your working code snippet.\nUnfortunately, even this work-around is not reliable for all families.\nOn some families, the FamilyCategory property is not implemented either.\nThe most reliable method is to check the Category property on any one symbol contained in the family.\nMostly, it is practical to just use the first symbol defined in the family.\nHere is some updated code demonstrating this approach:</p><pre class=\"code\">\n<span class=\"teal\">Category</span> categoryMechanicalEquipment\n  = doc.Settings.Categories.get_Item( bic );\n \n<span class=\"teal\">ElementId</span> categoryId\n  = categoryMechanicalEquipment.Id;\n \n<span class=\"teal\">ElementIterator</span> it\n  = doc.get_Elements( <span class=\"blue\">typeof</span>( <span class=\"teal\">Family</span> ) );\n \n<span class=\"blue\">while</span>( it.MoveNext() )\n{\n  <span class=\"teal\">Family</span> family = it.Current <span class=\"blue\">as</span> <span class=\"teal\">Family</span>;\n  <span class=\"blue\">foreach</span>( <span class=\"teal\">Symbol</span> s <span class=\"blue\">in</span> family.Symbols )\n  {\n    <span class=\"blue\">if</span>( s.Category.Id.Equals( categoryId ) )\n    {\n      famsInCat.Add( family );\n    }\n    <span class=\"blue\">break</span>; <span class=\"green\">// only need to look at first symbol</span>\n  }\n}\n<span class=\"blue\">return</span> famsInCat;\n</pre><p>Unfortunately, as Martin points out above, this does indeed mean that you have to add some own slightly cumbersome code after the filtered element retrieval to check for the desired category.</p>"
  }
]