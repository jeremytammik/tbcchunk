[
  {
    "original_filename": "0313_nested_family_utils",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<head>\n<link href=\"bc.css\" rel=\"stylesheet\" type=\"text/css\"/>\n</head>"
  },
  {
    "original_filename": "0313_nested_family_utils",
    "header_text": "Nested Family Utility Methods",
    "local_header_href": "#nested-family-utility-methods",
    "chunk_text": "<h3>Nested Family Utility Methods</h3><p>Nested families seem to be a recurring topic right now.\nWe just recently discussed how to test whether a family instance in a project file is \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/02/nested-family-instance.html\">\nnested inside another</a>,\n\nand before that we addressed\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2009/05/nested-instance-geometry.html\">\nnested instance geometry</a> and \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2009/11/nested-family.html\">\ncreating a nested family</a>.\n\nThe first place to look for information on using the Revit API in the context of families is the \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2009/08/the-revit-family-api.html\">\noverview of the family API</a>\n\nwith the associated \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2009/08/the-revit-family-api.html#4\">\nlabs</a> and the \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2009/08/the-revit-family-api.html#5\">\nmaterials and recording</a> of the webcast we presented on the topic.\n\n<p>I received a couple of useful helper methods for exploring and working in the family context from an anonymous contributor whom we can call SOA-boy, since he already contributed some hints on using \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2009/08/serviceoriented-architecture.html\">\nService-Oriented Architecture</a>. Here is his description:\n\n<p>Because the normal filtering mechanism apparently doesn't work for detecting nested family definitions or nested family instances within a family document, I wrote some code for iterating over all the elements in the host family document as quickly as possible. \nThe code is intended to be highly reusable. \n\n<p>Another issue addressed is to get to a nested family's parameter, because you have to call different methods depending on whether or not that parameter is a shared parameter or a family one.\nThe code to do that turns out to be simple, just non-intuitive, until you think about it some more.  \nMaybe that's a more familiar approach to programmers of the project editor API, but if you work more in the family editor API, it wasn't intuitive at all.\nMethods are provided for getting a reference to a nested family's parameter, and to allow you to link a nested family's parameter to a FamilyParameter on the host family.\n\n<p>I implemented a new Building Coder sample module CmdNestedFamilies.cs which includes these methods in the class NestedFamilyFunctions. \nThe methods provided include:\n\n<ul>\n<li>GetFilteredNestedFamilyDefinitions: \n     Returns a list of the nested family files in the given family document whose name \n     matches the given family file name filter.  Useful for checking to see if a family\n     desired for nesting into the host family document is already nested in.\n<li>GetFilteredNestedFamilyInstances:\n     Returns a list of family instances found in the given family document whose family file\n     name matches the given familyFileNameFilter and whose type name matches the given \n     typeNameFilter.  If no filter values are provided (or they evaluate to the empty string\n     when trimmed) then all instances will be evaluated.\n<li>GetFamilyParameter:\n     Returns a reference to the FAMILY parameter (as a simple Parameter data type) on the given instance\n     for the parameter with the given name.  Will return the parameter\n     whether it is an instance or type parameter.\n<li>LinkNestedFamilyParameterToHostFamilyParameter:\n     This method takes an instance of a nested family and links a parameter on it to\n     a parameter on the given host family instance.  This allows a change at the host\n     level to automatically be sent down and applied to the nested family instance.\n</li></li></li></li></ul>\n<p>The motivation for the first method is that standard Revit filtering techniques fail when searching for nested families in a family document, so we have no choice but to iterate over all elements in the family.\nWhile there usually aren't that many elements at the family level, nonetheless this method has been built for speed.\nIt returns collection of family file definitions nested into the given family document.\n\n<p>The methods are packaged in a utility class NestedFamilyFunctions.\nIt also includes two helper methods FilterMatches and ValidateFamilyDocument:\n\n<ul>\n<li>FilterMatches:\n     Returns whether or not the nameToCheck matches the given filter.\n     This is done with a simple Contains check, so wildcards won't work.\n<li>ValidateFamilyDocument:\n     This method will validate the provided Revit Document to make sure the reference \n     exists and is for a FAMILY document.  It will throw an ArgumentNullException\n     if nothing is sent, and will throw an ArgumentOutOfRangeException if the document\n     provided isn't a family document (e.g. is a project document)\n</li></li></ul>\n<p>Here is the NestedFamilyFunctions source code, including some comments describing what is going on and why.\nFollowing good SOA practices, the methods verify that the incoming data can be worked with.\nSince some lines are too long to display here in this post, you may have to either copy and paste to an editor or download the full source code to see them in full length:\n\n<pre class=\"code\">\n<span class=\"blue\">#region</span> Public Methods\n<span class=\"blue\">public</span> <span class=\"blue\">static</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">Family</span>&gt; \n  GetFilteredNestedFamilyDefinitions( \n    <span class=\"blue\">string</span> familyFileNameFilter,\n    <span class=\"teal\">Document</span> familyDocument,\n    <span class=\"blue\">bool</span> caseSensitiveFiltering )\n{\n  ValidateFamilyDocument( familyDocument );\n \n  <span class=\"green\">// The filter can be null, the filter matching function checks for that.</span>\n \n  <span class=\"teal\">List</span>&lt;<span class=\"teal\">Family</span>&gt; oResult = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">Family</span>&gt;();\n \n  <span class=\"teal\">ElementIterator</span> it = familyDocument.Elements;\n \n  <span class=\"blue\">while</span>( it.MoveNext() )\n  {\n    <span class=\"teal\">Element</span> oElement = it.Current <span class=\"blue\">as</span> <span class=\"teal\">Element</span>;\n \n    <span class=\"blue\">if</span>( ( oElement <span class=\"blue\">is</span> <span class=\"teal\">Family</span> ) \n      &amp;&amp; FilterMatches( oElement.Name, \n        familyFileNameFilter, caseSensitiveFiltering ) )\n    {\n      oResult.Add( oElement <span class=\"blue\">as</span> <span class=\"teal\">Family</span> );\n    }\n  }\n  <span class=\"blue\">return</span> oResult;\n}\n \n<span class=\"blue\">public</span> <span class=\"blue\">static</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">FamilyInstance</span>&gt; \n  GetFilteredNestedFamilyInstances( \n    <span class=\"blue\">string</span> familyFileNameFilter,\n    <span class=\"blue\">string</span> typeNameFilter,\n    <span class=\"teal\">Document</span> familyDocument,\n    <span class=\"blue\">bool</span> caseSensitiveFiltering )\n{\n  ValidateFamilyDocument( familyDocument );\n \n  <span class=\"green\">// The filters can be null</span>\n \n  <span class=\"teal\">List</span>&lt;<span class=\"teal\">FamilyInstance</span>&gt; oResult \n    = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">FamilyInstance</span>&gt;();\n \n  <span class=\"teal\">Family</span> oNestedFamilyFileCandidate;\n  <span class=\"teal\">FamilyInstance</span> oFamilyInstanceCandidate;\n  <span class=\"teal\">FamilySymbol</span> oFamilySymbolCandidate;\n \n  <span class=\"teal\">List</span>&lt;<span class=\"teal\">Family</span>&gt; oMatchingNestedFamilies \n    = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">Family</span>&gt;();\n \n  <span class=\"teal\">List</span>&lt;<span class=\"teal\">FamilyInstance</span>&gt; oAllFamilyInstances \n    = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">FamilyInstance</span>&gt;();\n \n  <span class=\"blue\">bool</span> bFamilyFileNameFilterExists = <span class=\"blue\">true</span>;\n  <span class=\"blue\">bool</span> bTypeNameFilterExists = <span class=\"blue\">true</span>;\n \n  <span class=\"green\">// Set up some fast-to-test boolean values, which will be </span>\n  <span class=\"green\">// used for short-circuit Boolean evaluation later.</span>\n \n  <span class=\"blue\">if</span>( <span class=\"blue\">string</span>.IsNullOrEmpty( familyFileNameFilter ) )\n  {\n    bFamilyFileNameFilterExists = <span class=\"blue\">false</span>;\n  }\n \n  <span class=\"blue\">if</span>( <span class=\"blue\">string</span>.IsNullOrEmpty( typeNameFilter ) )\n  {\n    bTypeNameFilterExists = <span class=\"blue\">false</span>;\n  }\n \n  <span class=\"green\">// Unfortunately detecting nested families in a family document requires iterating</span>\n  <span class=\"green\">// over all the elements in the document, because the built-in filtering mechanism</span>\n  <span class=\"green\">// doesn't work for this case.  However, families typically don't have nearly as many</span>\n  <span class=\"green\">// elements as a whole project, so the performance hit shouldn't be too bad.</span>\n  <span class=\"green\">//</span>\n  <span class=\"green\">// Still, the fastest performance should come by iterating over all elements in the given</span>\n  <span class=\"green\">// family document exactly once, keeping subsets of the family instances found for </span>\n  <span class=\"green\">// later testing against the nested family file matches found.</span>\n \n  <span class=\"teal\">ElementIterator</span> oElementIterator \n    = familyDocument.Elements;\n \n  <span class=\"blue\">while</span>( oElementIterator.MoveNext() )\n  {\n    <span class=\"green\">// See if this is a family file nested into the current family document.</span>\n    oNestedFamilyFileCandidate \n      = oElementIterator.Current <span class=\"blue\">as</span> <span class=\"teal\">Family</span>;\n \n    <span class=\"blue\">if</span>( oNestedFamilyFileCandidate != <span class=\"blue\">null</span> )\n    {\n      <span class=\"green\">// Must ask the \"Element\" version for it's name, because the Family object's </span>\n      <span class=\"green\">// name is always the empty string.</span>\n      <span class=\"blue\">if</span>( !bFamilyFileNameFilterExists \n        || FilterMatches( oNestedFamilyFileCandidate.Name, \n          familyFileNameFilter, caseSensitiveFiltering ) )\n      {\n        <span class=\"green\">// This is a nested family file, and either no valid family file name filter was</span>\n        <span class=\"green\">// given, or the name of this family file matches the filter.</span>\n \n        oMatchingNestedFamilies.Add( \n          oNestedFamilyFileCandidate );\n      }\n    }\n    <span class=\"blue\">else</span>\n    {\n      <span class=\"green\">// This element is not a nested family file definition, see if it's a </span>\n      <span class=\"green\">// nested family instance.</span>\n \n      oFamilyInstanceCandidate \n        = oElementIterator.Current <span class=\"blue\">as</span> <span class=\"teal\">FamilyInstance</span>;\n \n      <span class=\"blue\">if</span>( oFamilyInstanceCandidate != <span class=\"blue\">null</span> )\n      {\n        <span class=\"green\">// Just add the family instance to our \"all\" collection for later testing</span>\n        <span class=\"green\">// because we may not have yet found all the matching nested family file </span>\n        <span class=\"green\">// definitions.</span>\n        oAllFamilyInstances.Add( \n          oFamilyInstanceCandidate );\n      }\n    }\n \n  } <span class=\"green\">// End iterating over all the elements in the family document exactly once</span>\n \n \n  <span class=\"green\">// See if any matching nested family file definitions were found.  Only do any</span>\n  <span class=\"green\">// more work if at least one was found.</span>\n  <span class=\"blue\">foreach</span>( <span class=\"teal\">Family</span> oMatchingNestedFamilyFile \n    <span class=\"blue\">in</span> oMatchingNestedFamilies )\n  {\n    <span class=\"green\">// Count backwards through the all family instances list.  As we find </span>\n    <span class=\"green\">// matches on this iteration through the matching nested families, we can</span>\n    <span class=\"green\">// delete them from the candidates list to reduce the number of family </span>\n    <span class=\"green\">// instance candidates to test for later matching nested family files to be tested </span>\n    <span class=\"blue\">for</span>( <span class=\"blue\">int</span> iCounter = oAllFamilyInstances.Count - 1; \n      iCounter &gt;= 0; iCounter-- )\n    {\n      oFamilyInstanceCandidate \n        = oAllFamilyInstances[iCounter];\n \n      oFamilySymbolCandidate \n        = oFamilyInstanceCandidate.ObjectType \n          <span class=\"blue\">as</span> <span class=\"teal\">FamilySymbol</span>;\n \n      <span class=\"blue\">if</span>( oFamilySymbolCandidate.Family.UniqueId \n        == oMatchingNestedFamilyFile.UniqueId )\n      {\n        <span class=\"green\">// Only add this family instance to the results if there was no type name</span>\n        <span class=\"green\">// filter, or this family instance's type matches the given filter.</span>\n \n        <span class=\"blue\">if</span>( !bTypeNameFilterExists\n          || FilterMatches( oFamilyInstanceCandidate.Name, \n            typeNameFilter, caseSensitiveFiltering ) )\n        {\n          oResult.Add( oFamilyInstanceCandidate );\n        }\n \n        <span class=\"green\">// No point in testing this one again, </span>\n        <span class=\"green\">// since we know its family definition</span>\n        <span class=\"green\">// has already been processed.</span>\n \n        oAllFamilyInstances.RemoveAt( iCounter );\n      }\n \n    } <span class=\"green\">// Next family instance candidate</span>\n \n  } <span class=\"green\">// End of for each matching nested family file definition found</span>\n \n  <span class=\"blue\">return</span> oResult;\n}\n \n<span class=\"blue\">public</span> <span class=\"blue\">static</span> <span class=\"teal\">Parameter</span> GetFamilyParameter( \n  <span class=\"teal\">FamilyInstance</span> nestedFamilyInstance,\n  <span class=\"blue\">string</span> parameterName )\n{\n  <span class=\"blue\">if</span>( nestedFamilyInstance == <span class=\"blue\">null</span> )\n  {\n    <span class=\"blue\">throw</span> <span class=\"blue\">new</span> <span class=\"teal\">ArgumentNullException</span>( \n      <span class=\"maroon\">\"nestedFamilyInstance\"</span> );\n  }\n \n  <span class=\"blue\">if</span>( <span class=\"blue\">string</span>.IsNullOrEmpty( parameterName ) )\n  {\n    <span class=\"blue\">throw</span> <span class=\"blue\">new</span> <span class=\"teal\">ArgumentNullException</span>( \n      <span class=\"maroon\">\"parameterName\"</span> );\n  }\n \n  <span class=\"teal\">Parameter</span> oResult = <span class=\"blue\">null</span>;\n \n  <span class=\"green\">//See if the parameter is an Instance parameter</span>\n  oResult = nestedFamilyInstance.get_Parameter( \n    parameterName );\n \n  <span class=\"green\">// No?  See if it's a Type parameter</span>\n  <span class=\"blue\">if</span>( oResult == <span class=\"blue\">null</span> )\n  {\n    oResult = nestedFamilyInstance.Symbol.get_Parameter( \n      parameterName );\n  }\n  <span class=\"blue\">return</span> oResult;\n}\n \n<span class=\"blue\">public</span> <span class=\"blue\">static</span> <span class=\"blue\">void</span> \n  LinkNestedFamilyParameterToHostFamilyParameter(\n    <span class=\"teal\">Document</span> hostFamilyDocument,\n    <span class=\"teal\">FamilyInstance</span> nestedFamilyInstance,\n    <span class=\"blue\">string</span> nestedFamilyParameterName,\n    <span class=\"blue\">string</span> hostFamilyParameterNameToLink )\n{\n  ValidateFamilyDocument( hostFamilyDocument );\n \n  <span class=\"blue\">if</span>( nestedFamilyInstance == <span class=\"blue\">null</span> )\n  {\n    <span class=\"blue\">throw</span> <span class=\"blue\">new</span> <span class=\"teal\">ArgumentNullException</span>( \n      <span class=\"maroon\">\"nestedFamilyInstance\"</span> );\n  }\n \n  <span class=\"blue\">if</span>( <span class=\"blue\">string</span>.IsNullOrEmpty( nestedFamilyParameterName ) )\n  {\n    <span class=\"blue\">throw</span> <span class=\"blue\">new</span> <span class=\"teal\">ArgumentNullException</span>( \n      <span class=\"maroon\">\"nestedFamilyParameterName\"</span> );\n  }\n \n  <span class=\"blue\">if</span>( <span class=\"blue\">string</span>.IsNullOrEmpty( hostFamilyParameterNameToLink ) )\n  {\n    <span class=\"blue\">throw</span> <span class=\"blue\">new</span> <span class=\"teal\">ArgumentNullException</span>( \n      <span class=\"maroon\">\"hostFamilyParameterNameToLink\"</span> );\n  }\n \n  <span class=\"teal\">Parameter</span> oNestedFamilyParameter \n    = GetFamilyParameter( nestedFamilyInstance, \n      nestedFamilyParameterName );\n \n  <span class=\"blue\">if</span>( oNestedFamilyParameter == <span class=\"blue\">null</span> )\n  {\n    <span class=\"blue\">throw</span> <span class=\"blue\">new</span> <span class=\"teal\">Exception</span>( <span class=\"maroon\">\"Parameter '\"</span> \n      + nestedFamilyParameterName \n      + <span class=\"maroon\">\"' was not found on the nested family '\"</span> \n      + nestedFamilyInstance.Symbol.Name + <span class=\"maroon\">\"'\"</span> );\n  }\n \n  <span class=\"teal\">FamilyParameter</span> oHostFamilyParameter \n    = hostFamilyDocument.FamilyManager.get_Parameter( \n      hostFamilyParameterNameToLink );\n \n  <span class=\"blue\">if</span>( oHostFamilyParameter == <span class=\"blue\">null</span> )\n  {\n    <span class=\"blue\">throw</span> <span class=\"blue\">new</span> <span class=\"teal\">Exception</span>( <span class=\"maroon\">\"Parameter '\"</span> \n      + hostFamilyParameterNameToLink \n      + <span class=\"maroon\">\"' was not found on the host family.\"</span> );\n  }\n \n  hostFamilyDocument.FamilyManager\n    .AssociateElementParameterToFamilyParameter( \n      oNestedFamilyParameter, oHostFamilyParameter );\n}\n<span class=\"blue\">#endregion</span> Public Methods\n \n<span class=\"blue\">#region</span> Private / Helper Methods\n<span class=\"blue\">private</span> <span class=\"blue\">static</span> <span class=\"blue\">bool</span> FilterMatches( \n  <span class=\"blue\">string</span> nameToCheck,\n  <span class=\"blue\">string</span> filter,\n  <span class=\"blue\">bool</span> caseSensitiveComparison )\n{\n  <span class=\"blue\">bool</span> bResult = <span class=\"blue\">false</span>;\n \n  <span class=\"blue\">if</span>( <span class=\"blue\">string</span>.IsNullOrEmpty( nameToCheck ) )\n  {\n    <span class=\"green\">// No name given, so the call must fail.</span>\n    <span class=\"blue\">return</span> <span class=\"blue\">false</span>;\n  }\n \n  <span class=\"blue\">if</span>( <span class=\"blue\">string</span>.IsNullOrEmpty( filter ) )\n  {\n    <span class=\"green\">// No filter given, so the given name passes the test</span>\n    <span class=\"blue\">return</span> <span class=\"blue\">true</span>;\n  }\n \n  <span class=\"blue\">if</span>( !caseSensitiveComparison )\n  {\n    <span class=\"green\">// Since the String.Contains function only does case-sensitive checks,</span>\n    <span class=\"green\">// cheat with our copies of the values which we'll use for the comparison.</span>\n    nameToCheck = nameToCheck.ToUpper();\n    filter = filter.ToUpper();\n  }\n \n  bResult = nameToCheck.Contains( filter );\n \n  <span class=\"blue\">return</span> bResult;\n}\n \n<span class=\"blue\">private</span> <span class=\"blue\">static</span> <span class=\"blue\">void</span> ValidateFamilyDocument( \n  <span class=\"teal\">Document</span> document )\n{\n  <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == document )\n  {\n    <span class=\"blue\">throw</span> <span class=\"blue\">new</span> <span class=\"teal\">ArgumentNullException</span>( <span class=\"maroon\">\"document\"</span> );\n  }\n \n  <span class=\"blue\">if</span>( !document.IsFamilyDocument )\n  {\n    <span class=\"blue\">throw</span> <span class=\"blue\">new</span> <span class=\"teal\">ArgumentOutOfRangeException</span>( \n      <span class=\"maroon\">\"The document provided is not a Family Document.\"</span> );\n  }\n}\n<span class=\"blue\">#endregion</span> Private / Helper Methods\n</pre>\n<p>Here is\n\n<a href=\"zip/bc11063.zip\">\nversion 1.1.0.63</a>\n\nof the complete Building Coder source code and Visual Studio solution including the new external command CmdNestedFamilies and the NestedFamilyFunctions utility class.</p>\n<p>Many thanks to SOA-boy for this contribution!\n</p></p></p></p></p></p></p></p></p>"
  }
]