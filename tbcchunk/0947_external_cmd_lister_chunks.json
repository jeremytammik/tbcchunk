[
  {
    "original_filename": "0947_external_cmd_lister",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<head>\n<link href=\"bc.css\" rel=\"stylesheet\" type=\"text/css\"/>\n</head>"
  },
  {
    "original_filename": "0947_external_cmd_lister",
    "header_text": "External Command Lister and Adding Ribbon Commands",
    "local_header_href": "#external-command-lister-and-adding-ribbon-commands",
    "chunk_text": "<h3>External Command Lister and Adding Ribbon Commands</h3><p>I have been asked a couple of times how you can integrate multiple Revit add-ins from different sources together into a single ribbon panel.\n\n<p>This topic has also been discussed on the web, e.g. towards the end of\n\n<a href=\"http://www.revitforum.org/third-party-add-ins-api-r/9591-install-add-ins-tab-make-new.html\">\nwhether to install to the add-ins tab or make new ribbon tab</a>,\n\nand at Autodesk University, where Jose Guia presented\n\n<a href=\"http://au.autodesk.com/?nd=class&amp;session_id=10493\">\nCP3766 – Tying All of Your Revit Add-ins into a Pretty Little Ribbon</a>.\n\n<p>Unfortunately, none of these offer any very useful solution, or show or share any code.</p>\n<p>I have a very simple approach to suggest, though, which has been around for several years already:</p>\n<p>The RvtSamples SDK application reads a text file listing any number of .NET assemblies defining any number of external commands and generates a ribbon panel populated with buttons to launch them all.</p>\n<p>Each entry in that file occupies seven lines specifying a group, menu text, description, large image, small image, .NET assembly path and full name of the external command to launch.\nHere is the first entry in that file:</p>\n<pre>\n  Analysis\n  EnergyAnalysis Model\n  Demonstrates how to use EnergyAnalysisModel API.\n  LargeImage:\n  Image:\n  Z:\\...\\bin\\Debug\\EnergyAnalysisModel.dll\n  Revit.SDK.Samples.EnergyAnalysisModel.CS.Command\n</pre>\n<p>Only the two last lines of the entry are really relevant.\nAl the rest is decorative, and hopefully informative as well.</p>\n<p>In fact, that is the one and only method that I use myself to launch both SDK sample external commands and all The Building Coder sample code.</p>\n<p>Furthermore, the text file read by RvtSamples includes support for\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2008/11/loading-the-building-coder-samples.html\">\ninclude files</a> that\n\nI implemented back in 2008, similar to the standard C\n\n<a href=\"http://en.wikipedia.org/wiki/Include_directive\">\n#include pre-processor directive</a>.</p>\n<p>The only important information required to populate the RvtSamples text file is the .NET assembly filename of the DLL implementing the external command, and the full external command implementation class name, including its namespace prefix.</p>\n<p>Here is the complete EnergyAnalysisModel Revit SDK sample add-in manifest, showing the information corresponding to the lines shown above extracted from RvtSamples.txt:</p>\n<pre>\n<span class=\"blue\">&lt;?</span><span class=\"maroon\">xml</span><span class=\"blue\"> </span><span class=\"red\">version</span><span class=\"blue\">=</span>\"<span class=\"blue\">1.0</span>\"<span class=\"blue\"> </span><span class=\"red\">encoding</span><span class=\"blue\">=</span>\"<span class=\"blue\">utf-8</span>\"<span class=\"blue\">?&gt;</span>\n<span class=\"blue\">&lt;</span><span class=\"maroon\">RevitAddIns</span><span class=\"blue\">&gt;</span>\n<span class=\"blue\">  &lt;</span><span class=\"maroon\">AddIn</span><span class=\"blue\"> </span><span class=\"red\">Type</span><span class=\"blue\">=</span>\"<span class=\"blue\">Command</span>\"<span class=\"blue\">&gt;</span>\n<span class=\"blue\">    &lt;</span><span class=\"maroon\">Assembly</span><span class=\"blue\">&gt;</span>Z:\\...\\bin\\Debug\\EnergyAnalysisModel.dll<span class=\"blue\">&lt;/</span><span class=\"maroon\">Assembly</span><span class=\"blue\">&gt;</span>\n<span class=\"blue\">    &lt;</span><span class=\"maroon\">ClientId</span><span class=\"blue\">&gt;</span>6f559488-4285-40b7-bfca-043bb69ea0a7<span class=\"blue\">&lt;/</span><span class=\"maroon\">ClientId</span><span class=\"blue\">&gt;</span>\n<span class=\"blue\">    &lt;</span><span class=\"maroon\">FullClassName</span><span class=\"blue\">&gt;</span>Revit.SDK.Samples.EnergyAnalysisModel.CS.Command<span class=\"blue\">&lt;/</span><span class=\"maroon\">FullClassName</span><span class=\"blue\">&gt;</span>\n<span class=\"blue\">    &lt;</span><span class=\"maroon\">Text</span><span class=\"blue\">&gt;</span>EnergyAnalysis Model<span class=\"blue\">&lt;/</span><span class=\"maroon\">Text</span><span class=\"blue\">&gt;</span>\n<span class=\"blue\">    &lt;</span><span class=\"maroon\">Description</span><span class=\"blue\">&gt;</span>Demonstrates how to use EnergyAnalysisModel API.<span class=\"blue\">&lt;/</span><span class=\"maroon\">Description</span><span class=\"blue\">&gt;</span>\n<span class=\"blue\">    &lt;</span><span class=\"maroon\">VisibilityMode</span><span class=\"blue\">&gt;</span>AlwaysVisible<span class=\"blue\">&lt;/</span><span class=\"maroon\">VisibilityMode</span><span class=\"blue\">&gt;</span>\n<span class=\"blue\">    &lt;</span><span class=\"maroon\">VendorId</span><span class=\"blue\">&gt;</span>ADSK<span class=\"blue\">&lt;/</span><span class=\"maroon\">VendorId</span><span class=\"blue\">&gt;</span>\n<span class=\"blue\">    &lt;</span><span class=\"maroon\">VendorDescription</span><span class=\"blue\">&gt;</span>Autodesk, www.autodesk.com<span class=\"blue\">&lt;/</span><span class=\"maroon\">VendorDescription</span><span class=\"blue\">&gt;</span>\n<span class=\"blue\">  &lt;/</span><span class=\"maroon\">AddIn</span><span class=\"blue\">&gt;</span>\n<span class=\"blue\">&lt;/</span><span class=\"maroon\">RevitAddIns</span><span class=\"blue\">&gt;</span>\n</pre>\n<p>As you can see, the content of the Assembly and FullClassName tags correspond exactly to the two last lines specified in the RvtSamples.txt entry.</p>\n<p>Where can this information be obtained?</p>\n<p>Well, the simplest and most direct source would the add-in manifest, if one is available.</p>\n<p>To load an external command on its own, the assembly path and implementation class name are listed in the Assembly and FullClassName\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/04/addin-manifest-and-guidize.html#2\">\nadd-in manifest tags</a>.</p>\n<p>Unfortunately, if the add-in you wish to integrate defines an external application to create a custom panel, it may not list all its command names in the manifest file.</p>\n<p>Where can they be obtained from then?</p>\n<p>Well, several tools exist which can read .NET assemblies and display their contents.</p>\n<p>I talked about\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2008/10/converting-between-vb-and-c-and-net-decompilation.html\">\nReflector</a> way\n\nback in the early days of the blog.\nIt since became commercial.\nVictor Chekalin mentioned using\n\n<a href=\"http://www.jetbrains.com/decompiler\">\ndotPeek</a>,\n\nand my colleague Adam added that he uses the\n\n<a href=\"http://ilspy.net\">\nILSpy .NET decompiler</a> and\n\nis perfectly happy with that.</p>\n<p>Basically, the information is made accessible via the .NET Reflection namespace functionality.</p>\n<p>To make things really simple for you non-programmer guys, I went and implemented a little Revit add-in external command which does nothing but list the full class names of all other external commands defined in any assembly you care to point it at.</p>\n<p>It can be run in Revit without even opening a document, in zero document state.</p>\n<p>It prompts you to select a DLL file, opens it as a .NET assembly, and uses reflection to determine all the classes defined in it derived from the IExternalCommand interface.</p>\n<p>These are listed in a read-only dynamically generated resizable form.</p>\n<p>Here is the result of pointing it at the\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2013/05/a-simpler-dockable-panel-sample.html\">\nsimpler DockableDialog sample</a> I\n\npublished last week:</p>\n<center>\n<img alt=\"External command lister\" src=\"img/external_command_lister.png\"/>\n</center>\n<p>The code is very simple.</p>\n<p>The ExternalCommandLister class is instantiated with a .NET assembly filename and extracts all external command definitions from it like this:</p>\n<pre class=\"code\">\n<span class=\"blue\">class</span> <span class=\"teal\">ExternalCommandLister</span>\n{\n  <span class=\"blue\">string</span> _assembly_filename;\n  <span class=\"blue\">string</span>[] _external_commmand_class_names;\n \n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n  <span class=\"gray\">///</span><span class=\"green\"> Display error message</span>\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;param name=\"msg\"&gt;</span><span class=\"green\">Message to display</span><span class=\"gray\">&lt;/param&gt;</span>\n  <span class=\"blue\">void</span> ErrorMsg( <span class=\"blue\">string</span> msg )\n  {\n    <span class=\"teal\">Debug</span>.WriteLine( <span class=\"maroon\">\"External Command Lister: \"</span>\n      + msg );\n \n    <span class=\"teal\">TaskDialog</span>.Show( <span class=\"maroon\">\"External Command Lister\"</span>,\n      msg );\n  }\n \n  <span class=\"blue\">public</span> ExternalCommandLister(\n    <span class=\"blue\">string</span> assembly_filename )\n  {\n    _assembly_filename = assembly_filename;\n    _external_commmand_class_names = <span class=\"blue\">null</span>;\n \n    <span class=\"blue\">if</span>( !<span class=\"teal\">File</span>.Exists( assembly_filename ) )\n    {\n      <span class=\"blue\">throw</span> <span class=\"blue\">new</span> <span class=\"teal\">ArgumentOutOfRangeException</span>(\n        <span class=\"maroon\">\"assembly_filename\"</span>, <span class=\"maroon\">\"file not found\"</span> );\n    }\n    <span class=\"blue\">try</span>\n    {\n      <span class=\"green\">// No need to load the Revit API assemblies, </span>\n      <span class=\"green\">// because we are ourselves a Revit API add-in </span>\n      <span class=\"green\">// inside of Revit, so they are guaranteed to</span>\n      <span class=\"green\">// be present.</span>\n \n      <span class=\"green\">//Assembly revit = Assembly.LoadFrom( \"C:/Program Files/Autodesk/Revit Architecture 2014/RevitAPI.dll\" );</span>\n      <span class=\"green\">//string root = \"C:/Program Files/Autodesk Revit Architecture 2014/\";</span>\n      <span class=\"green\">//Assembly adWindows = Assembly.LoadFrom( root + \"AdWindows.dll\" );</span>\n      <span class=\"green\">//Assembly uiFramework = Assembly.LoadFrom( root + \"UIFramework.dll\" );</span>\n      <span class=\"green\">//Assembly revit = Assembly.LoadFrom( root + \"RevitAPI.dll\" );</span>\n \n      <span class=\"green\">// Load the selected assembly into </span>\n      <span class=\"green\">// the current application domain:</span>\n \n      <span class=\"teal\">Assembly</span> asm = <span class=\"teal\">Assembly</span>.LoadFrom(\n        assembly_filename );\n \n      <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == asm )\n      {\n        ErrorMsg( <span class=\"blue\">string</span>.Format(\n          <span class=\"maroon\">\"Unable to load assembly '{0}'\"</span>,\n          assembly_filename ) );\n      }\n      <span class=\"blue\">else</span>\n      {\n        <span class=\"teal\">IEnumerable</span>&lt;<span class=\"teal\">Type</span>&gt; types = asm.GetTypes()\n          .Where&lt;<span class=\"teal\">Type</span>&gt;( t =&gt;\n            <span class=\"blue\">null</span> != t.GetInterface(\n              <span class=\"maroon\">\"IExternalCommand\"</span> ) );\n \n        _external_commmand_class_names = types\n          .Select&lt;<span class=\"teal\">Type</span>,<span class=\"blue\">string</span>&gt;( t =&gt; t.FullName )\n          .ToArray();\n      }\n    }\n    <span class=\"blue\">catch</span>( <span class=\"teal\">Exception</span> ex )\n    {\n      ErrorMsg( <span class=\"blue\">string</span>.Format(\n        <span class=\"maroon\">\"Exception '{0}' processing assembly '{1}'\"</span>,\n        ex.Message, assembly_filename ) );\n    }\n  }\n \n  <span class=\"blue\">public</span> <span class=\"blue\">string</span> AssemblyFilename\n  {\n    <span class=\"blue\">get</span>\n    {\n      <span class=\"blue\">return</span> <span class=\"teal\">Path</span>.GetFileName( _assembly_filename );\n    }\n  }\n \n  <span class=\"blue\">public</span> <span class=\"blue\">string</span>[] CommandClassnames\n  {\n    <span class=\"blue\">get</span>\n    {\n      <span class=\"blue\">return</span> _external_commmand_class_names;\n    }\n  }\n}\n</pre>\n<p>The one single important line is really just</p>\n<pre class=\"code\">\n  <span class=\"teal\">IEnumerable</span>&lt;<span class=\"teal\">Type</span>&gt; types = asm.GetTypes()\n    .Where&lt;<span class=\"teal\">Type</span>&gt;( t =&gt;\n      <span class=\"blue\">null</span> != t.GetInterface(\n        <span class=\"maroon\">\"IExternalCommand\"</span> ) );\n</pre>\n<p>It asks the assembly for all the types it defines and extracts the ones derived from IExternalCommand, i.e. the external command implementation classes.</p>\n<p>The external command mainline Execute implementation prompts the user to select a DLL file, instantiates an ExternalCommandLister instance, queries the command names and displays them in a form created on the fly like this:</p>\n<pre class=\"code\">\n[<span class=\"teal\">Transaction</span>( <span class=\"teal\">TransactionMode</span>.Manual )]\n<span class=\"blue\">public</span> <span class=\"blue\">class</span> <span class=\"teal\">Command</span> : <span class=\"teal\">IExternalCommand</span>\n{\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n  <span class=\"gray\">///</span><span class=\"green\"> Define the initial .NET assembly folder.</span>\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n  <span class=\"blue\">const</span> <span class=\"blue\">string</span> _assembly_folder_name\n    = <span class=\"maroon\">\"C:\\\\ProgramData\\\\Autodesk\\\\Revit\\\\Addins\\\\2014\"</span>;\n \n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n  <span class=\"gray\">///</span><span class=\"green\"> Select a .NET assembly file in the given folder.</span>\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;param name=\"folder\"&gt;</span><span class=\"green\">Initial folder.</span><span class=\"gray\">&lt;/param&gt;</span>\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;param name=\"filename\"&gt;</span><span class=\"green\">Selected filename on success.</span><span class=\"gray\">&lt;/param&gt;</span>\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;returns&gt;</span><span class=\"green\">Return true if a file was successfully selected.</span><span class=\"gray\">&lt;/returns&gt;</span>\n  <span class=\"blue\">static</span> <span class=\"blue\">bool</span> FileSelect(\n    <span class=\"blue\">string</span> folder,\n    <span class=\"blue\">out</span> <span class=\"blue\">string</span> filename )\n  {\n    <span class=\"teal\">OpenFileDialog</span> dlg = <span class=\"blue\">new</span> <span class=\"teal\">OpenFileDialog</span>();\n    dlg.Title = <span class=\"maroon\">\"Select .NET Assembly or Cancel to Exit\"</span>;\n    dlg.CheckFileExists = <span class=\"blue\">true</span>;\n    dlg.CheckPathExists = <span class=\"blue\">true</span>;\n    dlg.InitialDirectory = folder;\n    dlg.Filter = <span class=\"maroon\">\".NET Assembly DLL Files (*.dll)|*.dll\"</span>;\n    <span class=\"blue\">bool</span> rc = ( <span class=\"teal\">DialogResult</span>.OK == dlg.ShowDialog() );\n    filename = dlg.FileName;\n    <span class=\"blue\">return</span> rc;\n  }\n \n  <span class=\"blue\">void</span> DisplayExternalCommands(\n    <span class=\"blue\">string</span> filename,\n    <span class=\"teal\">IWin32Window</span> owner )\n  {\n    <span class=\"teal\">ExternalCommandLister</span> lister\n      = <span class=\"blue\">new</span> <span class=\"teal\">ExternalCommandLister</span>( filename );\n \n    <span class=\"blue\">string</span>[] a = lister.CommandClassnames;\n    <span class=\"blue\">int</span> n = a.Length;\n \n    System.Windows.Forms.<span class=\"teal\">Form</span> form\n      = <span class=\"blue\">new</span> System.Windows.Forms.<span class=\"teal\">Form</span>();\n \n    form.Size = <span class=\"blue\">new</span> <span class=\"teal\">Size</span>( 400, 150 );\n \n    form.Text = <span class=\"blue\">string</span>.Format(\n      <span class=\"maroon\">\"{0} defines {1} external command{2}\"</span>,\n      lister.AssemblyFilename, n,\n      ( 1 == n ? <span class=\"maroon\">\"\"</span> : <span class=\"maroon\">\"s\"</span> ) );\n \n    form.FormBorderStyle\n      = <span class=\"teal\">FormBorderStyle</span>.SizableToolWindow;\n \n    System.Windows.Forms.<span class=\"teal\">TextBox</span> tb\n      = <span class=\"blue\">new</span> System.Windows.Forms.<span class=\"teal\">TextBox</span>();\n \n    tb.Dock = System.Windows.Forms.<span class=\"teal\">DockStyle</span>.Fill;\n    tb.Location = <span class=\"blue\">new</span> System.Drawing.<span class=\"teal\">Point</span>( 0, 0 );\n    tb.Multiline = <span class=\"blue\">true</span>;\n    tb.TabIndex = 0;\n    tb.WordWrap = <span class=\"blue\">false</span>;\n    tb.ReadOnly = <span class=\"blue\">true</span>;\n    tb.Text = <span class=\"blue\">string</span>.Join( <span class=\"maroon\">\"\\r\\n\"</span>,\n      lister.CommandClassnames );\n \n    form.Controls.Add( tb );\n    form.ShowDialog( owner );\n  }\n \n  <span class=\"blue\">public</span> <span class=\"teal\">Result</span> Execute(\n    <span class=\"teal\">ExternalCommandData</span> commandData,\n    <span class=\"blue\">ref</span> <span class=\"blue\">string</span> message,\n    <span class=\"teal\">ElementSet</span> elements )\n  {\n    <span class=\"teal\">IWin32Window</span> revit_window\n      = <span class=\"blue\">new</span> <span class=\"teal\">JtWindowHandle</span>(\n        <span class=\"teal\">ComponentManager</span>.ApplicationWindow );\n \n    <span class=\"blue\">string</span> filename;\n \n    <span class=\"blue\">while</span>( FileSelect(\n      _assembly_folder_name,\n      <span class=\"blue\">out</span> filename ) )\n    {\n      DisplayExternalCommands( filename,\n        revit_window );\n    }\n    <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Succeeded;\n  }\n}\n</pre>\n<p>The reason I implemented this as a Revit command instead of a stand-alone command-line console application was simply to be sure that the Revit API assemblies are already present before I try to load the add-in assemblies.</p>\n<p>I implemented such a stand-alone console application in the past that loaded RevitAPI.dll itself, but that was a long time ago.\nNow the number of Revit API assemblies is larger, and other restrictions may have been added as well.</p>\n<p>A complex external command may obviously depend on additional dependencies in addition to the Revit API assemblies.\nIn that case, it might be harder or impossible to simply load it as shown above.\nOne option then might be to load the other add-in into Revit first using its own loading mechanism, and then try to access its assembly data.</p>\n<p>Another caveat is the ClientId tag in the external add-in manifest.\nFor the simple add-ins that I create, it is hardly used, except for extensible storage access.\nIt might be important for other applications as well, though.</p>\n<p>Here is <a href=\"zip/JtExternalCommandLister.zip\">JtExternalCommandLister.zip</a> containing\n\nthe complete source code, Visual Studio solution and add-in manifest of this external command.</p>\n<p>I hope you find this useful and that it helps resolves discussions such as the one pointed to above.</p>\n<a name=\"2\"></a>\n<p><strong>Addendum</strong> by Rudolf Honke of\n\n<a href=\"http://www.acadgraph.de\">\nMensch und Maschine acadGraph GmbH</a>:\n\n<p>If different add-ins create custom ribbon panels in the same tab, whichever one of them arrives last will obviously run into a collision attempting to create a tab that already exists.\n\n<p>Worse still: the Revit API provides no method to query the existence of a specific tab.\nIt may be possible using the .NET UI Automation library.\n\n<p>However, you can always attempt to retrieve a tab with a specific name using GetRibbonPanels(tabName).\nIf the tab does not exist, this method will throw an exception.\n\n<p>The two add-ins could therefore safely add their panels to the same tab using the following approach:</p>\n<pre class=\"code\">\n<span class=\"blue\">public</span> Autodesk.Revit.UI.<span class=\"teal\">Result</span> OnStartup(\n  <span class=\"teal\">UIControlledApplication</span> application )\n{\n  <span class=\"blue\">string</span> tabName = <span class=\"maroon\">\"TBC\"</span>;\n  <span class=\"blue\">string</span> panelName = <span class=\"maroon\">\"TBC\"</span>;\n \n  <span class=\"blue\">try</span>\n  {\n    <span class=\"teal\">List</span>&lt;<span class=\"teal\">RibbonPanel</span>&gt; panels = application\n      .GetRibbonPanels( tabName );\n  }\n  <span class=\"blue\">catch</span>\n  {\n    <span class=\"green\">// Tab \"TBC\" does not yet exist, </span>\n    <span class=\"green\">// so create new</span>\n \n    application.CreateRibbonTab( tabName );\n  }\n \n  <span class=\"teal\">RibbonPanel</span> panel = application\n    .CreateRibbonPanel( tabName, panelName );\n \n  <span class=\"green\">// Add your buttons here</span>\n \n  <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Succeeded;\n}\n</pre>\n<p>In principle, this approach may be regarded as bad coding style, because\n\n<a href=\"http://www.jacopretorius.net/2009/10/exceptions-should-be-exceptional.html\">\nexceptions are and should remain exceptional</a>.\n\n<p>Since there is no other way to obtain the required information in this case, though, one is left no choice.\n\n<p>Actually an alternative might exist using the .NET UIAutomation library, but such an approach may be awfully slow.</p>\n</p></p></p></p></p></p></p></p>"
  }
]