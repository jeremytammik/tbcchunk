[
  {
    "original_filename": "1955_corridor_skeleton",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n<link rel=\"stylesheet\" type=\"text/css\" href=\"bc.css\">\n<script src=\"https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js\" type=\"text/javascript\"></script>\n</head>\n\n<!---\n\n- alpha shape\n  Get room centerline(s) and intersections (For corridors/passage type rooms)\n  https://forums.autodesk.com/t5/revit-api-forum/get-room-centerline-s-and-intersections-for-corridors-passage/m-p/11212632\n  https://forums.autodesk.com/t5/revit-api-forum/get-room-centerline-s-and-intersections-for-corridors-passage/m-p/11216756\n\ntwitter:\n\nA request for feedback on the upcoming Copy and Paste API enhancements and various interesting approaches to defining a corridor centre line in the #RevitAPI  @AutodeskForge @AutodeskRevit #bim #DynamoBim #ForgeDevCon https://autode.sk/corridorskeleton\n\nAn urgent request for feedback from the Revit development team and an especially interesting thread from\nthe Revit API discussion forum\n&ndash; Copy and paste API Feedback\n&ndash; Corridor skeleton...\n\nlinkedin:\n\nA request for feedback on the upcoming Copy and Paste API enhancements and various interesting approaches to defining a corridor centre line in the #RevitAPI\n\nhttps://autode.sk/corridorskeleton\n\n- Copy and paste API Feedback\n- Corridor skeleton...\n\n#bim #DynamoBim #ForgeDevCon #Revit #API #IFC #SDK #AI #VisualStudio #Autodesk #AEC #adsk\n\nthe [Revit API discussion forum](http://forums.autodesk.com/t5/revit-api-forum/bd-p/160) thread\n\n<center>\n<img src=\"img/\" alt=\"\" title=\"\" width=\"600\" height=\"\"/>\n<p style=\"font-size: 80%; font-style:italic\"></p>\n</center>\n\n-->"
  },
  {
    "original_filename": "1955_corridor_skeleton",
    "header_text": "Corridor Skeleton, Copy and Paste API",
    "local_header_href": "#corridor-skeleton-copy-and-paste-api",
    "chunk_text": "### Corridor Skeleton, Copy and Paste API\n\nToday, we highlight an urgent request for feedback from the Revit development team and an especially interesting thread from\nthe [Revit API discussion forum](http://forums.autodesk.com/t5/revit-api-forum/bd-p/160):\n\n- [Copy and paste API feedback](#2)\n- [Corridor skeleton](#3)"
  },
  {
    "original_filename": "1955_corridor_skeleton",
    "header_text": "Copy and Paste API Feedback",
    "local_header_href": "#2",
    "chunk_text": "####<a name=\"2\"></a> Copy and Paste API Feedback\n\nThe development team announced the Copy/Paste API enhancement and request feedback on it in\nthe [Revit API discussion forum](http://forums.autodesk.com/t5/revit-api-forum/bd-p/160) thread asking \nto [help us test the enhanced Copy API for sketch members!](https://forums.autodesk.com/t5/revit-api-forum/june-preview-release-help-us-test-the-enhanced-copy-api-for/td-p/11234171)\n\n> If you are a participant in the Revit beta program, please check out this month's June preview release!\n\n> We have an enhanced API to better support Copy-Paste of Sketch members and would like your feedback on it.\n\n> Weâ€™ve made Copy-Pasting of Sketch members in API more consistent with UI, and in the process fixed multiple bugs.\n\n> Find the summary of changes and code samples to try out the new functionality on our Preview Release Forum.\n\n> Apply for access at [revit.preview.access@autodesk.com](mailto:revit.preview.access@autodesk.com).\n\n> For any questions or concerns you might have, please get in touch with us at [feedback.autodesk.com](mailto:feedback.autodesk.com)."
  },
  {
    "original_filename": "1955_corridor_skeleton",
    "header_text": "Corridor Skeleton",
    "local_header_href": "#3",
    "chunk_text": "####<a name=\"3\"></a> Corridor Skeleton\n\nAn exciting discussion ensued in\nthe [Revit API discussion forum](http://forums.autodesk.com/t5/revit-api-forum/bd-p/160) thread on how \nto [get room centerlines and intersections for corridors and passages](https://forums.autodesk.com/t5/revit-api-forum/get-room-centerline-s-and-intersections-for-corridors-passage/m-p/11216756):\n\n**Question:** How do I get the centerlines of a single room shown below?\nI know one way is to divide the room manually into rectangular rooms with additional room separation lines, that way I can just use bounding boxes and get individual center lines.\nBut how Do I approach this for a single room with multiple turns/crossing/intersection??\n\n<center>\n<img src=\"img/corridor_centerline_1.png\" alt=\"Corridor centerline\" title=\"Corridor centerline\" width=\"400\"/> <!-- 1117 -->\n</center>\n\n**Answer:** This sounds like an interesting computational algebra task.\nI would suggest doing some purely geometrical research completely disconnected from Revit and BIM, to start with.\nInitially, I thought that\nan [alpha shape](https://en.wikipedia.org/wiki/Alpha_shape) might\nbe useful for you, but just looking at the picture,\nthe [minimum spanning tree](https://en.wikipedia.org/wiki/Minimum_spanning_tree) looks more like your goal.\n\n**Response:** Thanks for the Alpha Shape suggestion.\nThat is what I am ultimately looking for.\nIt's also called Concave hull in some forums.\n\nI went through the steps where one has to vary the 'Alpha' to get the desired outcome which is basically the radius of the circle getting used in the algorithm.\n\nI looked at this [alpha shape (concave hull) algorithm in C#](https://stackoverflow.com/questions/16625063/alpha-shape-concave-hull-algorithm-in-c-sharp).\nI definitely want to implement this for my case.\n\nMeanwhile, me being lazy, I figured out an easy way to solve my particular problem.\n\nI used part of\nyour [Revit API code for convex hull](https://thebuildingcoder.typepad.com/blog/2016/08/online-revit-api-docs-and-convex-hull.html#3) to\nget the vertices of the room. \nThis is necessary, as there are multiple boundary segments when there is an overlapping room separation line, a door in the wall, etc.\nInstead of calculating the convex hull, I just iterate over those resulting vertices and determine the pair of points which are 'nearby'.\nAs the corridor width is fairly standard, I can define my own suitable 'nearby' tolerance.\nThen, I calculate the midpoint of each pair.\nThat basically provides the centerline vertices:\n\n<center>\n<img src=\"img/corridor_centerline_2.png\" alt=\"Corridor centerline\" title=\"Corridor centerline\" width=\"400\"/> <!-- 1135 -->\n</center>\n\nI understand this is just a temporary and lazy solution that only works for my case.\nI intend to implement the Alpha shape (concave hull) algorithm over the weekend. \n\n**Answer:** The simpler the better.\n[Kiss](https://en.wikipedia.org/wiki/KISS_principle)!\nI love your pragmatic closest-point-pair approach.\nThank you very much for sharing that, and looking forward to the alpha shape results.\nHappy, fruitful weekend and successful coding!\n\n**Answer2:** I think a [straight skeleton](https://en.wikipedia.org/wiki/Straight_skeleton),\nor some other topological skeleton, would work much better than an alpha shape for your situation.\n\n**Response:** So, I was implementing Alpha shape for this polygon; halfway through, I realized that already is an Alpha shape. :-)\nI read more about Straight skeleton.\nIt led me to Medial Axis, which is basically the centerlines that we are talking about.\nThere are a few algorithms to calculate Medial Axis, e.g.,\nto [find medial axis of a polygon using C#](https://stackoverflow.com/questions/1069523/find-medial-axis-of-a-polygon-using-c-sharp).\nBut this seems quite time consuming, and for now I am adhering\nto [Kiss](https://en.wikipedia.org/wiki/KISS_principle)! :-)\nThanks @jeremy.tammik and @mhannonQ65N2 for your inputs. \n\nHere is the Method which returns the list of pairs of vertices which are 'nearby'.\n\nNote: This only works when the corridor width is around 1500mm (which is design standard in my firm). For larger width, we can vary the 'tolerance' variable. Also, the length of a single branch/ junction is not less than 2550mm. Otherwise it'll return additional pairs. Which is more or less fine as the center points of those pairs will also lie on the Medial Axis (corridor centerline)\n\n<pre class=\"code\">\n&nbsp;&nbsp;<span style=\"color:blue;\">public</span>&nbsp;List&lt;List&lt;XYZ&gt;&gt;&nbsp;<span style=\"color:#74531f;\">ReturnVertexPairs</span>(Room&nbsp;<span style=\"color:#1f377f;\">corridorRoom</span>)\n&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;SpatialElementBoundaryOptions&nbsp;<span style=\"color:#1f377f;\">opt</span>&nbsp;=&nbsp;<span style=\"color:blue;\">new</span>&nbsp;SpatialElementBoundaryOptions\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SpatialElementBoundaryLocation&nbsp;=\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SpatialElementBoundaryLocation.Finish\n&nbsp;&nbsp;&nbsp;&nbsp;};\n \n&nbsp;&nbsp;&nbsp;&nbsp;IList&lt;IList&lt;BoundarySegment&gt;&gt;&nbsp;<span style=\"color:#1f377f;\">loops</span>&nbsp;=&nbsp;corridorRoom.GetBoundarySegments(opt);\n \n&nbsp;&nbsp;&nbsp;&nbsp;List&lt;XYZ&gt;&nbsp;<span style=\"color:#1f377f;\">roomVertices</span>&nbsp;=&nbsp;<span style=\"color:blue;\">new</span>&nbsp;List&lt;XYZ&gt;();&nbsp;<span style=\"color:green;\">//List&nbsp;of&nbsp;all&nbsp;room&nbsp;vertices</span>\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:#8f08c4;\">foreach</span>&nbsp;(IList&lt;BoundarySegment&gt;&nbsp;<span style=\"color:#1f377f;\">loop</span>&nbsp;<span style=\"color:#8f08c4;\">in</span>&nbsp;loops)\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:green;\">//TaskDialog.Show(&quot;Revit&quot;,&nbsp;&quot;Total&nbsp;Segments&nbsp;=&nbsp;&quot;&nbsp;+&nbsp;loop.Count().ToString());</span>\n \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XYZ&nbsp;<span style=\"color:#1f377f;\">p0</span>&nbsp;=&nbsp;<span style=\"color:blue;\">null</span>;&nbsp;<span style=\"color:green;\">//previous&nbsp;segment&nbsp;start&nbsp;point</span>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XYZ&nbsp;<span style=\"color:#1f377f;\">p</span>&nbsp;=&nbsp;<span style=\"color:blue;\">null</span>;&nbsp;<span style=\"color:green;\">//&nbsp;segment&nbsp;start&nbsp;point</span>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XYZ&nbsp;<span style=\"color:#1f377f;\">q</span>&nbsp;=&nbsp;<span style=\"color:blue;\">null</span>;&nbsp;<span style=\"color:green;\">//&nbsp;segment&nbsp;end&nbsp;point</span>\n \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:#8f08c4;\">foreach</span>&nbsp;(BoundarySegment&nbsp;<span style=\"color:#1f377f;\">seg</span>&nbsp;<span style=\"color:#8f08c4;\">in</span>&nbsp;loop)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q&nbsp;=&nbsp;seg.GetCurve().GetEndPoint(1);\n \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:#8f08c4;\">if</span>&nbsp;(p&nbsp;==&nbsp;<span style=\"color:blue;\">null</span>)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;roomVertices.Add(seg.GetCurve().GetEndPoint(0));\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p&nbsp;=&nbsp;seg.GetCurve().GetEndPoint(0);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p0&nbsp;=&nbsp;p;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:#8f08c4;\">continue</span>;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p&nbsp;=&nbsp;seg.GetCurve().GetEndPoint(0);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:#8f08c4;\">if</span>&nbsp;(p&nbsp;!=&nbsp;<span style=\"color:blue;\">null</span>&nbsp;&amp;&amp;&nbsp;p0&nbsp;!=&nbsp;<span style=\"color:blue;\">null</span>)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:#8f08c4;\">if</span>&nbsp;(AreCollinear(p0,&nbsp;p,&nbsp;q))<span style=\"color:green;\">//skipping&nbsp;the&nbsp;segments&nbsp;that&nbsp;are&nbsp;collinear</span>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p0&nbsp;=&nbsp;p;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:#8f08c4;\">continue</span>;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:#8f08c4;\">else</span>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;roomVertices.Add(p);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p0&nbsp;=&nbsp;p;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;}\n \n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">double</span>&nbsp;<span style=\"color:#1f377f;\">tolerance</span>&nbsp;=&nbsp;2550;&nbsp;<span style=\"color:green;\">//Distance&nbsp;between&nbsp;two&nbsp;Points&nbsp;(in&nbsp;mm)&nbsp;should&nbsp;be&nbsp;less&nbsp;than&nbsp;this&nbsp;number</span>\n&nbsp;&nbsp;&nbsp;&nbsp;List&lt;List&lt;XYZ&gt;&gt;&nbsp;<span style=\"color:#1f377f;\">nearbyPairs</span>&nbsp;=&nbsp;<span style=\"color:blue;\">new</span>&nbsp;List&lt;List&lt;XYZ&gt;&gt;();&nbsp;<span style=\"color:green;\">//List&nbsp;of&nbsp;Pairs&nbsp;of&nbsp;nearby&nbsp;points</span>\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:#8f08c4;\">for</span>&nbsp;(<span style=\"color:blue;\">int</span>&nbsp;<span style=\"color:#1f377f;\">i</span>&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;roomVertices.Count()&nbsp;-&nbsp;1;&nbsp;i++)\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:#8f08c4;\">for</span>&nbsp;(<span style=\"color:blue;\">int</span>&nbsp;<span style=\"color:#1f377f;\">j</span>&nbsp;=&nbsp;i&nbsp;+&nbsp;1;&nbsp;j&nbsp;&lt;&nbsp;roomVertices.Count();&nbsp;j++)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">double</span>&nbsp;<span style=\"color:#1f377f;\">dist</span>&nbsp;=&nbsp;roomVertices[i].DistanceTo(roomVertices[j])&nbsp;*&nbsp;304.8;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:#8f08c4;\">if</span>&nbsp;(dist&nbsp;&lt;&nbsp;tolerance)&nbsp;<span style=\"color:green;\">//checking&nbsp;whether&nbsp;two&nbsp;points&nbsp;are&nbsp;nearby&nbsp;based&nbsp;on&nbsp;tolerance</span>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nearbyPairs.Add(<span style=\"color:blue;\">new</span>&nbsp;List&lt;XYZ&gt;&nbsp;{&nbsp;roomVertices[i],&nbsp;roomVertices[j]&nbsp;});\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:green;\">//TaskDialog.Show(&quot;Revit&quot;,&nbsp;&quot;Total&nbsp;points&nbsp;=&nbsp;&quot;&nbsp;+&nbsp;roomVertices.Count().ToString()</span>\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:green;\">//&nbsp;&nbsp;+&nbsp;Environment.NewLine&nbsp;+&nbsp;&quot;Total&nbsp;Pairs&nbsp;=&nbsp;&quot;&nbsp;+&nbsp;nearbyPairs.Count());</span>\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:#8f08c4;\">return</span>&nbsp;nearbyPairs;\n&nbsp;&nbsp;}\n \n</pre>\n\nHelper method to check whether points are collinear, used to skip collinear boundary segments:\n\n<pre class=\"code\">\n&nbsp;&nbsp;<span style=\"color:blue;\">static</span>&nbsp;<span style=\"color:blue;\">bool</span>&nbsp;<span style=\"color:#74531f;\">AreCollinear</span>(XYZ&nbsp;<span style=\"color:#1f377f;\">p1</span>,&nbsp;XYZ&nbsp;<span style=\"color:#1f377f;\">p2</span>,&nbsp;XYZ&nbsp;<span style=\"color:#1f377f;\">p3</span>)\n&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">bool</span>&nbsp;<span style=\"color:#1f377f;\">collinear</span>&nbsp;=&nbsp;<span style=\"color:blue;\">false</span>;\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">double</span>&nbsp;<span style=\"color:#1f377f;\">area</span>&nbsp;=&nbsp;0.5&nbsp;*&nbsp;Math.Abs(p1.X&nbsp;*&nbsp;(p2.Y&nbsp;-&nbsp;p3.Y)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+&nbsp;p2.X&nbsp;*&nbsp;(p3.Y&nbsp;-&nbsp;p1.Y)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+&nbsp;p3.X&nbsp;*&nbsp;(p1.Y&nbsp;-&nbsp;p2.Y));\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:green;\">//sometimes&nbsp;area&nbsp;is&nbsp;not&nbsp;exactly&nbsp;zero&nbsp;but&nbsp;is&nbsp;very&nbsp;small&nbsp;number</span>\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:#8f08c4;\">if</span>&nbsp;(area&nbsp;&lt;&nbsp;0.1)\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;collinear&nbsp;=&nbsp;<span style=\"color:blue;\">true</span>;\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:#8f08c4;\">return</span>&nbsp;collinear;\n&nbsp;&nbsp;}\n</pre>\n\nMany thanks to @amrut.modani.wwi for raising this and sharing his nice approach!"
  }
]