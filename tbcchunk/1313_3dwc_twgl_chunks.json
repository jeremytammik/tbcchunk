[
  {
    "original_filename": "1313_3dwc_twgl",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<head>\n<meta content=\"text/html; charset=utf-8\" http-equiv=\"Content-Type\"/>\n<link href=\"bc.css\" rel=\"stylesheet\" type=\"text/css\"/>\n</head>"
  },
  {
    "original_filename": "1313_3dwc_twgl",
    "header_text": "Live Rendering of 3D Revit Element Geometry in a Remote WebGL Viewer",
    "local_header_href": "#live-rendering-of-3d-revit-element-geometry-in-a-remote-webgl-viewer",
    "chunk_text": "<h3>Live Rendering of 3D Revit Element Geometry in a Remote WebGL Viewer</h3><p>Today, I'll implement live real-time export of 3D geometry from a Revit add-in to a web-hosted WebGL viewer.</p><p>This is an enhancement to the initial version\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2015/04/exporting-3d-element-geometry-to-a-webgl-viewer.html\">\nexporting 3D element geometry to a WebGL viewer</a>,\nwhich just generated data that I copied and pasted to hard-code it into the\n<a href=\"https://github.com/jeremytammik/NodeWebGL\">NodeWebGL viewer</a> as\na proof of concept.</p><p>Meanwhile, I enhanced the WebGL viewer in various ways to prepare it for this real-time live connection, mainly by adding a REST API and support for HTTP POST:</p><ul>\n<li><a href=\"http://the3dwebcoder.typepad.com/blog/2015/04/implementing-a-node-rest-api-server.html\">Implementing a Node REST API server</a></li>\n<li><a href=\"http://the3dwebcoder.typepad.com/blog/2015/04/implementing-node-server-http-post-get-vs-post.html\">Implementing HTTP POST</a></li>\n<li><a href=\"http://the3dwebcoder.typepad.com/blog/2015/04/post-data-and-swig-driven-webgl-viewer-node-server.html\">Adding a view engine</a></li>\n<li><a href=\"http://the3dwebcoder.typepad.com/blog/2015/04/node-server-rendering-using-either-swig-and-handlebars.html\">POST geometry data to the viewer</a></li>\n<li><a href=\"http://the3dwebcoder.typepad.com/blog/2015/04/cleaner-node-server-rest-api-implementation.html\">Cleaning up the Node server REST API implementation</a></li>\n</ul><p>Now that the viewer sports a REST API accepting POST data, the time has come to drive it directly from the Revit add-in instead of copy and paste of hard-coded geometry data into the viewer.\n\n<p>Here are the steps I took to achieve this:</p>\n<ul>\n<li><a href=\"#2\">Package geometry data into JSON</a></li>\n<li><a href=\"#3\">Send an HTTP POST Request and Display Result in Browser</a></li>\n<li><a href=\"#4\">Install Node.js on Windows</a></li>\n<li><a href=\"#5\">Demo</a></li>\n<li><a href=\"#6\">Download</a></li>\n<li><a href=\"#7\">Next steps</a></li>\n</ul>\n<a name=\"2\"></a>\n<h4>Package Geometry Data into JSON</h4>\n<p>I retrieve the geometry to be rendered by analysing the element geometry of a selected Revit element and generating lists of face vertices, normal vectors and indices to represent it.</p>\n<p>In the initial implementation, I just printed this data to the debug console for manual copy and paste to the viewer.</p>\n<p>Now I package that data into a JSON string for rendering via the <a href=\"#3\">DisplayWgl</a> method like this:</p>\n<pre class=\"code\">\n  <span class=\"teal\">List</span>&lt;<span class=\"blue\">int</span>&gt; faceIndices = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"blue\">int</span>&gt;();\n  <span class=\"teal\">List</span>&lt;<span class=\"blue\">int</span>&gt; faceVertices = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"blue\">int</span>&gt;();\n  <span class=\"teal\">List</span>&lt;<span class=\"blue\">double</span>&gt; faceNormals = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"blue\">double</span>&gt;();\n\n  . . .\n\n  <span class=\"green\">// Scale the vertices to a [-1,1] cube </span>\n  <span class=\"green\">// centered around the origin. Translation</span>\n  <span class=\"green\">// to the origin was already performed above.</span>\n \n  <span class=\"blue\">double</span> scale = 2.0 / FootToMm( MaxCoord( vsize ) );\n \n  <span class=\"blue\">string</span> sposition = <span class=\"blue\">string</span>.Join( <span class=\"maroon\">\", \"</span>,\n    faceVertices.ConvertAll&lt;<span class=\"blue\">string</span>&gt;(\n      i =&gt; ( i * scale ).ToString( <span class=\"maroon\">\"0.##\"</span> ) ) );\n \n  <span class=\"blue\">string</span> snormal = <span class=\"blue\">string</span>.Join( <span class=\"maroon\">\", \"</span>,\n    faceNormals.ConvertAll&lt;<span class=\"blue\">string</span>&gt;(\n      f =&gt; f.ToString( <span class=\"maroon\">\"0.##\"</span> ) ) );\n \n  <span class=\"blue\">string</span> sindices = <span class=\"blue\">string</span>.Join( <span class=\"maroon\">\", \"</span>,\n    faceIndices.ConvertAll&lt;<span class=\"blue\">string</span>&gt;(\n      i =&gt; i.ToString() ) );\n \n  <span class=\"teal\">Debug</span>.Print( <span class=\"maroon\">\"position: [{0}],\"</span>, sposition );\n  <span class=\"teal\">Debug</span>.Print( <span class=\"maroon\">\"normal: [{0}],\"</span>, snormal );\n  <span class=\"teal\">Debug</span>.Print( <span class=\"maroon\">\"indices: [{0}],\"</span>, sindices );\n \n  <span class=\"blue\">string</span> json_geometry_data =\n    <span class=\"maroon\">\"{ \\\"position\\\": [\"</span> + sposition\n    + <span class=\"maroon\">\"],\\n\\\"normal\\\": [\"</span> + snormal\n    + <span class=\"maroon\">\"],\\n\\\"indices\\\": [\"</span> + sindices\n    + <span class=\"maroon\">\"] }\"</span>;\n \n  <span class=\"teal\">Debug</span>.Print( <span class=\"maroon\">\"json: \"</span> + json_geometry_data );\n \n  DisplayWgl( json_geometry_data );\n</pre>\n<p>With that in hand, it is time for the exciting stuff.</p>\n<a name=\"3\"></a>\n<h4>Send an HTTP POST Request and Display Result in Browser</h4>\n<p>The DisplayWgl implements the following tasks:</p>\n<ul>\n<li>Define the base URL and REST API route on the WebGL rendering server</li>\n<li>Support switching between a locally hosted or remote Heroku-hosted server</li>\n<li>Receive a JSON package defining the geometry data to be rendered</li>\n<li>Package the JSON string into a POST data package</li>\n<li>Sends it via a HTTP POST request to the server</li>\n<li>Retrieve the HTTP result</li>\n<li>Store it in a local file</li>\n<li>Display it in the browser</li>\n</ul>\n<p>The implementation looks like this:</p>\n<pre class=\"code\">\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n  <span class=\"gray\">///</span><span class=\"green\"> Toggle between a local server and</span>\n  <span class=\"gray\">///</span><span class=\"green\"> a remote Heroku-hosted one.</span>\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n  <span class=\"blue\">static</span> <span class=\"blue\">public</span> <span class=\"blue\">bool</span> UseLocalServer = <span class=\"blue\">false</span>;\n\n  . . .\n\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n  <span class=\"gray\">///</span><span class=\"green\"> Invoke the node.js WebGL viewer web server.</span>\n  <span class=\"gray\">///</span><span class=\"green\"> Use a local or global base URL and an HTTP POST</span>\n  <span class=\"gray\">///</span><span class=\"green\"> request passing the 3D geometry data as body.</span>\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n  <span class=\"blue\">void</span> DisplayWgl( <span class=\"blue\">string</span> json_geometry_data )\n  {\n    <span class=\"blue\">string</span> base_url = UseLocalServer\n      ? <span class=\"maroon\">\"http://127.0.0.1:5000\"</span>\n      : <span class=\"maroon\">\"https://nameless-harbor-7576.herokuapp.com\"</span>;\n \n    <span class=\"blue\">string</span> api_route = <span class=\"maroon\">\"api/v2\"</span>;\n \n    <span class=\"blue\">string</span> uri = base_url + <span class=\"maroon\">\"/\"</span> + api_route;\n \n    <span class=\"teal\">HttpWebRequest</span> req = <span class=\"teal\">WebRequest</span>.Create( uri ) <span class=\"blue\">as</span> <span class=\"teal\">HttpWebRequest</span>;\n \n    req.KeepAlive = <span class=\"blue\">false</span>;\n    req.Method = <span class=\"teal\">WebRequestMethods</span>.<span class=\"teal\">Http</span>.Post;\n \n    <span class=\"green\">// Turn our request string into a byte stream.</span>\n \n    <span class=\"blue\">byte</span>[] postBytes = <span class=\"teal\">Encoding</span>.UTF8.GetBytes( json_geometry_data );\n \n    req.ContentLength = postBytes.Length;\n \n    <span class=\"green\">// Specify content type.</span>\n \n    req.ContentType = <span class=\"maroon\">\"application/json; charset=UTF-8\"</span>; <span class=\"green\">// or just \"text/json\"?</span>\n    req.Accept = <span class=\"maroon\">\"application/json\"</span>;\n    req.ContentLength = postBytes.Length;\n \n    <span class=\"teal\">Stream</span> requestStream = req.GetRequestStream();\n    requestStream.Write( postBytes, 0, postBytes.Length );\n    requestStream.Close();\n \n    <span class=\"teal\">HttpWebResponse</span> res = req.GetResponse() <span class=\"blue\">as</span> <span class=\"teal\">HttpWebResponse</span>;\n \n    <span class=\"blue\">string</span> result;\n \n    <span class=\"blue\">using</span>( <span class=\"teal\">StreamReader</span> reader = <span class=\"blue\">new</span> <span class=\"teal\">StreamReader</span>(\n      res.GetResponseStream() ) )\n    {\n      result = reader.ReadToEnd();\n    }\n \n    <span class=\"blue\">string</span> filename = <span class=\"teal\">Path</span>.GetTempFileName();\n    filename = <span class=\"teal\">Path</span>.ChangeExtension( filename, <span class=\"maroon\">\"html\"</span> );\n \n    <span class=\"blue\">using</span>( <span class=\"teal\">StreamWriter</span> writer = <span class=\"teal\">File</span>.CreateText( filename ) )\n    {\n      writer.Write( result );\n      writer.Close();\n    }\n \n    System.Diagnostics.<span class=\"teal\">Process</span>.Start( filename );\n  }\n</pre>\n<p>I wonder whether there might be an easier or more efficient way to transfer the HTTP result to the browser than saving it to a local file.</p>\n<p>There are probably more efficient methods, but this approach is hard to beat for easy of use.</p>\n<a name=\"4\"></a>\n<h4>Install Node.js on Windows</h4>\n<p>For local testing, I initially thought I would run the node.js server on the Mac and access that from the Windows virtual machine.</p>\n<p>However, I was unable to access the Mac localhost running my local node server from Parallels.</p>\n<p>Happily, it took one single click to install node.js on the Windows virtual machine and then run the unmodified code inside the virtual box:</p>\n<p>Just go to <a href=\"https://nodejs.org\">nodejs.org</a> and click the big green Install button.</p>\n<p>After doing so, I could immediately run the existing server locally inside the box:</p>\n<center>\n<img alt=\"NodeWebGL running locally on Windows\" src=\"img/twgl_node_js_windows.png\" width=\"516\"/>\n</center>\n<p>It worked fine locally.</p>\n<p>Next, I switched to the remote viewer.</p>\n<p>That worked as well with no problem.</p>\n<a name=\"5\"></a>\n<h4>Demo</h4>\n<p>Here is a quick <a href=\"https://youtu.be/qBjbb_Wv6Qk\">one-minute video</a> showing the TwglExport Revit add-in and the Heroku-hosted node.js WebGL server NodeWebGL in concerted action:</p>\n<center>\n<iframe allowfullscreen=\"\" frameborder=\"0\" height=\"270\" src=\"https://www.youtube.com/embed/qBjbb_Wv6Qk\" width=\"480\"></iframe>\n</center>\n<a name=\"6\"></a>\n<h4>Download</h4>\n<p>The entire TwglExport source code, Visual Studio solution and add-in manifest are provided in the\n\n<a href=\"https://github.com/jeremytammik/TwglExport\">TwglExport GitHub repository</a>,\n\nand the version presented here is\n\n<a href=\"https://github.com/jeremytammik/TwglExport/releases/tag/2015.0.0.3\">release 2015.0.0.3</a>.</p>\n<p>The complete node server implementation is available from the\n<a href=\"https://github.com/jeremytammik/NodeWebGL\">NodeWebGL GitHub repo</a>,\nand the version discussed here is\n<a href=\"https://github.com/jeremytammik/NodeWebGL/releases/tag/0.2.7\">0.2.7</a>.</p>\n<a name=\"7\"></a>\n<h4>Next Steps</h4>\n<p>The Revit element traversal is currently totally simplistic.</p>\n<p>It grabs the first non-empty solid it can find and renders that with no questions asked.</p>\n<p>This will not work for a family instance, for instance – please pardon the pun – to access any solid contained in its geometry, you have to navigate through the geometry instance level first.</p>\n<p>I could obviously  enhance the geometry traversal, as we already did for numerous other add-ins, e.g. the\n<a href=\"http://thebuildingcoder.typepad.com/blog/2012/07/obj-model-exporter-with-multiple-solid-support.html\">\nOBJ exporter</a>.</p>\n<p>That would be silly, though.</p>\n<p>It is much easier to implement a\n<a href=\"http://thebuildingcoder.typepad.com/blog/about-the-author.html#5.1\">\ncustom exporter</a> and grab the geometry from that.</p>\n<p>No more worries about elements, transformations, instances and all that stuff.</p>\n<p>Stay tuned and have fun!</p>\n</p>"
  },
  {
    "original_filename": "1313_3dwc_twgl",
    "header_text": "Package Geometry Data into JSON",
    "local_header_href": "#package-geometry-data-into-json",
    "chunk_text": "<h4>Package Geometry Data into JSON</h4><p>I retrieve the geometry to be rendered by analysing the element geometry of a selected Revit element and generating lists of face vertices, normal vectors and indices to represent it.</p><p>In the initial implementation, I just printed this data to the debug console for manual copy and paste to the viewer.</p><p>Now I package that data into a JSON string for rendering via the <a href=\"#3\">DisplayWgl</a> method like this:</p><pre class=\"code\">\n  <span class=\"teal\">List</span>&lt;<span class=\"blue\">int</span>&gt; faceIndices = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"blue\">int</span>&gt;();\n  <span class=\"teal\">List</span>&lt;<span class=\"blue\">int</span>&gt; faceVertices = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"blue\">int</span>&gt;();\n  <span class=\"teal\">List</span>&lt;<span class=\"blue\">double</span>&gt; faceNormals = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"blue\">double</span>&gt;();\n\n  . . .\n\n  <span class=\"green\">// Scale the vertices to a [-1,1] cube </span>\n  <span class=\"green\">// centered around the origin. Translation</span>\n  <span class=\"green\">// to the origin was already performed above.</span>\n \n  <span class=\"blue\">double</span> scale = 2.0 / FootToMm( MaxCoord( vsize ) );\n \n  <span class=\"blue\">string</span> sposition = <span class=\"blue\">string</span>.Join( <span class=\"maroon\">\", \"</span>,\n    faceVertices.ConvertAll&lt;<span class=\"blue\">string</span>&gt;(\n      i =&gt; ( i * scale ).ToString( <span class=\"maroon\">\"0.##\"</span> ) ) );\n \n  <span class=\"blue\">string</span> snormal = <span class=\"blue\">string</span>.Join( <span class=\"maroon\">\", \"</span>,\n    faceNormals.ConvertAll&lt;<span class=\"blue\">string</span>&gt;(\n      f =&gt; f.ToString( <span class=\"maroon\">\"0.##\"</span> ) ) );\n \n  <span class=\"blue\">string</span> sindices = <span class=\"blue\">string</span>.Join( <span class=\"maroon\">\", \"</span>,\n    faceIndices.ConvertAll&lt;<span class=\"blue\">string</span>&gt;(\n      i =&gt; i.ToString() ) );\n \n  <span class=\"teal\">Debug</span>.Print( <span class=\"maroon\">\"position: [{0}],\"</span>, sposition );\n  <span class=\"teal\">Debug</span>.Print( <span class=\"maroon\">\"normal: [{0}],\"</span>, snormal );\n  <span class=\"teal\">Debug</span>.Print( <span class=\"maroon\">\"indices: [{0}],\"</span>, sindices );\n \n  <span class=\"blue\">string</span> json_geometry_data =\n    <span class=\"maroon\">\"{ \\\"position\\\": [\"</span> + sposition\n    + <span class=\"maroon\">\"],\\n\\\"normal\\\": [\"</span> + snormal\n    + <span class=\"maroon\">\"],\\n\\\"indices\\\": [\"</span> + sindices\n    + <span class=\"maroon\">\"] }\"</span>;\n \n  <span class=\"teal\">Debug</span>.Print( <span class=\"maroon\">\"json: \"</span> + json_geometry_data );\n \n  DisplayWgl( json_geometry_data );\n</pre><p>With that in hand, it is time for the exciting stuff.</p><a name=\"3\"></a>"
  },
  {
    "original_filename": "1313_3dwc_twgl",
    "header_text": "Send an HTTP POST Request and Display Result in Browser",
    "local_header_href": "#send-an-http-post-request-and-display-result-in-browser",
    "chunk_text": "<h4>Send an HTTP POST Request and Display Result in Browser</h4><p>The DisplayWgl implements the following tasks:</p><ul>\n<li>Define the base URL and REST API route on the WebGL rendering server</li>\n<li>Support switching between a locally hosted or remote Heroku-hosted server</li>\n<li>Receive a JSON package defining the geometry data to be rendered</li>\n<li>Package the JSON string into a POST data package</li>\n<li>Sends it via a HTTP POST request to the server</li>\n<li>Retrieve the HTTP result</li>\n<li>Store it in a local file</li>\n<li>Display it in the browser</li>\n</ul><p>The implementation looks like this:</p><pre class=\"code\">\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n  <span class=\"gray\">///</span><span class=\"green\"> Toggle between a local server and</span>\n  <span class=\"gray\">///</span><span class=\"green\"> a remote Heroku-hosted one.</span>\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n  <span class=\"blue\">static</span> <span class=\"blue\">public</span> <span class=\"blue\">bool</span> UseLocalServer = <span class=\"blue\">false</span>;\n\n  . . .\n\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n  <span class=\"gray\">///</span><span class=\"green\"> Invoke the node.js WebGL viewer web server.</span>\n  <span class=\"gray\">///</span><span class=\"green\"> Use a local or global base URL and an HTTP POST</span>\n  <span class=\"gray\">///</span><span class=\"green\"> request passing the 3D geometry data as body.</span>\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n  <span class=\"blue\">void</span> DisplayWgl( <span class=\"blue\">string</span> json_geometry_data )\n  {\n    <span class=\"blue\">string</span> base_url = UseLocalServer\n      ? <span class=\"maroon\">\"http://127.0.0.1:5000\"</span>\n      : <span class=\"maroon\">\"https://nameless-harbor-7576.herokuapp.com\"</span>;\n \n    <span class=\"blue\">string</span> api_route = <span class=\"maroon\">\"api/v2\"</span>;\n \n    <span class=\"blue\">string</span> uri = base_url + <span class=\"maroon\">\"/\"</span> + api_route;\n \n    <span class=\"teal\">HttpWebRequest</span> req = <span class=\"teal\">WebRequest</span>.Create( uri ) <span class=\"blue\">as</span> <span class=\"teal\">HttpWebRequest</span>;\n \n    req.KeepAlive = <span class=\"blue\">false</span>;\n    req.Method = <span class=\"teal\">WebRequestMethods</span>.<span class=\"teal\">Http</span>.Post;\n \n    <span class=\"green\">// Turn our request string into a byte stream.</span>\n \n    <span class=\"blue\">byte</span>[] postBytes = <span class=\"teal\">Encoding</span>.UTF8.GetBytes( json_geometry_data );\n \n    req.ContentLength = postBytes.Length;\n \n    <span class=\"green\">// Specify content type.</span>\n \n    req.ContentType = <span class=\"maroon\">\"application/json; charset=UTF-8\"</span>; <span class=\"green\">// or just \"text/json\"?</span>\n    req.Accept = <span class=\"maroon\">\"application/json\"</span>;\n    req.ContentLength = postBytes.Length;\n \n    <span class=\"teal\">Stream</span> requestStream = req.GetRequestStream();\n    requestStream.Write( postBytes, 0, postBytes.Length );\n    requestStream.Close();\n \n    <span class=\"teal\">HttpWebResponse</span> res = req.GetResponse() <span class=\"blue\">as</span> <span class=\"teal\">HttpWebResponse</span>;\n \n    <span class=\"blue\">string</span> result;\n \n    <span class=\"blue\">using</span>( <span class=\"teal\">StreamReader</span> reader = <span class=\"blue\">new</span> <span class=\"teal\">StreamReader</span>(\n      res.GetResponseStream() ) )\n    {\n      result = reader.ReadToEnd();\n    }\n \n    <span class=\"blue\">string</span> filename = <span class=\"teal\">Path</span>.GetTempFileName();\n    filename = <span class=\"teal\">Path</span>.ChangeExtension( filename, <span class=\"maroon\">\"html\"</span> );\n \n    <span class=\"blue\">using</span>( <span class=\"teal\">StreamWriter</span> writer = <span class=\"teal\">File</span>.CreateText( filename ) )\n    {\n      writer.Write( result );\n      writer.Close();\n    }\n \n    System.Diagnostics.<span class=\"teal\">Process</span>.Start( filename );\n  }\n</pre><p>I wonder whether there might be an easier or more efficient way to transfer the HTTP result to the browser than saving it to a local file.</p><p>There are probably more efficient methods, but this approach is hard to beat for easy of use.</p><a name=\"4\"></a>"
  },
  {
    "original_filename": "1313_3dwc_twgl",
    "header_text": "Install Node.js on Windows",
    "local_header_href": "#install-nodejs-on-windows",
    "chunk_text": "<h4>Install Node.js on Windows</h4><p>For local testing, I initially thought I would run the node.js server on the Mac and access that from the Windows virtual machine.</p><p>However, I was unable to access the Mac localhost running my local node server from Parallels.</p><p>Happily, it took one single click to install node.js on the Windows virtual machine and then run the unmodified code inside the virtual box:</p><p>Just go to <a href=\"https://nodejs.org\">nodejs.org</a> and click the big green Install button.</p><p>After doing so, I could immediately run the existing server locally inside the box:</p><center>\n<img alt=\"NodeWebGL running locally on Windows\" src=\"img/twgl_node_js_windows.png\" width=\"516\"/>\n</center><p>It worked fine locally.</p><p>Next, I switched to the remote viewer.</p><p>That worked as well with no problem.</p><a name=\"5\"></a>"
  },
  {
    "original_filename": "1313_3dwc_twgl",
    "header_text": "Demo",
    "local_header_href": "#demo",
    "chunk_text": "<h4>Demo</h4><p>Here is a quick <a href=\"https://youtu.be/qBjbb_Wv6Qk\">one-minute video</a> showing the TwglExport Revit add-in and the Heroku-hosted node.js WebGL server NodeWebGL in concerted action:</p><center>\n<iframe allowfullscreen=\"\" frameborder=\"0\" height=\"270\" src=\"https://www.youtube.com/embed/qBjbb_Wv6Qk\" width=\"480\"></iframe>\n</center><a name=\"6\"></a>"
  },
  {
    "original_filename": "1313_3dwc_twgl",
    "header_text": "Download",
    "local_header_href": "#download",
    "chunk_text": "<h4>Download</h4><p>The entire TwglExport source code, Visual Studio solution and add-in manifest are provided in the\n\n<a href=\"https://github.com/jeremytammik/TwglExport\">TwglExport GitHub repository</a>,\n\nand the version presented here is\n\n<a href=\"https://github.com/jeremytammik/TwglExport/releases/tag/2015.0.0.3\">release 2015.0.0.3</a>.</p><p>The complete node server implementation is available from the\n<a href=\"https://github.com/jeremytammik/NodeWebGL\">NodeWebGL GitHub repo</a>,\nand the version discussed here is\n<a href=\"https://github.com/jeremytammik/NodeWebGL/releases/tag/0.2.7\">0.2.7</a>.</p><a name=\"7\"></a>"
  },
  {
    "original_filename": "1313_3dwc_twgl",
    "header_text": "Next Steps",
    "local_header_href": "#next-steps",
    "chunk_text": "<h4>Next Steps</h4><p>The Revit element traversal is currently totally simplistic.</p><p>It grabs the first non-empty solid it can find and renders that with no questions asked.</p><p>This will not work for a family instance, for instance – please pardon the pun – to access any solid contained in its geometry, you have to navigate through the geometry instance level first.</p><p>I could obviously  enhance the geometry traversal, as we already did for numerous other add-ins, e.g. the\n<a href=\"http://thebuildingcoder.typepad.com/blog/2012/07/obj-model-exporter-with-multiple-solid-support.html\">\nOBJ exporter</a>.</p><p>That would be silly, though.</p><p>It is much easier to implement a\n<a href=\"http://thebuildingcoder.typepad.com/blog/about-the-author.html#5.1\">\ncustom exporter</a> and grab the geometry from that.</p><p>No more worries about elements, transformations, instances and all that stuff.</p><p>Stay tuned and have fun!</p>"
  }
]