[
  {
    "original_filename": "0893_mep_system_traversal",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<head>\n<meta content=\"text/html; charset=utf-8\" http-equiv=\"Content-Type\"/>\n<link href=\"bc.css\" rel=\"stylesheet\" type=\"text/css\"/>\n</head>"
  },
  {
    "original_filename": "0893_mep_system_traversal",
    "header_text": "Simple MEP System Traversal",
    "local_header_href": "#simple-mep-system-traversal",
    "chunk_text": "<h3>Simple MEP System Traversal</h3><p>Here is a simple MEP system traversal implementation that especially addresses the issue of determining what equipment is connected to the systems.\n\n<p>The following read-only external command traverses all MEP systems in the document, using the MEPSystem.Elements property to retrieve most of the desired elements with very little effort.\n\n<p>More than half the code is actually fussing about with formatting the result:\n\n<pre class=\"code\">\n[<span class=\"teal\">Transaction</span>( <span class=\"teal\">TransactionMode</span>.ReadOnly )]\n<span class=\"blue\">public</span> <span class=\"blue\">class</span> <span class=\"teal\">Command</span> : <span class=\"teal\">IExternalCommand</span>\n{\n  <span class=\"blue\">static</span> <span class=\"blue\">string</span> PluralSuffix( <span class=\"blue\">int</span> n )\n  {\n    <span class=\"blue\">return</span> 1 == n ? <span class=\"maroon\">\"\"</span> : <span class=\"maroon\">\"s\"</span>;\n  }\n \n  <span class=\"blue\">void</span> TraverseSystems( <span class=\"teal\">Document</span> doc )\n  {\n    <span class=\"teal\">FilteredElementCollector</span> systems\n      = <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( doc )\n        .OfClass( <span class=\"blue\">typeof</span>( <span class=\"teal\">MEPSystem</span> ) );\n \n    <span class=\"blue\">int</span> i, n;\n    <span class=\"blue\">string</span> s;\n    <span class=\"blue\">string</span>[] a;\n \n    <span class=\"teal\">StringBuilder</span> message = <span class=\"blue\">new</span> <span class=\"teal\">StringBuilder</span>();\n \n    <span class=\"blue\">foreach</span>( <span class=\"teal\">MEPSystem</span> system <span class=\"blue\">in</span> systems )\n    {\n      message.AppendLine( <span class=\"maroon\">\"System Name: \"</span>\n        + system.Name );\n \n      message.AppendLine( <span class=\"maroon\">\"Base Equipment: \"</span>\n        + system.BaseEquipment );\n \n      <span class=\"teal\">ConnectorSet</span> cs = system.ConnectorManager\n        .Connectors;\n \n      i = 0;\n      n = cs.Size;\n      a = <span class=\"blue\">new</span> <span class=\"blue\">string</span>[n];\n \n      s = <span class=\"blue\">string</span>.Format(\n        <span class=\"maroon\">\"{0} element{1} in ConnectorManager: \"</span>,\n        n, PluralSuffix( n ) );\n \n      <span class=\"blue\">foreach</span>( <span class=\"teal\">Connector</span> c <span class=\"blue\">in</span> cs )\n      {\n        <span class=\"teal\">Element</span> e = c.Owner;\n \n        <span class=\"blue\">if</span>( <span class=\"blue\">null</span> != e )\n        {\n          a[i++] = e.GetType().Name\n            + <span class=\"maroon\">\" \"</span> + e.Id.ToString();\n        }\n      }\n \n      message.AppendLine( s\n        + <span class=\"blue\">string</span>.Join( <span class=\"maroon\">\", \"</span>, a ) );\n \n      i = 0;\n      n = system.Elements.Size;\n      a = <span class=\"blue\">new</span> <span class=\"blue\">string</span>[n];\n \n      s = <span class=\"blue\">string</span>.Format(\n        <span class=\"maroon\">\"{0} element{1} in System: \"</span>,\n        n, PluralSuffix( n ) );\n \n      <span class=\"blue\">foreach</span>( <span class=\"teal\">Element</span> e <span class=\"blue\">in</span> system.Elements )\n      {\n        a[i++] = e.GetType().Name\n          + <span class=\"maroon\">\" \"</span> + e.Id.ToString();\n      }\n \n      message.AppendLine( s\n        + <span class=\"blue\">string</span>.Join( <span class=\"maroon\">\", \"</span>, a ) );\n    }\n \n    n = systems.Count&lt;<span class=\"teal\">Element</span>&gt;();\n \n    <span class=\"blue\">string</span> caption =\n      <span class=\"blue\">string</span>.Format( <span class=\"maroon\">\"Traverse {0} MEP System{1}\"</span>,\n      n, (1 == n ? <span class=\"maroon\">\"\"</span> : <span class=\"maroon\">\"s\"</span>) );\n \n    <span class=\"teal\">TaskDialog</span> dlg = <span class=\"blue\">new</span> <span class=\"teal\">TaskDialog</span>( caption );\n    dlg.MainContent = message.ToString();\n    dlg.Show();\n  }\n \n  <span class=\"blue\">public</span> <span class=\"teal\">Result</span> Execute(\n    <span class=\"teal\">ExternalCommandData</span> commandData,\n    <span class=\"blue\">ref</span> <span class=\"blue\">string</span> message,\n    <span class=\"teal\">ElementSet</span> elements )\n  {\n    <span class=\"teal\">UIApplication</span> uiapp = commandData.Application;\n    <span class=\"teal\">UIDocument</span> uidoc = uiapp.ActiveUIDocument;\n    <span class=\"teal\">Document</span> doc = uidoc.Document;\n \n    TraverseSystems( doc );\n \n    <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Succeeded;\n  }\n}\n</pre>\n<p>I executed this on an absolutely trivial system:</p>\n<center>\n<img alt=\"Simple system\" src=\"img/traverse_system_system.png\" width=\"400\"/>\n</center>\n<p>That generates the following message box as a result:</p>\n<center>\n<img alt=\"Resulting message\" src=\"img/traverse_system_msg.png\" width=\"400\"/>\n</center>\n<p>Obviously, you will want to clean up the reporting significantly to suit your needs.\nCurrently, the owner elements in the ConnectorSet are listed, and the same elements also appear in the system elements list.\nHere is another result of running this on two systems, an electrical and a duct system, with the elements highlighted in yellow:</p>\n<center>\n<img alt=\"Duplicated elements\" src=\"img/traverse_system_duplicates.png\" width=\"400\"/>\n</center>\n<p>Also, the API reports four elements in the system including one duct segment, whereas the UI reports three, which is what one would expect, so some identification of duplicate elements needs to be added to make this useful.\n\n<p>Furthermore, reporting on these ‘logical’ systems may have the limitation that in-line equipment such as duct dampers and valves are not reported as part of the system.\nThe other system traversal samples based on physical connectivity provide this info, however.\n\n<p>For now, the main point is to demonstrate that this simple access exists at all.\n\n<p>For your convenience, here is\n\n<a href=\"zip/MepSystemTraversal.zip\">MepSystemTraversal.zip</a> containing\n\nthe source code, Visual Studio solution and add-in manifest for this command.</p>\n<p>For more advanced traversal algorithms and determining the correct order of the individual system elements in the direction of the flow, you can look at the\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2009/06/revit-mep-api.html\">\nTraverseSystem SDK sample</a>\n\n(<a href=\"http://thebuildingcoder.typepad.com/blog/2009/09/the-revit-mep-api.html#6\">2010</a>,\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/05/the-revit-mep-2011-api.html#samples\">2011</a>)\n\nfor mechanical systems and the\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2012/05/the-adn-mep-sample-adnrme-for-revit-mep-2013.html\">\nAdnRme</a> sample\n\nfor electrical ones.</p>\n</p></p></p></p></p></p>"
  }
]