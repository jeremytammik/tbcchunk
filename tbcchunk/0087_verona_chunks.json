[
  {
    "original_filename": "0087_verona",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<style>\n.blue { color: blue; }\n.teal { color: teal; }\n.maroon { color: maroon; }\n.green { color: green; }\n</style>"
  },
  {
    "original_filename": "0087_verona",
    "header_text": "Verona Revit API Training",
    "local_header_href": "#verona-revit-api-training",
    "chunk_text": "<h3>Verona Revit API Training</h3><p>Yesterday was the last day of the advanced Revit Structure API training at\n\n<a href=\"http://www.steel-graphics.com\">\nSteel &amp; Graphics srl</a>\n\nin Verona, Italy, with Gianni, Stefano, Michele, Paolo, and we started diving into deeper topics.</p><img alt=\"Gianni, Michele, Jeremy and Stefano\" src=\"img/verona_2_380.jpg\"/><p>But first, here are some of the initial things we discussed in the previous days:</p><ul>\n<li>Making use of FamilyInstance.AddCoping to implement a Boolean operation between solids, for instance to cut a hole in a steel beam.</li>\n<li>Computing the volumes of all compound wall layers.</li>\n<li>Creating new column and beam types and inserting column and beam instances through the API.</li>\n<li>Improving the Revit SDK FrameBuilder sample to use language independent category comparison and make use of the Revit 2009 API filtering mechanism.</li>\n</ul><p>I already posted a description of the changes made to FrameBuilder to make the \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2009/01/category-comparison.html\">\ncategory comparison</a>\n\nlanguage independent.\nNotes on adding filtering may follow later.\nHere are some notes on the first of these issues:</p>"
  },
  {
    "original_filename": "0087_verona",
    "header_text": "AddCoping",
    "local_header_href": "#addcoping",
    "chunk_text": "<h4>AddCoping</h4><p>Making use of AddCoping is pretty trivial.\nAll we need to do is select two suitable beams, for instance a wide steel flange beam to cut a hole into, and a steel bar to define the hole, then feed these two instances into the AddCoping method.\nFirst of all, we implemented the following method to either extract a preselected element from the document selection set, or prompt the user to select a new one:</p><pre class=\"code\">\n<span class=\"teal\">Element</span> GetSelectedElement(\n  <span class=\"teal\">Document</span> doc,\n  <span class=\"blue\">string</span> description )\n{\n  <span class=\"teal\">Selection</span> sel = doc.Selection;\n  <span class=\"teal\">Element</span> e = <span class=\"blue\">null</span>;\n  <span class=\"blue\">while</span>( <span class=\"blue\">null</span> == e )\n  {\n    <span class=\"teal\">ElementSetIterator</span> i\n      = sel.Elements.ForwardIterator();\n \n    <span class=\"blue\">if</span>( i.MoveNext() )\n    {\n      e = i.Current <span class=\"blue\">as</span> <span class=\"teal\">Element</span>;\n      sel.Elements.Remove( e );\n    }\n    <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == e )\n    {\n      sel.Elements.Clear();\n \n      sel.StatusbarTip = <span class=\"maroon\">\"Please select \"</span>\n        + description;\n \n      <span class=\"blue\">if</span>( !sel.PickOne() )\n      {\n        <span class=\"blue\">return</span> <span class=\"blue\">null</span>;\n      }\n    }\n  }\n  <span class=\"blue\">return</span> e;\n}\n</pre><p>Then we can make use of that to select the two elements in the correct order and call the AddCoping method on the larger beam:</p><pre class=\"code\">\n<span class=\"blue\">public</span> <span class=\"teal\">IExternalCommand</span>.<span class=\"teal\">Result</span> Execute(\n  <span class=\"teal\">ExternalCommandData</span> commandData,\n  <span class=\"blue\">ref</span> <span class=\"blue\">string</span> message,\n  <span class=\"teal\">ElementSet</span> elements )\n{\n  <span class=\"blue\">string</span> s\n    = <span class=\"maroon\">\"Please select a family instance for the \"</span>;\n \n  <span class=\"teal\">IExternalCommand</span>.<span class=\"teal\">Result</span> rc\n    = <span class=\"teal\">IExternalCommand</span>.<span class=\"teal\">Result</span>.Failed;\n \n  <span class=\"teal\">Application</span> app = commandData.Application;\n  <span class=\"teal\">Document</span> doc = app.ActiveDocument;\n \n  <span class=\"teal\">Element</span> e1 = GetSelectedElement( doc,\n    <span class=\"maroon\">\"beam to cut\"</span> );\n \n  <span class=\"blue\">if</span>( <span class=\"blue\">null</span> != e1 )\n  {\n    <span class=\"teal\">Element</span> e2 = GetSelectedElement( doc,\n      <span class=\"maroon\">\"bar to drill hole\"</span> );\n \n    <span class=\"blue\">if</span>( <span class=\"blue\">null</span> != e2 )\n    {\n      <span class=\"teal\">FamilyInstance</span> beam = e1 <span class=\"blue\">as</span> <span class=\"teal\">FamilyInstance</span>;\n      <span class=\"teal\">FamilyInstance</span> bar = e2 <span class=\"blue\">as</span> <span class=\"teal\">FamilyInstance</span>;\n \n      <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == beam )\n      {\n        message = s + <span class=\"maroon\">\"beam\"</span>;\n      }\n      <span class=\"blue\">else</span> <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == bar )\n      {\n        message = s + <span class=\"maroon\">\"bar\"</span>;\n      }\n      <span class=\"blue\">else</span>\n      {\n        beam.AddCoping( bar );\n        rc = <span class=\"teal\">IExternalCommand</span>.<span class=\"teal\">Result</span>.Succeeded;\n      }\n    }\n  }\n  <span class=\"blue\">return</span> rc;\n}\n</pre><p>The result of executing this is the flange beam with a nice little hole in it:</p><img alt=\"Beam with a hole cut by AddCoping\" src=\"img/AddCoping.png\"/><p>Unfortunately, this cannot be used as a generic Boolean operation, because if the bar is erased from the project, the hole immediately and automatically seals up again.</p><p>I hope to be able to jot down some notes on the other topics listed above on the way back home.</p>"
  }
]