[
  {
    "original_filename": "0540_dim_walls_find_refs",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<head>\n<link href=\"bc.css\" rel=\"stylesheet\" type=\"text/css\"/>\n</head>"
  },
  {
    "original_filename": "0540_dim_walls_find_refs",
    "header_text": "Dimension Walls using FindReferencesByDirection",
    "local_header_href": "#dimension-walls-using-findreferencesbydirection",
    "chunk_text": "<h3>Dimension Walls using FindReferencesByDirection</h3><p>On Monday I presented a new Building Coder sample command\n\n<a href=\"\">\nCmdDimensionWallsIterateFaces</a>\n\ndemonstrating how to create dimensioning between two opposing wall faces by explicitly iterating over their solid geometry and its faces, asking the Revit geometry library to \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/01/geometry-options.html\">\ncompute stable references</a> to \n\nattach the dimensioning elements to.\nThe explicit iteration over geometry, searching for the right faces, and extraction of their references can all be simplified by making use of the higher-level specialised \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/01/findreferencesbydirection.html\">\nFindReferencesByDirection</a> method\n\nprovided for this purpose by the Revit API.\n\n<p>I continued working on the topic and implemented the alternative approach using FindReferencesByDirection as well in a second Building Coder sample external command implementation named CmdDimensionWallsFindRefs.\n\n<p>It removes the following limitations of the previous sample:\n\n<ul>\n<li>The dimension line was defined from wall midpoint to wall midpoint: In the new solution, there is no limitation on the location of the dimension line relative to the walls. The user selects the location of the dimension line somewhere on the second wall. The two walls must be parallel, and the projection of the first wall onto the second wall's location line must intersect with the point picked for the dimension line location.\n<li>The array of references required for the creation of the dimension element is created directly from the references returned by the high-level FindReferencesByDirection method. It shoots a ray through the Revit model and reports the elements and their faces and the points on the faces intersected by the ray. We pick out all references which refer to surfaces on the two selected walls and use those directly to create the dimension element.\n</li></li></ul>\n<p>The resulting command is more robust and foolproof than the first solution.\n\n<p>The new sample also demonstrates use of the PickObject method to select the walls in conjunction with a selection filter implementation of the ISelectionFilter interface. It also demonstrates that this method returns a pick point which can be evaluated to ask the user to select the dimension line location at the same time as selecting the second wall.\n\n<p>Here is the selection filter implementation that only allows the  user to pick a point on a wall:\n\n<pre class=\"code\">\n<span class=\"blue\">class</span> <span class=\"teal\">WallSelectionFilter</span> : <span class=\"teal\">ISelectionFilter</span>\n{\n  <span class=\"blue\">public</span> <span class=\"blue\">bool</span> AllowElement( <span class=\"teal\">Element</span> e )\n  {\n    <span class=\"blue\">return</span> e <span class=\"blue\">is</span> <span class=\"teal\">Wall</span>;\n  }\n \n  <span class=\"blue\">public</span> <span class=\"blue\">bool</span> AllowReference( <span class=\"teal\">Reference</span> r, <span class=\"teal\">XYZ</span> p )\n  {\n    <span class=\"blue\">return</span> <span class=\"blue\">true</span>;\n  }\n}\n</pre>\n<p>The call to FindReferencesByDirection requires a 3D view to be provided.\nWe assume that a suitable 3D view exists in the document and implement the following simple helper method making a call to a filtered element collector to retrieve the first 3D view encountered:\n\n<pre class=\"code\">\n<span class=\"blue\">private</span> <span class=\"teal\">View3D</span> Get3DView( <span class=\"teal\">Document</span> doc )\n{\n  <span class=\"teal\">FilteredElementCollector</span> collector\n    = <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( doc );\n \n  collector.OfClass( <span class=\"blue\">typeof</span>( <span class=\"teal\">View3D</span> ) );\n \n  <span class=\"blue\">foreach</span>( <span class=\"teal\">View3D</span> v <span class=\"blue\">in</span> collector )\n  {\n    <span class=\"green\">// skip view templates here because they</span>\n    <span class=\"green\">// are invisible in project browsers:</span>\n \n    <span class=\"blue\">if</span>( v != <span class=\"blue\">null</span> &amp;&amp; !v.IsTemplate &amp;&amp; v.Name == <span class=\"maroon\">\"{3D}\"</span> )\n    {\n      <span class=\"blue\">return</span> v;\n    }\n  }\n  <span class=\"blue\">return</span> <span class=\"blue\">null</span>;\n}\n</pre>\n<p>With these two methods in place and making use of the CreateDimensionElement helper method used in the previous CmdDimensionWallsIterateFaces command, the new external command implementation looks like this:\n\n<pre class=\"code\">\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n<span class=\"gray\">///</span><span class=\"green\"> Dimension two opposing parallel walls.</span>\n<span class=\"gray\">///</span><span class=\"green\"> Prompt user to select the first wall, and</span>\n<span class=\"gray\">///</span><span class=\"green\"> the second at the point at which to create </span>\n<span class=\"gray\">///</span><span class=\"green\"> the dimensioning. Use FindReferencesByDirection</span>\n<span class=\"gray\">///</span><span class=\"green\"> to determine the wall face references.</span>\n<span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n[<span class=\"teal\">Transaction</span>( <span class=\"teal\">TransactionMode</span>.Manual )]\n[<span class=\"teal\">Regeneration</span>( <span class=\"teal\">RegenerationOption</span>.Manual )]\n<span class=\"blue\">class</span> <span class=\"teal\">CmdDimensionWallsFindRefs</span> : <span class=\"teal\">IExternalCommand</span>\n{\n  <span class=\"blue\">const</span> <span class=\"blue\">string</span> _prompt\n    = <span class=\"maroon\">\"Please select two parallel straight walls\"</span>\n      + <span class=\"maroon\">\" with a partial projected overlap.\"</span>;\n \n  <span class=\"blue\">public</span> <span class=\"teal\">Result</span> Execute(\n    <span class=\"teal\">ExternalCommandData</span> commandData,\n    <span class=\"blue\">ref</span> <span class=\"blue\">string</span> message,\n    <span class=\"teal\">ElementSet</span> elements )\n  {\n    <span class=\"teal\">UIApplication</span> uiapp = commandData.Application;\n    <span class=\"teal\">UIDocument</span> uidoc = uiapp.ActiveUIDocument;\n    <span class=\"teal\">Application</span> app = uiapp.Application;\n    <span class=\"teal\">Document</span> doc = uidoc.Document;\n \n    <span class=\"green\">// select two walls and the dimension line point:</span>\n \n    <span class=\"teal\">Selection</span> sel = uidoc.Selection;\n    <span class=\"teal\">ReferenceArray</span> refs = <span class=\"blue\">new</span> <span class=\"teal\">ReferenceArray</span>();\n \n    <span class=\"blue\">try</span>\n    {\n      <span class=\"teal\">WallSelectionFilter</span> f \n        = <span class=\"blue\">new</span> <span class=\"teal\">WallSelectionFilter</span>();\n \n      refs.Append( sel.PickObject( \n        <span class=\"teal\">ObjectType</span>.Element, f,\n        <span class=\"maroon\">\"Please select first wall\"</span> ) );\n \n      refs.Append( sel.PickObject( \n        <span class=\"teal\">ObjectType</span>.Element, f,\n        <span class=\"maroon\">\"Please pick dimension line \"</span>\n        + <span class=\"maroon\">\"point on second wall\"</span> ) );\n    }\n    <span class=\"blue\">catch</span>( <span class=\"teal\">OperationCanceledException</span> )\n    {\n      message = <span class=\"maroon\">\"No two walls selected\"</span>;\n      <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n    }\n \n    <span class=\"green\">// ensure the two selected walls are straight and </span>\n    <span class=\"green\">// parallel; determine their mutual normal vector </span>\n    <span class=\"green\">// and a point on each wall for distance </span>\n    <span class=\"green\">// calculations:</span>\n \n    <span class=\"teal\">Wall</span>[] walls = <span class=\"blue\">new</span> <span class=\"teal\">Wall</span>[2];\n    <span class=\"teal\">List</span>&lt;<span class=\"blue\">int</span>&gt; ids = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"blue\">int</span>&gt;( 2 );\n    <span class=\"teal\">XYZ</span>[] pts = <span class=\"blue\">new</span> <span class=\"teal\">XYZ</span>[2];\n    <span class=\"teal\">Line</span>[] lines = <span class=\"blue\">new</span> <span class=\"teal\">Line</span>[2];\n    <span class=\"teal\">IntersectionResult</span> ir;\n    <span class=\"teal\">XYZ</span> normal = <span class=\"blue\">null</span>;\n    <span class=\"blue\">int</span> i = 0;\n \n    <span class=\"blue\">foreach</span>( <span class=\"teal\">Reference</span> r <span class=\"blue\">in</span> refs )\n    {\n      <span class=\"teal\">Wall</span> wall = r.Element <span class=\"blue\">as</span> <span class=\"teal\">Wall</span>;\n      walls[i] = wall;\n      ids.Add( wall.Id.IntegerValue );\n \n      <span class=\"green\">// obtain location curve and </span>\n      <span class=\"green\">// check that it is straight:</span>\n \n      <span class=\"teal\">LocationCurve</span> lc = wall.Location \n        <span class=\"blue\">as</span> <span class=\"teal\">LocationCurve</span>;\n \n      <span class=\"teal\">Curve</span> curve = lc.Curve;\n      lines[i] = curve <span class=\"blue\">as</span> <span class=\"teal\">Line</span>;\n \n      <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == lines[i] )\n      {\n        message = _prompt;\n        <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n      }\n \n      <span class=\"green\">// obtain normal vectors</span>\n      <span class=\"green\">// and ensure that they are equal,</span>\n      <span class=\"green\">// i.e. walls are parallel:</span>\n \n      <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == normal )\n      {\n        normal = <span class=\"teal\">Util</span>.Normal( lines[i] );\n      }\n      <span class=\"blue\">else</span>\n      {\n        <span class=\"blue\">if</span>( !<span class=\"teal\">Util</span>.IsParallel( normal, \n          <span class=\"teal\">Util</span>.Normal( lines[i] ) ) )\n        {\n          message = _prompt;\n          <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n        }\n      }\n \n      <span class=\"green\">// obtain pick points and project</span>\n      <span class=\"green\">// onto wall location lines:</span>\n \n      <span class=\"teal\">XYZ</span> p = r.GlobalPoint;\n      ir = lines[i].Project( p );\n \n      <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == ir )\n      {\n        message = <span class=\"blue\">string</span>.Format(\n          <span class=\"maroon\">\"Unable to project pick point {0} \"</span>\n          + <span class=\"maroon\">\"onto wall location line.\"</span>,\n          i );\n \n        <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n      }\n \n      pts[i] = ir.XYZPoint;\n \n      <span class=\"teal\">Debug</span>.Print( \n        <span class=\"maroon\">\"Wall {0} id {1} at {2}, {3} --&gt; point {4}\"</span>,\n        i, wall.Id.IntegerValue,\n        <span class=\"teal\">Util</span>.PointString( lines[i].get_EndPoint( 0 ) ),\n        <span class=\"teal\">Util</span>.PointString( lines[i].get_EndPoint( 1 ) ),\n        <span class=\"teal\">Util</span>.PointString( pts[i] ) );\n \n      <span class=\"blue\">if</span>( 0 &lt; i )\n      {\n        <span class=\"green\">// project dimension point selected on second wall</span>\n        <span class=\"green\">// back onto first wall, and ensure that normal </span>\n        <span class=\"green\">// points from second wall to first:</span>\n \n        ir = lines[0].Project( pts[1] );\n        <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == ir )\n        {\n          message = <span class=\"blue\">string</span>.Format(\n            <span class=\"maroon\">\"Unable to project selected dimension \"</span>\n            + <span class=\"maroon\">\"line point {0} on second wall onto \"</span>\n            + <span class=\"maroon\">\"first wall's location line.\"</span>,\n            <span class=\"teal\">Util</span>.PointString( pts[1] ) );\n \n          <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n        }\n        pts[0] = ir.XYZPoint;\n      }\n \n      ++i;\n    }\n \n    <span class=\"teal\">XYZ</span> v = pts[0] - pts[1];\n    <span class=\"blue\">if</span>( 0 &gt; v.DotProduct( normal ) )\n    {\n      normal = -normal;\n    }\n \n    <span class=\"green\">// invoke FindReferencesByDirection, shooting ray</span>\n    <span class=\"green\">// back from second picked wall towards first:</span>\n \n    <span class=\"teal\">View3D</span> view = Get3DView( doc );\n \n    refs = doc.FindReferencesByDirection( \n      pts[1], normal, view );\n \n    <span class=\"teal\">Debug</span>.Print( <span class=\"maroon\">\"Shooting ray from {0} direction \"</span>\n      + <span class=\"maroon\">\"{1} returns {2} references\"</span>,\n      <span class=\"teal\">Util</span>.PointString( pts[1] ),\n      <span class=\"teal\">Util</span>.PointString( normal ),\n      refs.Size );\n \n    <span class=\"green\">// store the references to the wall surfaces:</span>\n \n    <span class=\"teal\">Reference</span>[] surfrefs = <span class=\"blue\">new</span> <span class=\"teal\">Reference</span>[2] { \n      <span class=\"blue\">null</span>, <span class=\"blue\">null</span> };\n \n    <span class=\"green\">// find the two closest intersection </span>\n    <span class=\"green\">// points on each of the two walls:</span>\n \n    <span class=\"blue\">double</span>[] minDistance = <span class=\"blue\">new</span> <span class=\"blue\">double</span>[2] {\n      <span class=\"blue\">double</span>.MaxValue,\n      <span class=\"blue\">double</span>.MaxValue };\n \n    <span class=\"blue\">foreach</span>( <span class=\"teal\">Reference</span> r <span class=\"blue\">in</span> refs )\n    {\n      <span class=\"teal\">Element</span> e = r.Element;\n \n      <span class=\"blue\">if</span>( e <span class=\"blue\">is</span> <span class=\"teal\">Wall</span> )\n      {\n        i = ids.IndexOf( e.Id.IntegerValue );\n \n        <span class=\"blue\">if</span>( -1 &lt; i\n          &amp;&amp; <span class=\"teal\">ElementReferenceType</span>.REFERENCE_TYPE_SURFACE\n            == r.ElementReferenceType )\n        {\n          <span class=\"teal\">GeometryObject</span> g = r.GeometryObject;\n \n          <span class=\"blue\">if</span>( g <span class=\"blue\">is</span> <span class=\"teal\">PlanarFace</span> )\n          {\n            <span class=\"teal\">PlanarFace</span> face = g <span class=\"blue\">as</span> <span class=\"teal\">PlanarFace</span>;\n \n            <span class=\"teal\">Line</span> line = ( e.Location <span class=\"blue\">as</span> <span class=\"teal\">LocationCurve</span> )\n              .Curve <span class=\"blue\">as</span> <span class=\"teal\">Line</span>;\n \n            <span class=\"teal\">Debug</span>.Print(\n              <span class=\"maroon\">\"Wall {0} at {1}, {2} surface {3} \"</span>\n              + <span class=\"maroon\">\"normal {4} proximity {5}\"</span>,\n              e.Id.IntegerValue,\n              <span class=\"teal\">Util</span>.PointString( line.get_EndPoint( 0 ) ),\n              <span class=\"teal\">Util</span>.PointString( line.get_EndPoint( 1 ) ),\n              <span class=\"teal\">Util</span>.PointString( face.Origin ),\n              <span class=\"teal\">Util</span>.PointString( face.Normal ),\n              r.ProximityParameter );\n \n            <span class=\"green\">// first reference: assert it is a face on this wall </span>\n            <span class=\"green\">// and the distance is half the wall thickness</span>\n            <span class=\"green\">//</span>\n            <span class=\"green\">// second reference: the first reference on the other </span>\n            <span class=\"green\">// wall; assert the distance between the two references</span>\n            <span class=\"green\">// equals the distance between the wall location lines </span>\n            <span class=\"green\">// minus half of the sum of the two wall thicknesses.</span>\n \n            <span class=\"blue\">if</span>( r.ProximityParameter &lt; minDistance[i] )\n            {\n              surfrefs[i] = r;\n              minDistance[i] = r.ProximityParameter;\n            }\n          }\n        }\n      }\n    }\n \n    <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == surfrefs[0] )\n    {\n      message = <span class=\"maroon\">\"No suitable face intersection \"</span>\n        + <span class=\"maroon\">\"points found on first wall.\"</span>;\n \n      <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n    }\n \n    <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == surfrefs[1] )\n    {\n      message = <span class=\"maroon\">\"No suitable face intersection \"</span>\n        + <span class=\"maroon\">\"points found on second wall.\"</span>;\n \n      <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n    }\n \n    <span class=\"teal\">CmdDimensionWallsIterateFaces</span>\n      .CreateDimensionElement( doc.ActiveView, \n      pts[0], surfrefs[0], pts[1], surfrefs[1] );\n \n    <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Succeeded;\n  }\n}\n</pre>\n<p>Here is a slightly less horrible example than the previous one of a horizontal and a vertical dimensioning element created by this command:\n\n<center>\n<img alt=\"Dimensioning two opposing walls using FindReferencesByDirection\" src=\"img/DimensionTwoWallsFindReferencesByDirection.png\"/>\n</center>\n<p>Here is\n\n<!-- C:\\a\\doc\\revit\\blog\\zip\\bc_11_86.zip -->\n<a href=\"zip/bc_11_86.zip\">\nversion 2011.0.86.0</a>\n\nof The Building Coder samples including the complete source code and Visual Studio solution with both of the two new commands.\n</p></p></p></p></p></p></p></p></p></p>"
  }
]