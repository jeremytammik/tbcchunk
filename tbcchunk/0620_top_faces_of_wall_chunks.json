[
  {
    "original_filename": "0620_top_faces_of_wall",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<head>\n<link href=\"bc.css\" rel=\"stylesheet\" type=\"text/css\"/>\n</head>"
  },
  {
    "original_filename": "0620_top_faces_of_wall",
    "header_text": "Top Faces of Sloped Wall",
    "local_header_href": "#top-faces-of-sloped-wall",
    "chunk_text": "<h3>Top Faces of Sloped Wall</h3><p>In the distant past, I discussed retrieving specific floor and wall faces based on their face normal, e.g. the \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2008/10/slab-boundary.html\">\nbottom face and boundary of a horizontal floor slab</a>, the\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2008/11/wall-elevation-profile.html\">\nexterior face of a vertical wall</a>, and finally the \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2009/08/bottom-face-of-a-wall.html\">\nbottom face of a wall</a>.\n\n<p>But what if the normal is not exactly horizontal or vertical?\n\n<p>For instance, how about retrieving the top face of a\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2009/02/creating-a-wall-with-a-sloped-profile.html\">\nwall with a sloped profile</a> or the\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2011/07/create-gable-wall.html\">\ngable wall</a> that we just looked at a few days ago?\n\n<p>That can get a bit complicated, and has an infinite number of solutions.\nI explore some of them below, with no guarantee that they are anywhere near optimal.\nIn fact, I can guarantee that there are better solutions.\n\n<p>This is prompted by Saikat Bhattacharya, who answered a question on that very issue.\nIn his solution, he also makes use of a couple of new Revit 2012 API methods, for which it is a great pleasure to present such a compelling use case.\n\n<ul>\n<li>HostObjectUtils – HostObject top, bottom, and side faces: \nThe new methods HostObjectUtils.GetTopFaces, GetBottomFaces and GetSideFaces provide shortcuts to locate the faces of a given roof, floor, or wall which act as the exterior or interior boundary of the object's CompoundStructure. Top and bottom faces are applicable to roofs and floors. Side faces are applicable to walls.\n\n<li>GetGeometryObjectFromReference – Reference properties:\nThe Reference class was renovated to be more closely aligned with the native Revit class it wraps.\nGetGeometryObjectFromReference replaces the obsolete GeometryObject property.\n\n<li>GetGeneratingElementIds – The Element.GetGeneratingElementIds method returns the ids of the elements that generated the input geometry object. The help file provides sample code showing how to use this to find all elements joined or attached to the end faces of a given wall, such as other walls and roofs.\n</li></li></li></ul>\n<p><strong>Question:</strong> How can I retrieve the top faces of a non-rectangular wall and determine their slopes?\n\n<p>Walls in Revit can have a sloping bottom surface as well as top. \nA wall can look almost like anything and it is also possible to add arbitrary openings, which complicate things. \nIt seems tricky to find out the right surfaces. \n\n<p>I can imagine I have to look at the wall solid faces and their normals.\n\n<p>However, if the wall has openings such as doors and windows, these objects will affect the faces collection as well. \nAny idea how to proceed in order to ensure that I identify the correct face or faces that really belong to the top of the wall? \n\n<p><strong>Answer:</strong> From what I understand, you wish to find out the faces which are on the top of the wall. \nIf you are analysing something like a gable wall, you expect to have multiple faces on the top of the wall. \n\n<p>There are obviously many different ways of approaching this. \n\n<p>One possible approach is to iterate through each face of the wall and determine its normal vector. \nSuch an approach was used to find the \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2009/08/bottom-face-of-a-wall.html\">\nbottom face of a wall</a>.\n\nYou can extend this to calculate the sloped top faces for your gable wall. \n\n<p>To extract the slope of the top most wall faces, you can start by \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2008/11/wall-elevation-profile.html\">\nidentifying the wall elevation profile</a>.\n\nThe approach described accesses each of the faces of a wall and determines the exterior one. \nOn this face, you can access each of the edge loops and determine which edges form the top edges, e.g. by determining the maximum and minimum Z coordinate values using them to calculate the slope.\n\n<p>Another approach could be to access each face of the wall and then go through all of its edges. \nUsing the length of the edge, you can find out the longest edge of a given face. \nFor this longest edge, you can access the start and end point. \nWith these two points for that face, you can use coordinate geometry formula to \n\n<a href=\"http://en.wikipedia.org/wiki/Slope\">\ncalculate the slope of the edge</a>. \n\nIf you happen to know that the wall base and vertical sides are perfectly horizontal and vertical, then the sloped edges all belong to the top of the wall. \n\n<p>Following are the steps that might help in calculating the top faces if there are multiple door/windows on a wall which might also return top faces (and thus confuse with the wall top faces): \n\n<ul>\n<li>Start with identifying the wall inner or outer face. \n<li>Any given wall has various layers which can be extracted from the compound structure of the wall, and the order of these layers are from the exterior face to the interior. So for example, if a wall has material A in exterior face and then Material B in middle layer and Material C in interior layer, the CompoundStructure property of a wall will return the layers in this order and so the last layer in this will be one which is on the interior face. \n<li>So after we know the material of the interior face of the wall, we can parse through each of the faces of the wall and check which face has which material. When we find a face which has a material that is the same that that of the interior layer, we can know that the face if the interior face. The same approach can be used for finding exterior face too (whichever suits your use case). \n<li>After we find the inner/outer face of wall, we need to identify the top edges of one of the two faces (interior or exterior). You can either use the maximum z value of either of the end points for the edge to identify it or check if the normal on the adjacent faces is a non-zero X, Y or Z with a positive Z value. You can devise your own approach here too. \n<li>Finally you need to collect all the faces that neighbour the top edges and fit the criteria.\n</li></li></li></li></li></ul>\n<p>In Revit 2012, things are much simpler.\nThe Revit 2012 API provides a new utility class HostObjectUtils with a method GetSideFaces which can be used to obtain the side face of a wall. \n\n<p>From then on, you can follow the approach discussed above, i.e. walk the outer contour of edges of the side face.  \nFind the neighbouring faces, and the face normal returned by Face.ComputeNormal has a positive Z component, it is a top face. \n\n<p>In Revit 2012, you also use the new method GetGeneratingElementIds to find the element ids of the elements that generate the input geometry. \n\n<p>I wrote the following code to demonstrate this approach. \nIt is not yet complete, since we need to add some methods to determine the outer loop, as mentioned in the comments, but it should provide an idea on how you can proceed. \nYou can test this code first with a simple gable wall with no doors or windows and then extend it by adding logic to detect the outer loop returned from face.EdgeLoops.\n\n<pre class=\"code\">\n  <span class=\"teal\">IList</span>&lt;<span class=\"teal\">Face</span>&gt; topFaces = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">Face</span>&gt;();\n \n  <span class=\"blue\">foreach</span>( <span class=\"teal\">Element</span> e <span class=\"blue\">in</span> uidoc.Selection.Elements )\n  {\n    <span class=\"teal\">Wall</span> pickedWall = e <span class=\"blue\">as</span> <span class=\"teal\">Wall</span>;\n \n    <span class=\"green\">// Get the side faces</span>\n \n    <span class=\"teal\">IList</span>&lt;<span class=\"teal\">Reference</span>&gt; sideFaces \n      = <span class=\"teal\">HostObjectUtils</span>.GetSideFaces( pickedWall, \n        <span class=\"teal\">ShellLayerType</span>.Exterior );\n \n    <span class=\"green\">// Access the side face</span>\n \n    <span class=\"teal\">Element</span> e2 = doc.GetElement( sideFaces[0] );\n \n    <span class=\"teal\">Face</span> face = e2.GetGeometryObjectFromReference( \n      sideFaces[0] ) <span class=\"blue\">as</span> <span class=\"teal\">Face</span>;\n \n    <span class=\"green\">// When there are multiple windows or doors in </span>\n    <span class=\"green\">// the wall, we need to find the outer loop </span>\n    <span class=\"green\">// that is returned using the face.Edgeloops.</span>\n    <span class=\"green\">// For one possible approach to extract the </span>\n    <span class=\"green\">// outermost loop, please refer to </span>\n    <span class=\"green\">// http://thebuildingcoder.typepad.com/blog/2008/12/2d-polygon-areas-and-outer-loop.html</span>\n \n    <span class=\"green\">// With the outermost loop, calculate the top faces</span>\n \n    <span class=\"blue\">foreach</span>( <span class=\"teal\">EdgeArray</span> ea <span class=\"blue\">in</span> face.EdgeLoops )\n    {\n      <span class=\"blue\">foreach</span>( <span class=\"teal\">Edge</span> edge <span class=\"blue\">in</span> ea )\n      {\n        <span class=\"green\">// For each edge, get the neighbouring </span>\n        <span class=\"green\">// face and check its normal</span>\n \n        <span class=\"blue\">for</span>( <span class=\"blue\">int</span> i = 0; i &lt; 2; ++i )\n        {\n          <span class=\"teal\">Face</span> neighbourFace = edge.get_Face( i );\n \n          <span class=\"teal\">XYZ</span> p = edge.Tessellate()[0];\n \n          <span class=\"blue\">if</span>( neighbourFace.ComputeNormal(\n            <span class=\"blue\">new</span> <span class=\"teal\">UV</span>( p.X, p.Y ) ).Z &gt; 0 )\n          {\n            topFaces.Add( neighbourFace );\n          }\n        }\n      }\n    }\n  }\n \n  <span class=\"blue\">int</span> n = topFaces.Count;\n \n  <span class=\"teal\">TaskDialog</span>.Show( <span class=\"maroon\">\"Wall Top Faces\"</span>, \n    <span class=\"blue\">string</span>.Format( <span class=\"maroon\">\"This wall has {0} top face{1}.\"</span>,\n    n, (1 == n ? <span class=\"maroon\">\"\"</span> : <span class=\"maroon\">\"s\"</span>) ) );\n</pre>\n<p>Here is Saikat's detailed explanation of the steps:\n\n<ul>\n<li>Retrieve the wall we are working with and its side faces, in this case the exterior one.\n<li>Assuming the wall has no windows or doors in it, all the edges of the exterior side faces are part of the outer boundary loop.\n<li>In the case of a rectangular wall, this returns four edges: top, bottom, and two vertical side edges.\n<li>With each edge, say top one, access both the adjoining faces.\n<li>For the top edge, one neighbouring face is the top one and other is vertical and should be the same as the exterior face that we started with.\n<li>For each of the faces, check the Z value of its normal on any point on the edge. I used the Tessellate method to get the points on the edge and calculate the normal at the first point of the edge. One could also use the start point of the edge.\n<li>If the Z value is positive, we know that the face is the top face.\n</li></li></li></li></li></li></li></ul>\n<p>This worked fine for all the test models that I applied it to.\n\n<p><strong>Jeremy adds:</strong> Many thanks to Saikat for this research and sample code!\n\n<p>I created a new Building Coder sample command CmdWallTopFaces based on Saikat's code, and before doing so I implemented some support methods in order to easily determine the outermost loop for a wall with openings.\n\n<p>Step one of this process is to implement a simple method to determine the area of an EdgeArray.\n\n<p>Saikat mentioned my implementation to determine the \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2008/12/2d-polygon-areas-and-outer-loop.html\">\nouter loop of a 2D polygon</a> using the method GetSignedPolygonArea.\n\n<p>I also already implemented the method \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2008/12/3d-polygon-areas.html\">\nGetPolygonPlane</a> which \n\nreturns the plane properties of a given 3D polygon placed and oriented arbitrarily in space, i.e. the plane normal, area, and its distance from the origin.\n\n<p>The input polygon for GetPolygonPlane to analyse is provided as a List&lt;XYZ&gt; instance.\nAs you see above, the wall face contour loops are returned from the face Edge|Loops property as EdgeArray instances, so I would like to convert an EdgeArray to a List&lt;XYZ&gt; to easily apply GetPolygonPlane to it.\n\n<p>This is an ideal opportunity to implement an extension method, i.e. a method that I can provide to extend the functionality of the Revit API EdgeArray class in a way that makes it indistinguishable from the EdgeArray native member methods.\nI created a new class JtEdgeArrayExtensionMethods in the Util.cs module to host the new extension method implementation:\n\n<pre class=\"code\">\n<span class=\"blue\">public</span> <span class=\"blue\">static</span> <span class=\"blue\">class</span> <span class=\"teal\">JtEdgeArrayExtensionMethods</span>\n{\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n  <span class=\"gray\">///</span><span class=\"green\"> Return a polygon as a list of XYZ points from </span>\n  <span class=\"gray\">///</span><span class=\"green\"> an EdgeArray. If any of the edges are curved,</span>\n  <span class=\"gray\">///</span><span class=\"green\"> we retrieve the tessellated points, i.e. an </span>\n  <span class=\"gray\">///</span><span class=\"green\"> approximation determined by Revit.</span>\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n  <span class=\"blue\">public</span> <span class=\"blue\">static</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">XYZ</span>&gt; GetPolygon( \n    <span class=\"blue\">this</span> <span class=\"teal\">EdgeArray</span> ea )\n  {\n    <span class=\"blue\">int</span> n = ea.Size;\n \n    <span class=\"teal\">List</span>&lt;<span class=\"teal\">XYZ</span>&gt; polygon = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">XYZ</span>&gt;( n );\n \n    <span class=\"blue\">foreach</span>( <span class=\"teal\">Edge</span> e <span class=\"blue\">in</span> ea )\n    {\n      <span class=\"teal\">IList</span>&lt;<span class=\"teal\">XYZ</span>&gt; pts = e.Tessellate();\n \n      n = polygon.Count;\n \n      <span class=\"blue\">if</span>( 0 &lt; n )\n      {\n        <span class=\"teal\">Debug</span>.Assert( pts[0]\n          .IsAlmostEqualTo( polygon[n-1] ),\n          <span class=\"maroon\">\"expected last edge end point to \"</span>\n          + <span class=\"maroon\">\"equal next edge start point\"</span> );\n \n        polygon.RemoveAt( n - 1 );\n      }\n      polygon.AddRange( pts );\n    }\n    n = polygon.Count;\n \n    <span class=\"teal\">Debug</span>.Assert( polygon[0]\n      .IsAlmostEqualTo( polygon[n - 1] ),\n      <span class=\"maroon\">\"expected first edge start point to \"</span>\n      + <span class=\"maroon\">\"equal last edge end point\"</span> );\n \n    polygon.RemoveAt( n - 1 );\n \n    <span class=\"blue\">return</span> polygon;\n  }\n}\n</pre>\n<p>With that helper method in place and the existing CmdWallProfileArea.GetPolygonPlane method to determine the area of a 3D polygon, I can easily find the outer loop of a wall which may contain openings like this:\n\n<pre class=\"code\">\n  <span class=\"teal\">XYZ</span> normal;\n  <span class=\"blue\">double</span> area, dist, maxArea = 0;\n  <span class=\"teal\">EdgeArray</span> outerLoop = <span class=\"blue\">null</span>;\n \n  <span class=\"blue\">foreach</span>( <span class=\"teal\">EdgeArray</span> ea <span class=\"blue\">in</span> face.EdgeLoops )\n  {\n    <span class=\"blue\">if</span>( <span class=\"teal\">CmdWallProfileArea</span>.GetPolygonPlane(\n      ea.GetPolygon(), <span class=\"blue\">out</span> normal, <span class=\"blue\">out</span> dist, <span class=\"blue\">out</span> area )\n      &amp;&amp; <span class=\"teal\">Math</span>.Abs( area ) &gt; <span class=\"teal\">Math</span>.Abs( maxArea ) )\n    {\n      maxArea = area;\n      outerLoop = ea;\n    }\n  }\n</pre>\n<p>Now I just need to examine the outer loop to find the wall top faces, and can skip all the others, which are related to openings in the wall:\n\n<pre class=\"code\">\n  <span class=\"green\">// With the outermost loop, calculate the top faces</span>\n \n  <span class=\"blue\">foreach</span>( <span class=\"teal\">Edge</span> edge <span class=\"blue\">in</span> outerLoop )\n  {\n    <span class=\"green\">// For each edge, get the neighbouring </span>\n    <span class=\"green\">// face and check its normal</span>\n \n    <span class=\"blue\">for</span>( <span class=\"blue\">int</span> i = 0; i &lt; 2; ++i )\n    {\n      <span class=\"teal\">Face</span> neighbourFace = edge.get_Face( i );\n \n      <span class=\"teal\">XYZ</span> p = edge.Tessellate()[0];\n \n      <span class=\"blue\">if</span>( neighbourFace.ComputeNormal(\n        <span class=\"blue\">new</span> <span class=\"teal\">UV</span>( p.X, p.Y ) ).Z &gt; 0 )\n      {\n        topFaces.Add( neighbourFace );\n      }\n    }\n  }\n}\n</pre>\n<p>To test it, I ran my sample command on the walls of the basic sample project included in the Revit installation:</p>\n<center>\n<img alt=\"Basic sample project walls\" src=\"img/wall_top_faces_basic_sample_project.png\"/>\n</center>\n<p>I had to add a few checks to handle exceptional cases.\nAfter that, the command generates the following result in the Visual Studio debug output window:\n\n<pre>\n4 top faces found on Walls &lt;117652 Generic - 200&gt;\n1 top face found on Walls &lt;117653 Foundation - 305 Concrete&gt;\n3 top faces found on Walls &lt;117654 Generic - 200&gt;\n2 top faces found on Walls &lt;117685 CORR&gt;\n4 top faces found on Walls &lt;117698 CORR&gt;\nNo side face found for Walls &lt;117714 Storefront&gt;\n1 top face found on Walls &lt;117787 Interior - Partition&gt;\n1 top face found on Walls &lt;117836 translucent wall&gt;\n1 top face found on Walls &lt;117887 Generic - 200&gt;\n1 top face found on Walls &lt;117945 Interior - Partition&gt;\n2 top faces found on Walls &lt;117963 Interior - Partition&gt;\n2 top faces found on Walls &lt;118356 Interior - Partition&gt;\n1 top face found on Walls &lt;118454 Generic - 200&gt;\n1 top face found on Walls &lt;118547 Interior - Partition&gt;\n1 top face found on Walls &lt;118570 Interior - 165 Partition (1-hr)&gt;\n1 top face found on Walls &lt;118640 Interior - 165 Partition (1-hr)&gt;\n2 top faces found on Walls &lt;123926 CORR&gt;\nNo side face found for Walls &lt;123967 Storefront&gt;\n1 top face found on Walls &lt;124284 Interior - Partition&gt;\n1 top face found on Walls &lt;124302 Interior - Partition&gt;\n1 top face found on Walls &lt;124405 Interior - Partition&gt;\n1 top face found on Walls &lt;124670 CORR&gt;\n1 top face found on Walls &lt;127132 Foundation - 305 Concrete&gt;\nSkipped Walls FIREPLACE &lt;127491 FIREPLACE&gt;\n0 top faces found on Walls &lt;127659 Interior - Partition&gt;\n1 top face found on Walls &lt;127660 Interior - Partition&gt;\n1 top face found on Walls &lt;127663 Interior - Partition&gt;\n0 top faces found on Walls &lt;127941 Interior - Partition&gt;\n1 top face found on Walls &lt;128006 Interior - Partition&gt;\nNo side face found for Walls &lt;132770 Storefront&gt;\n1 top face found on Walls &lt;135324 Foundation - 305 Concrete&gt;\n1 top face found on Walls &lt;135343 Foundation - 305 Concrete&gt;\n1 top face found on Walls &lt;135362 Foundation - 305 Concrete&gt;\n1 top face found on Walls &lt;135527 Interior - Partition&gt;\n1 top face found on Walls &lt;140108 Interior - Partition&gt;\n2 top faces found on Walls &lt;140130 Interior - Partition&gt;\n1 top face found on Walls &lt;140190 Interior - Partition&gt;\n0 top faces found on Walls &lt;140191 Interior - Partition&gt;\n6 top faces found on Walls &lt;140204 Generic - 200&gt;\n2 top faces found on Walls &lt;144706 Interior - Partition&gt;\n2 top faces found on Walls &lt;144998 CORR&gt;\n1 top face found on Walls &lt;145015 CORR&gt;\n2 top faces found on Walls &lt;145032 CORR&gt;\n1 top face found on Walls &lt;145199 Interior - Partition&gt;\n1 top face found on Walls &lt;150987 Generic - 305&gt;\n3 top faces found on Walls &lt;151006 Generic - 200&gt;\n1 top face found on Walls &lt;151081 Generic - 305&gt;\n</pre>\n<p>Anyway, here is the final result reported by this task dialogue message:</p>\n<center>\n<img alt=\"Summary of basic sample project wall top faces\" src=\"img/wall_top_faces_basic_sample_project_result_63.png\"/>\n</center>\n<p>Some of the results in the list above are rather strange, actually... \nI explored them a bit further and have no explanation so far for the large number of top faces found on some simple walls.\nFor instance, this is the wall '140204 Generic - 200' which is reported to have six top faces in the list above:</p>\n<center>\n<img alt=\"Simple wall with six top faces\" src=\"img/wall_top_faces_six.png\"/>\n</center>\n<p>The only explanation I can offer for this is that some faces are counted multiple times. \nOne approach to debug this better and try to track down the cause would be to paint the faces like I did for the \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2008/11/wall-elevation-profile.html\">\nexterior face of a wall</a> and \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2008/12/2d-polygon-areas-and-outer-loop.html\">\nbottom outer loop of a floor slab</a>.\n\n<p>Another idea that comes to mind is to iterate over the faces instead of the edges.\nAt least that will ensure that no face will be examined more than once.\n\n<p>To identify a face neighbouring the outer side loop, I ended up comparing vertices with each other.\nObviously, like all comparisons of real numbers, that requires us to add a fuzz factor, since real-valued coordinates will almost never be exactly equal.\n\n<p>I already implemented an XYZ equality comparer incorporating such a fuzz factor in \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2009/05/nested-instance-geometry.html\">\nCmdNestedInstanceGeo.XyzEqualityComparer</a>.\n\n<p>Unfortunately, that equality comparer uses the native Revit API XYZ comparison member method IsAlmostEqualTo, which apparently uses a built-in tolerance that is too fine for our purposes and does not recognise points that we need to identify as equal.\nI therefore had to implement a new comparer class which takes a given tolerance as an input argument to the constructor, and use a tolerance of 1e-6 instead of the default 1e-9 used internally by Revit, as far as I know:\n\n<pre class=\"code\">\n<span class=\"blue\">public</span> <span class=\"blue\">class</span> <span class=\"teal\">XyzEqualityComparer</span> : <span class=\"teal\">IEqualityComparer</span>&lt;<span class=\"teal\">XYZ</span>&gt;\n{\n  <span class=\"blue\">double</span> _eps;\n \n  XyzEqualityComparer( <span class=\"blue\">double</span> eps )\n  {\n    <span class=\"teal\">Debug</span>.Assert( 0 &lt; eps,\n      <span class=\"maroon\">\"expected a positive tolerance\"</span> );\n \n    _eps = eps;\n  }\n \n  <span class=\"blue\">public</span> <span class=\"blue\">bool</span> Equals( <span class=\"teal\">XYZ</span> p, <span class=\"teal\">XYZ</span> q )\n  {\n    <span class=\"blue\">return</span> _eps &gt; p.DistanceTo( q );\n  }\n \n  <span class=\"blue\">public</span> <span class=\"blue\">int</span> GetHashCode( <span class=\"teal\">XYZ</span> p )\n  {\n    <span class=\"blue\">return</span> <span class=\"teal\">Util</span>.PointString( p ).GetHashCode();\n  }\n}\n</pre>\n<p>That improved things a bit. \n\n<p>One aspect that is somewhat open to interpretation is how to decide whether a face is a top face or not.\nIn some irregularly shaped walls, there may be faces which can be considered either side or top, as you please.\nI ended up using the following criterion, which allows you to specify a minimum slope of the face normal vector:\n\n<pre class=\"code\">\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n  <span class=\"gray\">///</span><span class=\"green\"> Minimum slope for a vector to be considered </span>\n  <span class=\"gray\">///</span><span class=\"green\"> to be pointing upwards. Slope is simply the</span>\n  <span class=\"gray\">///</span><span class=\"green\"> relationship between the vertical and </span>\n  <span class=\"gray\">///</span><span class=\"green\"> horizontal components.</span>\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n  <span class=\"blue\">const</span> <span class=\"blue\">double</span> _minimumSlope = 0.3;\n \n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n  <span class=\"gray\">///</span><span class=\"green\"> Return true if the Z coordinate of the </span>\n  <span class=\"gray\">///</span><span class=\"green\"> given vector is positive and the slope</span>\n  <span class=\"gray\">///</span><span class=\"green\"> is larger than the minimum limit.</span>\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n  <span class=\"blue\">static</span> <span class=\"blue\">bool</span> PointsUpwards( <span class=\"teal\">XYZ</span> v )\n  {\n    <span class=\"blue\">double</span> horizontalLength = v.X * v.X + v.Y * v.Y;\n    <span class=\"blue\">double</span> verticalLength = v.Z * v.Z;\n \n    <span class=\"blue\">return</span> 0 &lt; v.Z\n      &amp;&amp; _minimumSlope\n        &lt; verticalLength / horizontalLength;\n  }\n</pre>\n<p>I also ended up implementing the creation of model curve copies of all the top face edges as well, so that the results can be easily visualised and verified.\nThat requires me to open a transaction, which in turn prevents me from using read-only transaction mode, so I encapsulated all the model line creation code within conditional compilation statements like this:\n\n<pre class=\"code\">\n<span class=\"blue\">#if</span> CREATE_MODEL_CURVES_FOR_TOP_FACE_EDGES\n  [<span class=\"teal\">Transaction</span>( <span class=\"teal\">TransactionMode</span>.Manual )]\n<span class=\"blue\">#else</span>\n<span class=\"gray\">  [Transaction( TransactionMode.ReadOnly )]</span>\n<span class=\"blue\">#endif</span> <span class=\"green\">// CREATE_MODEL_CURVES_FOR_TOP_FACE_EDGES</span>\n</pre>\n<p>Here is a simplified model that I generated from the basic sample model and used for final testing:</p>\n<center>\n<img alt=\"Basic sample project walls cleaned up\" src=\"img/wall_top_faces_basic_sample_project_cleaned_up.png\"/>\n</center>\n<p>The code now determines 49 top faces for the 45 walls, which is correct, as far as I can tell:</p>\n<center>\n<img alt=\"Correct summary of basic sample project wall top faces\" src=\"img/wall_top_faces_basic_sample_project_result_49.png\"/>\n</center>\n<p>Here are the generated model line copies of the top face edge curves, offset by an inch upwards and isolated in the view:</p>\n<center>\n<img alt=\"Model line copies of the top face edges\" src=\"img/wall_top_faces_model_lines.png\"/>\n</center>\n<p>The final code is a little bit daunting, partly due of the conditional compilation statements:\n\n<pre class=\"code\">\n  <span class=\"teal\">UIApplication</span> uiapp = commandData.Application;\n  <span class=\"teal\">UIDocument</span> uidoc = uiapp.ActiveUIDocument;\n  <span class=\"teal\">Application</span> app = uiapp.Application;\n  <span class=\"teal\">Document</span> doc = uidoc.Document;\n \n  <span class=\"teal\">Options</span> opt = app.Create.NewGeometryOptions();\n \n  <span class=\"teal\">XyzEqualityComparer</span> comparer\n    = <span class=\"blue\">new</span> <span class=\"teal\">XyzEqualityComparer</span>( 1e-6 );\n \n<span class=\"blue\">#if</span> CREATE_MODEL_CURVES_FOR_TOP_FACE_EDGES\n \n  <span class=\"teal\">Creator</span> creator = <span class=\"blue\">new</span> <span class=\"teal\">Creator</span>( doc );\n \n  <span class=\"teal\">Transaction</span> t = <span class=\"blue\">new</span> <span class=\"teal\">Transaction</span>( doc ); \n \n  t.Start( <span class=\"maroon\">\"Create model curve copies of top face edges\"</span> );\n \n<span class=\"blue\">#endif</span> <span class=\"green\">// CREATE_MODEL_CURVES_FOR_TOP_FACE_EDGES</span>\n \n  <span class=\"teal\">IList</span>&lt;<span class=\"teal\">Face</span>&gt; topFaces = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"teal\">Face</span>&gt;();\n  <span class=\"blue\">int</span> n;\n \n  <span class=\"blue\">foreach</span>( <span class=\"teal\">Element</span> e <span class=\"blue\">in</span> uidoc.Selection.Elements )\n  {\n    <span class=\"teal\">Wall</span> wall = e <span class=\"blue\">as</span> <span class=\"teal\">Wall</span>;\n \n    <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == wall )\n    {\n      <span class=\"teal\">Debug</span>.Print( <span class=\"maroon\">\"Skipped \"</span>\n        + <span class=\"teal\">Util</span>.ElementDescription( e ) );\n      <span class=\"blue\">continue</span>;\n    }\n \n    <span class=\"green\">// Get the side faces</span>\n \n    <span class=\"teal\">IList</span>&lt;<span class=\"teal\">Reference</span>&gt; sideFaces \n      = <span class=\"teal\">HostObjectUtils</span>.GetSideFaces( wall, \n        <span class=\"teal\">ShellLayerType</span>.Exterior );\n \n    <span class=\"green\">// Access the first side face</span>\n \n    <span class=\"teal\">Element</span> e2 = doc.GetElement( sideFaces[0] );\n \n    <span class=\"teal\">Debug</span>.Assert( e2.Id.Equals( e.Id ), \n      <span class=\"maroon\">\"expected side face element to be the wall itself\"</span> );\n \n    <span class=\"teal\">Face</span> face = e2.GetGeometryObjectFromReference( \n      sideFaces[0] ) <span class=\"blue\">as</span> <span class=\"teal\">Face</span>;\n \n    <span class=\"blue\">if</span>( <span class=\"blue\">null</span> == face )\n    {\n      <span class=\"teal\">Debug</span>.Print( <span class=\"maroon\">\"No side face found for \"</span> \n        + <span class=\"teal\">Util</span>.ElementDescription( e ) );\n      <span class=\"blue\">continue</span>;\n    }\n \n    <span class=\"green\">// Determine the outer loop of the side face</span>\n    <span class=\"green\">// by finding the polygon with the largest area</span>\n \n    <span class=\"teal\">XYZ</span> normal;\n    <span class=\"blue\">double</span> area, dist, maxArea = 0;\n    <span class=\"teal\">EdgeArray</span> outerLoop = <span class=\"blue\">null</span>;\n \n    <span class=\"blue\">foreach</span>( <span class=\"teal\">EdgeArray</span> ea <span class=\"blue\">in</span> face.EdgeLoops )\n    {\n      <span class=\"blue\">if</span>( <span class=\"teal\">CmdWallProfileArea</span>.GetPolygonPlane(\n        ea.GetPolygon(), <span class=\"blue\">out</span> normal, <span class=\"blue\">out</span> dist, <span class=\"blue\">out</span> area )\n        &amp;&amp; <span class=\"teal\">Math</span>.Abs( area ) &gt; <span class=\"teal\">Math</span>.Abs( maxArea ) )\n      {\n        maxArea = area;\n        outerLoop = ea;\n      }\n    }\n \n    n = 0;\n \n    <span class=\"teal\">List</span>&lt;<span class=\"teal\">XYZ</span>&gt; sideVertices = outerLoop.GetPolygon();\n \n    <span class=\"green\">// Go over all the faces of the wall and </span>\n    <span class=\"green\">// determine which ones fulfill the following </span>\n    <span class=\"green\">// two criteria: (i) planar face pointing </span>\n    <span class=\"green\">// upwards, and (ii) neighbour of the side</span>\n    <span class=\"green\">// face outer loop.</span>\n \n    <span class=\"teal\">Solid</span> solid = wall.get_Geometry( opt ).Objects\n      .OfType&lt;<span class=\"teal\">Solid</span>&gt;()\n      .First&lt;<span class=\"teal\">Solid</span>&gt;( sol =&gt; <span class=\"blue\">null</span> != sol );\n \n    <span class=\"blue\">foreach</span>( <span class=\"teal\">Face</span> f <span class=\"blue\">in</span> solid.Faces )\n    {\n      <span class=\"blue\">if</span>( f <span class=\"blue\">is</span> <span class=\"teal\">PlanarFace</span>\n        &amp;&amp; PointsUpwards( ((<span class=\"teal\">PlanarFace</span>)f).Normal ) )\n      {\n        <span class=\"teal\">IList</span>&lt;<span class=\"teal\">XYZ</span>&gt; faceVertices \n          = f.Triangulate().Vertices;\n \n        <span class=\"green\">//if( sideVertices.Exists( v </span>\n        <span class=\"green\">//  =&gt; faceVertices.Contains&lt;XYZ&gt;( v, comparer ) ) )</span>\n        <span class=\"green\">//{</span>\n        <span class=\"green\">//  topFaces.Add( f );</span>\n        <span class=\"green\">//  ++n;</span>\n        <span class=\"green\">//}</span>\n \n        <span class=\"blue\">foreach</span>( <span class=\"teal\">XYZ</span> v <span class=\"blue\">in</span> faceVertices )\n        {\n          <span class=\"blue\">if</span>( sideVertices.Contains&lt;<span class=\"teal\">XYZ</span>&gt;( \n            v, comparer ) )\n          {\n            topFaces.Add( f );\n            ++n;\n \n<span class=\"blue\">#if</span> CREATE_MODEL_CURVES_FOR_TOP_FACE_EDGES\n \n            <span class=\"green\">// Display face for debugging purposes</span>\n \n            <span class=\"blue\">foreach</span>( <span class=\"teal\">EdgeArray</span> ea <span class=\"blue\">in</span> f.EdgeLoops )\n            {\n              <span class=\"teal\">IEnumerable</span>&lt;<span class=\"teal\">Curve</span>&gt; curves \n                = ea.Cast&lt;<span class=\"teal\">Edge</span>&gt;()\n                  .Select&lt;<span class=\"teal\">Edge</span>, <span class=\"teal\">Curve</span>&gt;( \n                    x =&gt; x.AsCurve() );\n \n              <span class=\"blue\">foreach</span>( <span class=\"teal\">Curve</span> curve <span class=\"blue\">in</span> curves )\n              {\n                creator.CreateModelCurve(\n                  curve.get_Transformed( _t ) );\n              }\n            }\n \n<span class=\"blue\">#endif</span> <span class=\"green\">// CREATE_MODEL_CURVES_FOR_TOP_FACE_EDGES</span>\n \n            <span class=\"blue\">break</span>;\n          }\n        }\n      }\n    }\n \n    <span class=\"teal\">Debug</span>.Print( <span class=\"blue\">string</span>.Format( \n      <span class=\"maroon\">\"{0} top face{1} found on {2}\"</span>,\n      n, <span class=\"teal\">Util</span>.PluralSuffix( n ),\n      <span class=\"teal\">Util</span>.ElementDescription( e ) ) );\n  }\n \n<span class=\"blue\">#if</span> CREATE_MODEL_CURVES_FOR_TOP_FACE_EDGES\n  t.Commit();\n<span class=\"blue\">#endif</span> <span class=\"green\">// CREATE_MODEL_CURVES_FOR_TOP_FACE_EDGES</span>\n \n  n = uidoc.Selection.Elements.Size;\n \n  <span class=\"blue\">string</span> s = <span class=\"blue\">string</span>.Format( \n    <span class=\"maroon\">\"{0} wall{1} selected\"</span>,\n    n, <span class=\"teal\">Util</span>.PluralSuffix( n ) );\n \n  n = topFaces.Count;\n \n  <span class=\"teal\">TaskDialog</span>.Show( <span class=\"maroon\">\"Wall Top Faces\"</span>, \n    <span class=\"blue\">string</span>.Format( \n      <span class=\"maroon\">\"{0} with {1} top face{2}.\"</span>,\n      s, n, <span class=\"teal\">Util</span>.PluralSuffix( n ) ) );\n \n  <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Succeeded;\n</pre>\n<p>Some obvious improvements to this algorithm immediately spring to mind.\nFor instance, I could check the list of side face outer loop vertices and eliminate all the ones which lie exactly below some other one. \nIn the simplest and most common case of a rectangular wall, that would eliminate the two bottom vertices and just leave the two top ones, halving their number.\nThat is left as an exercise to the reader.\n\n<p>I hope you find this as interesting and satisfying as I do and look forward to hearing about further uses that you find for both the new Revit API methods and my various extensions.\nI also look forward very much to hearing about your more effective solutions to this problem.\n\n<p>Here is \n\n<a href=\"zip/bc_12_89.zip\">\nversion 2012.0.89.0</a> of\n\nThe Building Coder samples including the new command CmdWallTopFaces.\n</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p>"
  }
]