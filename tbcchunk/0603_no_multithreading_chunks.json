[
  {
    "original_filename": "0603_no_multithreading",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<head>\n<link href=\"bc.css\" rel=\"stylesheet\" type=\"text/css\"/>\n</head>"
  },
  {
    "original_filename": "0603_no_multithreading",
    "header_text": "No Multithreading in Revit",
    "local_header_href": "#no-multithreading-in-revit",
    "chunk_text": "<h3>No Multithreading in Revit</h3><p>I repeatedly hear from developers asking whether multithreading can be used in conjunction with the Revit API.\nThe short answer is <b>no</b>.\n\n<p>To our surprise, we just noticed that the Truss SDK sample does demonstrate a use of multithreading.\nThat is an oversight and you should not rely on this working properly.\n\n<p>Here is the considered statement of Scott Conover, Software Development Manager of the Revit API, on the current state of multithreading and Revit:\n\n<p>\"Revit's internals make use of multiprocessing in only a few select isolated locations.  \nNone of these locations currently encompass the code in the Revit API, or any part of it.  \nThus Autodesk does not recommend making any calls to the Revit API from within simultaneously executing parallel threads.    \nIt may be that some part of the Revit API is isolated enough to be able to execute successfully from within such threading code in a test environment; this should not be taken to be a guarantee that the same source code will function for any model or situation, or that a future change in Revit will not cause this code to cease to function.\"\n\n<p>I hope this clarifies the situation.\n\n<h4>Truss SDK Sample Enhancement</h4>\n\nThe Truss SDK sample contains the following code and comments:\n\n<pre class=\"code\">\n  <span class=\"green\">// get all the beam types</span>\n  <span class=\"green\">// because GetBeamTypes() takes a long</span>\n  <span class=\"green\">// time, so call it in a new thread</span>\n \n  <span class=\"teal\">Thread</span> newThread = <span class=\"blue\">new</span> <span class=\"teal\">Thread</span>(\n    <span class=\"blue\">new</span> <span class=\"teal\">ThreadStart</span>( GetBeamTypes ) );\n \n  newThread.Start();\n</pre>\n<p>Here, GetBeamTypes is using the Revit API methods FilteredElementCollector and parameter access methods.\n\n<p>As said, this is not supported; Revit API access is required to be single threaded.  \nIt is an interesting side note that it apparently works, but this cannot be relied on and this code should definitely not be reused.\n\n<p>Actually, the sample would be faster if it made use of more of the FilteredElementCollector capabilities.\nThe implementation of this sample predated the introduction of filtered element collectors in Revit 2011:\n\n<pre class=\"code\">\n  m_beamTypes = <span class=\"blue\">from</span> elem <span class=\"blue\">in</span>\n    <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( doc )\n      .OfClass(<span class=\"blue\">typeof</span>(<span class=\"teal\">FamilySymbol</span>))\n      .ToElements()\n    <span class=\"blue\">let</span> type = elem <span class=\"blue\">as</span> <span class=\"teal\">FamilySymbol</span>\n    <span class=\"blue\">where</span> type != <span class=\"blue\">null</span> \n      &amp;&amp; type.Category != <span class=\"blue\">null</span>  \n      &amp;&amp; type.Category.Name == <span class=\"maroon\">\"Structural Framing\"</span>\n    <span class=\"blue\">select</span> type;\n</pre>\n\nA better implementation might be:\n\n<pre class=\"code\">\n  m_beamTypes \n    = <span class=\"blue\">from</span> elem <span class=\"blue\">in</span> <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( \n          m_activeDocument.Document )\n        .OfClass( <span class=\"blue\">typeof</span>( <span class=\"teal\">FamilySymbol</span> ) )\n        .OfCategory( <span class=\"teal\">BuiltInCategory</span>.OST_StructuralFraming )\n      <span class=\"blue\">let</span> type = elem <span class=\"blue\">as</span> <span class=\"teal\">FamilySymbol</span>\n      <span class=\"blue\">select</span> type; \n</pre>\n<p>This uses a quick category filter and avoids calling ToElements, which is unnecessary, as the filtered element collector itself is already an IEnumerable.\n\n<p>Other examples of using multithreading in perfectly valid ways in conjunction with the Revit API are provided by the APIAppStartup splash window and the AnalysisVisualizationFramework MultithreadedCalculation Revit SDK samples, where the separate threads do not make calls into Revit.\n</p></p></p></p></p></p></p></p></p></p>"
  },
  {
    "original_filename": "0603_no_multithreading",
    "header_text": "Truss SDK Sample Enhancement",
    "local_header_href": "#truss-sdk-sample-enhancement",
    "chunk_text": "<h4>Truss SDK Sample Enhancement</h4><pre class=\"code\">\n  <span class=\"green\">// get all the beam types</span>\n  <span class=\"green\">// because GetBeamTypes() takes a long</span>\n  <span class=\"green\">// time, so call it in a new thread</span>\n \n  <span class=\"teal\">Thread</span> newThread = <span class=\"blue\">new</span> <span class=\"teal\">Thread</span>(\n    <span class=\"blue\">new</span> <span class=\"teal\">ThreadStart</span>( GetBeamTypes ) );\n \n  newThread.Start();\n</pre><p>Here, GetBeamTypes is using the Revit API methods FilteredElementCollector and parameter access methods.\n\n<p>As said, this is not supported; Revit API access is required to be single threaded.  \nIt is an interesting side note that it apparently works, but this cannot be relied on and this code should definitely not be reused.\n\n<p>Actually, the sample would be faster if it made use of more of the FilteredElementCollector capabilities.\nThe implementation of this sample predated the introduction of filtered element collectors in Revit 2011:\n\n<pre class=\"code\">\n  m_beamTypes = <span class=\"blue\">from</span> elem <span class=\"blue\">in</span>\n    <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( doc )\n      .OfClass(<span class=\"blue\">typeof</span>(<span class=\"teal\">FamilySymbol</span>))\n      .ToElements()\n    <span class=\"blue\">let</span> type = elem <span class=\"blue\">as</span> <span class=\"teal\">FamilySymbol</span>\n    <span class=\"blue\">where</span> type != <span class=\"blue\">null</span> \n      &amp;&amp; type.Category != <span class=\"blue\">null</span>  \n      &amp;&amp; type.Category.Name == <span class=\"maroon\">\"Structural Framing\"</span>\n    <span class=\"blue\">select</span> type;\n</pre>\n\nA better implementation might be:\n\n<pre class=\"code\">\n  m_beamTypes \n    = <span class=\"blue\">from</span> elem <span class=\"blue\">in</span> <span class=\"blue\">new</span> <span class=\"teal\">FilteredElementCollector</span>( \n          m_activeDocument.Document )\n        .OfClass( <span class=\"blue\">typeof</span>( <span class=\"teal\">FamilySymbol</span> ) )\n        .OfCategory( <span class=\"teal\">BuiltInCategory</span>.OST_StructuralFraming )\n      <span class=\"blue\">let</span> type = elem <span class=\"blue\">as</span> <span class=\"teal\">FamilySymbol</span>\n      <span class=\"blue\">select</span> type; \n</pre>\n<p>This uses a quick category filter and avoids calling ToElements, which is unnecessary, as the filtered element collector itself is already an IEnumerable.\n\n<p>Other examples of using multithreading in perfectly valid ways in conjunction with the Revit API are provided by the APIAppStartup splash window and the AnalysisVisualizationFramework MultithreadedCalculation Revit SDK samples, where the separate threads do not make calls into Revit.\n</p></p></p></p></p>"
  }
]