[
  {
    "original_filename": "0314_object_relationship",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<head>\n<link href=\"bc.css\" rel=\"stylesheet\" type=\"text/css\"/>\n</head>"
  },
  {
    "original_filename": "0314_object_relationship",
    "header_text": "Object Relationships",
    "local_header_href": "#object-relationships",
    "chunk_text": "<h3>Object Relationships</h3><p>We already discussed several uses of the Document.Delete method to discover object relationships, e.g. the relationship between a \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2009/04/tag-association.html\">\ntag and the tagged element</a>, a\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2009/06/host-reference.html\">\nwall and its footing</a>,\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2009/06/host-reference.html\">\nhost and its hosted elements</a>, the \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2009/11/title-block-of-sheet.html\">\ntitle block of a sheet</a>, or \n\nhost elements and their openings for the purposes of \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/02/material-quantity-extraction.html\">\ngross material quantity determination</a>.\n\nAnother use of it is to obtain the \n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2010/02/unmodified-element-geometry.html\">\nunmodified element geometry</a>.\n\n<p>Here is a very neat little sample named ObjRel by Saikat Bhattacharya that shows how to use the method to determine generic objects relationships in a building model and display the results in a tree view.\nThe tree view is hosted by a .NET form, implemented by a class named Result.\n\n<p>The really neat trick of Saikat's implementation lies in the helper method GetDependentsElementIds and its three lines of code that determine all object relationships in a generic fashion by creating a transaction, calling the Delete method to obtain the dependent element ids, and aborting the transaction to restore the original state:\n\n<pre class=\"code\">\n<span class=\"teal\">ElementIdSet</span> GetDependentsElementIds( \n  <span class=\"teal\">Element</span> e )\n{\n  <span class=\"teal\">Document</span> doc = _app.ActiveDocument;\n \n  doc.BeginTransaction();\n \n  <span class=\"teal\">ElementIdSet</span> ids = doc.Delete( e );\n \n  doc.AbortTransaction();\n \n  <span class=\"blue\">return</span> ids;\n}\n</pre>\n<p>This method is used by the two tree view helper methods DisplayNode and CreateRelationships to populate the tree view with all BIM elements having relationships with other objects in the model:\n\n<ul>\n<li>DisplayNode:\n     This recursive method creates the tree nodes \n     based on dependent element ids. Each node \n     displays its element name, category and id.\n<li>CreateRelationships :\n     Creates the tree node with the initial node,\n     populates it, and maintains a list of elements \n     already included in the nodes to avoid duplication.\n</li></li></ul>\n<p>Here is the implementation of these two and the tree view dialogue constructor calling them:\n\n<pre class=\"code\">\n<span class=\"blue\">void</span> DisplayNode( <span class=\"teal\">Element</span> e, <span class=\"teal\">TreeNode</span> node )\n{\n  <span class=\"blue\">string</span> cat = (<span class=\"blue\">null</span> == e.Category) \n    ? <span class=\"maroon\">\"&lt;category unknown&gt;\"</span> \n    : e.Category.Name;\n \n  <span class=\"blue\">string</span> label = <span class=\"blue\">string</span>.Format( <span class=\"maroon\">\"{0}: {1} {2}\"</span>, \n    e.Name, cat, e.Id.Value );\n \n  <span class=\"teal\">TreeNode</span> father = node.Nodes.Add( label );\n \n  <span class=\"green\">// save element id to handle select event, </span>\n  <span class=\"green\">// cf. treeView1_AfterSelect:</span>\n \n  father.ImageKey = e.Id.Value.ToString(); \n \n  <span class=\"teal\">ElementIdSet</span> ids = GetDependentsElementIds( e );\n \n  <span class=\"blue\">try</span>\n  {\n    <span class=\"blue\">if</span>( <span class=\"blue\">null</span> != ids &amp;&amp; 1 &lt; ids.Size )\n    {\n      <span class=\"teal\">Document</span> doc = _app.ActiveDocument;\n \n      <span class=\"blue\">foreach</span>( <span class=\"teal\">ElementId</span> id1 <span class=\"blue\">in</span> ids )\n      {\n        <span class=\"teal\">ElementId</span> id = id1;\n        <span class=\"teal\">Element</span> e2 = doc.get_Element( <span class=\"blue\">ref</span> id );\n        <span class=\"blue\">if</span>( e2 != <span class=\"blue\">null</span> )\n        {\n          <span class=\"blue\">if</span>( !e2.Id.Equals( e.Id ) \n            &amp;&amp; !_displayedElems.Contains( e2 ) )\n          {\n            _displayedElems.Insert( e2 );\n            DisplayNode( e2, father );\n          }\n        }\n      }\n    }\n  }\n  <span class=\"blue\">catch</span>( <span class=\"teal\">Exception</span> ex )\n  {\n    <span class=\"teal\">MessageBox</span>.Show( ex.Message.ToString() );\n  }\n}\n \n<span class=\"blue\">void</span> CreateRelationships()\n{\n  rootNode = <span class=\"blue\">new</span> <span class=\"teal\">TreeNode</span>( _app.ActiveDocument.Title );\n  <span class=\"blue\">this</span>.treeView1.Nodes.Add( rootNode );\n \n  _displayedElems = <span class=\"blue\">new</span> <span class=\"teal\">ElementSet</span>();\n \n  <span class=\"blue\">foreach</span>( <span class=\"teal\">Element</span> e <span class=\"blue\">in</span> _elems )\n  {\n    <span class=\"blue\">if</span>( !_displayedElems.Contains( e ) )\n    {\n      DisplayNode( e, rootNode );\n    }\n  }\n}\n \n<span class=\"blue\">public</span> Result( <span class=\"teal\">ElementSet</span> elems, Autodesk.Revit.<span class=\"teal\">Application</span> app )\n{\n  _elems = elems;\n  _app = app;\n \n  InitializeComponent();\n  CreateRelationships();\n \n  treeView1.AfterSelect \n    += <span class=\"blue\">new</span> <span class=\"teal\">TreeViewEventHandler</span>( \n      treeView1_AfterSelect );\n}\n</pre>\n<p>Here is the external command Execute mainline implementation.\nIt creates a set of all model elements with visible graphics and representing a valid physical part of the building model and sends it the Result dialogue constructor, which calls the CreateRelationships method which in turn uses DisplayNode and GetDependentsElementIds to determine and display all dependencies:\n\n<pre class=\"code\">\n<span class=\"teal\">Application</span> app = commandData.Application;\n<span class=\"teal\">Document</span> doc = app.ActiveDocument;\n \nAutodesk.Revit.Geometry.<span class=\"teal\">Options</span> opt \n  = app.Create.NewGeometryOptions();\n \n<span class=\"teal\">BuiltInCategory</span> bicPreviewLegendComponent \n  = <span class=\"teal\">BuiltInCategory</span>.OST_PreviewLegendComponents;\n \n<span class=\"blue\">int</span> iBic = ( <span class=\"blue\">int</span> ) bicPreviewLegendComponent;\n \n<span class=\"blue\">try</span>\n{\n  <span class=\"green\">// select all model elements:</span>\n \n  <span class=\"teal\">ElementSet</span> a = app.Create.NewElementSet();\n \n  <span class=\"teal\">ElementIterator</span> it = app.ActiveDocument.Elements;\n \n  <span class=\"blue\">while</span>( it.MoveNext() )\n  {\n    <span class=\"teal\">Element</span> e = it.Current <span class=\"blue\">as</span> <span class=\"teal\">Element</span>;\n \n    <span class=\"blue\">if</span>( !( e <span class=\"blue\">is</span> <span class=\"teal\">Symbol</span> )\n      &amp;&amp; !( e <span class=\"blue\">is</span> <span class=\"teal\">FamilyBase</span> )\n      &amp;&amp; ( <span class=\"blue\">null</span> != e.Category )\n      &amp;&amp; ( iBic != e.Category.Id.Value )\n      &amp;&amp; ( <span class=\"blue\">null</span> != e.get_Geometry( opt ) ) )\n    {\n      a.Insert( e );\n    }\n  }\n \n  <span class=\"green\">// show the object relationship dialog</span>\n \n  <span class=\"teal\">Result</span> res = <span class=\"blue\">new</span> <span class=\"teal\">Result</span>( a, app );\n  res.ShowDialog();\n}\n<span class=\"blue\">catch</span>( <span class=\"teal\">Exception</span> ex )\n{\n  message = ex.Message;\n}\n<span class=\"blue\">return</span> <span class=\"teal\">IExternalCommand</span>.<span class=\"teal\">Result</span>.Failed;\n</pre>\n<p>We can use the following simple model to see the relationships displayed by this tool. \nHere is a 3D view showing the physical building model:</p>\n<center>\n<img alt=\"Simple house 3D view\" src=\"img/SimpleHouse3d.png\"/>\n</center>\n<p>The model also includes a few annotation elements which are only visible in plan view:</p>\n<center>\n<img alt=\"Simple house plan view\" src=\"img/SimpleHousePlan.png\"/>\n</center>\n<p>Here is the result of running the ObjRel command on this model and then fully expanding the tree view nodes to display all of the nested relationships detected:</p>\n<center>\n<img alt=\"Simple house object relationships\" src=\"img/SimpleHouseObjRel.png\"/>\n</center>\n<p>As you can see, a number of relationships between various objects have been determined and are displayed, and many of the types of relationships are ones which we had not previously explicitly noted.\n\n<p>Here is the complete \n\n<a href=\"zip/ObjRel.zip\">\nObjRel</a>\n\nsource code and Visual Studio solution including the sample model we used.</p>\n<p>Many thanks to Saikat for this brilliant idea of making such generic use of the Delete method to determine all object relationships and the neat little sample to demonstrate its use so succinctly and powerfully!\n\n</p></p></p></p></p></p></p></p>"
  }
]