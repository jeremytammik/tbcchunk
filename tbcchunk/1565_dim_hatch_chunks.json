[
  {
    "original_filename": "1565_dim_hatch",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n<link rel=\"stylesheet\" type=\"text/css\" href=\"bc.css\">\n<script src=\"run_prettify.js\" type=\"text/javascript\"></script>\n<!--\n<script src=\"https://google-code-prettify.googlecode.com/svn/loader/run_prettify.js\" type=\"text/javascript\"></script>\n-->\n</head>\n\n<!---\n\n- add-in guid\n  https://autodesk.slack.com/archives/C0SJ4U3PE/p1497273372195629\n  [q] if we create a revit addin, should the AddinId be unique across different versions of Revit (2017/2018/2019)? Or should they keep the same AddinId?\n  [a] They can have the same GUID. Not only can, but should keep the same add-in id. Some frameworks - updaters, external services and extensible storage, uses the add-in id and serializes it with relevant data.  So you will want the same add-in id in future versions so that Revit doesn't treat the capability as unrecognized.\n\n- https://forums.autodesk.com/t5/revit-api-forum/dimension-on-hatch-pattern-slab/td-p/7063302\n  /a/doc/revit/tbc/draft/dim_hatch.txt\n  undocumented relationships\n  \n- lb http://thebuildingcoder.typepad.com/blog/2011/11/undocumented-elementid-relationships.html\n  0702_avoid_idling.htm:1\n  0849_stair_geometry.htm:2\n  0996_attrib_relations.htm:1\n  1076_framing_xsec_analyse.htm:1\n  1205_image_relationships.htm:2\n  1565_dim_hatch.md:1\n\nWhy to retain your #RevitAPI Add-In GUID @AutodeskRevit #bim #dynamobim @AutodeskForge #ForgeDevCon http://bit.ly/dim_hatch_vodoo\nDimension hatch pattern with voodoo magic #RevitAPI @AutodeskRevit #bim #dynamobim @AutodeskForge #ForgeDevCon http://bit.ly/dim_hatch_vodoo\n\nReporting on a very exciting topic from the Revit API discussion forum from the Forge accelerator in Barcelona\n&ndash; Barcelona Forge accelerator\n&ndash; Retain the Add-In GUID\n&ndash; Dimension on hatch pattern...\n\n-->"
  },
  {
    "original_filename": "1565_dim_hatch",
    "header_text": "Hatch Line Dimensioning Voodoo",
    "local_header_href": "#hatch-line-dimensioning-voodoo",
    "chunk_text": "### Hatch Line Dimensioning Voodoo\n\nReporting on a very exciting topic from the Revit API discussion forum from the Forge accelerator in Barcelona:\n\n- [Barcelona Forge accelerator](#2)\n- [Retain the Add-In GUID](#3)\n- [Dimension on hatch pattern](#4)"
  },
  {
    "original_filename": "1565_dim_hatch",
    "header_text": "<a name=\"2\"></a>Barcelona Forge Accelerator",
    "local_header_href": "#a-name2abarcelona-forge-accelerator",
    "chunk_text": "#### <a name=\"2\"></a>Barcelona Forge Accelerator\n\nI am back in the Barcelona Autodesk office supporting the [Forge Accelerator](http://autodeskcloudaccelerator.com/forge-accelerator).\n\nI was here [last year](http://thebuildingcoder.typepad.com/blog/2016/03/adn-becomes-forge-and-barcelona-accelerator.html#3)\n[as well](http://thebuildingcoder.typepad.com/blog/2016/05/forge-accelerator-devcon-and-answer-day.html), where\nI started working on\nthe [roomedit3d project](https://github.com/jeremytammik/roomedit3d), implementing all \nits [Revit-independent functionality](http://thebuildingcoder.typepad.com/blog/2016/05/roomedit3d-console-test-and-rendering-assets.html#2).\n\nLet's look at two Revit API issues before I dig in deeper into Forge:"
  },
  {
    "original_filename": "1565_dim_hatch",
    "header_text": "<a name=\"3\"></a>Retain the Add-In GUID",
    "local_header_href": "#a-name3aretain-the-add-in-guid",
    "chunk_text": "#### <a name=\"3\"></a>Retain the Add-In GUID\n\n**Question:** If I create a Revit add-in, should the `AddinId` be unique across different versions of Revit (2017/2018/2019)?\n\nOr should I retain the same `AddinId`?\n\n**Answer:** The different versions can have the same GUID.\n\nNot only can, but they definitely should keep the same add-in id.\n\nSome frameworks, e.g., updaters, external services and extensible storage, use the add-in id and serialise it with relevant data.\n\nTherefore, you will want to retain the same add-in id in future versions, so that Revit doesn't treat the capability as unrecognized."
  },
  {
    "original_filename": "1565_dim_hatch",
    "header_text": "<a name=\"4\"></a>Dimension on Hatch Pattern",
    "local_header_href": "#a-name4adimension-on-hatch-pattern",
    "chunk_text": "#### <a name=\"4\"></a>Dimension on Hatch Pattern\n\nOn to a much more complex question, adding a new entry to our collection\nof [undocumented `ElementId` relationships](http://thebuildingcoder.typepad.com/blog/2011/11/undocumented-elementid-relationships.html).\n\nIt came up in\nthe [Revit API discussion forum](http://forums.autodesk.com/t5/revit-api-forum/bd-p/160) thread\non creating a [dimension on hatch pattern slab](https://forums.autodesk.com/t5/revit-api-forum/dimension-on-hatch-pattern-slab/td-p/7063302) and\nwas answered very creatively indeed by Fair59, who has already contributed numerous answers to other very tricky issues.\n\nFair59's solution reminds me of\nScott Wilson's [`Reference` stable representation magic voodoo](http://thebuildingcoder.typepad.com/blog/2016/04/stable-reference-string-magic-voodoo.html):\n\n\n**Question:** I want to get dimension on hatch pattern slab like this: \n\n<center>\n<img src=\"img/dim_hatch_01.png\" alt=\"Dimension hatch lines\" width=\"400\">\n</center>\n\nBut I don't know how to retrieve hatch line.\n\n\n**Answer 1:** First: Use [RevitLookup](https://github.com/jeremytammik/RevitLookup) to\nfind out what elements you are after:\n \nSecond: Retrieve their geometry, asking for `ComputeReferences = true`.\n \nThird: Create the dimensioning using the references:\n\n- [Dimension walls by iterating faces](http://thebuildingcoder.typepad.com/blog/2011/02/dimension-walls-by-iterating-faces.html)\n- [Dimension walls using `FindReferencesByDirection`](http://thebuildingcoder.typepad.com/blog/2011/02/dimension-walls-using-findreferencesbydirection.html)\n\n**Response:** That does not help.\n\n1. I already know it's a floor and can get it.\n2. I already retrieve the solid of floor.\n\nThe problem is, from the solid I cannot retrieve the geometry of the line pattern in the floor to create dimensions between them.\n \nCan you explain more details, please?\n \nHere my code in this project so far:\n \n<pre class=\"code\">\n<span style=\"color:green;\">//&nbsp;Pick&nbsp;floor&nbsp;element</span>\n<span style=\"color:#2b91af;\">IList</span>&lt;<span style=\"color:#2b91af;\">Element</span>&gt;&nbsp;elems&nbsp;=&nbsp;sel.PickElementsByRectangle();\n<span style=\"color:#2b91af;\">Floor</span>&nbsp;fl&nbsp;=&nbsp;<span style=\"color:blue;\">null</span>;\n \n<span style=\"color:green;\">//&nbsp;Loop&nbsp;elems&nbsp;to&nbsp;get&nbsp;Floor</span>\n<span style=\"color:blue;\">foreach</span>(&nbsp;<span style=\"color:#2b91af;\">Element</span>&nbsp;e&nbsp;<span style=\"color:blue;\">in</span>&nbsp;elems&nbsp;)\n{\n&nbsp;&nbsp;<span style=\"color:blue;\">if</span>(&nbsp;e&nbsp;<span style=\"color:blue;\">is</span>&nbsp;<span style=\"color:#2b91af;\">Floor</span>&nbsp;)\n&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;fl&nbsp;=&nbsp;(<span style=\"color:#2b91af;\">Floor</span>)&nbsp;e;\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">break</span>;\n&nbsp;&nbsp;}\n}\n \n<span style=\"color:#2b91af;\">Solid</span>&nbsp;s&nbsp;=&nbsp;<span style=\"color:blue;\">null</span>;\n<span style=\"color:#2b91af;\">Options</span>&nbsp;o&nbsp;=&nbsp;<span style=\"color:blue;\">new</span>&nbsp;<span style=\"color:#2b91af;\">Options</span>();\no.ComputeReferences&nbsp;=&nbsp;<span style=\"color:blue;\">true</span>;\n<span style=\"color:#2b91af;\">GeometryElement</span>&nbsp;geoElem&nbsp;=&nbsp;fl.get_Geometry(&nbsp;o&nbsp;);\n \n<span style=\"color:green;\">//&nbsp;Loop&nbsp;the&nbsp;geometry&nbsp;of&nbsp;Floor&nbsp;to&nbsp;get&nbsp;solid</span>\n<span style=\"color:blue;\">foreach</span>(&nbsp;<span style=\"color:#2b91af;\">GeometryObject</span>&nbsp;geoObj&nbsp;<span style=\"color:blue;\">in</span>&nbsp;geoElem&nbsp;)\n{\n&nbsp;&nbsp;<span style=\"color:blue;\">if</span>(&nbsp;s&nbsp;!=&nbsp;<span style=\"color:blue;\">null</span>&nbsp;)\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">break</span>;\n&nbsp;&nbsp;s&nbsp;=&nbsp;(<span style=\"color:#2b91af;\">Solid</span>)&nbsp;geoObj;\n}\n \n<span style=\"color:green;\">//&nbsp;Stop&nbsp;here,have&nbsp;solid&nbsp;of&nbsp;floor&nbsp;but&nbsp;don&#39;t&nbsp;know&nbsp;</span>\n<span style=\"color:green;\">//&nbsp;how&nbsp;to&nbsp;retrieve&nbsp;line&nbsp;in&nbsp;fill&nbsp;pattern&nbsp;of&nbsp;floor&nbsp;:(</span>\n</pre>\n\n\n**Answer 2:** The answer is: you cannot get the geometry objects of the hatch pattern, at all.\n \nYou even cannot calculate the hatch line positions manually, since there is no information about origin and direction in relation to the face.\n\nAlso, the  user may have edited the hatch pattern origin by hand.\n\nAdditionally, there are two kinds of fill patterns: 'model' and 'drawing'. One of them depends on view's scale, the other not.\n\nYou can analySe the related FillPattern's FillGrids, but you don't have the logical connection to the Face's coordinates.\n \nSo, no, it cannot be done.\n\n\n**Answer 3:** There is indeed no direct way to get to hatch lines.\n\nHowever, we have just about enough information to construct them.\n \nI had a hunch, that the reference to the surface and to the hatch lines are related.\n\nA call to `Reference.ConvertToStableRepresentation` returns:\n\n- Surface: 926c1621-1982-4ef6-bcbc-21fe350f0087-001f2d0b:1:SURFACE\n- Hatch Line: 926c1621-1982-4ef6-bcbc-21fe350f0087-001f2d0b:1:SURFACE/6\n\nSo, given a `StableRepresentation` of a surface , you can construct a `Reference` to a hatch line like this, where `index` is an integer `>1`:\n\n<pre class=\"code\">\n<span style=\"color:#2b91af;\">Reference</span>&nbsp;HatchRef\n&nbsp;&nbsp;=&nbsp;<span style=\"color:#2b91af;\">Reference</span>.ParseFromStableRepresentation(&nbsp;doc,\n&nbsp;&nbsp;&nbsp;&nbsp;StableRepresentation&nbsp;of&nbsp;<span style=\"color:#2b91af;\">Surface</span>&nbsp;+&nbsp;<span style=\"color:#a31515;\">&quot;/index&quot;</span>&nbsp;);\n</pre> \n\nThe indices are distributed over the different hatch lines as follows:\n\n<center>\n<img src=\"img/dim_hatch_line_index.png\" alt=\"Dimension hatch line indices\" width=\"600\">\n</center>\n\nTake 2 references to a HatchLine and you can create a dimension.\n\nOnce you have the dimension, you can determine the direction and position of the 'unbound' lines.\n \nHere is my code the creates that dimension:\n\n<pre class=\"code\">\n<span style=\"color:#2b91af;\">Floor</span>&nbsp;_floor;\n<span style=\"color:#2b91af;\">Reference</span>&nbsp;top&nbsp;=&nbsp;<span style=\"color:#2b91af;\">HostObjectUtils</span>.GetTopFaces(&nbsp;_floor&nbsp;)\n&nbsp;&nbsp;.First();\n \n<span style=\"color:#2b91af;\">PlanarFace</span>&nbsp;topFace&nbsp;=&nbsp;_floor.GetGeometryObjectFromReference(&nbsp;\n&nbsp;&nbsp;top&nbsp;)&nbsp;<span style=\"color:blue;\">as</span>&nbsp;<span style=\"color:#2b91af;\">PlanarFace</span>;\n \n<span style=\"color:green;\">//&nbsp;Check&nbsp;for&nbsp;model&nbsp;surfacepattern</span>\n \n<span style=\"color:#2b91af;\">Material</span>&nbsp;mat&nbsp;=&nbsp;doc.GetElement(&nbsp;\n&nbsp;&nbsp;topFace.MaterialElementId&nbsp;)&nbsp;<span style=\"color:blue;\">as</span>&nbsp;<span style=\"color:#2b91af;\">Material</span>;\n \n<span style=\"color:#2b91af;\">FillPatternElement</span>&nbsp;patterntype&nbsp;=&nbsp;doc.GetElement(&nbsp;\n&nbsp;&nbsp;mat.SurfacePatternId&nbsp;)&nbsp;<span style=\"color:blue;\">as</span>&nbsp;<span style=\"color:#2b91af;\">FillPatternElement</span>;\n \n<span style=\"color:blue;\">if</span>(&nbsp;patterntype&nbsp;==&nbsp;<span style=\"color:blue;\">null</span>&nbsp;)&nbsp;<span style=\"color:blue;\">return</span>&nbsp;<span style=\"color:#2b91af;\">Result</span>.Failed;\n \n<span style=\"color:#2b91af;\">FillPattern</span>&nbsp;pattern&nbsp;=&nbsp;patterntype.GetFillPattern();\n \n<span style=\"color:blue;\">if</span>(&nbsp;pattern.IsSolidFill&nbsp;\n&nbsp;&nbsp;||&nbsp;pattern.Target&nbsp;==&nbsp;<span style=\"color:#2b91af;\">FillPatternTarget</span>.Drafting&nbsp;)\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:blue;\">return</span>&nbsp;<span style=\"color:#2b91af;\">Result</span>.Failed;\n \n<span style=\"color:green;\">//&nbsp;Get&nbsp;number&nbsp;of&nbsp;gridLines&nbsp;in&nbsp;pattern&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>\n \n<span style=\"color:blue;\">int</span>&nbsp;_gridCount&nbsp;=&nbsp;pattern.GridCount;\n \n<span style=\"color:green;\">//&nbsp;Construct&nbsp;StableRepresentations&nbsp;and&nbsp;find&nbsp;the&nbsp;</span>\n<span style=\"color:green;\">//&nbsp;Reference&nbsp;to&nbsp;HatchLines</span>\n \n<span style=\"color:blue;\">string</span>&nbsp;StableRef&nbsp;=&nbsp;top.ConvertToStableRepresentation(&nbsp;\n&nbsp;&nbsp;doc&nbsp;);\n \n<span style=\"color:#2b91af;\">ReferenceArray</span>&nbsp;_resArr&nbsp;=&nbsp;<span style=\"color:blue;\">new</span>&nbsp;<span style=\"color:#2b91af;\">ReferenceArray</span>();\n<span style=\"color:blue;\">for</span>(&nbsp;<span style=\"color:blue;\">int</span>&nbsp;ip&nbsp;=&nbsp;0;&nbsp;ip&nbsp;&lt;&nbsp;2;&nbsp;ip++&nbsp;)\n{\n&nbsp;&nbsp;<span style=\"color:blue;\">int</span>&nbsp;index&nbsp;=&nbsp;1&nbsp;+&nbsp;(&nbsp;ip&nbsp;*&nbsp;_gridCount&nbsp;*&nbsp;2&nbsp;);\n \n&nbsp;&nbsp;<span style=\"color:blue;\">string</span>&nbsp;StableHatchString&nbsp;=&nbsp;StableRef&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;+&nbsp;<span style=\"color:blue;\">string</span>.Format(&nbsp;<span style=\"color:#a31515;\">&quot;/{0}&quot;</span>,&nbsp;index&nbsp;);\n \n&nbsp;&nbsp;<span style=\"color:#2b91af;\">Reference</span>&nbsp;HatchRef&nbsp;=&nbsp;<span style=\"color:blue;\">null</span>;\n&nbsp;&nbsp;<span style=\"color:blue;\">try</span>\n&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;HatchRef&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;<span style=\"color:#2b91af;\">Reference</span>.ParseFromStableRepresentation(&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;doc,&nbsp;StableHatchString&nbsp;);\n&nbsp;&nbsp;}\n&nbsp;&nbsp;<span style=\"color:blue;\">catch</span>\n&nbsp;&nbsp;{&nbsp;}\n&nbsp;&nbsp;<span style=\"color:blue;\">if</span>(&nbsp;HatchRef&nbsp;==&nbsp;<span style=\"color:blue;\">null</span>&nbsp;)&nbsp;<span style=\"color:blue;\">continue</span>;\n&nbsp;&nbsp;_resArr.Append(&nbsp;HatchRef&nbsp;);\n}\n \n<span style=\"color:green;\">//&nbsp;2&nbsp;or&nbsp;more&nbsp;References&nbsp;=&gt;&nbsp;create&nbsp;dimension</span>\n \n<span style=\"color:blue;\">if</span>(&nbsp;_resArr.Size&nbsp;&gt;&nbsp;1&nbsp;)\n{\n&nbsp;&nbsp;<span style=\"color:blue;\">using</span>(&nbsp;<span style=\"color:#2b91af;\">Transaction</span>&nbsp;t&nbsp;=&nbsp;<span style=\"color:blue;\">new</span>&nbsp;<span style=\"color:#2b91af;\">Transaction</span>(&nbsp;doc&nbsp;)&nbsp;)\n&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;t.Start(&nbsp;<span style=\"color:#a31515;\">&quot;dimension&nbsp;Hatch&quot;</span>&nbsp;);\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:#2b91af;\">Dimension</span>&nbsp;_dimension&nbsp;=&nbsp;doc.Create.NewDimension(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;doc.ActiveView,&nbsp;<span style=\"color:#2b91af;\">Line</span>.CreateBound(&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:#2b91af;\">XYZ</span>.Zero,&nbsp;<span style=\"color:blue;\">new</span>&nbsp;<span style=\"color:#2b91af;\">XYZ</span>(&nbsp;10,&nbsp;0,&nbsp;0&nbsp;)&nbsp;),\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_resArr&nbsp;);\n \n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:green;\">//&nbsp;Move&nbsp;dimension&nbsp;a&nbsp;tiny&nbsp;amount&nbsp;to&nbsp;orient&nbsp;the&nbsp;</span>\n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:green;\">//&nbsp;dimension&nbsp;perpendicular&nbsp;to&nbsp;the&nbsp;hatchlines</span>\n \n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:green;\">//&nbsp;I&nbsp;can&#39;t&nbsp;say&nbsp;why&nbsp;it&nbsp;works,&nbsp;but&nbsp;it&nbsp;does.</span>\n \n&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:#2b91af;\">ElementTransformUtils</span>.MoveElement(&nbsp;doc,&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_dimension.Id,&nbsp;<span style=\"color:blue;\">new</span>&nbsp;<span style=\"color:#2b91af;\">XYZ</span>(&nbsp;.1,&nbsp;0,&nbsp;0&nbsp;)&nbsp;);\n \n&nbsp;&nbsp;&nbsp;&nbsp;t.Commit();\n&nbsp;&nbsp;}\n}\n</pre>   \n \n**Response:** I ended up avoiding the problem by using a `FilledRegion` previous set on the floor pattern. The `FilledRegion` dimension should be equal to one tile dimension.\n\nSo, I can locate one tile on Floor, then create a dimension from that to others.  \n\nMany thanks to Fair59 for this extremely creative approach and another gem in the collection of tips and tricks making use of undocumented Revit `ElementId` relationships!"
  }
]