[
  {
    "original_filename": "1382_filter_shortcuts",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n<link rel=\"stylesheet\" type=\"text/css\" href=\"bc.css\">\n<script src=\"run_prettify.js\" type=\"text/javascript\"></script>\n<!---\n<script src=\"https://google-code-prettify.googlecode.com/svn/loader/run_prettify.js\" type=\"text/javascript\"></script>\n-->\n</head>\n\n<!---\n\n11316493 [FilteredElementCollectors with LINQ]\n10696417 [How to retrieve System Families]\n\n#dotnet #csharp\n#fsharp #python\n#grevit\n#responsivedesign #typepad\n#ah8 #augi #dotnet\n#stingray #adsklabs #rendering\n#3dweb #3dviewapi #html5 #threejs #webgl #3d #apis #mobile #vr #ecommerce\n#Markdown #Fusion360 #Fusion360Hackathon\n#javascript\n#RestSharp #restapi\n#mongoosejs #mongodb #nodejs\n#rtceur\n#geometry #3d\n#xaml\n\nRevit API, Jeremy Tammik, akn_include\n\nQuick, Slow and LINQ Element Filtering #revitapi #bim #aec #3dwebcoder #adsk\n\nI arrived back safe and sound in Switzerland after the exciting week at Autodesk University. Another happy arrival is my first grandson: He was preceded by his big sister almost two years ago. Life goes on. I have been wanting to highlight the difference between quick and slow element filters for quite a while, and now a query came in that provides an ideal opportunity\n&ndash; Use of LINQ with filtered element collectors\n&ndash; Revit element filter classification\n&ndash; Filter types\n&ndash; Efficiency guidelines\n&ndash; Logical filters\n&ndash; Quick filters\n&ndash; Slow filters...\n\n-->"
  },
  {
    "original_filename": "1382_filter_shortcuts",
    "header_text": "Quick, Slow and LINQ Element Filtering",
    "local_header_href": "#quick-slow-and-linq-element-filtering",
    "chunk_text": "### Quick, Slow and LINQ Element Filtering\n\nI arrived back safe and sound in Switzerland after the exciting week at Autodesk University.\n\nAnother happy arrival is my first grandson:\n\n<center>\n<img src=\"/p/people/marlon/20151208_marlon_cropped.jpg\" alt=\"Grandson\" width=\"400\">\n</center>\n\nHe was preceded by his big sister almost two years ago.\n\nLife goes on.\n\nI have been wanting to highlight the difference between quick and slow element filters for quite a while, and now a query came in that provides an ideal opportunity.\n\n- [Use of LINQ with filtered element collectors](#2)\n- [Revit element filter classification](#3)\n    - [Filter types](#4)\n    - [Efficiency guidelines](#5)\n    - [Logical filters](#5)\n    - [Quick filters](#6)\n    - [Slow filters](#7)"
  },
  {
    "original_filename": "1382_filter_shortcuts",
    "header_text": "<a name=\"2\"></a>Use of LINQ with Filtered Element Collectors",
    "local_header_href": "#a-name2ause-of-linq-with-filtered-element-collectors",
    "chunk_text": "#### <a name=\"2\"></a>Use of LINQ with Filtered Element Collectors\n\n**Question:** I have been using lots of LINQ with delegates to perform database queries.\n\nNow I am wondering how to use them with Revit filtered element collectors.\n\nI see several different possibilities, e.g. like this:\n\n<center>\n<img src=\"img/jo_collector_samples.png\" alt=\"Filtered element collector sample code snippets\" width=\"889\">\n</center>\n\nI have the following questions regarding this:\n\n1. What is the primary difference/benefit between the sample 1 code, which uses the Revit `ElementFilter` objects, and the sample 3 code, which just uses pure LINQ on the FilteredElementCollector itself? I assume they would get the same results but I don't quite grasp when I should be using the native Revit filter objects versus pure LINQ queries.\n2. In sample 2, is the `ToElements` method required? Is there any difference between that and the `foreach` loop on the FilteredElementCollector directly in sample 1?\n3. Similar question 2, in sample 3 is it safe to perform LINQ on the FilteredElementCollector directly or should I be invoking `ToElements` first then performing LINQ?\n\nI've found LINQ to be incredibly fast but I'm just trying to make sure I fully understand the impacts of using it on the FilteredElementCollector objects.\n\n**Answer:** These are very relevant and important questions, I think.\n\nHowever, I would *always* much prefer having the sample code snippets in text form rather than as a screen snapshot!\n\nTo start from the essentials and basics, you need to understand and consider three different levels of filtering element collector data access and performance:\n\n- Quick filters\n- Slow filters\n- .NET filtering, aka post-processing\n\nQuick filters are fast, because they operate on data present in the Revit element header.\n\nIn a huge project, Revit will not load the entire Revit database element information, only a small header for each element.\n\nA quick filter can execute immediately using only the header information, which is always available in the project.\n\nA slow filter may need to load the complete element information in order to execute. In a huge project, that may affect performance.\n\nThese two kinds of filters are built into the Revit filtered element collector framework and execute directly on the Revit element data within the Revit memory, with no need to translate and marshal the element information to pass it out to the .NET add-in client.\n\nAs soon as you use any kind of .NET operation to filter that data, you are requesting Revit to translate and marshal the element information and pass it out from the Revit memory space to the .NET add-in client. That is a hugely inefficient process, compared to the internal filtering.\n\nRegardless of what you are searching for, doing it in .NET instead of using a built-in filter is guaranteed to double the execution time and halve the performance.\n\nI tested various combinations of this quite extensively, starting with\nthe [collector benchmark](http://thebuildingcoder.typepad.com/blog/2010/04/collector-benchmark.html) in 2010.\n\nYou can find more examples by searching the Internet for CmdCollectorPerformance, optionally adding 'revit api' or 'building coder'.\n\nThey refer to\nthe [CmdCollectorPerformance.cs module](https://github.com/jeremytammik/the_building_coder_samples/blob/master/BuildingCoder/BuildingCoder/CmdCollectorPerformance.cs)\nin [The Building Coder samples](https://github.com/jeremytammik/the_building_coder_samples).\n\nYour question 2 regarding the optional use of `ToElements` is answered in my discussion of [ToElementIds performance](http://thebuildingcoder.typepad.com/blog/2012/12/toelementids-performance.html).\n\nIn short, you should avoid it unless you really need it.\n\nOne situation in which it might be useful is when you really need to determine the number of elements returned by the collector before starting to iterate over them. Unlike the collector itself, ToElements returns a generic List of Element objects providing a Count property.\n\nA more common need might be to access the element ids.\n\nI recently discussed an example that demonstrates the imperative need\nto [close the collector before deleting elements](http://thebuildingcoder.typepad.com/blog/2015/12/au-ioc-banks-and-not-to-delete-while-iterating.html#2),\nin which case `ToElementIds` can come in handy.\n\nBy now, I hope that it is clear that your sample 3 is an utter abomination and could be regarded as verging on criminal inefficiency.\n\nIf you say that you found LINQ to be incredibly fast, you will be happy to hear that the Revit filtered element collectors are at least twice as fast, in the worst case.\n\nFor the sake of completeness, see [below](#3) for more on the topic of the different Revit API filter types and quick versus slow ones.\n\nAn interesting specialised topic is how to convert from .NET post-process filtering to built-in Revit filtering in order to optimise performance. One typical situation in which the .NET filtering may seem easier to implement is when checking for specific element parameter values.\n\nThe collector performance samples pointed to above provide several samples of avoiding that by setting up appropriate element parameter filters instead, e.g., to [filter for elements in a specific view having a specific phase](https://github.com/jeremytammik/the_building_coder_samples/blob/master/BuildingCoder/BuildingCoder/CmdCollectorPerformance.cs#L148-L200).\n\nPlease also explore and understand the related discussion\non [FindElement and collector\noptimisation](http://thebuildingcoder.typepad.com/blog/2012/09/findelement-and-collector-optimisation.html).\n\nNow back to the overview that I have been planning to publish for so long:"
  },
  {
    "original_filename": "1382_filter_shortcuts",
    "header_text": "<a name=\"3\"></a>Revit Element Filter Classification",
    "local_header_href": "#a-name3arevit-element-filter-classification",
    "chunk_text": "#### <a name=\"3\"></a>Revit Element Filter Classification\n\nHere is an overview of the different types of element filters, based on\nthe [Revit API Introduction slide deck](https://github.com/ADN-DevTech/RevitTrainingMaterial/blob/master/Presentation/1_Revit_API_Intro.pptx) from\nthe [ADN Revit API training material](https://github.com/ADN-DevTech/RevitTrainingMaterial).\n\nAll Revit database elements are bundled in one single container.\n\nTo retrieve an element of interest, you filter for it using a filtered element collector.\n\nThe `FilteredElementCollector` class is used to search, filter and iterate through a set of elements.\n\nYou can assign a variety of conditions to filter the elements that are returned.\n\nThe system requires that at least one condition be set before making the attempt to access the elements, otherwise an exception thrown.\n\nThe `FilteredElementCollector` class supports the `IEnumerable` interface, so you can iterate over the resulting elements directly using `foreach`.\n\n**Tip:** because all built-in Revit element filters process elements in native code before their managed wrappers are generated, better performance will be obtained by using as many native filters as possible on the collector before attempting to process the results using LINQ queries or other .NET methods."
  },
  {
    "original_filename": "1382_filter_shortcuts",
    "header_text": "<a name=\"4\"></a>Filter Types",
    "local_header_href": "#a-name4afilter-types",
    "chunk_text": "#### <a name=\"4\"></a>Filter Types\n\n- Logical Filters &ndash; help to combine filter logic\n    - And\n    - Or\n- Quick filters &ndash; use internal element record header to determine passing state\n    - Examples: ElementClassFilter, ElementCategoryFilter\n- Slow filters &ndash; expand element to determine passing state\n    - Examples: FamilyInstanceFilter, AreaFilter\n\nQuick filters can use the internal element record to determine passing state. This allows Revit to find elements that have not been expanded into internal memory yet.\n\nSlow filters cannot determine the passing state based on the minimal element record, so these filters must load and expand each element to determine its passing state."
  },
  {
    "original_filename": "1382_filter_shortcuts",
    "header_text": "<a name=\"5\"></a>Efficiency Guidelines",
    "local_header_href": "#a-name5aefficiency-guidelines",
    "chunk_text": "#### <a name=\"5\"></a>Efficiency Guidelines\n\n- Filter quick aspects first\n- Filter slow aspects later\n- Do not use .NET or LINQ until after exhausting the built-in filtering techniques\n\n**Tip:** Use the shortcut methods on FilteredElementCollector.\n\n- Because there are currently no shortcuts for slow filters, you can be sure you are getting a quick filter when using a shortcut.\n- Examples: OfClass, OfCategoryId"
  },
  {
    "original_filename": "1382_filter_shortcuts",
    "header_text": "<a name=\"5\"></a>Logical Filters",
    "local_header_href": "#a-name5alogical-filters",
    "chunk_text": "#### <a name=\"5\"></a>Logical Filters\n\n- LogicalAndFilter: elements must pass two or more filters\n    - WherePasses &ndash; adds an additional filter\n    - IntersectWith &ndash; joins two sets of independent filters\n- LogicalOrFilter &ndash; elements must pass at least one of two or more filters\n    - UnionWith &ndash; joins two sets of independent filters"
  },
  {
    "original_filename": "1382_filter_shortcuts",
    "header_text": "<a name=\"6\"></a>Quick Filters",
    "local_header_href": "#a-name6aquick-filters",
    "chunk_text": "#### <a name=\"6\"></a>Quick Filters\n\nAll quick filters are visible as shortcut methods on the filtered element collector.\n\nHere is a list of the filter class name, shortcut method, if available, and description:\n\n- ElementCategoryFilter &ndash; `OfCategoryId` &ndash; elements matching the input category id.\n- ElementClassFilter &ndash; `OfClass` &ndash; elements matching the input runtime class.\n- ElementIsElementTypeFilter &ndash; `WhereElementIsElementType`, `WhereElementIsNotElementType` &ndash; elements that are element types, also called family symbols.\n- ElementOwnerViewFilter &ndash; `OwnedByView`, `WhereElementIsViewIndependent` &ndash; elements that are view-specific.\n- ElementDesignOptionFilter &ndash; `ContainedInDesignOption` &ndash; elements in a particular design option.\n- ElementIsCurveDrivenFilter &ndash; `WhereElementIsCurveDriven` &ndash; elements that are curve driven.\n- ElementStructuralTypeFilter &ndash; none &ndash; elements matching the given structural type.\n- FamilySymbolFilter &ndash; none &ndash; symbols of a particular family.\n- ExclusionFilter &ndash; `Excluding` &ndash; all elements except the ones who's ids are passed into to the filter.\n- BoundingBoxIntersectsFilter &ndash; none &ndash; elements that have a bounding box intersecting a given outline.\n- BoundingBoxIsInsideFilter &ndash; none &ndash; elements that have a bounding box inside a given outline.\n- BoundingBoxContainsPointFilter &ndash; none &ndash; elements that have a bounding box containing a given point."
  },
  {
    "original_filename": "1382_filter_shortcuts",
    "header_text": "<a name=\"7\"></a>Slow Filters",
    "local_header_href": "#a-name7aslow-filters",
    "chunk_text": "#### <a name=\"7\"></a>Slow Filters\n\nSlow filters have no corresponding shortcut method on the collector class:\n\n- FamilyInstanceFilter &ndash; instances of a particular family symbol.\n- ElementLevelFilter &ndash; elements associated to a given level id.\n- ElementParameterFilter &ndash; parameter existence, value matching, range matching, and/or string matching.\n- PrimaryDesignOptionMemberFilter &ndash; elements owned by any primary design option..\n- StructuralInstanceUsageFilter &ndash; structural usage parameter for family instances.\n- StructuralWallUsageFilter &ndash; structural usage parameter for walls.\n- StructuralMaterialTypeFilter &ndash; material type applied to family instances.\n- RoomFilter &ndash; finds rooms.\n- SpaceFilter &ndash; finds spaces.\n- AreaFilter &ndash; finds areas.\n- RoomTagFilter &ndash; finds room tags.\n- SpaceTagFilter &ndash; finds space tags.\n- AreaTagFilter &ndash; finds area tags.\n- CurveElementFilter &ndash; finds specific types of curve elements, e.g. model curves, symbolic curves, detail curves, etc."
  }
]