[
  {
    "original_filename": "1308_3dwc_twgl",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<head>\n<meta content=\"text/html; charset=utf-8\" http-equiv=\"Content-Type\"/>\n<link href=\"bc.css\" rel=\"stylesheet\" type=\"text/css\"/>\n</head>"
  },
  {
    "original_filename": "1308_3dwc_twgl",
    "header_text": "Exporting 3D Element Geometry to a WebGL Viewer",
    "local_header_href": "#exporting-3d-element-geometry-to-a-webgl-viewer",
    "chunk_text": "<h3>Exporting 3D Element Geometry to a WebGL Viewer</h3><p>Yesterday, I discussed\n\n<a href=\"http://the3dwebcoder.typepad.com/blog/2015/04/webgl-101-getting-started.html\">\nhow to get started with WebGL</a> and\n\ndemonstrated a simple 3D viewer making use of the Tiny WebGL helper Library <a href=\"http://twgljs.org\">TWGL</a>.</p><p>Today, I present the TwglExport Revit add-in to select an individual element and populate the viewer with that.</p><p>To drive the WebGL viewer, we just need a bunch of vertex locations, normal vectors in each vertex, and face definitions hooking them up with each other.</p><p>TwglExport achieves exactly that though the following steps:</p><ul>\n<li>Retrieve the pre-selected element.</li>\n<li>Determine its bounding box and geometry.</li>\n<li>Loop through the geometry objects, ignoring everything except solids.</li>\n<li>Loop through the solid faces.</li>\n<li>For each face, request a triangulated mesh.</li>\n<li>For each mesh triangle, export its three corners and its normals at each one.</li>\n<li>Add the indices of the resulting vertex and normal coordinate entries to the face definition list.</li>\n</ul><p>I already implemented a number of similar algorithms and add-ins in the past, e.g., the\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2012/07/obj-model-exporter-with-transparency-support.html\">OBJ model exporter</a> and the\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2013/07/adn-mesh-data-custom-exporter-to-json.html\">ADN mesh data custom exporter to JSON</a>.</p><p>Please be aware that for most serious uses, you will wish to export multiple elements that may have a complicated nested geometric structure, e.g. family instances, or an entire building model.</p><p>In those cases, you will almost certainly save a lot of effort by making use of a\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/about-the-author.html#5.1\">custom exporter</a> instead\n\nof traversing individual element geometry like I am doing here for this trivial single-element case.</p><p>The element geometry that I retrieve from the Revit database is all in feet.</p><p>For the sake of simplicity and efficiency – and maybe show the imperialists that I am in control here :-) – I convert it to the revolutionary and republican metric millimetres – Liberté, égalité, fraternité!</p><p>In case you were not aware of it, the\n<a href=\"https://en.wikipedia.org/wiki/Metric_system\">metric system</a> was introduced during the\n<a href=\"https://en.wikipedia.org/wiki/French_Revolution\">French Revolution</a>, by the\n<a href=\"https://en.wikipedia.org/wiki/French_First_Republic\">French First Republic</a>,\nin 1799.</p><p>I also find that having my geometric data in integers instead of real numbers makes it much easier to read and understand while debugging.</p><p>Furthermore, I translate it all from the midpoint of the selected element's bounding box to the origin.</p><p>Right at the end of the process, I convert it back to real numbers again to fit it into a unit cube – actually a 2-cube from -1 to 1 in all three dimensions – centred around the origin.</p><p>Here is the entire code of the read-only TwglExport external command that achieves all this:</p><pre class=\"code\">\n[<span class=\"teal\">Transaction</span>( <span class=\"teal\">TransactionMode</span>.ReadOnly )]\n<span class=\"blue\">public</span> <span class=\"blue\">class</span> <span class=\"teal\">Command</span> : <span class=\"teal\">IExternalCommand</span>\n{\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n  <span class=\"gray\">///</span><span class=\"green\"> If true, individual curved surface facets are</span>\n  <span class=\"gray\">///</span><span class=\"green\"> retained, otherwise (default) smoothing is </span>\n  <span class=\"gray\">///</span><span class=\"green\"> applied.</span>\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n  <span class=\"blue\">static</span> <span class=\"blue\">public</span> <span class=\"blue\">bool</span> RetainCurvedSurfaceFacets = <span class=\"blue\">false</span>;\n \n  <span class=\"green\">// Unit conversion factors.</span>\n \n  <span class=\"blue\">const</span> <span class=\"blue\">double</span> _mm_per_inch = 25.4;\n  <span class=\"blue\">const</span> <span class=\"blue\">double</span> _inch_per_foot = 12;\n  <span class=\"blue\">const</span> <span class=\"blue\">double</span> _foot_to_mm = _inch_per_foot * _mm_per_inch;\n \n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n  <span class=\"gray\">///</span><span class=\"green\"> Convert the given value from </span>\n  <span class=\"gray\">///</span><span class=\"green\"> imperial feet to metric millimetres.</span>\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n  <span class=\"blue\">static</span> <span class=\"blue\">int</span> FootToMm( <span class=\"blue\">double</span> a )\n  {\n    <span class=\"blue\">double</span> one_half = a &gt; 0 ? 0.5 : -0.5;\n    <span class=\"blue\">return</span> (<span class=\"blue\">int</span>) (a * _foot_to_mm + one_half);\n  }\n \n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;summary&gt;</span>\n  <span class=\"gray\">///</span><span class=\"green\"> Return the maximum absolute coordinate </span>\n  <span class=\"gray\">///</span><span class=\"green\"> of the given point or vector.</span>\n  <span class=\"gray\">///</span><span class=\"green\"> </span><span class=\"gray\">&lt;/summary&gt;</span>\n  <span class=\"blue\">static</span> <span class=\"blue\">double</span> MaxCoord( <span class=\"teal\">XYZ</span> a )\n  {\n    <span class=\"blue\">double</span> d = <span class=\"teal\">Math</span>.Abs( a.X );\n    d = <span class=\"teal\">Math</span>.Max( d, <span class=\"teal\">Math</span>.Abs( a.Y ) );\n    d = <span class=\"teal\">Math</span>.Max( d, <span class=\"teal\">Math</span>.Abs( a.Z ) );\n    <span class=\"blue\">return</span> d;\n  }\n \n  <span class=\"blue\">public</span> <span class=\"teal\">Result</span> Execute(\n    <span class=\"teal\">ExternalCommandData</span> commandData,\n    <span class=\"blue\">ref</span> <span class=\"blue\">string</span> message,\n    <span class=\"teal\">ElementSet</span> elements )\n  {\n    <span class=\"teal\">UIApplication</span> uiapp = commandData.Application;\n    <span class=\"teal\">UIDocument</span> uidoc = uiapp.ActiveUIDocument;\n    <span class=\"teal\">Document</span> doc = uidoc.Document;\n    <span class=\"teal\">Selection</span> sel = uidoc.Selection;\n    <span class=\"teal\">ICollection</span>&lt;<span class=\"teal\">ElementId</span>&gt; ids = sel.GetElementIds();\n \n    <span class=\"blue\">if</span>( 1 != ids.Count )\n    {\n      message = <span class=\"maroon\">\"Please select an element to export to TWGL.\"</span>;\n      <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Failed;\n    }\n \n    <span class=\"teal\">Element</span> e = <span class=\"blue\">null</span>;\n \n    <span class=\"blue\">foreach</span>( <span class=\"teal\">ElementId</span> id <span class=\"blue\">in</span> ids )\n    {\n      e = doc.GetElement( id );\n    }\n \n    <span class=\"green\">// Determine bounding box in order to translate</span>\n    <span class=\"green\">// all coordinates to bounding box midpoint.</span>\n \n    <span class=\"teal\">BoundingBoxXYZ</span> bb = e.get_BoundingBox( <span class=\"blue\">null</span> );\n    <span class=\"teal\">XYZ</span> pmin = bb.Min;\n    <span class=\"teal\">XYZ</span> pmax = bb.Max;\n    <span class=\"teal\">XYZ</span> vsize = pmax - pmin;\n    <span class=\"teal\">XYZ</span> pmid = pmin + 0.5 * vsize;\n \n    <span class=\"teal\">Options</span> opt = <span class=\"blue\">new</span> <span class=\"teal\">Options</span>();\n    <span class=\"teal\">GeometryElement</span> geo = e.get_Geometry( opt );\n \n    <span class=\"teal\">List</span>&lt;<span class=\"blue\">int</span>&gt; faceIndices = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"blue\">int</span>&gt;();\n    <span class=\"teal\">List</span>&lt;<span class=\"blue\">int</span>&gt; faceVertices = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"blue\">int</span>&gt;();\n    <span class=\"teal\">List</span>&lt;<span class=\"blue\">double</span>&gt; faceNormals = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"blue\">double</span>&gt;();\n    <span class=\"blue\">int</span>[] triangleIndices = <span class=\"blue\">new</span> <span class=\"blue\">int</span>[3];\n    <span class=\"teal\">XYZ</span>[] triangleCorners = <span class=\"blue\">new</span> <span class=\"teal\">XYZ</span>[3];\n \n    <span class=\"blue\">foreach</span>( <span class=\"teal\">GeometryObject</span> obj <span class=\"blue\">in</span> geo )\n    {\n      <span class=\"teal\">Solid</span> solid = obj <span class=\"blue\">as</span> <span class=\"teal\">Solid</span>;\n \n      <span class=\"blue\">if</span>( solid != <span class=\"blue\">null</span> &amp;&amp; 0 &lt; solid.Faces.Size )\n      {\n        faceIndices.Clear();\n        faceVertices.Clear();\n        faceNormals.Clear();\n \n        <span class=\"blue\">foreach</span>( <span class=\"teal\">Face</span> face <span class=\"blue\">in</span> solid.Faces )\n        {\n          <span class=\"teal\">Mesh</span> mesh = face.Triangulate();\n \n          <span class=\"blue\">int</span> nTriangles = mesh.NumTriangles;\n \n          <span class=\"teal\">IList</span>&lt;<span class=\"teal\">XYZ</span>&gt; vertices = mesh.Vertices;\n \n          <span class=\"blue\">int</span> nVertices = vertices.Count;\n \n          <span class=\"teal\">List</span>&lt;<span class=\"blue\">int</span>&gt; vertexCoordsMm = <span class=\"blue\">new</span> <span class=\"teal\">List</span>&lt;<span class=\"blue\">int</span>&gt;( 3 * nVertices );\n \n          <span class=\"green\">// A vertex may be reused several times with </span>\n          <span class=\"green\">// different normals for different faces, so </span>\n          <span class=\"green\">// we cannot precalculate normals per vertex.</span>\n          <span class=\"green\">//List&lt;double&gt; normals = new List&lt;double&gt;( 3 * nVertices );</span>\n \n          <span class=\"blue\">foreach</span>( <span class=\"teal\">XYZ</span> v <span class=\"blue\">in</span> vertices )\n          {\n            <span class=\"green\">// Translate the entire element geometry</span>\n            <span class=\"green\">// to the bounding box midpoint and scale </span>\n            <span class=\"green\">// to metric millimetres.</span>\n \n            <span class=\"teal\">XYZ</span> p = v - pmid;\n \n            vertexCoordsMm.Add( FootToMm( p.X ) );\n            vertexCoordsMm.Add( FootToMm( p.Y ) );\n            vertexCoordsMm.Add( FootToMm( p.Z ) );\n          }\n \n          <span class=\"blue\">for</span>( <span class=\"blue\">int</span> i = 0; i &lt; nTriangles; ++i )\n          {\n            <span class=\"teal\">MeshTriangle</span> triangle = mesh.get_Triangle( i );\n \n            <span class=\"blue\">for</span>( <span class=\"blue\">int</span> j = 0; j &lt; 3; ++j )\n            {\n              <span class=\"blue\">int</span> k = (<span class=\"blue\">int</span>) triangle.get_Index( j );\n              triangleIndices[j] = k;\n              triangleCorners[j] = vertices[k];\n            }\n \n            <span class=\"green\">// Calculate constant triangle facet normal.</span>\n \n            <span class=\"teal\">XYZ</span> v = triangleCorners[1]\n              - triangleCorners[0];\n            <span class=\"teal\">XYZ</span> w = triangleCorners[2]\n              - triangleCorners[0];\n            <span class=\"teal\">XYZ</span> triangleNormal = v\n              .CrossProduct( w )\n              .Normalize();\n \n            <span class=\"blue\">for</span>( <span class=\"blue\">int</span> j = 0; j &lt; 3; ++j )\n            {\n              <span class=\"blue\">int</span> nFaceVertices = faceVertices.Count;\n \n              <span class=\"teal\">Debug</span>.Assert( nFaceVertices.Equals( faceNormals.Count ),\n                <span class=\"maroon\">\"expected equal number of face vertex and normal coordinates\"</span> );\n \n              faceIndices.Add( nFaceVertices / 3 );\n \n              <span class=\"blue\">int</span> i3 = triangleIndices[j] * 3;\n \n              <span class=\"green\">// Rotate the X, Y and Z directions, </span>\n              <span class=\"green\">// since the Z direction points upward </span>\n              <span class=\"green\">// in Revit as opposed to sideways or</span>\n              <span class=\"green\">// outwards or forwards in WebGL.</span>\n \n              faceVertices.Add( vertexCoordsMm[i3 + 1] );\n              faceVertices.Add( vertexCoordsMm[i3 + 2] );\n              faceVertices.Add( vertexCoordsMm[i3] );\n \n              <span class=\"blue\">if</span>( RetainCurvedSurfaceFacets )\n              {\n                faceNormals.Add( triangleNormal.Y );\n                faceNormals.Add( triangleNormal.Z );\n                faceNormals.Add( triangleNormal.X );\n              }\n              <span class=\"blue\">else</span>\n              {\n                <span class=\"teal\">UV</span> uv = face.Project(\n                  triangleCorners[j] ).UVPoint;\n \n                <span class=\"teal\">XYZ</span> normal = face.ComputeNormal( uv );\n \n                faceNormals.Add( normal.Y );\n                faceNormals.Add( normal.Z );\n                faceNormals.Add( normal.X );\n              }\n            }\n          }\n        }\n \n        <span class=\"green\">// Scale the vertices to a [-1,1] cube </span>\n        <span class=\"green\">// centered around the origin. Translation</span>\n        <span class=\"green\">// to the origin was already performed above.</span>\n \n        <span class=\"blue\">double</span> scale = 2.0 / FootToMm( MaxCoord( vsize ) );\n \n        <span class=\"teal\">Debug</span>.Print( <span class=\"maroon\">\"position: [{0}],\"</span>,\n          <span class=\"blue\">string</span>.Join( <span class=\"maroon\">\", \"</span>,\n            faceVertices.ConvertAll&lt;<span class=\"blue\">string</span>&gt;(\n              i =&gt; ( i * scale ).ToString( <span class=\"maroon\">\"0.##\"</span> ) ) ) );\n \n        <span class=\"teal\">Debug</span>.Print( <span class=\"maroon\">\"normal: [{0}],\"</span>,\n          <span class=\"blue\">string</span>.Join( <span class=\"maroon\">\", \"</span>,\n            faceNormals.ConvertAll&lt;<span class=\"blue\">string</span>&gt;(\n              f =&gt; f.ToString( <span class=\"maroon\">\"0.##\"</span> ) ) ) );\n \n        <span class=\"teal\">Debug</span>.Print( <span class=\"maroon\">\"indices: [{0}],\"</span>,\n          <span class=\"blue\">string</span>.Join( <span class=\"maroon\">\", \"</span>,\n            faceIndices.ConvertAll&lt;<span class=\"blue\">string</span>&gt;(\n              i =&gt; i.ToString() ) ) );\n      }\n    }\n    <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Succeeded;\n  }\n}\n</pre><p>It also includes a smoothing option controlled by the setting of the Boolean RetainCurvedSurfaceFacets variable that defines whether curved faces display each of their individual facets or appear as one single nice and smooth organic surface.</p><p>I tested this on the model recently submitted by Alexander to test the\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2015/04/curved-wall-elevation-profile-and-creator-class-update.html\">\ncurved wall elevation profile and creator class enhancements</a>:</p><center>\n<img alt=\"TwglExport sample model\" src=\"img/twgl_export_model.png\" width=\"578\"/>\n</center><p>From it, I picked three walls of the four for testing, one of them in two flavours:</p><ol>\n<li>Simple wall with no openings</li>\n<li>Straight wall with a funny cloud-shaped window</li>\n<li>Curved wall with a rounded window, faceted</li>\n<li>Curved wall with a rounded window, smooth</li>\n</ol><p>Here is the result, enabling you to choose between these four options – click 'Render' to begin and when you switch your wall selection:</p><center>\n<iframe src=\"http://thebuildingcoder.typepad.com/webgl/twgl01/index.html\" style=\"width: 450px; height: 450px;\"></iframe>\n</center><p>Please be my guest and feel perfectly free to explore how this <a href=\"http://twgljs.org\">TWGL</a>-based WebGL viewer is implemented by viewing the HTML and JavaScript source code of this page.</p><p>The entire TwglExport source code, Visual Studio solution and add-in manifest are provided in the\n\n<a href=\"https://github.com/jeremytammik/TwglExport\">TwglExport GitHub repository</a>,\n\nand the version presented here is\n\n<a href=\"https://github.com/jeremytammik/TwglExport/releases/tag/2015.0.0.1\">release 2015.0.0.1</a>.</p><p>I'll dive into more detail and make this functionality available as a node.js web server anon, in happy cooperation with the\n\n<a href=\"http://the3dwebcoder.typepad.com/blog/2015/04/webgl-101-getting-started.html\">\ngetting started series</a> that\n\nI am putting together on\n\n<a href=\"http://the3dwebcoder.typepad.com\">The 3D Web Coder</a>.</p><p>Stay tuned...</p>"
  }
]