[
  {
    "original_filename": "1099_failure_api",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<head>\n<link href=\"bc.css\" rel=\"stylesheet\" type=\"text/css\"/>\n<meta content=\"text/html; charset=utf-8\" http-equiv=\"Content-Type\"/>\n</head>"
  },
  {
    "original_filename": "1099_failure_api",
    "header_text": "Skip Invalid Element Generation Using Failure API",
    "local_header_href": "#skip-invalid-element-generation-using-failure-api",
    "chunk_text": "<h3>Skip Invalid Element Generation Using Failure API</h3><p>We already took a couple of looks at the Failure API in the past, e.g.:</p><ul>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2010/04/failure-api.html\">Failure API</a></li>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2010/11/failure-api-take-two.html\">Failure API Take Two</a></li>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2012/04/failure-rollback.html\">Failure Rollback</a></li>\n</ul><p>Here is a slightly more convoluted situation that motivates revisiting the topic from a new angle, raised and solved by Stephen Faust of\n\n<a href=\"http://www.revolutiondesign.biz/\">\nRevolution Design, Inc.</a> together\n\nwith Arnošt Löbel of the Revit API development team, who also invested significant time and research in the issue:</p><p><strong>Question:</strong> I am generating some floor objects from rooms in a project.\nIn certain cases the sketch is not valid because of some oddities in the rooms.\nThis is OK if I can just delete or not create the floors and hopefully not show a dialogue to the user.\nWithout any failure handling it gives the user the 'can't make extrusion' error, but you can hit delete elements and be on your way.\nI thought I could do this with a failures preprocessor, but it doesn't seem to be working the way I hoped.\nHere is the functional part of my class that inherits IFailuresPreProcessor:</p><pre class=\"code\">\n  <span class=\"teal\">IList</span>&lt;<span class=\"teal\">FailureMessageAccessor</span>&gt; fmas\n    = failuresAccessor.GetFailureMessages();\n \n  <span class=\"blue\">if</span>( fmas.Count == 0 )\n  { <span class=\"blue\">return</span> <span class=\"teal\">FailureProcessingResult</span>.Continue; }\n \n  <span class=\"blue\">foreach</span>( <span class=\"teal\">FailureMessageAccessor</span> fma <span class=\"blue\">in</span> fmas )\n  { failuresAccessor.ResolveFailure( fma ); }\n \n  <span class=\"blue\">return</span> <span class=\"teal\">FailureProcessingResult</span>.ProceedWithCommit;\n</pre><p>When I use this with the transaction, it still gives me an error dialog, only this time it shows (Deleted) next to all of the elements.\nThe only thing I can do is cancel, which is actually worse, because then you don't get any of the floors.\nWhat am I doing wrong here?\nWhat do I need to do to just handle the dialog and tell it to remove those floors that aren't valid?</p><p><strong>Answer:</strong> What you probably need to do is to set the resolution on each failure.</p><p>There are also some checks required to avoid attempting to resolve a failure that may not be resolved (anymore).</p><p>I suggest the following starting point for an approach, plus further experimenting with it:</p><ul>\n<li>Test if invalid elements (floors) can actually be deleted by calling FailuresAccessors.IsElementsDeletionPermitted.</li>\n<li>Possibly, for each failure, it may be tested if its resolution by deleting the invalid elements is permitted. The method to do so is FailuresAccessors.IsFailureResolutionPermitted taking a FailureResolutionType.DeleteElements argument.</li>\n<li>Assuming you can, failures should be resolved by FailuresAccessors.ResolveFailures.</li>\n<li>I am also guessing that before returning ProceedWitCommit, FailuresAccessors.IsTransactionBeingCommitted is tested.</li>\n<li>Return ProceedWitCommit.</li>\n</ul><p><strong>Response:</strong> Thanks for the tips.</p><p>Here is what I ended up doing that seems to be working:</p><pre class=\"code\">\n  <span class=\"blue\">if</span>( failuresAccessor.GetTransactionName()\n    == <span class=\"maroon\">\"Create Temporary Roofs\"</span> )\n  {\n    <span class=\"teal\">IList</span>&lt;<span class=\"teal\">FailureMessageAccessor</span>&gt; fmas\n      = failuresAccessor.GetFailureMessages();\n \n    <span class=\"blue\">if</span>( fmas.Count == 0 )\n    { <span class=\"blue\">return</span> <span class=\"teal\">FailureProcessingResult</span>.Continue; }\n \n    <span class=\"blue\">foreach</span>( <span class=\"teal\">FailureMessageAccessor</span> fma <span class=\"blue\">in</span> fmas )\n    {\n      <span class=\"teal\">FailureSeverity</span> s = fma.GetSeverity();\n      <span class=\"blue\">if</span>( s == <span class=\"teal\">FailureSeverity</span>.Warning )\n      { failuresAccessor.DeleteWarning( fma ); }\n      <span class=\"blue\">else</span> <span class=\"blue\">if</span>( s == <span class=\"teal\">FailureSeverity</span>.Error )\n      {\n        <span class=\"blue\">if</span>( failuresAccessor\n          .IsElementsDeletionPermitted(\n            fma.GetFailingElementIds().ToList() ) )\n        {\n          failuresAccessor.DeleteElements(\n            fma.GetFailingElementIds().ToList() );\n        }\n        failuresAccessor.ResolveFailure( fma );\n      }\n    }\n    <span class=\"blue\">return</span> <span class=\"teal\">FailureProcessingResult</span>.ProceedWithCommit;\n  }\n  <span class=\"blue\">else</span>\n  { <span class=\"blue\">return</span> <span class=\"teal\">FailureProcessingResult</span>.Continue; }\n</pre><p>Basically I separated out warnings from errors.\nThen warnings can be deleted, errors can be processed and delete elements can be directly called for specific elements causing the error.</p>"
  }
]