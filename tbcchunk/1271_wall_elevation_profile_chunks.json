[
  {
    "original_filename": "1271_wall_elevation_profile",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<head>\n<meta content=\"text/html; charset=utf-8\" http-equiv=\"Content-Type\"/>\n<link href=\"bc.css\" rel=\"stylesheet\" type=\"text/css\"/>\n</head>"
  },
  {
    "original_filename": "1271_wall_elevation_profile",
    "header_text": "Getting the Wall Elevation Profile",
    "local_header_href": "#getting-the-wall-elevation-profile",
    "chunk_text": "<h3>Getting the Wall Elevation Profile</h3><p>I am back from the vacation in Italy, which I enjoyed very much, especially another visit to the wonderful coast of Amalfi.</p><p>To quickly share an interesting new result using the Revit API, here is a solution by Katsuaki Takamizawa to retrieve the wall elevation profile.</p><p>It also provides a nice little example of using the\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2015/01/exporterifcutils-curve-loop-sort-and-validate.html\">\nExporterIFCUtils.SortCurveLoops method</a> that\n\nwe just recently documented.</p><p>Says Katsu:</p><p>I created some sample code for finding the wall elevation profile and determining its outer and inner loops.</p><p>The\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2008/11/wall-elevation-profile.html\">\nwall elevation profile</a> topic\n\nwas already discussed way back in 2008, followed by determination of the related polygon areas.</p><p>This sample uses newer methods and the code is much simpler.</p><p>The sample draws model lines based on the existing wall elevation profile.</p><p>The outer edge loop is colored in red.</p><p>It uses the ExporterIFCUtils.SortCurveLoops method to sort the outer and inner loops.</p><p>The outer loop is always counter-clockwise oriented, so we can use the IsCounterclockwise method to detect it.</p><p>The result of running the command on a simple wall with a door and two windows looks like this:</p><center>\n<img alt=\"Wall elevation profile\" src=\"img/GetWallProfile.png\" width=\"347\"/>\n</center><p>Here is the entire implementation of the external command Execute method:</p><pre class=\"code\">\n  <span class=\"teal\">UIApplication</span> uiapp = commandData.Application;\n  <span class=\"teal\">UIDocument</span> uidoc = uiapp.ActiveUIDocument;\n  <span class=\"teal\">Application</span> app = uiapp.Application;\n  <span class=\"teal\">Document</span> doc = uidoc.Document;\n  <span class=\"teal\">View</span> view = doc.ActiveView;\n \n  Autodesk.Revit.Creation.<span class=\"teal\">Application</span> creapp\n    = app.Create;\n \n  Autodesk.Revit.Creation.<span class=\"teal\">Document</span> credoc\n    = doc.Create;\n \n  <span class=\"teal\">Reference</span> r = uidoc.Selection.PickObject(\n    <span class=\"teal\">ObjectType</span>.Element, <span class=\"maroon\">\"Select a wall\"</span> );\n \n  <span class=\"teal\">Element</span> e = uidoc.Document.GetElement( r );\n \n  <span class=\"teal\">Wall</span> wall = e <span class=\"blue\">as</span> <span class=\"teal\">Wall</span>;\n \n  <span class=\"blue\">using</span>( <span class=\"teal\">Transaction</span> tx = <span class=\"blue\">new</span> <span class=\"teal\">Transaction</span>( doc ) )\n  {\n    tx.Start( <span class=\"maroon\">\"Wall Profile\"</span> );\n \n    <span class=\"green\">// Get the external wall face for the profile</span>\n \n    <span class=\"teal\">IList</span>&lt;<span class=\"teal\">Reference</span>&gt; sideFaces\n      = <span class=\"teal\">HostObjectUtils</span>.GetSideFaces( wall,\n        <span class=\"teal\">ShellLayerType</span>.Exterior );\n \n    <span class=\"teal\">Element</span> e2 = doc.GetElement( sideFaces[0] );\n \n    <span class=\"teal\">Face</span> face = e2.GetGeometryObjectFromReference(\n      sideFaces[0] ) <span class=\"blue\">as</span> <span class=\"teal\">Face</span>;\n \n    <span class=\"green\">// The normal of the wall external face.</span>\n \n    <span class=\"teal\">XYZ</span> normal = face.ComputeNormal( <span class=\"blue\">new</span> <span class=\"teal\">UV</span>( 0, 0 ) );\n \n    <span class=\"green\">// Offset curve copies for visibility.</span>\n \n    <span class=\"teal\">Transform</span> offset = <span class=\"teal\">Transform</span>.CreateTranslation(\n      5 * normal );\n \n    <span class=\"green\">// If the curve loop direction is counter-</span>\n    <span class=\"green\">// clockwise, change its color to RED.</span>\n \n    <span class=\"teal\">Color</span> colorRed = <span class=\"blue\">new</span> <span class=\"teal\">Color</span>( 255, 0, 0 );\n \n    <span class=\"green\">// Get edge loops as curve loops.</span>\n \n    <span class=\"teal\">IList</span>&lt;<span class=\"teal\">CurveLoop</span>&gt; curveLoops\n      = face.GetEdgesAsCurveLoops();\n \n    <span class=\"green\">// ExporterIFCUtils class can also be used for </span>\n    <span class=\"green\">// non-IFC purposes. The SortCurveLoops method </span>\n    <span class=\"green\">// sorts curve loops (edge loops) so that the </span>\n    <span class=\"green\">// outer loops come first.</span>\n \n    <span class=\"teal\">IList</span>&lt;<span class=\"teal\">IList</span>&lt;<span class=\"teal\">CurveLoop</span>&gt;&gt; curveLoopLoop\n      = <span class=\"teal\">ExporterIFCUtils</span>.SortCurveLoops(\n        curveLoops );\n \n    <span class=\"blue\">foreach</span>( <span class=\"teal\">IList</span>&lt;<span class=\"teal\">CurveLoop</span>&gt; curveLoops2\n      <span class=\"blue\">in</span> curveLoopLoop )\n    {\n      <span class=\"blue\">foreach</span>( <span class=\"teal\">CurveLoop</span> curveLoop2 <span class=\"blue\">in</span> curveLoops2 )\n      {\n        <span class=\"green\">// Check if curve loop is counter-clockwise.</span>\n \n        <span class=\"blue\">bool</span> isCCW = curveLoop2.IsCounterclockwise(\n          normal );\n \n        <span class=\"teal\">CurveArray</span> curves = creapp.NewCurveArray();\n \n        <span class=\"blue\">foreach</span>( <span class=\"teal\">Curve</span> curve <span class=\"blue\">in</span> curveLoop2 )\n        {\n          curves.Append( curve.CreateTransformed( offset ) );\n        }\n \n        <span class=\"green\">// Create model lines for an curve loop.</span>\n \n        <span class=\"teal\">Plane</span> plane = creapp.NewPlane( curves );\n \n        <span class=\"teal\">SketchPlane</span> sketchPlane\n          = <span class=\"teal\">SketchPlane</span>.Create( doc, plane );\n \n        <span class=\"teal\">ModelCurveArray</span> curveElements\n          = credoc.NewModelCurveArray( curves,\n            sketchPlane );\n \n        <span class=\"blue\">if</span>( isCCW )\n        {\n          <span class=\"blue\">foreach</span>( <span class=\"teal\">ModelCurve</span> mcurve <span class=\"blue\">in</span> curveElements )\n          {\n            <span class=\"teal\">OverrideGraphicSettings</span> overrides\n              = view.GetElementOverrides(\n                mcurve.Id );\n \n            overrides.SetProjectionLineColor(\n              colorRed );\n \n            view.SetElementOverrides(\n              mcurve.Id, overrides );\n          }\n        }\n      }\n    }\n    tx.Commit();\n  }\n  <span class=\"blue\">return</span> <span class=\"teal\">Result</span>.Succeeded;\n</pre><p>I initially tried to move the model lines using the ElementTransformUtils.MoveElement method to offset them for better visibility.</p><p>That did not work.</p><p>It seems that these model lines are attached to the wall face, and the MoveElement method cannot move them away from the wall.</p><p>So I modified the underlying geometry curves first, before creating model lines from them.</p><p>Here is\n\n<a href=\"zip/GetWallProfileJt.zip\">GetWallProfile.zip</a> containing\n\nthe entire Visual Studio solution, external command source code and add-in manifest.</p><p>Many thanks to Katsu-san for implementing and sharing this!</p>"
  }
]