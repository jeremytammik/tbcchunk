[
  {
    "original_filename": "2012_dll_paradise",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n<link rel=\"stylesheet\" type=\"text/css\" href=\"bc.css\">\n<script src=\"https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js\" type=\"text/javascript\"></script>\n\n<style>\ntable, th, td {\n  border: 1px solid black;\n  border-collapse: collapse;\n}\nth, td {\n  padding-left: 1em;\n  padding-right: 1em;\n  text-align:right;\n}\n</style>\n\n</head>\n\n<!---\n\n- aps intro:\n  We have a new overview video answering the question “What is Autodesk Platform Services?” This gives a quick explanation of what APS is, how it fits into the Autodesk Platform, and shows some of the most popular applications of APS in use with our customers and partners. You can find the video on YouTube here: https://youtu.be/RrAel5Mx7-0?si=lk3C2qLjUHX8PALi\n\n- another open source multimodal model\n  Fuyu-8B: A Multimodal Architecture for AI Agents\n  https://www.adept.ai/blog/fuyu-8b\n  Can be run offline on a laptop CPU\n\n\ntwitter:\n\n@AutodeskAPS overview, and DLL paradise for @AutodeskRevit #RevitAPI add-ins via named pipe IPC, interprocess communication strategies and best practices communicating between .NET 4.8 and .NET 7 #BIM @DynamoBIM @AutodeskAPS https://autode.sk/dllparadise\n\nAPS overview\n&ndash; DLL paradise for Revit add-ins via named pipe IPC\n&ndash; Interprocess communication strategies and best practices\n&ndash; Using named pipes to communicate between different .NET versions\n&ndash; Interactions between .NET 4.8 and .NET 7\n&ndash; Server / client transmission protocol\n&ndash; Connection management\n&ndash; Two-way communication...\n\nlinkedin:\n\nAutodesk Platform Services APS overview, and DLL paradise for #Revit #API add-ins via named pipe IPC, interprocess communication strategies and best practices communicating between .NET 4.8 and .NET 7\n\nhttps://autode.sk/dllparadise\n\n- DLL paradise for Revit add-ins via named pipe IPC\n- Interprocess communication strategies and best practices\n- Using named pipes to communicate between different .NET versions\n- Interactions between .NET 4.8 and .NET 7\n- Server / client transmission protocol\n- Connection management\n- Two-way communication...\n\n#BIM #DynamoBIM #AutodeskAPS #Revit #API #IFC #SDK #Autodesk #AEC #adsk\n\nthe [Revit API discussion forum](http://forums.autodesk.com/t5/revit-api-forum/bd-p/160) thread\n\n<center>\n<img src=\"img/\" alt=\"\" title=\"\" width=\"600\"/>\n<p style=\"font-size: 80%; font-style:italic\"></p>\n</center>\n\n-->"
  },
  {
    "original_filename": "2012_dll_paradise",
    "header_text": "DLL Paradise and a Fall",
    "local_header_href": "#dll-paradise-and-a-fall",
    "chunk_text": "### DLL Paradise and a Fall\n\nOne huge article explaining how you can address DLL hell today, and a bunch of little notes to decorate it:\n\n- [What are the Autodesk Platform Services?](#1)\n- [DLL paradise for Revit add-ins via named pipe IPC](#2)\n- [Interprocess communication: strategies and best practices](#3)\n    - [Table of contents](#3.1)\n    - [Using named pipes to communicate between different .NET versions](#3.2)\n    - [What are named pipes?](#3.3)\n    - [Interactions between applications in .NET 4.8 and .NET 7](#3.4)\n    - [Server creation](#3.5)\n    - [Client creation](#3.6)\n    - [Transmission protocol](#3.7)\n    - [Connection management](#3.8)\n    - [Two-way communication](#3.9)\n    - [Implementation for Revit plug-in](#3.10)\n    - [Installing .NET runtime during plugin installation](#3.11)\n    - [Conclusion](#3.12)\n- [Fuyu-8B multimodal architecture for AI agents](#4)\n- [How open source wins](#6)\n- [HTTP/3](#5)\n\nBy the way, I am writing this from my hospital bed.\nI had a 6-metre fall from a ladder onto earth last weekend and broke my right hipbone, both front and back, plus some other less important bits and pieces.\nNow I am waiting for an operastion to get it all screwed back together again and hope that will provide a stable basis for a speedy recovery.\n\n<center>\n<img src=\"img/2023-10-21_jeremy_in_hospital.jpg\" alt=\"Jeremy in hospital\" title=\"Jeremy in hospital\" width=\"600\"/>\n</center>"
  },
  {
    "original_filename": "2012_dll_paradise",
    "header_text": "What are the Autodesk Platform Services?",
    "local_header_href": "#1",
    "chunk_text": "####<a name=\"1\"></a> What are the Autodesk Platform Services?\n\nWe have a new two-and-a-half-minute overview YouTube video answering\nthe question [What is Autodesk Platform Services?](https://youtu.be/RrAel5Mx7-0?feature=shared) to\ngive a quick explanation of what APS is, how it fits into the Autodesk Platform, and shows some of the most popular applications of APS in use with our customers and partners."
  },
  {
    "original_filename": "2012_dll_paradise",
    "header_text": "DLL Paradise for Revit Add-ins via Named Pipe IPC",
    "local_header_href": "#2",
    "chunk_text": "####<a name=\"2\"></a> DLL Paradise for Revit Add-ins via Named Pipe IPC\n\nWindows applications integrating external components occasionally\nencounter [DLL hell](https://duckduckgo.com/?q=dll+hell) due to conflicting dependencies.\nThe Building Coder discussed\nsome [specific and even some pretty generic solutions](https://www.google.com/search?q=dll+hell&as_sitesearch=thebuildingcoder.typepad.com).\nOnce again, Roman [Nice3point](https://github.com/Nice3point) Karpovich\nof [atomatiq](https://www.linkedin.com/company/atomatiq/), aka Роман Карпович,\nprincipal maintainer of RevitLookup, comes to the rescue, sharing a new article about Revit and add-in inter-processor communication:\n\nDive into the world of inter-process communication and discover how to establish seamless communication for running a Revit plugin on .NET 7.\n\nLearn about the essence of Named Pipes:\n\n- Inter-process communication across .NET 4.8 and .NET 7\n- Server setup and client creation\n- Efficient data transmission protocols\n- Connection management strategies\n- Two-way data transfer capabilities\n- Implementation of a Revit plugin\n\nWant to know how it works? Check out the full GitHub article\non [Interprocess Communication: Strategies and Best Practices](https://github.com/atomatiq/InterprocessCommunication):\n\n- [LinkedIn post](https://www.linkedin.com/feed/update/urn:li:activity:7120385512464388096/)\n- [ENU version](https://github.com/atomatiq/InterprocessCommunication)\n- [CIS version](https://github.com/Nice3point/InterprocessCommunication)\n\nPlease be aware that the Revit development team is looking at\npossible [options for moving the Revit API forward from .NET 4.8](https://thebuildingcoder.typepad.com/blog/2023/08/15-years-polygon-areas-and-net-core.html#3) as\nwe speak.\nWith the approach described here, you can move ahead today and address other DLL conflicts as well."
  },
  {
    "original_filename": "2012_dll_paradise",
    "header_text": "Interprocess Communication: Strategies and Best Practices",
    "local_header_href": "#3",
    "chunk_text": "####<a name=\"3\"></a> Interprocess Communication: Strategies and Best Practices\n\nWe all know how challenging it is to maintain large programs and keep up with progress.\nDevelopers of plugins for Revit understand this better than anyone else.\nWe have to write our programs in .NET Framework 4.8 and forgo modern and fast libraries.\nUltimately, this affects users who are forced to use outdated software.\n\nIn such scenarios, splitting the application into multiple processes using Named Pipes appears to be an excellent solution due to its performance and reliability.\nIn this article, we discuss how to create and use Named Pipes to communicate between the Revit application running on .NET 4.8 and its plugin running on .NET 7.\n\n<!--\n\n####<a name=\"3.1\"></a> Table of Contents\n\n* [Introduction to Using Named Pipes for Communication Between Applications on Different .NET Versions](#introduction-to-using-named-pipes-for-communication-between-applications-on-different-net-versions)\n* [What are Named Pipes?](#what-are-named-pipes)\n* [Interactions between applications in .NET 4.8 and .NET 7](#interactions-between-applications-in-net-48-and-net-7)\n    * [Server Creation](#server-creation)\n    * [Client Creation](#client-creation)\n    * [Transmission Protocol](#transmission-protocol)\n    * [Connection Management](#connection-management)\n    * [Two-Way Communication](#two-way-communication)\n    * [Implementation for Revit plug-in](#implementation-for-revit-plug-in)\n* [Installing .NET Runtime during plugin installation](#installing-net-runtime-during-plugin-installation)\n* [Conclusion](#conclusion)\n\n-->\n\n####<a name=\"3.2\"></a> Using Named Pipes to Communicate Between Different .NET Versions\n\nIn the world of application development, there is often a need to ensure data exchange between different applications, especially in cases where they operate on different versions of .NET or different languages.\nSplitting a single application into multiple processes must be justified.\nWhat is simpler, calling a function directly, or exchanging messages? Obviously, the former.\n\nSo what are the benefits of doing this?\n\n- Resolving Dependency Conflicts\n\nWith each passing year, the size of Revit plugins is growing exponentially, and dependencies are also increasing at a geometric rate.\nPlugins might use incompatible versions of a single library, leading to program crashes. Process isolation solves this problem.\n\n- Performance\n\nHere are a few performance measurements for sorting and mathematical calculations on different .NET versions:\n\n- BenchmarkDotNet v0.13.9, Windows 11 (10.0.22621.1702/22H2/2022Update/SunValley2)\n- AMD Ryzen 5 2600X, 1 CPU, 12 logical and 6 physical cores\n- .NET 7.0.9 (7.0.923.32018), X64 RyuJIT AVX2\n- .NET Framework 4.8.1 (4.8.9139.0), X64 RyuJIT VectorSize=256\n\n<center>\n<table>\n<tr><th> Method</th><th>.NET</th><th>Mean ns</th><th>Error ns</th><th>SthDev ns</th><th>Bytes</th></tr>\n<tr><td> ListSort   </td><td>7.0</td><td>1,113,161</td><td>20,385</td><td>21,811</td><td> 804753</td></tr>\n<tr><td> ListOrderBy</td><td>7.0</td><td>1,064,851</td><td>12,401</td><td>11,600</td><td> 807054</td></tr>\n<tr><td> MinValue   </td><td>7.0</td><td>      979</td><td>     7</td><td>     6</td><td>       </td></tr>\n<tr><td> MaxValue   </td><td>7.0</td><td>      970</td><td>     4</td><td>     3</td><td>       </td></tr>\n<tr><td> ListSort   </td><td>4.8</td><td>2,144,723</td><td>40,359</td><td>37,752</td><td>1101646</td></tr>\n<tr><td> ListOrderBy</td><td>4.8</td><td>2,192,414</td><td>25,938</td><td>24,263</td><td>1105311</td></tr>\n<tr><td> MinValue   </td><td>4.8</td><td>   58,019</td><td>   460</td><td>   430</td><td>     40</td></tr>\n<tr><td> MaxValue   </td><td>4.8</td><td>   66,053</td><td>   610</td><td>   541</td><td>     41</td></tr>\n</table>\n</center>\n\nThe 68-fold difference in speed when finding the minimum value, and the complete absence of memory allocation, is impressive.\n\nHow then to write a program in the latest .NET version that will interact with an incompatible .NET framework?\nCreate two applications, Server and Client, without adding dependencies between each other and configure the interaction between them using a configured protocol.\n\nHere are some possible ways of interaction between two applications:\n\n-  Using WCF (Windows Communication Foundation)\n-  Using sockets (TCP or UDP)\n-  Using Named Pipes\n-  Using operating system signals (e.g., Windows signals):\n\nAn example of the latter from Autodesk's code, the interaction of the Project Browser plugin with the Revit backend via messages.\n\n<pre class=\"prettyprint\">\npublic class DataTransmitter : IEventObserver\n{\n  private void PostMessageToMainWindow(int iCmd) =&gt;\n    this.HandleOnMainThread((Action) (() =&gt;\n      Win32Api.PostMessage(Application.UIApp.getUIApplication().MainWindowHandle, 273U, new IntPtr(iCmd), IntPtr.Zero)));\n\n  public void HandleShortCut(string key, bool ctrlPressed)\n  {\n    string lower = key.ToLower();\n    switch (PrivateImplementationDetails.ComputeStringHash(lower))\n    {\n    case 388133425:\n      if (!(lower == \"f2\")) break;\n      this.PostMessageToMainWindow(DataTransmitter.ID_RENAME);\n      break;\n    case 1740784714:\n      if (!(lower == \"delete\")) break;\n      this.PostMessageToMainWindow(DataTransmitter.ID_DELETE);\n      break;\n    case 3447633555:\n      if (!(lower == \"contextmenu\")) break;\n      this.PostMessageToMainWindow(DataTransmitter.ID_PROJECTBROWSER_CONTEXT_MENU_POP);\n      break;\n    case 3859557458:\n      if (!(lower == \"c\") || !ctrlPressed) break;\n      this.PostMessageToMainWindow(DataTransmitter.ID_COPY);\n      break;\n    case 4077666505:\n      if (!(lower == \"v\") || !ctrlPressed) break;\n      this.PostMessageToMainWindow(DataTransmitter.ID_PASTE);\n      break;\n    case 4228665076:\n      if (!(lower == \"y\") || !ctrlPressed) break;\n      this.PostMessageToMainWindow(DataTransmitter.ID_REDO);\n      break;\n    case 4278997933:\n      if (!(lower == \"z\") || !ctrlPressed) break;\n      this.PostMessageToMainWindow(DataTransmitter.ID_UNDO);\n      break;\n    }\n  }\n}\n</pre>\n\nEach option has its own pros and cons. In my opinion, the most convenient for local machine interaction is Named Pipes. Let's delve into it.\n\n####<a name=\"3.3\"></a> What are Named Pipes?\n\nNamed Pipes are a mechanism for Inter-Process Communication (IPC) that enables processes to exchange data through named channels.\nThey provide a one-way or duplex connection between processes.\nApart from high performance, Named Pipes also offer various security levels, making them an attractive solution for many inter-process communication scenarios.\n\n####<a name=\"3.4\"></a> Interactions between applications in .NET 4.8 and .NET 7\n\nLet's consider two applications, one containing the business logic (server), and the other one for the user interface (client).\nNamedPipe is used to facilitate communication between these two processes.\n\nThe operation principle of NamedPipe involves the following steps:\n\n-  **Creation and configuration of NamedPipe**: The server creates and configures the NamedPipe with a specific name that will be accessible to the client.\n   The client needs to know this name to connect to the pipe.\n-  **Waiting for connection**: The server starts to wait for the client to connect to the pipe.\n   This is a blocking operation, and the server remains in a pending state until the client connects.\n-  **Connecting to NamedPipe**: The client initiates a connection to the NamedPipe, specifying the name of the pipe to which it wants to connect.\n-  **Data exchange**: After a successful connection, the client and server can exchange data in the form of byte streams.\n   The client sends requests for executing the business logic, and the server processes these requests and sends back the results.\n-  **Session termination**: After the data exchange is complete, the client and server can close the connection with NamedPipe.\n\n#####<a name=\"3.5\"></a> Server Creation\n\nOn the .NET platform, the server side is represented by the `NamedPipeServerStream` class.\nThe class implementation provides both asynchronous and synchronous methods for working with NamedPipe.\nTo avoid blocking the main thread, we will utilize asynchronous methods.\n\nHere's an example code snippet for creating a NamedPipeServer:\n\n<pre class=\"prettyprint\">\npublic static class NamedPipeUtil\n{\n  /// &lt;summary&gt;\n  /// Create a server for the current user only\n  /// &lt;/summary&gt;\n  public static NamedPipeServerStream CreateServer(PipeDirection? pipeDirection = null)\n  {\n    const PipeOptions pipeOptions = PipeOptions.Asynchronous | PipeOptions.WriteThrough;\n    return new NamedPipeServerStream(\n      GetPipeName(),\n      pipeDirection ?? PipeDirection.InOut,\n      NamedPipeServerStream.MaxAllowedServerInstances,\n      PipeTransmissionMode.Byte,\n      pipeOptions);\n  }\n\n  private static string GetPipeName()\n  {\n    var serverDirectory = AppDomain.CurrentDomain.BaseDirectory.TrimEnd(Path.DirectorySeparatorChar);\n    var pipeNameInput = $\"{Environment.UserName}.{serverDirectory}\";\n    var hash = new SHA256Managed().ComputeHash(Encoding.UTF8.GetBytes(pipeNameInput));\n\n    return Convert.ToBase64String(hash)\n      .Replace(\"/\", \"_\")\n      .Replace(\"=\", string.Empty);\n  }\n}\n</pre>\n\nThe server name should not contain special characters to avoid exceptions.\nTo generate the pipe name, we will use a hash created from the username and the current folder, which is unique enough for the client to use this server upon connection.\nYou can modify this behavior or use any name within the scope of your project, especially if the client and server are in different directories.\n\nThis approach is used in the [Roslyn .NET compiler](https://github.com/dotnet/roslyn). For those who want to delve deeper into this topic, I recommend studying the source code of the project\n\nThe `PipeDirection` indicates the direction of the channel.\n`PipeDirection.In` implies that the server will only receive messages, while `PipeDirection.InOut` can both receive and send messages.\n\n#####<a name=\"3.6\"></a> Client Creation\n\nTo create the client, we will use the `NamedPipeClientStream` class.\nThe code is almost similar to the server and may vary slightly depending on the .NET versions.\nFor instance, in .NET framework 4.8, the `PipeOptions.CurrentUserOnly` value does not exist, but it appears in .NET 7.\n\n<pre class=\"prettyprint\">\n/// &lt;summary&gt;\n/// Create a client for the current user only\n/// &lt;/summary&gt;\npublic static NamedPipeClientStream CreateClient(PipeDirection? pipeDirection = null)\n{\n  const PipeOptions pipeOptions = PipeOptions.Asynchronous | PipeOptions.WriteThrough | PipeOptions.CurrentUserOnly;\n  return new NamedPipeClientStream(\".\",\n    GetPipeName(),\n    pipeDirection ?? PipeDirection.Out,\n    pipeOptions);\n}\n\nprivate static string GetPipeName()\n{\n  var clientDirectory = AppDomain.CurrentDomain.BaseDirectory.TrimEnd(Path.DirectorySeparatorChar);\n  var pipeNameInput = $\"{System.Environment.UserName}.{clientDirectory}\";\n  var bytes = SHA256.HashData(Encoding.UTF8.GetBytes(pipeNameInput));\n\n  return Convert.ToBase64String(bytes)\n    .Replace(\"/\", \"_\")\n    .Replace(\"=\", string.Empty);\n}\n</pre>\n\n#####<a name=\"3.7\"></a> Transmission Protocol\n\nNamedPipe represents a stream, which allows us to write any sequence of bytes to the stream.\nHowever, working with bytes directly might not be very convenient, especially when dealing with complex data or structures.\nTo simplify the interaction with data streams and structure information in a convenient format, transmission protocols are used.\n\nTransmission protocols define the format and order of data transmission between applications.\nThey ensure the structuring of information to facilitate understanding and proper interpretation of data between the sender and the receiver.\n\nIn cases where we need to send a \"Request to execute a specific command on the server\" or a \"Request to update application settings,\" the server must understand how to process it from the client.\nTherefore, to facilitate request handling and data exchange management, we will create an `RequestType` Enum.\n\n<pre class=\"prettyprint\">\npublic enum RequestType\n{\n    PrintMessage,\n    UpdateModel\n}\n</pre>\n\nThe request itself will be represented by a class that will contain all the information about the transmitted data.\n\n<pre class=\"prettyprint\">\npublic abstract class Request\n{\n  public abstract RequestType Type { get; }\n\n  protected abstract void AddRequestBody(BinaryWriter writer);\n\n  /// &lt;summary&gt;\n  ///   Write a Request to the given stream.\n  /// &lt;/summary&gt;\n  public async Task WriteAsync(Stream outStream)\n  {\n    using var memoryStream = new MemoryStream();\n    using var writer = new BinaryWriter(memoryStream, Encoding.Unicode);\n\n    writer.Write((int) Type);\n    AddRequestBody(writer);\n    writer.Flush();\n\n    // Write the length of the request\n    var length = checked((int) memoryStream.Length);\n\n    // There is no way to know the number of bytes written to\n    // the pipe stream. We just have to assume all of them are written\n    await outStream.WriteAsync(BitConverter.GetBytes(length), 0, 4);\n    memoryStream.Position = 0;\n    await memoryStream.CopyToAsync(outStream, length);\n  }\n\n  /// &lt;summary&gt;\n  /// Write a string to the Writer where the string is encoded\n  /// as a length prefix (signed 32-bit integer) follows by\n  /// a sequence of characters.\n  /// &lt;/summary&gt;\n  protected static void WriteLengthPrefixedString(BinaryWriter writer, string value)\n  {\n    writer.Write(value.Length);\n    writer.Write(value.ToCharArray());\n  }\n}\n</pre>\n\nThe class contains the basic code for writing data to the stream. `AddRequestBody()` is used by derived classes to write their own structured data.\n\nExamples of derived classes:\n\n<pre class=\"prettyprint\">\n/// &lt;summary&gt;\n/// Represents a Request from the client. A Request is as follows.\n///\n///  Field Name         Type            Size (bytes)\n/// --------------------------------------------------\n///  RequestType        Integer         4\n///  Message            String          Variable\n///\n/// Strings are encoded via a character count prefix as a\n/// 32-bit integer, followed by an array of characters.\n///\n/// &lt;/summary&gt;\npublic class PrintMessageRequest : Request\n{\n  public string Message { get; }\n\n  public override RequestType Type =&gt; RequestType.PrintMessage;\n\n  public PrintMessageRequest(string message)\n  {\n    Message = message;\n  }\n\n  protected override void AddRequestBody(BinaryWriter writer)\n  {\n    WriteLengthPrefixedString(writer, Message);\n  }\n}\n\n/// &lt;summary&gt;\n/// Represents a Request from the client. A Request is as follows.\n///\n///  Field Name         Type            Size (bytes)\n/// --------------------------------------------------\n///  ResponseType       Integer         4\n///  Iterations         Integer         4\n///  ForceUpdate        Boolean         1\n///  ModelName          String          Variable\n///\n/// Strings are encoded via a character count prefix as a\n/// 32-bit integer, followed by an array of characters.\n///\n/// &lt;/summary&gt;\npublic class UpdateModelRequest : Request\n{\n  public int Iterations { get; }\n  public bool ForceUpdate { get; }\n  public string ModelName { get; }\n\n  public override RequestType Type =&gt; RequestType.UpdateModel;\n\n  public UpdateModelRequest(string modelName, int iterations, bool forceUpdate)\n  {\n    Iterations = iterations;\n    ForceUpdate = forceUpdate;\n    ModelName = modelName;\n  }\n\n  protected override void AddRequestBody(BinaryWriter writer)\n  {\n    writer.Write(Iterations);\n    writer.Write(ForceUpdate);\n    WriteLengthPrefixedString(writer, ModelName);\n  }\n}\n</pre>\n\nBy using this structure, clients can create requests of various types, each of which defines its own logic for handling data and parameters.\nThe `PrintMessageRequest` and `UpdateModelRequest` classes provide examples of requests that can be sent to the server to perform specific tasks.\n\nOn the server side, it is necessary to develop the corresponding logic for processing incoming requests.\nTo do this, the server must read data from the stream and use the received parameters to perform the necessary operations.\n\nExample of a received request on the server side:\n\n<pre class=\"prettyprint\">\n/// &lt;summary&gt;\n/// Represents a request from the client. A request is as follows.\n///\n///  Field Name         Type                Size (bytes)\n/// ----------------------------------------------------\n///  RequestType       enum RequestType   4\n///  RequestBody       Request subclass   variable\n///\n/// &lt;/summary&gt;\npublic abstract class Request\n{\n  public enum RequestType\n  {\n    PrintMessage,\n    UpdateModel\n  }\n\n  public abstract RequestType Type { get; }\n\n  /// &lt;summary&gt;\n  ///   Read a Request from the given stream.\n  /// &lt;/summary&gt;\n  public static async Task&lt;Request&gt; ReadAsync(Stream stream)\n  {\n    var lengthBuffer = new byte[4];\n    await ReadAllAsync(stream, lengthBuffer, 4).ConfigureAwait(false);\n    var length = BitConverter.ToUInt32(lengthBuffer, 0);\n\n    var requestBuffer = new byte[length];\n    await ReadAllAsync(stream, requestBuffer, requestBuffer.Length);\n\n    using var reader = new BinaryReader(new MemoryStream(requestBuffer), Encoding.Unicode);\n\n    var requestType = (RequestType) reader.ReadInt32();\n    return requestType switch\n    {\n      RequestType.PrintMessage =&gt; PrintMessageRequest.Create(reader),\n      RequestType.UpdateModel =&gt; UpdateModelRequest.Create(reader),\n      _ =&gt; throw new ArgumentOutOfRangeException()\n    };\n  }\n\n  /// &lt;summary&gt;\n  /// This task does not complete until we are completely done reading.\n  /// &lt;/summary&gt;\n  private static async Task ReadAllAsync(Stream stream, byte[] buffer, int count)\n  {\n    var totalBytesRead = 0;\n    do\n    {\n      var bytesRead = await stream.ReadAsync(buffer, totalBytesRead, count - totalBytesRead);\n      if (bytesRead == 0) throw new EndOfStreamException(\"Reached end of stream before end of read.\");\n      totalBytesRead += bytesRead;\n    } while (totalBytesRead &lt; count);\n  }\n\n  /// &lt;summary&gt;\n  /// Read a string from the Reader where the string is encoded\n  /// as a length prefix (signed 32-bit integer) followed by\n  /// a sequence of characters.\n  /// &lt;/summary&gt;\n  protected static string ReadLengthPrefixedString(BinaryReader reader)\n  {\n    var length = reader.ReadInt32();\n    return length &lt; 0 ? null : new string(reader.ReadChars(length));\n  }\n}\n\n/// &lt;summary&gt;\n/// Represents a Request from the client. A Request is as follows.\n///\n///  Field Name         Type            Size (bytes)\n/// --------------------------------------------------\n///  RequestType        Integer         4\n///  Message            String          Variable\n///\n/// Strings are encoded via a character count prefix as a\n/// 32-bit integer, followed by an array of characters.\n///\n/// &lt;/summary&gt;\npublic class PrintMessageRequest : Request\n{\n  public string Message { get; }\n\n  public override RequestType Type =&gt; RequestType.PrintMessage;\n\n  public PrintMessageRequest(string message)\n  {\n    Message = message;\n  }\n\n  protected override void AddRequestBody(BinaryWriter writer)\n  {\n    WriteLengthPrefixedString(writer, Message);\n  }\n}\n\n/// &lt;summary&gt;\n/// Represents a Request from the client. A Request is as follows.\n///\n///  Field Name         Type            Size (bytes)\n/// --------------------------------------------------\n///  RequestType        Integer         4\n///  Iterations         Integer         4\n///  ForceUpdate        Boolean         1\n///  ModelName          String          Variable\n///\n/// Strings are encoded via a character count prefix as a\n/// 32-bit integer, followed by an array of characters.\n///\n/// &lt;/summary&gt;\npublic class UpdateModelRequest : Request\n{\n  public int Iterations { get; }\n  public bool ForceUpdate { get; }\n  public string ModelName { get; }\n\n  public override RequestType Type =&gt; RequestType.UpdateModel;\n\n  public UpdateModelRequest(string modelName, int iterations, bool forceUpdate)\n  {\n    Iterations = iterations;\n    ForceUpdate = forceUpdate;\n    ModelName = modelName;\n  }\n\n  protected override void AddRequestBody(BinaryWriter writer)\n  {\n    writer.Write(Iterations);\n    writer.Write(ForceUpdate);\n    WriteLengthPrefixedString(writer, ModelName);\n  }\n}\n</pre>\n\nThe `ReadAsync()` method reads the request type from the stream and then, depending on the type, reads the corresponding data and creates an object of the corresponding request.\n\nImplementing a data transmission protocol and structuring requests as classes enable efficient management of information exchange between the client and the server, ensuring structured and comprehensible interaction between the two parties.\nHowever, when designing such protocols, it is essential to consider potential security risks and ensure that both ends of the interaction handle all possible scenarios correctly.\n\n#####<a name=\"3.8\"></a> Connection Management\n\nTo send messages from the UI client to the server, let's create a `ClientDispatcher` class that will handle connections, timeouts, and scheduling requests, providing an interface for client-server interaction via named pipes.\n\n<pre class=\"prettyprint\">\n/// &lt;summary&gt;\n///     This class manages the connections, timeout and general scheduling of requests to the server.\n/// &lt;/summary&gt;\npublic class ClientDispatcher\n{\n  private const int TimeOutNewProcess = 10000;\n\n  private Task _connectionTask;\n  private readonly NamedPipeClientStream _client = NamedPipeUtil.CreateClient(PipeDirection.Out);\n\n  /// &lt;summary&gt;\n  ///   Connects to server without awaiting\n  /// &lt;/summary&gt;\n  public void ConnectToServer()\n  {\n    _connectionTask = _client.ConnectAsync(TimeOutNewProcess);\n  }\n\n  /// &lt;summary&gt;\n  ///   Write a Request to the server.\n  /// &lt;/summary&gt;\n  public async Task WriteRequestAsync(Request request)\n  {\n    await _connectionTask;\n    await request.WriteAsync(_client);\n  }\n}\n</pre>\n\nWorking principle:\n\n-  **Initialization:** the `NamedPipeClientStream` is initialized in the class constructor, used to create a client stream with a named pipe.\n-  **Establishing Connection:** the `ConnectToServer` method initiates an asynchronous connection to the server.\n   The operation's result is stored in a `Task`.\n   `TimeOutNewProcess` is used to disconnect the client in case of unexpected exceptions.\n-  **Sending Requests:** the `WriteRequestAsync` method is designed for asynchronously sending a Request object through the established connection.\n   The request will be sent only after the connection is established.\n\nTo receive messages by the server, we will create a `ServerDispatcher` class to manage the connection and read requests.\n\n<pre class=\"prettyprint\">\n/// &lt;summary&gt;\n///     This class manages the connections, timeout and general scheduling of the client requests.\n/// &lt;/summary&gt;\npublic class ServerDispatcher\n{\n  private readonly NamedPipeServerStream _server = NamedPipeUtil.CreateServer(PipeDirection.In);\n\n  /// &lt;summary&gt;\n  ///   This function will accept and process new requests until the client disconnects from the server\n  /// &lt;/summary&gt;\n  public async Task ListenAndDispatchConnections()\n  {\n    try\n    {\n      await _server.WaitForConnectionAsync();\n      await ListenAndDispatchConnectionsCoreAsync();\n    }\n    finally\n    {\n      _server.Close();\n    }\n  }\n\n  private async Task ListenAndDispatchConnectionsCoreAsync()\n  {\n    while (_server.IsConnected)\n    {\n      try\n      {\n        var request = await Request.ReadAsync(_server);\n        if (request.Type == Request.RequestType.PrintMessage)\n        {\n          var printRequest = (PrintMessageRequest) request;\n          Console.WriteLine($\"Message from client: {printRequest.Message}\");\n        }\n        else if (request.Type == Request.RequestType.UpdateModel)\n        {\n          var printRequest = (UpdateModelRequest) request;\n          Console.WriteLine($\"The {printRequest.ModelName} model has been {(printRequest.ForceUpdate ? \"forcibly\" : string.Empty)} updated {printRequest.Iterations} times\");\n        }\n      }\n      catch (EndOfStreamException)\n      {\n        return; //Pipe disconnected\n      }\n    }\n  }\n}\n</pre>\n\nWorking principle:\n\n-  **Initialization:** the `NamedPipeServerStream` is initialized in the class constructor, used to create a server stream with a named pipe.\n-  **Listening for Connections:** The `ListenAndDispatchConnections()` method asynchronously waits for a client connection.\n   After processing the requests, it closes the named pipe and releases resources.\n-  **Handling Requests:** The `ListenAndDispatchConnectionsCoreAsync()` method handles requests until the client is disconnected.\n   Depending on the type of request, corresponding data processing occurs, such as displaying the message content in the console or updating the model.\n\nAn example of sending a request from the UI to the server:\n\n<pre class=\"prettyprint\">\n/// &lt;summary&gt;\n///   Programme entry point\n/// &lt;/summary&gt;\npublic sealed partial class App\n{\n  public static ClientDispatcher ClientDispatcher { get; }\n\n  static App()\n  {\n    ClientDispatcher = new ClientDispatcher();\n    ClientDispatcher.ConnectToServer();\n  }\n}\n\n/// &lt;summary&gt;\n///   WPF view business logic\n/// &lt;/summary&gt;\npublic partial class MainViewModel : ObservableObject\n{\n  [ObservableProperty] private string _message = string.Empty;\n\n  [RelayCommand]\n  private async Task SendMessageAsync()\n  {\n    var request = new PrintMessageRequest(Message);\n    await App.ClientDispatcher.WriteRequestAsync(request);\n  }\n\n  [RelayCommand]\n  private async Task UpdateModelAsync()\n  {\n    var request = new UpdateModelRequest(AppDomain.CurrentDomain.FriendlyName, 666, true);\n    await App.ClientDispatcher.WriteRequestAsync(request);\n  }\n}\n</pre>\n\nThe complete code example is available in the repository, and you can run it on your machine by following a few steps:\n\n- Run \"Build Solution.\"\n- Run \"Run OneWay/Backend.\"\n\nThe application will automatically launch the Server and Client, and you will see the full output of the messages transmitted via the NamedPipe in the IDE console.\n\n#####<a name=\"3.9\"></a> Two-Way Communication\n\nThere are often situations where the usual one-way data transmission from the client to the server is not sufficient.\nIn such cases, it is necessary to handle errors or send results in response.\nTo enable more complex interaction between the client and the server, developers have to resort to the use of two-way data transmission, which allows for the exchange of information in both directions.\n\nSimilar to requests, to efficiently handle responses, it is also necessary to define an enumeration for response types.\nThis will enable the client to interpret the received data correctly.\n\n<pre class=\"prettyprint\">\npublic enum ResponseType\n{\n  // The update request completed on the server and the results are contained in the message.\n  UpdateCompleted,\n\n  // The request was rejected by the server.\n  Rejected\n}\n</pre>\n\nEfficient handling of responses will require creating a new class named `Response`.\nFunctionally, it does not differ from the Request class.\nHowever, unlike Request, which can be read on the server, Response will be written to the stream.\n\n<pre class=\"prettyprint\">\n/// &lt;summary&gt;\n/// Base class for all possible responses to a request.\n/// The ResponseType enum should list all possible response types\n/// and ReadResponse creates the appropriate response subclass based\n/// on the response type sent by the client.\n/// The format of a response is:\n///\n/// Field Name       Field Type          Size (bytes)\n/// -------------------------------------------------\n/// ResponseType     enum ResponseType   4\n/// ResponseBody     Response subclass   variable\n/// &lt;/summary&gt;\npublic abstract class Response\n{\n  public enum ResponseType\n  {\n    // The update request completed on the server and the results are contained in the message.\n    UpdateCompleted,\n\n    // The request was rejected by the server.\n    Rejected\n  }\n\n  public abstract ResponseType Type { get; }\n\n  protected abstract void AddResponseBody(BinaryWriter writer);\n\n  /// &lt;summary&gt;\n  ///   Write a Response to the stream.\n  /// &lt;/summary&gt;\n  public async Task WriteAsync(Stream outStream)\n  {\n    // Same as request class from client\n  }\n\n  /// &lt;summary&gt;\n  /// Write a string to the Writer where the string is encoded\n  /// as a length prefix (signed 32-bit integer) follows by\n  /// a sequence of characters.\n  /// &lt;/summary&gt;\n  protected static void WriteLengthPrefixedString(BinaryWriter writer, string value)\n  {\n    // Same as request class from client\n  }\n}\n</pre>\n\nYou can find derivative classes in the project repository: [PipeProtocol](https://github.com/atomatiq/InterprocessCommunication/blob/main/TwoWay/Backend/Server/PipeProtocol.cs)\n\nTo enable the server to send responses to the client, we need to modify the `ServerDispatcher` class.\nThis will allow writing responses to the stream after executing a task.\n\nAdditionally, let's change the pipe direction to bidirectional:\n\n<pre class=\"prettyprint\">\n_server = NamedPipeUtil.CreateServer(PipeDirection.InOut);\n\n/// &lt;summary&gt;\n///     Write a Response to the client.\n/// &lt;/summary&gt;\npublic async Task WriteResponseAsync(Response response) =&gt; await response.WriteAsync(_server);\n</pre>\n\nTo demonstrate the operation, let's add a 2-second delay, emulating a heavy task, in the `ListenAndDispatchConnectionsCoreAsync()` method.\n\n<pre class=\"prettyprint\">\nprivate async Task ListenAndDispatchConnectionsCoreAsync()\n{\n  while (_server.IsConnected)\n  {\n    try\n    {\n      var request = await Request.ReadAsync(_server);\n\n      // ...\n      if (request.Type == Request.RequestType.UpdateModel)\n      {\n        var printRequest = (UpdateModelRequest) request;\n\n        await Task.Delay(TimeSpan.FromSeconds(2));\n        await WriteResponseAsync(new UpdateCompletedResponse(changes: 69, version: \"2.1.7\"));\n      }\n    }\n    catch (EndOfStreamException)\n    {\n      return; //Pipe disconnected\n    }\n  }\n}\n</pre>\n\nCurrently, the client does not handle responses from the server.\nLet's address this. Let's create a `Response` class in the client that will handle the received responses.\n\n<pre class=\"prettyprint\">\n/// &lt;summary&gt;\n/// Base class for all possible responses to a request.\n/// The ResponseType enum should list all possible response types\n/// and ReadResponse creates the appropriate response subclass based\n/// on the response type sent by the client.\n/// The format of a response is:\n///\n/// Field Name       Field Type          Size (bytes)\n/// -------------------------------------------------\n/// ResponseType     enum ResponseType   4\n/// ResponseBody     Response subclass   variable\n///\n/// &lt;/summary&gt;\npublic abstract class Response\n{\n  public enum ResponseType\n  {\n    // The update request completed on the server and the results are contained in the message.\n    UpdateCompleted,\n\n    // The request was rejected by the server.\n    Rejected\n  }\n\n  public abstract ResponseType Type { get; }\n\n  /// &lt;summary&gt;\n  ///   Read a Request from the given stream.\n  /// &lt;/summary&gt;\n  public static async Task&lt;Response&gt; ReadAsync(Stream stream)\n  {\n    // Same as request class from server\n  }\n\n  /// &lt;summary&gt;\n  /// This task does not complete until we are completely done reading.\n  /// &lt;/summary&gt;\n  private static async Task ReadAllAsync(Stream stream, byte[] buffer, int count)\n  {\n    // Same as request class from server\n  }\n\n  /// &lt;summary&gt;\n  /// Read a string from the Reader where the string is encoded\n  /// as a length prefix (signed 32-bit integer) followed by\n  /// a sequence of characters.\n  /// &lt;/summary&gt;\n  protected static string ReadLengthPrefixedString(BinaryReader reader)\n  {\n    // Same as request class from server\n  }\n}\n</pre>\n\nFurthermore, we'll update the `ClientDispatcher` class to handle responses from the server.\nTo do this, we'll add a new method and change the direction to bidirectional.\n\n<pre class=\"prettyprint\">\n_client = NamedPipeUtil.CreateClient(PipeDirection.InOut);\n\n/// &lt;summary&gt;\n///     Read a Response from the server.\n/// &lt;/summary&gt;\npublic async Task&lt;Response&gt; ReadResponseAsync() =&gt; await Response.ReadAsync(_client);\n</pre>\n\nWe'll also add response handling to the ViewModel, where we'll simply display it as a message.\n\n<pre class=\"prettyprint\">\n[RelayCommand]\nprivate async Task UpdateModelAsync()\n{\n  var request = new UpdateModelRequest(AppDomain.CurrentDomain.FriendlyName, 666, true);\n  await App.ClientDispatcher.WriteRequestAsync(request);\n\n  var response = await App.ClientDispatcher.ReadResponseAsync();\n  if (response.Type == Response.ResponseType.UpdateCompleted)\n  {\n    var completedResponse = (UpdateCompletedResponse) response;\n\n    MessageBox.Show($\"{completedResponse.Changes} elements successfully updated to version {completedResponse.Version}\");\n  }\n  else if (response.Type == Response.ResponseType.Rejected)\n  {\n    MessageBox.Show(\"Update failed\");\n  }\n}\n</pre>\n\nThese changes will allow for more efficient organization of the interaction between the client and the server, ensuring a more complete and reliable handling of requests and responses.\n\n#####<a name=\"3.10\"></a> Implementation for Revit plug-in\n\n<center>\n<img src=\"img/2023_revit_technology.jpg\" alt=\"Revit technology 2023\" title=\"Revit technology 2023\" width=\"500\"/>\n<p style=\"font-size: 80%; font-style:italic\">Technology evolves, Revit never changes © Confucius</p>\n</center>\n\nCurrently, Revit is using .NET Framework 4.8.\nHowever, to enhance the plugin user interface, let's consider upgrading to .NET 7.\nIt is important to note that the backend of the plugin will interact only with the outdated framework of Revit and will act as a server.\n\nLet's create a mechanism of interaction that allows the client to send requests for the deletion of model elements and subsequently receive responses regarding the deletion results.\nTo implement this functionality, we will use bidirectional data transfer between the server and the client.\n\nThe first step in our development process will be to enable the plugin to automatically close upon Revit's closure.\nTo accomplish this, we have written a method that sends the ID of the current process to the client.\nThis will help the client to automatically close its process upon the closure of the parent Revit process.\n\nHere is the code for sending the ID of the current process to the client:\n\n<pre class=\"prettyprint\">\nprivate static void RunClient(string clientName)\n{\n  var startInfo = new ProcessStartInfo\n  {\n    FileName = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location)!.AppendPath(clientName),\n    Arguments = Process.GetCurrentProcess().Id.ToString()\n  };\n\n  Process.Start(startInfo);\n}\n</pre>\n\nAnd here is the code for the client, which facilitates the closure of its process upon the closure of the parent Revit process:\n\n<pre class=\"prettyprint\">\nprotected override void OnStartup(StartupEventArgs args)\n{\n  ParseCommandArguments(args.Args);\n}\n\nprivate void ParseCommandArguments(string[] args)\n{\n  var ownerPid = args[0];\n  var ownerProcess = Process.GetProcessById(int.Parse(ownerPid));\n  ownerProcess.EnableRaisingEvents = true;\n  ownerProcess.Exited += (_, _) =&gt; Shutdown();\n}\n</pre>\n\nAdditionally, we require a method that will handle the deletion of selected model elements:\n\n<pre class=\"prettyprint\">\npublic static ICollection&lt;ElementId&gt; DeleteSelectedElements()\n{\n  var transaction = new Transaction(Document);\n  transaction.Start(\"Delete elements\");\n\n  var selectedIds = UiDocument.Selection.GetElementIds();\n  var deletedIds = Document.Delete(selectedIds);\n\n  transaction.Commit();\n  return deletedIds;\n}\n</pre>\n\nLet's also update the method `ListenAndDispatchConnectionsCoreAsync()` to handle incoming connections:\n\n<pre class=\"prettyprint\">\nprivate async Task ListenAndDispatchConnectionsCoreAsync()\n{\n  while (_server.IsConnected)\n  {\n    try\n    {\n      var request = await Request.ReadAsync(_server);\n      if (request.Type == Request.RequestType.DeleteElements)\n      {\n        await ProcessDeleteElementsAsync();\n      }\n    }\n    catch (EndOfStreamException)\n    {\n      return; //Pipe disconnected\n    }\n  }\n}\n\nprivate async Task ProcessDeleteElementsAsync()\n{\n  try\n  {\n    var deletedIds = await Application.AsyncEventHandler.RaiseAsync(_ =&gt; RevitApi.DeleteSelectedElements());\n    await WriteResponseAsync(new DeletionCompletedResponse(deletedIds.Count));\n  }\n  catch (Exception exception)\n  {\n    await WriteResponseAsync(new RejectedResponse(exception.Message));\n  }\n}\n</pre>\n\nAnd finally, the updated ViewModel code:\n\n<pre class=\"prettyprint\">\n[RelayCommand]\nprivate async Task DeleteElementsAsync()\n{\n  var request = new DeleteElementsRequest();\n  await App.ClientDispatcher.WriteRequestAsync(request);\n\n  var response = await App.ClientDispatcher.ReadResponseAsync();\n  if (response.Type == Response.ResponseType.Success)\n  {\n    var completedResponse = (DeletionCompletedResponse) response;\n    MessageBox.Show($\"{completedResponse.Changes} elements successfully deleted\");\n  }\n  else if (response.Type == Response.ResponseType.Rejected)\n  {\n    var rejectedResponse = (RejectedResponse) response;\n    MessageBox.Show($\"Deletion failed\\n{rejectedResponse.Reason}\");\n  }\n}\n</pre>\n\n####<a name=\"3.11\"></a> Installing .NET Runtime during plugin installation\n\nNot every user may have the latest version of .NET Runtime installed on their local machine, so we need to make some changes to the plugin installer.\n\nIf you are using the [Nice3point.RevitTemplates](https://github.com/Nice3point/RevitTemplates), making these adjustments will be effortless.\nThe templates use the WixSharp library, which enables the creation of `.msi` files directly in C#.\n\nTo add custom actions and install .NET Runtime, we will create a `CustomAction`:\n\n<pre class=\"prettyprint\">\npublic static class RuntimeActions\n{\n  /// &lt;summary&gt;\n  ///   Add-in client .NET version\n  /// &lt;/summary&gt;\n  private const string DotnetRuntimeVersion = \"7\";\n\n  /// &lt;summary&gt;\n  ///   Direct download link\n  /// &lt;/summary&gt;\n  private const string DotnetRuntimeUrl = $\"https://aka.ms/dotnet/{DotnetRuntimeVersion}.0/windowsdesktop-runtime-win-x64.exe\";\n\n  /// &lt;summary&gt;\n  ///   Installing the .NET runtime after installing software\n  /// &lt;/summary&gt;\n  [CustomAction]\n  public static ActionResult InstallDotnet(Session session)\n  {\n    try\n    {\n      var isRuntimeInstalled = CheckDotnetInstallation();\n      if (isRuntimeInstalled) return ActionResult.Success;\n\n      var destinationPath = Path.Combine(Path.GetTempPath(), \"windowsdesktop-runtime-win-x64.exe\");\n\n      UpdateStatus(session, \"Downloading .NET runtime\");\n      DownloadRuntime(destinationPath);\n\n      UpdateStatus(session, \"Installing .NET runtime\");\n      var status = InstallRuntime(destinationPath);\n\n      var result = status switch\n      {\n        0 =&gt; ActionResult.Success,\n        1602 =&gt; ActionResult.UserExit,\n        1618 =&gt; ActionResult.Success,\n        _ =&gt; ActionResult.Failure\n      };\n\n      File.Delete(destinationPath);\n      return result;\n    }\n    catch (Exception exception)\n    {\n      session.Log(\"Error downloading and installing DotNet: \" + exception.Message);\n      return ActionResult.Failure;\n    }\n  }\n\n  private static int InstallRuntime(string destinationPath)\n  {\n    var startInfo = new ProcessStartInfo(destinationPath)\n    {\n      Arguments = \"/q\",\n      UseShellExecute = false\n    };\n\n    var installProcess = Process.Start(startInfo)!;\n    installProcess.WaitForExit();\n    return installProcess.ExitCode;\n  }\n\n  private static void DownloadRuntime(string destinationPath)\n  {\n    ServicePointManager.SecurityProtocol = SecurityProtocolType.Tls12 | SecurityProtocolType.Tls11 | SecurityProtocolType.Tls;\n\n    using var httpClient = new HttpClient();\n    var responseBytes = httpClient.GetByteArrayAsync(DotnetRuntimeUrl).Result;\n\n    File.WriteAllBytes(destinationPath, responseBytes);\n  }\n\n  private static bool CheckDotnetInstallation()\n  {\n    var startInfo = new ProcessStartInfo\n    {\n      FileName = \"dotnet\",\n      Arguments = \"--list-runtimes\",\n      RedirectStandardOutput = true,\n      UseShellExecute = false,\n      CreateNoWindow = true\n    };\n\n    try\n    {\n      var process = Process.Start(startInfo)!;\n      var output = process.StandardOutput.ReadToEnd();\n      process.WaitForExit();\n\n      return output.Split('\\n')\n        .Where(line =&gt; line.Contains(\"Microsoft.WindowsDesktop.App\"))\n        .Any(line =&gt; line.Contains($\"{DotnetRuntimeVersion}.\"));\n    }\n    catch\n    {\n      return false;\n    }\n  }\n\n  private static void UpdateStatus(Session session, string message)\n  {\n    var record = new Record(3);\n    record[2] = message;\n\n    session.Message(InstallMessage.ActionStart, record);\n  }\n}\n</pre>\n\nThis code checks whether the required version of .NET is installed on the local machine, and if not, it downloads and installs it.\nThe installation process updates the `Status` of the current progress of downloading and unpacking the Runtime.\n\nFinally, we need to connect the `CustomAction` to the WixSharp project. To do this, we initialize the `Actions` property:\n\n<pre class=\"prettyprint\">\nvar project = new Project\n{\n  Name = \"Wix Installer\",\n  UI = WUI.WixUI_FeatureTree,\n  GUID = new Guid(\"8F2926C8-3C6C-4D12-9E3C-7DF611CD6DDF\"),\n  Actions = new Action[]\n  {\n    new ManagedAction(RuntimeActions.InstallDotnet,\n      Return.check,\n      When.Before,\n      Step.InstallFinalize,\n      Condition.NOT_Installed)\n  }\n};\n</pre>\n\n####<a name=\"3.12\"></a> Conclusion\n\nIn this article, we explored how Named Pipes, primarily used for Inter-Process Communication (IPC), can be used in scenarios requiring data exchange between applications running on different .NET versions.\nDealing with code that needs to be maintained across multiple versions, a well-considered IPC strategy can be valuable, providing key benefits such as:\n\n- Dependency conflict resolution\n- Enhancing performance\n- Functional flexibility\n\nWe discussed the process of creating a server and client that interact with each other through a pre-defined protocol, as well as various ways of managing connections.\n\nWe examined an example of server responses and demonstrated the operation of both sides of the interaction.\n\nFinally, we underscored how Named Pipes are used in the development of a plugin for Revit to provide communication between the backend operating on the legacy .NET 4.8 platform and the user interface running on the newer .NET 7 version.\n\nDemo code for each part of this article is available on GitHub.\n\nIn certain cases, splitting applications into separate processes can not only reduce dependencies within the program but also improve the UI responsiveness.\nHowever, let us not forget that the choice of approach requires analysis and should be based on the actual requirements and constraints of your project.\n\nDo you need to split each plugin into multiple processes? Definitely not.\n\nWe hope that this article will help you find the best solution for your interprocess communication scenarios and give you an understanding of how to apply IPC approaches in practice.\n\nMany thanks to Roman for his deep research and careful documentation of this important topic, in addition to all his maintenance work on RevitLookup."
  },
  {
    "original_filename": "2012_dll_paradise",
    "header_text": "Fuyu-8B Multimodal Architecture for AI Agents",
    "local_header_href": "#4",
    "chunk_text": "####<a name=\"4\"></a> Fuyu-8B Multimodal Architecture for AI Agents\n\nAnother open source multimodal model hit the scene,\n[Fuyu-8B: A Multimodal Architecture for AI Agents](https://www.adept.ai/blog/fuyu-8b).\nIt can be run offline on a laptop CPU."
  },
  {
    "original_filename": "2012_dll_paradise",
    "header_text": "How Open Source Wins",
    "local_header_href": "#6",
    "chunk_text": "####<a name=\"6\"></a> How Open Source Wins\n\n[Open Source does not win by being cheaper](https://github.com/getlago/lago/wiki/Open-Source-does-not-win-by-being-cheaper#how-open-source-winsby-solving-an-extensibility-problem),\nbut by offering tranparency, extensibility and quality."
  },
  {
    "original_filename": "2012_dll_paradise",
    "header_text": "HTTP/3",
    "local_header_href": "#5",
    "chunk_text": "####<a name=\"5\"></a> HTTP/3\n\nDid you notice that you have started using HTTP/3?\nI hadn't.\nLearn [why HTTP/3 is eating the world](https://blog.apnic.net/2023/09/25/why-http-3-is-eating-the-world/)."
  }
]