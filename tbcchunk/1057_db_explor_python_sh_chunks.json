[
  {
    "original_filename": "1057_db_explor_python_sh",
    "header_text": "Introduction",
    "local_header_href": "#introduction",
    "chunk_text": "<head>\n<link href=\"bc.css\" rel=\"stylesheet\" type=\"text/css\"/>\n<meta content=\"text/html; charset=utf-8\" http-equiv=\"Content-Type\"/>\n<script src=\"http://thebuildingcoder.typepad.com/google-code-prettify/run_prettify.js\"></script>\n</head>"
  },
  {
    "original_filename": "1057_db_explor_python_sh",
    "header_text": "Revit Database Exploration Tools and the Python Shell",
    "local_header_href": "#revit-database-exploration-tools-and-the-python-shell",
    "chunk_text": "<h3>Revit Database Exploration Tools and the Python Shell</h3><p>I keep repeating the importance of being able to explore the Revit database model efficiently to understand what is going on.\n\n<p>This can even be important for end users, and is certainly much more so for developers.</p>\n<p>The first and foremost important tool is obviously RevitLookup.</p>\n<p>The BipChecker is less important and yet also handy for exploring element parameters.</p>\n<p>The disadvantage of these two is that they only explore existing values provided by properties and parameters.</p>\n<p>They do not offer much support for evaluating methods or exploring dynamically changing relationships.</p>\n<p>This mostly requires active programming, e.g. in the Revit macro environment, or hard-core implementation and debugging of an external add-in.</p>\n<p>It would be very nice to be able to interact directly with the Revit database using the API hands-on, interpreted, not compiled or packaged in a static macro.</p>\n<p>Well, as we have mentioned several times, you can, twice over, using the\n\n<a href=\"http://code.google.com/p/revitpythonshell\">\nRevit Python Shell</a> or\n\n<a href=\"https://github.com/hakonhc/RevitRubyShell\">\nRevit Ruby Shell</a>.</p>\n<p>We look at the\n\n<a href=\"http://code.google.com/p/revitpythonshell\">RevitPythonShell</a> below,\n\nsince we are not as knowledgeable in Ruby as in Python.</p>\n<p>Personally, I would actually prefer the Ruby language to Python, though, for its more modern architecture.</p>\n<p>To run the tests described below, I downloaded and ran the\n\n<a href=\"http://revitpythonshell.googlecode.com/files/Setup_RevitPythonShell_2014.exe\">\ninstaller for RevitPythonShell for Revit 2014 (r186)</a> and\n\nthe\n\n<a href=\"http://ironpython.net\">IronPython</a>\n<a href=\"http://ironpython.codeplex.com/downloads/get/723206\">installer</a>.</p>\n<p>That was it, no further configuration of any kind required:</p>\n<center>\n<img alt=\"Say hello to Revit Python Shell\" src=\"img/rps201401.png\"/>\n</center>\n<p>Alexander Ignatovich of\n\n<a href=\"http://www.iv-com.ru\">\nInvesticionnaya Venchurnaya Companiya</a> very\n\nkindly describes in more detail how these tools can be used for highly efficient exploration and API testing in the Revit database:</p>\n<a name=\"2\"></a>\n<h4>Interactive Revit Database Exploration Using the Revit Python Shell</h4>\n<p>First of all, about RevitLookup. I don't know what to say about it, except I can't imagine my work without this tool now ;-)</p>\n<p>I also explored its source, when I began to work with Revit API and needed to realize some functionality.</p>\n<p>I use two good tools that let you not waste time waiting for Revit to load and some project you need to open or create:\n\n<ul>\n<li>Revit Python Shell</li>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2013/05/external-command-lister-and-adding-ribbon-commands.html\">\nExternal Command Listener</a></li>\n</ul>\n<p>These are fantastically effective for API exploration, testing some algorithm parts and preparing complex environment for your add-ins.</p>\n<p>I mean, for example, creating thousands of family instances in your test.rvt, changing something that you cannot change manually through the interface, for example, extensible storages entities and so on.</p>\n<p>I also created some lightweight tools that can point out some pieces of information about project or its specific elements, related to our products, which also cannot be extracted from the interface.\nThey also help me provide product support.</p>\n<p>The criteria for your choices depend only your own practice.\nI use the Python shell when the script code:</p>\n<ul>\n<li>Should not exceed 1/2 – 2/3 of the screen height.</li>\n<li>Should not use your own assemblies (yes, you can load assemblies and add references in your Python script, but our project contains multiple assemblies with dependences and sometimes they read their configuration files, so it's much quicker to create new project in Visual Studio and use External Command Listener to test some functionality).</li>\n<li>Should not react to Revit events, contains dynamic updaters or failure processing.</li>\n<li>Should prepare the environment for you. In this case the first rule can be ignored.</li>\n</ul>\n<p>In other cases I use the External Command Listener (but again, it cannot be used if your code needs to react to events, use dynamic updaters or failure processing).</p>\n<p>I like Python.\nIts syntax is very simple.</p>\n<p>If you know any programming language, you can immediately write something on Python, even if all you ever read about it is here in this post.</p>\n<p>I'll show some examples of scripts.</p>\n<p>So, let's start to explore this tools.\nStart the extension, copy this script to console and press F5 (copy and paste the following code snippets somewhere or view source to see truncated lines in full):</p>\n<pre class=\"prettyprint\">\nprint \"Path:\", doc.PathName\nif doc.GetWorksharingCentralModelPath() != None:\n  print \"Central model path:\", ModelPathUtils.ConvertModelPathToUserVisiblePath(doc.GetWorksharingCentralModelPath())\nelse:\n  print \"The project is not work-sharing\"\n\nprint dir(uidoc)\n\nfor elem in selection:\n  print elem, elem.Id\n</pre>\n<p>First of all, the script prints RVT path and the path of central file.\nPractically, it's the first useful lightweight tool in your arsenal.\nYou can quickly copy RVT file and central model paths of an opened project.</p>\n<p>Secondly, it prints a list of all properties and methods of Autodesk.Revit.UI.UIDocument, which is sometimes useful.</p>\n<p>It uses the pre-defined variable uidoc to access the currently active UIDocument.\nIt is defined like this:</p>\n<pre class=\"prettyprint\">\nuidoc = __revit__.ActiveUIDocument\n</pre>\n<p>The last thing shown in this simple example that I use in 95% of my scripts – iterating through the collection of selected elements.</p>\n<p>There is absolutely no magic in the doc, uidoc and selection variables.\nIf you click the Revit Python Shell \"Configure...\" command and open the InitScript tab, you'll see:</p>\n<pre class=\"prettyprint\">\n# these commands get executed in the current scope\n# of each new shell (but not for canned commands)\nimport clr\nclr.AddReference('RevitAPI')\nclr.AddReference('RevitAPIUI')\nfrom Autodesk.Revit.DB import *\nfrom Autodesk.Revit.DB.Architecture import *\nfrom Autodesk.Revit.DB.Analysis import *\n\nuidoc = __revit__.ActiveUIDocument\ndoc = __revit__.ActiveUIDocument.Document\nselection = list(__revit__.ActiveUIDocument.Selection.Elements)\n...\n</pre>\n<p>This also provides an example of how to add additional references in your scripts, and the C# \"using\" keyword analogue.</p>\n<p>The second very often useful thing is filtering elements from the model:</p>\n<pre class=\"prettyprint\">\ncollector = FilteredElementCollector(doc)\nlinkedElements = collector\n  .OfClass(RevitLinkType).ToElements()\n\nfor elem in linkedElements:\n  efr = elem.GetExternalFileReference()\n  print ModelPathUtils.ConvertModelPathToUserVisiblePath(\n    efr.GetAbsolutePath())\n  print \"---------\"\n</pre>\n<p>This is simple.\nJust notice that Python requires no \"new\" keyword.</p>\n<p>So we created a filtered element collector for our opened document, retrieved all RevitLinkType elements and iterated through the elements list.</p>\n<!--\n<p>**Jeremy, I don't know exactly, how the ELEM_PARTITION_PARAM is named in Revit properties tab in English version, correct it, if it is not named as \"Work set\", please</p>\n-->\n<p>Let's go deeper and see something more complicated.</p>\n<p>Some months ago I needed to prepare some model elements information, grouped by worksets.\nBack in those fabled times I didn't know how to do it :-)</p>\n<p>I noticed that elements in the model have a \"work set\" parameter, so I selected an element, executed the RevitLookup \"Snoop current selection...\" command, went to the parameters field, found \"work set\" parameter, noticed that it has integer value, went to it's definition and found out that its built-in parameter name is ELEM_PARTITION_PARAM.</p>\n<p>I deduced that if we get all worksets from model, we can get their elements by using an ElementParameterFilter.</p>\n<p>At this point, I went to\n\n<a href=\"http://thebuildingcoder.typepad.com\">The Building Coder</a>,\n\nsearched it for \"document workset table\" and found the post on the\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2011/11/read-only-workset-api.html\">workset API</a>.</p>\n<p>I learned that I should use a FilteredWorksetCollector. So let's try:</p>\n<pre class=\"prettyprint\">\nworksets = FilteredWorksetCollector( doc )\nworksets.OfKind( WorksetKind.UserWorkset );\n\nfor elem in worksets:\n  print elem.Name\n</pre>\n<p>We got it!\nThey are not sorted, but remember, we are only exploring to find a way to solve the problem, and it is not the production code.</p>\n<p>So, continuing to explore how to retrieve the elements from the model that belong to a specific workset.</p>\n<p>Let's write a function that filters elements for a specific workset.</p>\n<p>The filtered element \"work set\" parameter should be equal to the Workset.Id.Integer value.\nWe'll pass it to the function as wId:</p>\n<pre class=\"prettyprint\">\ndef FindElementsByWorkset(wId):\n  worksetI = int(BuiltInParameter.ELEM_PARTITION_PARAM) # convert enumeration element to an integer\n  worksetE = ElementId(worksetI) # and create element id from it\n\n  provider = ParameterValueProvider(worksetE) # the parameter should be BuiltInParameter.ELEM_PARTITION_PARAM\n  evaluator = FilterNumericEquals() # the value should be equal\n  rule = FilterIntegerRule(provider, evaluator, wId) # to wId\n\n  parafilter = ElementParameterFilter(rule); # create filter parameter\n  collector = FilteredElementCollector(doc) # create collector\n  collector.WherePasses(parafilter) # and filter elements\n\n  # iterate through the elements\n  for elem in collector:\n    print \"\\t\", elem.Id, elem.GetType().Name\n</pre>\n<p>This function should be placed before our previous code that retrieves the worksets from the model.</p>\n<p>The last thing is to invoke our function in a loop:</p>\n<pre class=\"prettyprint\">\nfor elem in worksets:\n  print elem.Name\n  FindElementsByWorkset(elem.Id.IntegerValue)\n</pre>\n<p>As you can easily imagine, I would have spent <b><i>much</i></b> more time if I were forced to restart Revit every time I changed something in this code analogue.</p>\n<p>The advantages of using this kind of tools are completely obvious, aren't they?</p>\n<p>The remaining examples will cover some non-obvious things, that you would need to search for, when you face them.\nAnd you <b>will</b> face them :-)</p>\n<p>These things include GUIDs and generic methods.\nThis example shows using such things.\nIt finds an extensible storage schema with a specific name, gets doc.OwnerFamily entity of the schema found and retrieves the \"FamilyId\" field of Guid type.</p>\n<pre class=\"prettyprint\">\nfrom Autodesk.Revit.DB.ExtensibleStorage import *\nfrom System import Guid # you need to import this, when you work with Guids!\nfor sch in Schema.ListSchemas():\n  if sch.SchemaName == \"CatalogFamilyInfoEntity\": # looking for the schema\n    schema = sch\nprint schema.SchemaName\nentity = doc.OwnerFamily.GetEntity(schema)\nprint entity.IsValid()\nprint entity.Get[Guid](\"FamilyId\") # generic method public FieldType Get FieldType (string fieldName)\n</pre>\n<!--\n<p>***Jeremy, I remember, that there was a problem in subscription site with angular brackets (around FieldType), may be just in browser, so I didn't write them</p>\n-->\n<p>Another non-obvious thing is creating a new Guid for something.\nIf you already know your Guid value, you may use something like this:</p>\n<pre class=\"prettyprint\">\nimport System\nparameterId = System.Guid(\"0ce6f957-070e-4e1b-8f33-7a9d95cf1142\")\nprint \"parameter\", doc.ProjectInformation.get_Parameter(parameterId).AsString() # I've got shared parameter with this id in the RVT file, you should use your own Guid\n</pre>\n<p>If you want to create an absolutely new Guid:</p>\n<pre class=\"prettyprint\">\nfrom System.Guid import NewGuid\nprint NewGuid()\n</pre>\n<p>The (almost) last example shows how to automatically create thousands of family instances of different family types of a specific family.\nThe code is not very good, but it is not the production, it's only for me and I seldom use it.\nThis script will create a layer of rng * rng family instances for each family symbol of specific family:</p>\n<pre class=\"prettyprint\">\ncollector = FilteredElementCollector(doc)\ncollector.OfCategory(BuiltInCategory.OST_StructuralFraming) # my family in this category, just remove this or change to the category of family you want to place in the document\nelems = collector.OfClass(FamilySymbol).ToElements() # we get all family symbols in this category\n\nrng = 80 # 80*80 elements of each family symbol\ndist = 5 # distance between elements\n\nt = Transaction(doc, 'Create multiple family instances.')\nt.Start()\n\nz = 0\nfor elem in elems:\n  if elem.Family.Name == \"Enter your family name here\":\n    for i in range(0,rng):\n      for j in range(0,rng):\n        loc = XYZ((i*dist),(j*dist),(z*dist))\n        familyInst = doc.Create.NewFamilyInstance(loc, elem, Structure.StructuralType.NonStructural)\n    z = z + 1\n\nt.Commit()\n</pre>\n<p>Let's end with one additional Python script that demonstrates working with LINQ and enumerations:</p>\n<pre class=\"prettyprint\">\nfrom System import *\nclr.AddReference(\"System.Core\")\nfrom System.Collections.Generic import *\nimport System\nclr.ImportExtensions(System.Linq)\nfrom System.Linq import Enumerable\n\ndef printSubCategories(elem, n):\n  tab = \"\"\n  for i in range(1, n):\n    tab = tab + \"\\t\"\n  print tab, elem.Name, Enum.ToObject(BuiltInCategory, elem.Id.IntegerValue), elem.Id\n  for child in elem.SubCategories:\n    printSubCategories(child, n + 1)\n\nfor elem in Enumerable.ToList[Category](doc.Settings.Categories).OrderBy(lambda x: x.Name):\n  print elem.Name, Enum.ToObject(BuiltInCategory, elem.Id.IntegerValue), elem.Id\n  printSubCategories(elem, 1)\n  print \"---\"\n</pre>\n<p>Very many thanks to Alexander for these nice examples!</p>\n<p>I hope that everybody takes this chance to really dig deep into intimate direct API interaction with Revit.</p>\n</p></p>"
  },
  {
    "original_filename": "1057_db_explor_python_sh",
    "header_text": "Interactive Revit Database Exploration Using the Revit Python Shell",
    "local_header_href": "#interactive-revit-database-exploration-using-the-revit-python-shell",
    "chunk_text": "<h4>Interactive Revit Database Exploration Using the Revit Python Shell</h4><p>First of all, about RevitLookup. I don't know what to say about it, except I can't imagine my work without this tool now ;-)</p><p>I also explored its source, when I began to work with Revit API and needed to realize some functionality.</p><p>I use two good tools that let you not waste time waiting for Revit to load and some project you need to open or create:\n\n<ul>\n<li>Revit Python Shell</li>\n<li><a href=\"http://thebuildingcoder.typepad.com/blog/2013/05/external-command-lister-and-adding-ribbon-commands.html\">\nExternal Command Listener</a></li>\n</ul>\n<p>These are fantastically effective for API exploration, testing some algorithm parts and preparing complex environment for your add-ins.</p>\n<p>I mean, for example, creating thousands of family instances in your test.rvt, changing something that you cannot change manually through the interface, for example, extensible storages entities and so on.</p>\n<p>I also created some lightweight tools that can point out some pieces of information about project or its specific elements, related to our products, which also cannot be extracted from the interface.\nThey also help me provide product support.</p>\n<p>The criteria for your choices depend only your own practice.\nI use the Python shell when the script code:</p>\n<ul>\n<li>Should not exceed 1/2 – 2/3 of the screen height.</li>\n<li>Should not use your own assemblies (yes, you can load assemblies and add references in your Python script, but our project contains multiple assemblies with dependences and sometimes they read their configuration files, so it's much quicker to create new project in Visual Studio and use External Command Listener to test some functionality).</li>\n<li>Should not react to Revit events, contains dynamic updaters or failure processing.</li>\n<li>Should prepare the environment for you. In this case the first rule can be ignored.</li>\n</ul>\n<p>In other cases I use the External Command Listener (but again, it cannot be used if your code needs to react to events, use dynamic updaters or failure processing).</p>\n<p>I like Python.\nIts syntax is very simple.</p>\n<p>If you know any programming language, you can immediately write something on Python, even if all you ever read about it is here in this post.</p>\n<p>I'll show some examples of scripts.</p>\n<p>So, let's start to explore this tools.\nStart the extension, copy this script to console and press F5 (copy and paste the following code snippets somewhere or view source to see truncated lines in full):</p>\n<pre class=\"prettyprint\">\nprint \"Path:\", doc.PathName\nif doc.GetWorksharingCentralModelPath() != None:\n  print \"Central model path:\", ModelPathUtils.ConvertModelPathToUserVisiblePath(doc.GetWorksharingCentralModelPath())\nelse:\n  print \"The project is not work-sharing\"\n\nprint dir(uidoc)\n\nfor elem in selection:\n  print elem, elem.Id\n</pre>\n<p>First of all, the script prints RVT path and the path of central file.\nPractically, it's the first useful lightweight tool in your arsenal.\nYou can quickly copy RVT file and central model paths of an opened project.</p>\n<p>Secondly, it prints a list of all properties and methods of Autodesk.Revit.UI.UIDocument, which is sometimes useful.</p>\n<p>It uses the pre-defined variable uidoc to access the currently active UIDocument.\nIt is defined like this:</p>\n<pre class=\"prettyprint\">\nuidoc = __revit__.ActiveUIDocument\n</pre>\n<p>The last thing shown in this simple example that I use in 95% of my scripts – iterating through the collection of selected elements.</p>\n<p>There is absolutely no magic in the doc, uidoc and selection variables.\nIf you click the Revit Python Shell \"Configure...\" command and open the InitScript tab, you'll see:</p>\n<pre class=\"prettyprint\">\n# these commands get executed in the current scope\n# of each new shell (but not for canned commands)\nimport clr\nclr.AddReference('RevitAPI')\nclr.AddReference('RevitAPIUI')\nfrom Autodesk.Revit.DB import *\nfrom Autodesk.Revit.DB.Architecture import *\nfrom Autodesk.Revit.DB.Analysis import *\n\nuidoc = __revit__.ActiveUIDocument\ndoc = __revit__.ActiveUIDocument.Document\nselection = list(__revit__.ActiveUIDocument.Selection.Elements)\n...\n</pre>\n<p>This also provides an example of how to add additional references in your scripts, and the C# \"using\" keyword analogue.</p>\n<p>The second very often useful thing is filtering elements from the model:</p>\n<pre class=\"prettyprint\">\ncollector = FilteredElementCollector(doc)\nlinkedElements = collector\n  .OfClass(RevitLinkType).ToElements()\n\nfor elem in linkedElements:\n  efr = elem.GetExternalFileReference()\n  print ModelPathUtils.ConvertModelPathToUserVisiblePath(\n    efr.GetAbsolutePath())\n  print \"---------\"\n</pre>\n<p>This is simple.\nJust notice that Python requires no \"new\" keyword.</p>\n<p>So we created a filtered element collector for our opened document, retrieved all RevitLinkType elements and iterated through the elements list.</p>\n<!--\n<p>**Jeremy, I don't know exactly, how the ELEM_PARTITION_PARAM is named in Revit properties tab in English version, correct it, if it is not named as \"Work set\", please</p>\n-->\n<p>Let's go deeper and see something more complicated.</p>\n<p>Some months ago I needed to prepare some model elements information, grouped by worksets.\nBack in those fabled times I didn't know how to do it :-)</p>\n<p>I noticed that elements in the model have a \"work set\" parameter, so I selected an element, executed the RevitLookup \"Snoop current selection...\" command, went to the parameters field, found \"work set\" parameter, noticed that it has integer value, went to it's definition and found out that its built-in parameter name is ELEM_PARTITION_PARAM.</p>\n<p>I deduced that if we get all worksets from model, we can get their elements by using an ElementParameterFilter.</p>\n<p>At this point, I went to\n\n<a href=\"http://thebuildingcoder.typepad.com\">The Building Coder</a>,\n\nsearched it for \"document workset table\" and found the post on the\n\n<a href=\"http://thebuildingcoder.typepad.com/blog/2011/11/read-only-workset-api.html\">workset API</a>.</p>\n<p>I learned that I should use a FilteredWorksetCollector. So let's try:</p>\n<pre class=\"prettyprint\">\nworksets = FilteredWorksetCollector( doc )\nworksets.OfKind( WorksetKind.UserWorkset );\n\nfor elem in worksets:\n  print elem.Name\n</pre>\n<p>We got it!\nThey are not sorted, but remember, we are only exploring to find a way to solve the problem, and it is not the production code.</p>\n<p>So, continuing to explore how to retrieve the elements from the model that belong to a specific workset.</p>\n<p>Let's write a function that filters elements for a specific workset.</p>\n<p>The filtered element \"work set\" parameter should be equal to the Workset.Id.Integer value.\nWe'll pass it to the function as wId:</p>\n<pre class=\"prettyprint\">\ndef FindElementsByWorkset(wId):\n  worksetI = int(BuiltInParameter.ELEM_PARTITION_PARAM) # convert enumeration element to an integer\n  worksetE = ElementId(worksetI) # and create element id from it\n\n  provider = ParameterValueProvider(worksetE) # the parameter should be BuiltInParameter.ELEM_PARTITION_PARAM\n  evaluator = FilterNumericEquals() # the value should be equal\n  rule = FilterIntegerRule(provider, evaluator, wId) # to wId\n\n  parafilter = ElementParameterFilter(rule); # create filter parameter\n  collector = FilteredElementCollector(doc) # create collector\n  collector.WherePasses(parafilter) # and filter elements\n\n  # iterate through the elements\n  for elem in collector:\n    print \"\\t\", elem.Id, elem.GetType().Name\n</pre>\n<p>This function should be placed before our previous code that retrieves the worksets from the model.</p>\n<p>The last thing is to invoke our function in a loop:</p>\n<pre class=\"prettyprint\">\nfor elem in worksets:\n  print elem.Name\n  FindElementsByWorkset(elem.Id.IntegerValue)\n</pre>\n<p>As you can easily imagine, I would have spent <b><i>much</i></b> more time if I were forced to restart Revit every time I changed something in this code analogue.</p>\n<p>The advantages of using this kind of tools are completely obvious, aren't they?</p>\n<p>The remaining examples will cover some non-obvious things, that you would need to search for, when you face them.\nAnd you <b>will</b> face them :-)</p>\n<p>These things include GUIDs and generic methods.\nThis example shows using such things.\nIt finds an extensible storage schema with a specific name, gets doc.OwnerFamily entity of the schema found and retrieves the \"FamilyId\" field of Guid type.</p>\n<pre class=\"prettyprint\">\nfrom Autodesk.Revit.DB.ExtensibleStorage import *\nfrom System import Guid # you need to import this, when you work with Guids!\nfor sch in Schema.ListSchemas():\n  if sch.SchemaName == \"CatalogFamilyInfoEntity\": # looking for the schema\n    schema = sch\nprint schema.SchemaName\nentity = doc.OwnerFamily.GetEntity(schema)\nprint entity.IsValid()\nprint entity.Get[Guid](\"FamilyId\") # generic method public FieldType Get FieldType (string fieldName)\n</pre>\n<!--\n<p>***Jeremy, I remember, that there was a problem in subscription site with angular brackets (around FieldType), may be just in browser, so I didn't write them</p>\n-->\n<p>Another non-obvious thing is creating a new Guid for something.\nIf you already know your Guid value, you may use something like this:</p>\n<pre class=\"prettyprint\">\nimport System\nparameterId = System.Guid(\"0ce6f957-070e-4e1b-8f33-7a9d95cf1142\")\nprint \"parameter\", doc.ProjectInformation.get_Parameter(parameterId).AsString() # I've got shared parameter with this id in the RVT file, you should use your own Guid\n</pre>\n<p>If you want to create an absolutely new Guid:</p>\n<pre class=\"prettyprint\">\nfrom System.Guid import NewGuid\nprint NewGuid()\n</pre>\n<p>The (almost) last example shows how to automatically create thousands of family instances of different family types of a specific family.\nThe code is not very good, but it is not the production, it's only for me and I seldom use it.\nThis script will create a layer of rng * rng family instances for each family symbol of specific family:</p>\n<pre class=\"prettyprint\">\ncollector = FilteredElementCollector(doc)\ncollector.OfCategory(BuiltInCategory.OST_StructuralFraming) # my family in this category, just remove this or change to the category of family you want to place in the document\nelems = collector.OfClass(FamilySymbol).ToElements() # we get all family symbols in this category\n\nrng = 80 # 80*80 elements of each family symbol\ndist = 5 # distance between elements\n\nt = Transaction(doc, 'Create multiple family instances.')\nt.Start()\n\nz = 0\nfor elem in elems:\n  if elem.Family.Name == \"Enter your family name here\":\n    for i in range(0,rng):\n      for j in range(0,rng):\n        loc = XYZ((i*dist),(j*dist),(z*dist))\n        familyInst = doc.Create.NewFamilyInstance(loc, elem, Structure.StructuralType.NonStructural)\n    z = z + 1\n\nt.Commit()\n</pre>\n<p>Let's end with one additional Python script that demonstrates working with LINQ and enumerations:</p>\n<pre class=\"prettyprint\">\nfrom System import *\nclr.AddReference(\"System.Core\")\nfrom System.Collections.Generic import *\nimport System\nclr.ImportExtensions(System.Linq)\nfrom System.Linq import Enumerable\n\ndef printSubCategories(elem, n):\n  tab = \"\"\n  for i in range(1, n):\n    tab = tab + \"\\t\"\n  print tab, elem.Name, Enum.ToObject(BuiltInCategory, elem.Id.IntegerValue), elem.Id\n  for child in elem.SubCategories:\n    printSubCategories(child, n + 1)\n\nfor elem in Enumerable.ToList[Category](doc.Settings.Categories).OrderBy(lambda x: x.Name):\n  print elem.Name, Enum.ToObject(BuiltInCategory, elem.Id.IntegerValue), elem.Id\n  printSubCategories(elem, 1)\n  print \"---\"\n</pre>\n<p>Very many thanks to Alexander for these nice examples!</p>\n<p>I hope that everybody takes this chance to really dig deep into intimate direct API interaction with Revit.</p>\n</p>"
  }
]